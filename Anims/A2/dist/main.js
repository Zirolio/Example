(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.according = void 0;
exports.according = 20;
const planck_1 = require("planck");
const box_1 = require("./objects/box");
const circle_1 = require("./objects/circle");
// Create and set canvas
const canvas = document.body.appendChild(document.createElement('canvas'));
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const c = canvas.getContext('2d');
const world = new planck_1.World((0, planck_1.Vec2)(0, 30));
// ---------------------
// Constants
const toJ = 40;
const delay = 1 / 60;
const speed = 10;
const jumpSpeed = 10000;
const radius = 30;
const keys = {
    w: false,
    s: false,
    a: false,
    d: false
};
let _toJC = 0; // To jump counter
// ---------
// Objects
const objects = new Set();
// Area
const bottomH = 45;
const t2W = (canvas.width / 2) / 8;
objects.add(new box_1.Box(0, canvas.height - bottomH, canvas.width / 2, bottomH, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
for (let x = canvas.width / 2 + t2W; x < canvas.width; x += t2W * 2) {
    objects.add(new box_1.Box(x + t2W / 2 - bottomH / 4, canvas.height - bottomH * 5, bottomH / 2, bottomH * 4, 'rgb(105, 42, 0)', world, c, { type: 'dynamic' }, { density: 8, userData: { ccap: true } }));
    objects.add(new box_1.Box(x, canvas.height - bottomH, t2W, bottomH, 'rgb(126, 5, 5)', world, c, { type: 'static', fixedRotation: false }));
}
objects.add(new box_1.Box(0, canvas.height - bottomH * 4, bottomH, bottomH / 2, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new circle_1.Circle(canvas.width / 4 + bottomH * 4, canvas.height - bottomH * 3, bottomH / 3, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new circle_1.Circle(canvas.width / 4, canvas.height - bottomH * 5.5, bottomH, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new box_1.Box(0, canvas.height - bottomH * 8, bottomH, bottomH / 2, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new box_1.Box(bottomH * 2, canvas.height - bottomH * 12.5, canvas.width / 2 * 0.8, bottomH, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new box_1.Box(0, canvas.height - bottomH * 16, bottomH, bottomH / 2, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new box_1.Box(0, radius * 2, bottomH, bottomH / 2, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new box_1.Box(canvas.width - canvas.width / 2 * 0.8, radius * 5, canvas.width / 2 * 0.8, bottomH / 2, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new box_1.Box(canvas.width / 2 + bottomH / 2, canvas.height - bottomH * 15.65, bottomH / 2, bottomH / 2, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
objects.add(new box_1.Box(canvas.width - canvas.width / 2 * 0.8, canvas.height * (1.5 / 3), canvas.width / 2 * 0.8, bottomH * 4, 'rgb(126, 5, 5)', world, c, { type: 'static' }));
// ------
// Dynamic bodies
let player = new circle_1.Circle(radius, canvas.height - bottomH - radius, radius, 'rgb(241, 180, 9)', world, c, { type: 'dynamic' }, { restitution: 0, density: 1, userData: { ccap: true } });
objects.add(new circle_1.Circle(200, 100, radius, 'green', world, c, { type: 'dynamic', linearDamping: 2 }, { restitution: 0.7, density: 1, userData: { ccap: true } }));
objects.add(new circle_1.Circle(canvas.width - canvas.width / 2 * 0.8 + radius * 1.5, radius * 2, radius, 'rgb(212, 16, 196)', world, c, { type: 'dynamic', linearDamping: 2 }, { restitution: 0.7, density: 1, userData: { ccap: true } }));
objects.add(player);
const ballR = radius / 3, ballsC = 10;
for (let x = canvas.width - canvas.width / 2 * 0.4, y = canvas.height * (1.5 / 3) - ballR; y > canvas.height * (1.5 / 3) - ballR * 2 * ballsC; y -= ballR * 2)
    objects.add(new circle_1.Circle(x, y, ballR, 'green', world, c, { type: 'dynamic', linearDamping: 1 }, { restitution: 0.85, density: 1, userData: { ccap: true } }));
// -------
// Input listeners
document.onkeydown = (k) => {
    if (k.code == 'KeyW')
        keys.w = true;
    if (k.code == 'KeyS')
        keys.s = true;
    if (k.code == 'KeyA')
        keys.a = true;
    if (k.code == 'KeyD')
        keys.d = true;
};
document.onkeyup = (k) => {
    if (k.code == 'KeyW')
        keys.w = false;
    if (k.code == 'KeyS')
        keys.s = false;
    if (k.code == 'KeyA')
        keys.a = false;
    if (k.code == 'KeyD')
        keys.d = false;
};
canvas.onmousedown = (md) => {
    const clickOn = world.queryAABB((0, planck_1.AABB)((0, planck_1.Vec2)((md.x - 1) / exports.according, (md.y - 1) / exports.according), (0, planck_1.Vec2)((md.x + 1) / exports.according, (md.y + 1) / exports.according)), f => {
        const obj = f.getUserData();
        if (obj && obj.data && obj.data.ccap) {
            player = obj;
            return false;
        }
        return true;
    });
};
// ---------------
// Clear context
const clear = (c) => {
    c.fillStyle = '';
    c.shadowBlur = 0;
    c.shadowColor = '';
    c.strokeStyle = '';
    c.fillStyle = '';
    c.filter = '';
    c.lineWidth = 0;
};
// :)
const animate = () => {
    var _a;
    requestAnimationFrame(animate);
    clear(c);
    c.fillStyle = 'rgba(0, 0, 0, 0.05)';
    c.fillRect(0, 0, canvas.width, canvas.height);
    // Update Physic
    world.step(delay);
    // Keys Process
    const velNow = player.body.getLinearVelocity(); // Velocity v
    // Jump
    _toJC && _toJC--;
    if (!_toJC && keys.w && Math.abs(velNow.y) < 0.05) {
        _toJC = toJ;
        player.body.applyForce((0, planck_1.Vec2)(0, -jumpSpeed * (((_a = player.body.getFixtureList()) === null || _a === void 0 ? void 0 : _a.getDensity()) || 1)), player.body.getWorldCenter());
    }
    // Key "s" xD
    if (keys.s)
        player.body.setGravityScale(5);
    else
        player.body.setGravityScale(1);
    // Movement
    if (keys.a)
        velNow.x = -speed;
    if (keys.d)
        velNow.x = speed;
    if (!keys.a && !keys.d)
        velNow.x = 0;
    player.body.setLinearVelocity(velNow);
    // ------------
    // Draw Process
    objects.forEach(p => p.draw());
    // ------------
};
animate(); // Start

},{"./objects/box":2,"./objects/circle":3,"planck":4}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Box = void 0;
const planck_1 = require("planck");
const __1 = require("..");
class Box {
    constructor(x, y, width, height, color, world, c, bodyDef = {}, fixtDef = {}) {
        this.data = fixtDef.userData;
        this.width = width;
        this.height = height;
        this.color = color;
        this.world = world;
        this.c = c;
        this._body = world.createBody(Object.assign({ position: (0, planck_1.Vec2)(x, y).mul(1 / __1.according) }, bodyDef));
        const w = width / __1.according / 2, h = height / __1.according / 2;
        this._body.createFixture((0, planck_1.Box)(w, h, (0, planck_1.Vec2)(w, h)), Object.assign(Object.assign({}, fixtDef), { userData: this }));
    }
    draw() {
        const c = this.c, pos = this._body.getPosition().clone().mul(__1.according);
        c.beginPath();
        c.fillStyle = this.color;
        c.translate(pos.x, pos.y);
        c.rotate(this._body.getAngle());
        c.fillRect(0, 0, this.width, this.height);
        c.setTransform(1, 0, 0, 1, 0, 0);
    }
    get body() {
        return this._body;
    }
}
exports.Box = Box;

},{"..":1,"planck":4}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Circle = void 0;
const planck_1 = require("planck");
const __1 = require("..");
class Circle {
    constructor(x, y, radius, color, world, c, bodyDef = {}, fixtDef = {}) {
        this.data = fixtDef.userData;
        this.radius = radius;
        this.color = color;
        this.world = world;
        this.c = c;
        this._body = world.createBody(Object.assign({ position: (0, planck_1.Vec2)(x, y).mul(1 / __1.according), fixedRotation: true }, bodyDef));
        this._body.createFixture((0, planck_1.Circle)(this.radius / __1.according), Object.assign(Object.assign({}, fixtDef), { userData: this }));
        console.log(fixtDef);
    }
    draw() {
        const c = this.c, pos = this._body.getPosition().clone().mul(__1.according);
        c.beginPath();
        c.fillStyle = this.color;
        c.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2, false);
        c.fill();
    }
    get body() {
        return this._body;
    }
}
exports.Circle = Circle;

},{"..":1,"planck":4}],4:[function(require,module,exports){
/**
 * Planck.js v1.0.0-beta.16
 * @license The MIT license
 * @copyright Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.planck = {}));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    /** @internal */
    var options = function (input, defaults) {
        if (input === null || typeof input === 'undefined') {
            // tslint:disable-next-line:no-object-literal-type-assertion
            input = {};
        }
        var output = __assign({}, input);
        // tslint:disable-next-line:no-for-in
        for (var key in defaults) {
            if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {
                output[key] = defaults[key];
            }
        }
        if (typeof Object.getOwnPropertySymbols === 'function') {
            var symbols = Object.getOwnPropertySymbols(defaults);
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === 'undefined') {
                    output[symbol] = defaults[symbol];
                }
            }
        }
        return output;
    };

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_random = Math.random;
    var EPSILON = 1e-9;
    /** @internal @deprecated */
    var isFinite = Number.isFinite;
    /**
     * @deprecated
     * Next Largest Power of 2 Given a binary integer value x, the next largest
     * power of 2 can be computed by a SWAR algorithm that recursively "folds" the
     * upper bits into the lower bits. This process yields a bit vector with the
     * same most significant 1 as x, but all 1's below it. Adding 1 to that value
     * yields the next largest power of 2. For a 32-bit value:
     */
    function nextPowerOfTwo(x) {
        x |= (x >> 1);
        x |= (x >> 2);
        x |= (x >> 4);
        x |= (x >> 8);
        x |= (x >> 16);
        return x + 1;
    }
    /** @deprecated */
    function isPowerOfTwo(x) {
        return x > 0 && (x & (x - 1)) === 0;
    }
    /** @deprecated */
    function mod(num, min, max) {
        if (typeof min === 'undefined') {
            max = 1;
            min = 0;
        }
        else if (typeof max === 'undefined') {
            max = min;
            min = 0;
        }
        if (max > min) {
            num = (num - min) % (max - min);
            return num + (num < 0 ? max : min);
        }
        else {
            num = (num - max) % (min - max);
            return num + (num <= 0 ? min : max);
        }
    }
    /**
     * @deprecated
     * Returns a min if num is less than min, and max if more than max, otherwise returns num.
     */
    function clamp(num, min, max) {
        if (num < min) {
            return min;
        }
        else if (num > max) {
            return max;
        }
        else {
            return num;
        }
    }
    /**
     * @deprecated
     * Returns a random number between min and max when two arguments are provided.
     * If one arg is provided between 0 to max.
     * If one arg is passed between 0 to 1.
     */
    function random(min, max) {
        if (typeof min === 'undefined') {
            max = 1;
            min = 0;
        }
        else if (typeof max === 'undefined') {
            max = min;
            min = 0;
        }
        return min === max ? min : math_random() * (max - min) + min;
    }
    /** @ignore */
    var math = Object.create(Math);
    math.EPSILON = EPSILON;
    math.isFinite = isFinite;
    math.nextPowerOfTwo = nextPowerOfTwo;
    math.isPowerOfTwo = isPowerOfTwo;
    math.mod = mod;
    math.clamp = clamp;
    math.random = random;

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$9 = Math.abs;
    /** @internal */ var math_sqrt$5 = Math.sqrt;
    /** @internal */ var math_max$8 = Math.max;
    /** @internal */ var math_min$8 = Math.min;
    var Vec2 = /** @class */ (function () {
        // tslint:disable-next-line:typedef
        function Vec2(x, y) {
            if (!(this instanceof Vec2)) {
                return new Vec2(x, y);
            }
            if (typeof x === 'undefined') {
                this.x = 0;
                this.y = 0;
            }
            else if (typeof x === 'object') {
                this.x = x.x;
                this.y = x.y;
            }
            else {
                this.x = x;
                this.y = y;
            }
        }
        /** @internal */
        Vec2.prototype._serialize = function () {
            return {
                x: this.x,
                y: this.y
            };
        };
        /** @internal */
        Vec2._deserialize = function (data) {
            var obj = Object.create(Vec2.prototype);
            obj.x = data.x;
            obj.y = data.y;
            return obj;
        };
        Vec2.zero = function () {
            var obj = Object.create(Vec2.prototype);
            obj.x = 0;
            obj.y = 0;
            return obj;
        };
        /** @internal */
        Vec2.neo = function (x, y) {
            var obj = Object.create(Vec2.prototype);
            obj.x = x;
            obj.y = y;
            return obj;
        };
        Vec2.clone = function (v) {
            return Vec2.neo(v.x, v.y);
        };
        /** @internal */
        Vec2.prototype.toString = function () {
            return JSON.stringify(this);
        };
        /**
         * Does this vector contain finite coordinates?
         */
        Vec2.isValid = function (obj) {
            if (obj === null || typeof obj === 'undefined') {
                return false;
            }
            return Number.isFinite(obj.x) && Number.isFinite(obj.y);
        };
        Vec2.assert = function (o) {
        };
        Vec2.prototype.clone = function () {
            return Vec2.clone(this);
        };
        /**
         * Set this vector to all zeros.
         *
         * @returns this
         */
        Vec2.prototype.setZero = function () {
            this.x = 0.0;
            this.y = 0.0;
            return this;
        };
        /**
         * Set this vector to some specified coordinates.
         *
         * @returns this
         */
        // tslint:disable-next-line:typedef
        Vec2.prototype.set = function (x, y) {
            if (typeof x === 'object') {
                this.x = x.x;
                this.y = x.y;
            }
            else {
                this.x = x;
                this.y = y;
            }
            return this;
        };
        /**
         * Set this vector to some specified coordinates.
         *
         * @returns this
         */
        Vec2.prototype.setNum = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        /**
         * Set this vector to some specified coordinates.
         *
         * @returns this
         */
        Vec2.prototype.setVec2 = function (value) {
            this.x = value.x;
            this.y = value.y;
            return this;
        };
        /** @internal @deprecated Use setCombine or setMul */
        Vec2.prototype.wSet = function (a, v, b, w) {
            if (typeof b !== 'undefined' || typeof w !== 'undefined') {
                return this.setCombine(a, v, b, w);
            }
            else {
                return this.setMul(a, v);
            }
        };
        /**
         * Set linear combination of v and w: `a * v + b * w`
         */
        Vec2.prototype.setCombine = function (a, v, b, w) {
            var x = a * v.x + b * w.x;
            var y = a * v.y + b * w.y;
            // `this` may be `w`
            this.x = x;
            this.y = y;
            return this;
        };
        Vec2.prototype.setMul = function (a, v) {
            var x = a * v.x;
            var y = a * v.y;
            this.x = x;
            this.y = y;
            return this;
        };
        /**
         * Add a vector to this vector.
         *
         * @returns this
         */
        Vec2.prototype.add = function (w) {
            this.x += w.x;
            this.y += w.y;
            return this;
        };
        /** @internal @deprecated Use addCombine or addMul */
        Vec2.prototype.wAdd = function (a, v, b, w) {
            if (typeof b !== 'undefined' || typeof w !== 'undefined') {
                return this.addCombine(a, v, b, w);
            }
            else {
                return this.addMul(a, v);
            }
        };
        /**
         * Add linear combination of v and w: `a * v + b * w`
         */
        Vec2.prototype.addCombine = function (a, v, b, w) {
            var x = a * v.x + b * w.x;
            var y = a * v.y + b * w.y;
            // `this` may be `w`
            this.x += x;
            this.y += y;
            return this;
        };
        Vec2.prototype.addMul = function (a, v) {
            var x = a * v.x;
            var y = a * v.y;
            this.x += x;
            this.y += y;
            return this;
        };
        /**
         * @deprecated Use subCombine or subMul
         */
        Vec2.prototype.wSub = function (a, v, b, w) {
            if (typeof b !== 'undefined' || typeof w !== 'undefined') {
                return this.subCombine(a, v, b, w);
            }
            else {
                return this.subMul(a, v);
            }
        };
        /**
         * Subtract linear combination of v and w: `a * v + b * w`
         */
        Vec2.prototype.subCombine = function (a, v, b, w) {
            var x = a * v.x + b * w.x;
            var y = a * v.y + b * w.y;
            // `this` may be `w`
            this.x -= x;
            this.y -= y;
            return this;
        };
        Vec2.prototype.subMul = function (a, v) {
            var x = a * v.x;
            var y = a * v.y;
            this.x -= x;
            this.y -= y;
            return this;
        };
        /**
         * Subtract a vector from this vector
         *
         * @returns this
         */
        Vec2.prototype.sub = function (w) {
            this.x -= w.x;
            this.y -= w.y;
            return this;
        };
        /**
         * Multiply this vector by a scalar.
         *
         * @returns this
         */
        Vec2.prototype.mul = function (m) {
            this.x *= m;
            this.y *= m;
            return this;
        };
        /**
         * Get the length of this vector (the norm).
         *
         * For performance, use this instead of lengthSquared (if possible).
         */
        Vec2.prototype.length = function () {
            return Vec2.lengthOf(this);
        };
        /**
         * Get the length squared.
         */
        Vec2.prototype.lengthSquared = function () {
            return Vec2.lengthSquared(this);
        };
        /**
         * Convert this vector into a unit vector.
         *
         * @returns old length
         */
        Vec2.prototype.normalize = function () {
            var length = this.length();
            if (length < EPSILON) {
                return 0.0;
            }
            var invLength = 1.0 / length;
            this.x *= invLength;
            this.y *= invLength;
            return length;
        };
        /**
         * Get the length of this vector (the norm).
         *
         * For performance, use this instead of lengthSquared (if possible).
         */
        Vec2.lengthOf = function (v) {
            return math_sqrt$5(v.x * v.x + v.y * v.y);
        };
        /**
         * Get the length squared.
         */
        Vec2.lengthSquared = function (v) {
            return v.x * v.x + v.y * v.y;
        };
        Vec2.distance = function (v, w) {
            var dx = v.x - w.x;
            var dy = v.y - w.y;
            return math_sqrt$5(dx * dx + dy * dy);
        };
        Vec2.distanceSquared = function (v, w) {
            var dx = v.x - w.x;
            var dy = v.y - w.y;
            return dx * dx + dy * dy;
        };
        Vec2.areEqual = function (v, w) {
            return v === w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;
        };
        /**
         * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
         */
        Vec2.skew = function (v) {
            return Vec2.neo(-v.y, v.x);
        };
        /** Dot product on two vectors */
        Vec2.dot = function (v, w) {
            return v.x * w.x + v.y * w.y;
        };
        Vec2.cross = function (v, w) {
            if (typeof w === 'number') {
                return Vec2.neo(w * v.y, -w * v.x);
            }
            else if (typeof v === 'number') {
                return Vec2.neo(-v * w.y, v * w.x);
            }
            else {
                return v.x * w.y - v.y * w.x;
            }
        };
        /** Cross product on two vectors */
        Vec2.crossVec2Vec2 = function (v, w) {
            return v.x * w.y - v.y * w.x;
        };
        /** Cross product on a vector and a scalar */
        Vec2.crossVec2Num = function (v, w) {
            return Vec2.neo(w * v.y, -w * v.x);
        };
        /** Cross product on a vector and a scalar */
        Vec2.crossNumVec2 = function (v, w) {
            return Vec2.neo(-v * w.y, v * w.x);
        };
        Vec2.addCross = function (a, v, w) {
            if (typeof w === 'number') {
                return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);
            }
            else if (typeof v === 'number') {
                return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);
            }
        };
        /**
         * Returns `a + (v x w)`
         */
        Vec2.addCrossVec2Num = function (a, v, w) {
            return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);
        };
        /**
         * Returns `a + (v x w)`
         */
        Vec2.addCrossNumVec2 = function (a, v, w) {
            return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);
        };
        Vec2.add = function (v, w) {
            return Vec2.neo(v.x + w.x, v.y + w.y);
        };
        /** @internal @deprecated */
        Vec2.wAdd = function (a, v, b, w) {
            if (typeof b !== 'undefined' || typeof w !== 'undefined') {
                return Vec2.combine(a, v, b, w);
            }
            else {
                return Vec2.mulNumVec2(a, v);
            }
        };
        Vec2.combine = function (a, v, b, w) {
            return Vec2.zero().setCombine(a, v, b, w);
        };
        Vec2.sub = function (v, w) {
            return Vec2.neo(v.x - w.x, v.y - w.y);
        };
        Vec2.mul = function (a, b) {
            if (typeof a === 'object') {
                return Vec2.neo(a.x * b, a.y * b);
            }
            else if (typeof b === 'object') {
                return Vec2.neo(a * b.x, a * b.y);
            }
        };
        Vec2.mulVec2Num = function (a, b) {
            return Vec2.neo(a.x * b, a.y * b);
        };
        Vec2.mulNumVec2 = function (a, b) {
            return Vec2.neo(a * b.x, a * b.y);
        };
        Vec2.prototype.neg = function () {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        };
        Vec2.neg = function (v) {
            return Vec2.neo(-v.x, -v.y);
        };
        Vec2.abs = function (v) {
            return Vec2.neo(math_abs$9(v.x), math_abs$9(v.y));
        };
        Vec2.mid = function (v, w) {
            return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);
        };
        Vec2.upper = function (v, w) {
            return Vec2.neo(math_max$8(v.x, w.x), math_max$8(v.y, w.y));
        };
        Vec2.lower = function (v, w) {
            return Vec2.neo(math_min$8(v.x, w.x), math_min$8(v.y, w.y));
        };
        Vec2.prototype.clamp = function (max) {
            var lengthSqr = this.x * this.x + this.y * this.y;
            if (lengthSqr > max * max) {
                var scale = max / math_sqrt$5(lengthSqr);
                this.x *= scale;
                this.y *= scale;
            }
            return this;
        };
        Vec2.clamp = function (v, max) {
            var r = Vec2.neo(v.x, v.y);
            r.clamp(max);
            return r;
        };
        /**  @internal @deprecated */
        Vec2.scaleFn = function (x, y) {
            // todo: this was used in examples, remove in the future
            return function (v) {
                return Vec2.neo(v.x * x, v.y * y);
            };
        };
        /**  @internal @deprecated */
        Vec2.translateFn = function (x, y) {
            // todo: this was used in examples, remove in the future
            return function (v) {
                return Vec2.neo(v.x + x, v.y + y);
            };
        };
        return Vec2;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_max$7 = Math.max;
    /** @internal */ var math_min$7 = Math.min;
    var AABB = /** @class */ (function () {
        function AABB(lower, upper) {
            if (!(this instanceof AABB)) {
                return new AABB(lower, upper);
            }
            this.lowerBound = Vec2.zero();
            this.upperBound = Vec2.zero();
            if (typeof lower === 'object') {
                this.lowerBound.setVec2(lower);
            }
            if (typeof upper === 'object') {
                this.upperBound.setVec2(upper);
            }
            else if (typeof lower === 'object') {
                this.upperBound.setVec2(lower);
            }
        }
        /**
         * Verify that the bounds are sorted.
         */
        AABB.prototype.isValid = function () {
            return AABB.isValid(this);
        };
        AABB.isValid = function (obj) {
            if (obj === null || typeof obj === 'undefined') {
                return false;
            }
            return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;
        };
        AABB.assert = function (o) {
        };
        /**
         * Get the center of the AABB.
         */
        AABB.prototype.getCenter = function () {
            return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);
        };
        /**
         * Get the extents of the AABB (half-widths).
         */
        AABB.prototype.getExtents = function () {
            return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);
        };
        /**
         * Get the perimeter length.
         */
        AABB.prototype.getPerimeter = function () {
            return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);
        };
        /**
         * Combine one or two AABB into this one.
         */
        AABB.prototype.combine = function (a, b) {
            b = b || this;
            var lowerA = a.lowerBound;
            var upperA = a.upperBound;
            var lowerB = b.lowerBound;
            var upperB = b.upperBound;
            var lowerX = math_min$7(lowerA.x, lowerB.x);
            var lowerY = math_min$7(lowerA.y, lowerB.y);
            var upperX = math_max$7(upperB.x, upperA.x);
            var upperY = math_max$7(upperB.y, upperA.y);
            this.lowerBound.setNum(lowerX, lowerY);
            this.upperBound.setNum(upperX, upperY);
        };
        AABB.prototype.combinePoints = function (a, b) {
            this.lowerBound.setNum(math_min$7(a.x, b.x), math_min$7(a.y, b.y));
            this.upperBound.setNum(math_max$7(a.x, b.x), math_max$7(a.y, b.y));
        };
        AABB.prototype.set = function (aabb) {
            this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);
            this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);
        };
        AABB.prototype.contains = function (aabb) {
            var result = true;
            result = result && this.lowerBound.x <= aabb.lowerBound.x;
            result = result && this.lowerBound.y <= aabb.lowerBound.y;
            result = result && aabb.upperBound.x <= this.upperBound.x;
            result = result && aabb.upperBound.y <= this.upperBound.y;
            return result;
        };
        AABB.prototype.extend = function (value) {
            AABB.extend(this, value);
            return this;
        };
        AABB.extend = function (out, value) {
            out.lowerBound.x -= value;
            out.lowerBound.y -= value;
            out.upperBound.x += value;
            out.upperBound.y += value;
            return out;
        };
        AABB.testOverlap = function (a, b) {
            var d1x = b.lowerBound.x - a.upperBound.x;
            var d2x = a.lowerBound.x - b.upperBound.x;
            var d1y = b.lowerBound.y - a.upperBound.y;
            var d2y = a.lowerBound.y - b.upperBound.y;
            if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {
                return false;
            }
            return true;
        };
        AABB.areEqual = function (a, b) {
            return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);
        };
        AABB.diff = function (a, b) {
            var wD = math_max$7(0, math_min$7(a.upperBound.x, b.upperBound.x) - math_max$7(b.lowerBound.x, a.lowerBound.x));
            var hD = math_max$7(0, math_min$7(a.upperBound.y, b.upperBound.y) - math_max$7(b.lowerBound.y, a.lowerBound.y));
            var wA = a.upperBound.x - a.lowerBound.x;
            var hA = a.upperBound.y - a.lowerBound.y;
            var wB = b.upperBound.x - b.lowerBound.x;
            var hB = b.upperBound.y - b.lowerBound.y;
            return wA * hA + wB * hB - wD * hD;
        };
        AABB.prototype.rayCast = function (output, input) {
            // From Real-time Collision Detection, p179.
            var tmin = -Infinity;
            var tmax = Infinity;
            var p = input.p1;
            var d = Vec2.sub(input.p2, input.p1);
            var absD = Vec2.abs(d);
            var normal = Vec2.zero();
            for (var f = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {
                if (absD.x < EPSILON) {
                    // Parallel.
                    if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {
                        return false;
                    }
                }
                else {
                    var inv_d = 1.0 / d[f];
                    var t1 = (this.lowerBound[f] - p[f]) * inv_d;
                    var t2 = (this.upperBound[f] - p[f]) * inv_d;
                    // Sign of the normal vector.
                    var s = -1.0;
                    if (t1 > t2) {
                        var temp = t1;
                        t1 = t2;
                        t2 = temp;
                        s = 1.0;
                    }
                    // Push the min up
                    if (t1 > tmin) {
                        normal.setZero();
                        normal[f] = s;
                        tmin = t1;
                    }
                    // Pull the max down
                    tmax = math_min$7(tmax, t2);
                    if (tmin > tmax) {
                        return false;
                    }
                }
            }
            // Does the ray start inside the box?
            // Does the ray intersect beyond the max fraction?
            if (tmin < 0.0 || input.maxFraction < tmin) {
                return false;
            }
            // Intersection.
            output.fraction = tmin;
            output.normal = normal;
            return true;
        };
        /** @internal */ AABB.prototype.toString = function () {
            return JSON.stringify(this);
        };
        AABB.combinePoints = function (out, a, b) {
            out.lowerBound.x = math_min$7(a.x, b.x);
            out.lowerBound.y = math_min$7(a.y, b.y);
            out.upperBound.x = math_max$7(a.x, b.x);
            out.upperBound.y = math_max$7(a.y, b.y);
            return out;
        };
        AABB.combinedPerimeter = function (a, b) {
            var lx = math_min$7(a.lowerBound.x, b.lowerBound.x);
            var ly = math_min$7(a.lowerBound.y, b.lowerBound.y);
            var ux = math_max$7(a.upperBound.x, b.upperBound.x);
            var uy = math_max$7(a.upperBound.y, b.upperBound.y);
            return 2.0 * (ux - lx + uy - ly);
        };
        return AABB;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_PI$6 = Math.PI;
    /**
     * Tuning constants based on meters-kilograms-seconds (MKS) units.
     *
     * Some tolerances are absolute and some are relative. Absolute tolerances use MKS units.
     */
    var Settings = /** @class */ (function () {
        function Settings() {
        }
        Object.defineProperty(Settings, "polygonRadius", {
            /**
             * The radius of the polygon/edge shape skin. This should not be modified.
             * Making this smaller means polygons will have an insufficient buffer for
             * continuous collision. Making it larger may create artifacts for vertex
             * collision.
             */
            get: function () { return 2.0 * Settings.linearSlop; },
            enumerable: false,
            configurable: true
        });
        /**
         * You can use this to change the length scale used by your game.
         *
         * For example for inches you could use 39.4.
         */
        Settings.lengthUnitsPerMeter = 1.0;
        // Collision
        /**
         * The maximum number of contact points between two convex shapes. Do not change
         * this value.
         */
        Settings.maxManifoldPoints = 2;
        /**
         * The maximum number of vertices on a convex polygon. You cannot increase this
         * too much because BlockAllocator has a maximum object size.
         */
        Settings.maxPolygonVertices = 12;
        /**
         * This is used to fatten AABBs in the dynamic tree. This allows proxies to move
         * by a small amount without triggering a tree adjustment. This is in meters.
         */
        Settings.aabbExtension = 0.1;
        /**
         * This is used to fatten AABBs in the dynamic tree. This is used to predict the
         * future position based on the current displacement. This is a dimensionless
         * multiplier.
         */
        Settings.aabbMultiplier = 2.0;
        /**
         * A small length used as a collision and constraint tolerance. Usually it is
         * chosen to be numerically significant, but visually insignificant.
         */
        Settings.linearSlop = 0.005;
        /**
         * A small angle used as a collision and constraint tolerance. Usually it is
         * chosen to be numerically significant, but visually insignificant.
         */
        Settings.angularSlop = (2.0 / 180.0 * math_PI$6);
        /**
         * Maximum number of sub-steps per contact in continuous physics simulation.
         */
        Settings.maxSubSteps = 8;
        // Dynamics
        /**
         * Maximum number of contacts to be handled to solve a TOI impact.
         */
        Settings.maxTOIContacts = 32;
        /**
         * Maximum iterations to solve a TOI.
         */
        Settings.maxTOIIterations = 20;
        /**
         * Maximum iterations to find Distance.
         */
        Settings.maxDistanceIterations = 20;
        /**
         * A velocity threshold for elastic collisions. Any collision with a relative
         * linear velocity below this threshold will be treated as inelastic.
         */
        Settings.velocityThreshold = 1.0;
        /**
         * The maximum linear position correction used when solving constraints. This
         * helps to prevent overshoot.
         */
        Settings.maxLinearCorrection = 0.2;
        /**
         * The maximum angular position correction used when solving constraints. This
         * helps to prevent overshoot.
         */
        Settings.maxAngularCorrection = (8.0 / 180.0 * math_PI$6);
        /**
         * The maximum linear velocity of a body. This limit is very large and is used
         * to prevent numerical problems. You shouldn't need to adjust Settings.
         */
        Settings.maxTranslation = 2.0;
        /**
         * The maximum angular velocity of a body. This limit is very large and is used
         * to prevent numerical problems. You shouldn't need to adjust Settings.
         */
        Settings.maxRotation = (0.5 * math_PI$6);
        /**
         * This scale factor controls how fast overlap is resolved. Ideally this would
         * be 1 so that overlap is removed in one time step. However using values close
         * to 1 often lead to overshoot.
         */
        Settings.baumgarte = 0.2;
        Settings.toiBaugarte = 0.75;
        // Sleep
        /**
         * The time that a body must be still before it will go to sleep.
         */
        Settings.timeToSleep = 0.5;
        /**
         * A body cannot sleep if its linear velocity is above this tolerance.
         */
        Settings.linearSleepTolerance = 0.01;
        /**
         * A body cannot sleep if its angular velocity is above this tolerance.
         */
        Settings.angularSleepTolerance = (2.0 / 180.0 * math_PI$6);
        return Settings;
    }());
    /** @internal */
    var SettingsInternal = /** @class */ (function () {
        function SettingsInternal() {
        }
        Object.defineProperty(SettingsInternal, "maxManifoldPoints", {
            get: function () {
                return Settings.maxManifoldPoints;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxPolygonVertices", {
            get: function () {
                return Settings.maxPolygonVertices;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "aabbExtension", {
            get: function () {
                return Settings.aabbExtension * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "aabbMultiplier", {
            get: function () {
                return Settings.aabbMultiplier;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "linearSlop", {
            get: function () {
                return Settings.linearSlop * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "linearSlopSquared", {
            get: function () {
                return Settings.linearSlop * Settings.lengthUnitsPerMeter * Settings.linearSlop * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "angularSlop", {
            get: function () {
                return Settings.angularSlop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "polygonRadius", {
            get: function () {
                return 2.0 * Settings.linearSlop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxSubSteps", {
            get: function () {
                return Settings.maxSubSteps;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxTOIContacts", {
            get: function () {
                return Settings.maxTOIContacts;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxTOIIterations", {
            get: function () {
                return Settings.maxTOIIterations;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxDistanceIterations", {
            get: function () {
                return Settings.maxDistanceIterations;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "velocityThreshold", {
            get: function () {
                return Settings.velocityThreshold * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxLinearCorrection", {
            get: function () {
                return Settings.maxLinearCorrection * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxAngularCorrection", {
            get: function () {
                return Settings.maxAngularCorrection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxTranslation", {
            get: function () {
                return Settings.maxTranslation * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxTranslationSquared", {
            get: function () {
                return Settings.maxTranslation * Settings.lengthUnitsPerMeter * Settings.maxTranslation * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxRotation", {
            get: function () {
                return Settings.maxRotation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "maxRotationSquared", {
            get: function () {
                return Settings.maxRotation * Settings.maxRotation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "baumgarte", {
            get: function () {
                return Settings.baumgarte;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "toiBaugarte", {
            get: function () {
                return Settings.toiBaugarte;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "timeToSleep", {
            get: function () {
                return Settings.timeToSleep;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "linearSleepTolerance", {
            get: function () {
                return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "linearSleepToleranceSqr", {
            get: function () {
                return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter * Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "angularSleepTolerance", {
            get: function () {
                return Settings.angularSleepTolerance;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SettingsInternal, "angularSleepToleranceSqr", {
            get: function () {
                return Settings.angularSleepTolerance * Settings.angularSleepTolerance;
            },
            enumerable: false,
            configurable: true
        });
        return SettingsInternal;
    }());

    /*
     * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
     *
     * This software is provided 'as-is', without any express or implied
     * warranty.  In no event will the authors be held liable for any damages
     * arising from the use of this software.
     * Permission is granted to anyone to use this software for any purpose,
     * including commercial applications, and to alter it and redistribute it
     * freely, subject to the following restrictions:
     * 1. The origin of this software must not be misrepresented; you must not
     * claim that you wrote the original software. If you use this software
     * in a product, an acknowledgment in the product documentation would be
     * appreciated but is not required.
     * 2. Altered source versions must be plainly marked as such, and must not be
     * misrepresented as being the original software.
     * 3. This notice may not be removed or altered from any source distribution.
     */
    /** @internal */
    var Pool = /** @class */ (function () {
        function Pool(opts) {
            this._list = [];
            this._max = Infinity;
            this._hasCreateFn = false;
            this._createCount = 0;
            this._hasAllocateFn = false;
            this._allocateCount = 0;
            this._hasReleaseFn = false;
            this._releaseCount = 0;
            this._hasDisposeFn = false;
            this._disposeCount = 0;
            this._list = [];
            this._max = opts.max || this._max;
            this._createFn = opts.create;
            this._hasCreateFn = typeof this._createFn === 'function';
            this._allocateFn = opts.allocate;
            this._hasAllocateFn = typeof this._allocateFn === 'function';
            this._releaseFn = opts.release;
            this._hasReleaseFn = typeof this._releaseFn === 'function';
            this._disposeFn = opts.dispose;
            this._hasDisposeFn = typeof this._disposeFn === 'function';
        }
        Pool.prototype.max = function (n) {
            if (typeof n === 'number') {
                this._max = n;
                return this;
            }
            return this._max;
        };
        Pool.prototype.size = function () {
            return this._list.length;
        };
        Pool.prototype.allocate = function () {
            var item;
            if (this._list.length > 0) {
                item = this._list.shift();
            }
            else {
                this._createCount++;
                if (this._hasCreateFn) {
                    item = this._createFn();
                }
                else {
                    // tslint:disable-next-line:no-object-literal-type-assertion
                    item = {};
                }
            }
            this._allocateCount++;
            if (this._hasAllocateFn) {
                this._allocateFn(item);
            }
            return item;
        };
        Pool.prototype.release = function (item) {
            if (this._list.length < this._max) {
                this._releaseCount++;
                if (this._hasReleaseFn) {
                    this._releaseFn(item);
                }
                this._list.push(item);
            }
            else {
                this._disposeCount++;
                if (this._hasDisposeFn) {
                    item = this._disposeFn(item);
                }
            }
        };
        Pool.prototype.toString = function () {
            return " +" + this._createCount + " >" + this._allocateCount + " <" + this._releaseCount + " -"
                + this._disposeCount + " =" + this._list.length + "/" + this._max;
        };
        return Pool;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$8 = Math.abs;
    /** @internal */ var math_max$6 = Math.max;
    /**
     * A node in the dynamic tree. The client does not interact with this directly.
     */
    var TreeNode = /** @class */ (function () {
        function TreeNode(id) {
            /** Enlarged AABB */
            this.aabb = new AABB();
            this.userData = null;
            this.parent = null;
            this.child1 = null;
            this.child2 = null;
            /** 0: leaf, -1: free node */
            this.height = -1;
            this.id = id;
        }
        /** @internal */
        TreeNode.prototype.toString = function () {
            return this.id + ": " + this.userData;
        };
        TreeNode.prototype.isLeaf = function () {
            return this.child1 == null;
        };
        return TreeNode;
    }());
    /** @internal */ var poolTreeNode = new Pool({
        create: function () {
            return new TreeNode();
        },
        release: function (node) {
            node.userData = null;
            node.parent = null;
            node.child1 = null;
            node.child2 = null;
            node.height = -1;
            node.id = undefined;
        }
    });
    /**
     * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A
     * dynamic tree arranges data in a binary tree to accelerate queries such as
     * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we
     * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger
     * than the client object. This allows the client object to move by small
     * amounts without triggering a tree update.
     *
     * Nodes are pooled and relocatable, so we use node indices rather than
     * pointers.
     */
    var DynamicTree = /** @class */ (function () {
        function DynamicTree() {
            this.inputPool = new Pool({
                create: function () {
                    // tslint:disable-next-line:no-object-literal-type-assertion
                    return {};
                },
                release: function (stack) {
                }
            });
            this.stackPool = new Pool({
                create: function () {
                    return [];
                },
                release: function (stack) {
                    stack.length = 0;
                }
            });
            this.iteratorPool = new Pool({
                create: function () {
                    return new Iterator();
                },
                release: function (iterator) {
                    iterator.close();
                }
            });
            this.m_root = null;
            this.m_nodes = {};
            this.m_lastProxyId = 0;
        }
        /**
         * Get proxy user data.
         *
         * @return the proxy user data or 0 if the id is invalid.
         */
        DynamicTree.prototype.getUserData = function (id) {
            var node = this.m_nodes[id];
            return node.userData;
        };
        /**
         * Get the fat AABB for a node id.
         *
         * @return the proxy user data or 0 if the id is invalid.
         */
        DynamicTree.prototype.getFatAABB = function (id) {
            var node = this.m_nodes[id];
            return node.aabb;
        };
        DynamicTree.prototype.allocateNode = function () {
            var node = poolTreeNode.allocate();
            node.id = ++this.m_lastProxyId;
            this.m_nodes[node.id] = node;
            return node;
        };
        DynamicTree.prototype.freeNode = function (node) {
            // tslint:disable-next-line:no-dynamic-delete
            delete this.m_nodes[node.id];
            poolTreeNode.release(node);
        };
        /**
         * Create a proxy in the tree as a leaf node. We return the index of the node
         * instead of a pointer so that we can grow the node pool.
         *
         * Create a proxy. Provide a tight fitting AABB and a userData pointer.
         */
        DynamicTree.prototype.createProxy = function (aabb, userData) {
            var node = this.allocateNode();
            node.aabb.set(aabb);
            // Fatten the aabb.
            AABB.extend(node.aabb, SettingsInternal.aabbExtension);
            node.userData = userData;
            node.height = 0;
            this.insertLeaf(node);
            return node.id;
        };
        /**
         * Destroy a proxy. This asserts if the id is invalid.
         */
        DynamicTree.prototype.destroyProxy = function (id) {
            var node = this.m_nodes[id];
            this.removeLeaf(node);
            this.freeNode(node);
        };
        /**
         * Move a proxy with a swepted AABB. If the proxy has moved outside of its
         * fattened AABB, then the proxy is removed from the tree and re-inserted.
         * Otherwise the function returns immediately.
         *
         * @param d Displacement
         *
         * @return true if the proxy was re-inserted.
         */
        DynamicTree.prototype.moveProxy = function (id, aabb, d) {
            var node = this.m_nodes[id];
            if (node.aabb.contains(aabb)) {
                return false;
            }
            this.removeLeaf(node);
            node.aabb.set(aabb);
            // Extend AABB.
            aabb = node.aabb;
            AABB.extend(aabb, SettingsInternal.aabbExtension);
            // Predict AABB displacement.
            // const d = Vec2.mul(Settings.aabbMultiplier, displacement);
            if (d.x < 0.0) {
                aabb.lowerBound.x += d.x * SettingsInternal.aabbMultiplier;
            }
            else {
                aabb.upperBound.x += d.x * SettingsInternal.aabbMultiplier;
            }
            if (d.y < 0.0) {
                aabb.lowerBound.y += d.y * SettingsInternal.aabbMultiplier;
            }
            else {
                aabb.upperBound.y += d.y * SettingsInternal.aabbMultiplier;
            }
            this.insertLeaf(node);
            return true;
        };
        DynamicTree.prototype.insertLeaf = function (leaf) {
            if (this.m_root == null) {
                this.m_root = leaf;
                this.m_root.parent = null;
                return;
            }
            // Find the best sibling for this node
            var leafAABB = leaf.aabb;
            var index = this.m_root;
            while (!index.isLeaf()) {
                var child1 = index.child1;
                var child2 = index.child2;
                var area = index.aabb.getPerimeter();
                var combinedArea = AABB.combinedPerimeter(index.aabb, leafAABB);
                // Cost of creating a new parent for this node and the new leaf
                var cost = 2.0 * combinedArea;
                // Minimum cost of pushing the leaf further down the tree
                var inheritanceCost = 2.0 * (combinedArea - area);
                // Cost of descending into child1
                var newArea1 = AABB.combinedPerimeter(leafAABB, child1.aabb);
                var cost1 = newArea1 + inheritanceCost;
                if (!child1.isLeaf()) {
                    var oldArea = child1.aabb.getPerimeter();
                    cost1 -= oldArea;
                }
                // Cost of descending into child2
                var newArea2 = AABB.combinedPerimeter(leafAABB, child2.aabb);
                var cost2 = newArea2 + inheritanceCost;
                if (!child2.isLeaf()) {
                    var oldArea = child2.aabb.getPerimeter();
                    cost2 -= oldArea;
                }
                // Descend according to the minimum cost.
                if (cost < cost1 && cost < cost2) {
                    break;
                }
                // Descend
                if (cost1 < cost2) {
                    index = child1;
                }
                else {
                    index = child2;
                }
            }
            var sibling = index;
            // Create a new parent.
            var oldParent = sibling.parent;
            var newParent = this.allocateNode();
            newParent.parent = oldParent;
            newParent.userData = null;
            newParent.aabb.combine(leafAABB, sibling.aabb);
            newParent.height = sibling.height + 1;
            if (oldParent != null) {
                // The sibling was not the root.
                if (oldParent.child1 === sibling) {
                    oldParent.child1 = newParent;
                }
                else {
                    oldParent.child2 = newParent;
                }
                newParent.child1 = sibling;
                newParent.child2 = leaf;
                sibling.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling was the root.
                newParent.child1 = sibling;
                newParent.child2 = leaf;
                sibling.parent = newParent;
                leaf.parent = newParent;
                this.m_root = newParent;
            }
            // Walk back up the tree fixing heights and AABBs
            index = leaf.parent;
            while (index != null) {
                index = this.balance(index);
                var child1 = index.child1;
                var child2 = index.child2;
                index.height = 1 + math_max$6(child1.height, child2.height);
                index.aabb.combine(child1.aabb, child2.aabb);
                index = index.parent;
            }
            // validate();
        };
        DynamicTree.prototype.removeLeaf = function (leaf) {
            if (leaf === this.m_root) {
                this.m_root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.child1 === leaf) {
                sibling = parent.child2;
            }
            else {
                sibling = parent.child1;
            }
            if (grandParent != null) {
                // Destroy parent and connect sibling to grandParent.
                if (grandParent.child1 === parent) {
                    grandParent.child1 = sibling;
                }
                else {
                    grandParent.child2 = sibling;
                }
                sibling.parent = grandParent;
                this.freeNode(parent);
                // Adjust ancestor bounds.
                var index = grandParent;
                while (index != null) {
                    index = this.balance(index);
                    var child1 = index.child1;
                    var child2 = index.child2;
                    index.aabb.combine(child1.aabb, child2.aabb);
                    index.height = 1 + math_max$6(child1.height, child2.height);
                    index = index.parent;
                }
            }
            else {
                this.m_root = sibling;
                sibling.parent = null;
                this.freeNode(parent);
            }
            // validate();
        };
        /**
         * Perform a left or right rotation if node A is imbalanced. Returns the new
         * root index.
         */
        DynamicTree.prototype.balance = function (iA) {
            var A = iA;
            if (A.isLeaf() || A.height < 2) {
                return iA;
            }
            var B = A.child1;
            var C = A.child2;
            var balance = C.height - B.height;
            // Rotate C up
            if (balance > 1) {
                var F = C.child1;
                var G = C.child2;
                // Swap A and C
                C.child1 = A;
                C.parent = A.parent;
                A.parent = C;
                // A's old parent should point to C
                if (C.parent != null) {
                    if (C.parent.child1 === iA) {
                        C.parent.child1 = C;
                    }
                    else {
                        C.parent.child2 = C;
                    }
                }
                else {
                    this.m_root = C;
                }
                // Rotate
                if (F.height > G.height) {
                    C.child2 = F;
                    A.child2 = G;
                    G.parent = A;
                    A.aabb.combine(B.aabb, G.aabb);
                    C.aabb.combine(A.aabb, F.aabb);
                    A.height = 1 + math_max$6(B.height, G.height);
                    C.height = 1 + math_max$6(A.height, F.height);
                }
                else {
                    C.child2 = G;
                    A.child2 = F;
                    F.parent = A;
                    A.aabb.combine(B.aabb, F.aabb);
                    C.aabb.combine(A.aabb, G.aabb);
                    A.height = 1 + math_max$6(B.height, F.height);
                    C.height = 1 + math_max$6(A.height, G.height);
                }
                return C;
            }
            // Rotate B up
            if (balance < -1) {
                var D = B.child1;
                var E = B.child2;
                // Swap A and B
                B.child1 = A;
                B.parent = A.parent;
                A.parent = B;
                // A's old parent should point to B
                if (B.parent != null) {
                    if (B.parent.child1 === A) {
                        B.parent.child1 = B;
                    }
                    else {
                        B.parent.child2 = B;
                    }
                }
                else {
                    this.m_root = B;
                }
                // Rotate
                if (D.height > E.height) {
                    B.child2 = D;
                    A.child1 = E;
                    E.parent = A;
                    A.aabb.combine(C.aabb, E.aabb);
                    B.aabb.combine(A.aabb, D.aabb);
                    A.height = 1 + math_max$6(C.height, E.height);
                    B.height = 1 + math_max$6(A.height, D.height);
                }
                else {
                    B.child2 = E;
                    A.child1 = D;
                    D.parent = A;
                    A.aabb.combine(C.aabb, D.aabb);
                    B.aabb.combine(A.aabb, E.aabb);
                    A.height = 1 + math_max$6(C.height, D.height);
                    B.height = 1 + math_max$6(A.height, E.height);
                }
                return B;
            }
            return A;
        };
        /**
         * Compute the height of the binary tree in O(N) time. Should not be called
         * often.
         */
        DynamicTree.prototype.getHeight = function () {
            if (this.m_root == null) {
                return 0;
            }
            return this.m_root.height;
        };
        /**
         * Get the ratio of the sum of the node areas to the root area.
         */
        DynamicTree.prototype.getAreaRatio = function () {
            if (this.m_root == null) {
                return 0.0;
            }
            var root = this.m_root;
            var rootArea = root.aabb.getPerimeter();
            var totalArea = 0.0;
            var node;
            var it = this.iteratorPool.allocate().preorder(this.m_root);
            while (node = it.next()) {
                if (node.height < 0) {
                    // Free node in pool
                    continue;
                }
                totalArea += node.aabb.getPerimeter();
            }
            this.iteratorPool.release(it);
            return totalArea / rootArea;
        };
        /**
         * Compute the height of a sub-tree.
         */
        DynamicTree.prototype.computeHeight = function (id) {
            var node;
            if (typeof id !== 'undefined') {
                node = this.m_nodes[id];
            }
            else {
                node = this.m_root;
            }
            // false && console.assert(0 <= id && id < this.m_nodeCapacity);
            if (node.isLeaf()) {
                return 0;
            }
            var height1 = this.computeHeight(node.child1.id);
            var height2 = this.computeHeight(node.child2.id);
            return 1 + math_max$6(height1, height2);
        };
        DynamicTree.prototype.validateStructure = function (node) {
            if (node == null) {
                return;
            }
            if (node === this.m_root) ;
            var child1 = node.child1;
            var child2 = node.child2;
            if (node.isLeaf()) {
                return;
            }
            this.validateStructure(child1);
            this.validateStructure(child2);
        };
        DynamicTree.prototype.validateMetrics = function (node) {
            if (node == null) {
                return;
            }
            var child1 = node.child1;
            var child2 = node.child2;
            if (node.isLeaf()) {
                return;
            }
            // false && console.assert(0 <= child1 && child1 < this.m_nodeCapacity);
            // false && console.assert(0 <= child2 && child2 < this.m_nodeCapacity);
            child1.height;
            child2.height;
            var aabb = new AABB();
            aabb.combine(child1.aabb, child2.aabb);
            this.validateMetrics(child1);
            this.validateMetrics(child2);
        };
        /**
         * Validate this tree. For testing.
         */
        DynamicTree.prototype.validate = function () {
            return;
        };
        /**
         * Get the maximum balance of an node in the tree. The balance is the difference
         * in height of the two children of a node.
         */
        DynamicTree.prototype.getMaxBalance = function () {
            var maxBalance = 0;
            var node;
            var it = this.iteratorPool.allocate().preorder(this.m_root);
            while (node = it.next()) {
                if (node.height <= 1) {
                    continue;
                }
                var balance = math_abs$8(node.child2.height - node.child1.height);
                maxBalance = math_max$6(maxBalance, balance);
            }
            this.iteratorPool.release(it);
            return maxBalance;
        };
        /**
         * Build an optimal tree. Very expensive. For testing.
         */
        DynamicTree.prototype.rebuildBottomUp = function () {
            var nodes = [];
            var count = 0;
            // Build array of leaves. Free the rest.
            var node;
            var it = this.iteratorPool.allocate().preorder(this.m_root);
            while (node = it.next()) {
                if (node.height < 0) {
                    // free node in pool
                    continue;
                }
                if (node.isLeaf()) {
                    node.parent = null;
                    nodes[count] = node;
                    ++count;
                }
                else {
                    this.freeNode(node);
                }
            }
            this.iteratorPool.release(it);
            while (count > 1) {
                var minCost = Infinity;
                var iMin = -1;
                var jMin = -1;
                for (var i = 0; i < count; ++i) {
                    var aabbi = nodes[i].aabb;
                    for (var j = i + 1; j < count; ++j) {
                        var aabbj = nodes[j].aabb;
                        var cost = AABB.combinedPerimeter(aabbi, aabbj);
                        if (cost < minCost) {
                            iMin = i;
                            jMin = j;
                            minCost = cost;
                        }
                    }
                }
                var child1 = nodes[iMin];
                var child2 = nodes[jMin];
                var parent_1 = this.allocateNode();
                parent_1.child1 = child1;
                parent_1.child2 = child2;
                parent_1.height = 1 + math_max$6(child1.height, child2.height);
                parent_1.aabb.combine(child1.aabb, child2.aabb);
                parent_1.parent = null;
                child1.parent = parent_1;
                child2.parent = parent_1;
                nodes[jMin] = nodes[count - 1];
                nodes[iMin] = parent_1;
                --count;
            }
            this.m_root = nodes[0];
        };
        /**
         * Shift the world origin. Useful for large worlds. The shift formula is:
         * position -= newOrigin
         *
         * @param newOrigin The new origin with respect to the old origin
         */
        DynamicTree.prototype.shiftOrigin = function (newOrigin) {
            // Build array of leaves. Free the rest.
            var node;
            var it = this.iteratorPool.allocate().preorder(this.m_root);
            while (node = it.next()) {
                var aabb = node.aabb;
                aabb.lowerBound.x -= newOrigin.x;
                aabb.lowerBound.y -= newOrigin.y;
                aabb.upperBound.x -= newOrigin.x;
                aabb.upperBound.y -= newOrigin.y;
            }
            this.iteratorPool.release(it);
        };
        /**
         * Query an AABB for overlapping proxies. The callback class is called for each
         * proxy that overlaps the supplied AABB.
         */
        DynamicTree.prototype.query = function (aabb, queryCallback) {
            var stack = this.stackPool.allocate();
            stack.push(this.m_root);
            while (stack.length > 0) {
                var node = stack.pop();
                if (node == null) {
                    continue;
                }
                if (AABB.testOverlap(node.aabb, aabb)) {
                    if (node.isLeaf()) {
                        var proceed = queryCallback(node.id);
                        if (proceed === false) {
                            return;
                        }
                    }
                    else {
                        stack.push(node.child1);
                        stack.push(node.child2);
                    }
                }
            }
            this.stackPool.release(stack);
        };
        /**
         * Ray-cast against the proxies in the tree. This relies on the callback to
         * perform a exact ray-cast in the case were the proxy contains a shape. The
         * callback also performs the any collision filtering. This has performance
         * roughly equal to k * log(n), where k is the number of collisions and n is the
         * number of proxies in the tree.
         *
         * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.
         * @param rayCastCallback A function that is called for each proxy that is hit by the ray.
         */
        DynamicTree.prototype.rayCast = function (input, rayCastCallback) {
            var p1 = input.p1;
            var p2 = input.p2;
            var r = Vec2.sub(p2, p1);
            r.normalize();
            // v is perpendicular to the segment.
            var v = Vec2.crossNumVec2(1.0, r);
            var abs_v = Vec2.abs(v);
            // Separating axis for segment (Gino, p80).
            // |dot(v, p1 - c)| > dot(|v|, h)
            var maxFraction = input.maxFraction;
            // Build a bounding box for the segment.
            var segmentAABB = new AABB();
            var t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);
            segmentAABB.combinePoints(p1, t);
            var stack = this.stackPool.allocate();
            var subInput = this.inputPool.allocate();
            stack.push(this.m_root);
            while (stack.length > 0) {
                var node = stack.pop();
                if (node == null) {
                    continue;
                }
                if (AABB.testOverlap(node.aabb, segmentAABB) === false) {
                    continue;
                }
                // Separating axis for segment (Gino, p80).
                // |dot(v, p1 - c)| > dot(|v|, h)
                var c = node.aabb.getCenter();
                var h = node.aabb.getExtents();
                var separation = math_abs$8(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);
                if (separation > 0.0) {
                    continue;
                }
                if (node.isLeaf()) {
                    subInput.p1 = Vec2.clone(input.p1);
                    subInput.p2 = Vec2.clone(input.p2);
                    subInput.maxFraction = maxFraction;
                    var value = rayCastCallback(subInput, node.id);
                    if (value === 0.0) {
                        // The client has terminated the ray cast.
                        return;
                    }
                    if (value > 0.0) {
                        // update segment bounding box.
                        maxFraction = value;
                        t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);
                        segmentAABB.combinePoints(p1, t);
                    }
                }
                else {
                    stack.push(node.child1);
                    stack.push(node.child2);
                }
            }
            this.stackPool.release(stack);
            this.inputPool.release(subInput);
        };
        return DynamicTree;
    }());
    /** @internal */
    var Iterator = /** @class */ (function () {
        function Iterator() {
            this.parents = [];
            this.states = [];
        }
        Iterator.prototype.preorder = function (root) {
            this.parents.length = 0;
            this.parents.push(root);
            this.states.length = 0;
            this.states.push(0);
            return this;
        };
        Iterator.prototype.next = function () {
            while (this.parents.length > 0) {
                var i = this.parents.length - 1;
                var node = this.parents[i];
                if (this.states[i] === 0) {
                    this.states[i] = 1;
                    return node;
                }
                if (this.states[i] === 1) {
                    this.states[i] = 2;
                    if (node.child1) {
                        this.parents.push(node.child1);
                        this.states.push(1);
                        return node.child1;
                    }
                }
                if (this.states[i] === 2) {
                    this.states[i] = 3;
                    if (node.child2) {
                        this.parents.push(node.child2);
                        this.states.push(1);
                        return node.child2;
                    }
                }
                this.parents.pop();
                this.states.pop();
            }
        };
        Iterator.prototype.close = function () {
            this.parents.length = 0;
        };
        return Iterator;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_max$5 = Math.max;
    /** @internal */ var math_min$6 = Math.min;
    /**
     * The broad-phase wraps and extends a dynamic-tree to keep track of moved
     * objects and query them on update.
     */
    var BroadPhase = /** @class */ (function () {
        function BroadPhase() {
            var _this = this;
            this.m_tree = new DynamicTree();
            this.m_moveBuffer = [];
            /**
             * Query an AABB for overlapping proxies. The callback class is called for each
             * proxy that overlaps the supplied AABB.
             */
            this.query = function (aabb, queryCallback) {
                _this.m_tree.query(aabb, queryCallback);
            };
            this.queryCallback = function (proxyId) {
                // A proxy cannot form a pair with itself.
                if (proxyId === _this.m_queryProxyId) {
                    return true;
                }
                var proxyIdA = math_min$6(proxyId, _this.m_queryProxyId);
                var proxyIdB = math_max$5(proxyId, _this.m_queryProxyId);
                // TODO: Skip any duplicate pairs.
                var userDataA = _this.m_tree.getUserData(proxyIdA);
                var userDataB = _this.m_tree.getUserData(proxyIdB);
                // Send the pairs back to the client.
                _this.m_callback(userDataA, userDataB);
                return true;
            };
        }
        /**
         * Get user data from a proxy. Returns null if the id is invalid.
         */
        BroadPhase.prototype.getUserData = function (proxyId) {
            return this.m_tree.getUserData(proxyId);
        };
        /**
         * Test overlap of fat AABBs.
         */
        BroadPhase.prototype.testOverlap = function (proxyIdA, proxyIdB) {
            var aabbA = this.m_tree.getFatAABB(proxyIdA);
            var aabbB = this.m_tree.getFatAABB(proxyIdB);
            return AABB.testOverlap(aabbA, aabbB);
        };
        /**
         * Get the fat AABB for a proxy.
         */
        BroadPhase.prototype.getFatAABB = function (proxyId) {
            return this.m_tree.getFatAABB(proxyId);
        };
        /**
         * Get the number of proxies.
         */
        BroadPhase.prototype.getProxyCount = function () {
            return this.m_moveBuffer.length;
        };
        /**
         * Get the height of the embedded tree.
         */
        BroadPhase.prototype.getTreeHeight = function () {
            return this.m_tree.getHeight();
        };
        /**
         * Get the balance (integer) of the embedded tree.
         */
        BroadPhase.prototype.getTreeBalance = function () {
            return this.m_tree.getMaxBalance();
        };
        /**
         * Get the quality metric of the embedded tree.
         */
        BroadPhase.prototype.getTreeQuality = function () {
            return this.m_tree.getAreaRatio();
        };
        /**
         * Ray-cast against the proxies in the tree. This relies on the callback to
         * perform a exact ray-cast in the case were the proxy contains a shape. The
         * callback also performs the any collision filtering. This has performance
         * roughly equal to k * log(n), where k is the number of collisions and n is the
         * number of proxies in the tree.
         *
         * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.
         * @param rayCastCallback A function that is called for each proxy that is hit by the ray.
         */
        BroadPhase.prototype.rayCast = function (input, rayCastCallback) {
            this.m_tree.rayCast(input, rayCastCallback);
        };
        /**
         * Shift the world origin. Useful for large worlds. The shift formula is:
         * position -= newOrigin
         *
         * @param newOrigin The new origin with respect to the old origin
         */
        BroadPhase.prototype.shiftOrigin = function (newOrigin) {
            this.m_tree.shiftOrigin(newOrigin);
        };
        /**
         * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs
         * is called.
         */
        BroadPhase.prototype.createProxy = function (aabb, userData) {
            var proxyId = this.m_tree.createProxy(aabb, userData);
            this.bufferMove(proxyId);
            return proxyId;
        };
        /**
         * Destroy a proxy. It is up to the client to remove any pairs.
         */
        BroadPhase.prototype.destroyProxy = function (proxyId) {
            this.unbufferMove(proxyId);
            this.m_tree.destroyProxy(proxyId);
        };
        /**
         * Call moveProxy as many times as you like, then when you are done call
         * UpdatePairs to finalized the proxy pairs (for your time step).
         */
        BroadPhase.prototype.moveProxy = function (proxyId, aabb, displacement) {
            var changed = this.m_tree.moveProxy(proxyId, aabb, displacement);
            if (changed) {
                this.bufferMove(proxyId);
            }
        };
        /**
         * Call to trigger a re-processing of it's pairs on the next call to
         * UpdatePairs.
         */
        BroadPhase.prototype.touchProxy = function (proxyId) {
            this.bufferMove(proxyId);
        };
        BroadPhase.prototype.bufferMove = function (proxyId) {
            this.m_moveBuffer.push(proxyId);
        };
        BroadPhase.prototype.unbufferMove = function (proxyId) {
            for (var i = 0; i < this.m_moveBuffer.length; ++i) {
                if (this.m_moveBuffer[i] === proxyId) {
                    this.m_moveBuffer[i] = null;
                }
            }
        };
        /**
         * Update the pairs. This results in pair callbacks. This can only add pairs.
         */
        BroadPhase.prototype.updatePairs = function (addPairCallback) {
            this.m_callback = addPairCallback;
            // Perform tree queries for all moving proxies.
            while (this.m_moveBuffer.length > 0) {
                this.m_queryProxyId = this.m_moveBuffer.pop();
                if (this.m_queryProxyId === null) {
                    continue;
                }
                // We have to query the tree with the fat AABB so that
                // we don't fail to create a pair that may touch later.
                var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);
                // Query tree, create pairs and add them pair buffer.
                this.m_tree.query(fatAABB, this.queryCallback);
            }
            // Try to keep the tree balanced.
            // this.m_tree.rebalance(4);
        };
        return BroadPhase;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2023 Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_sin$2 = Math.sin;
    /** @internal */ var math_cos$2 = Math.cos;
    /** @internal */ var math_sqrt$4 = Math.sqrt;
    function vec2(x, y) {
        return { x: x, y: y };
    }
    function rotation(angle) {
        return { s: math_sin$2(angle), c: math_cos$2(angle) };
    }
    function setVec2(out, x, y) {
        out.x = x;
        out.y = y;
        return out;
    }
    function copyVec2(out, w) {
        out.x = w.x;
        out.y = w.y;
        return out;
    }
    function zeroVec2(out) {
        out.x = 0;
        out.y = 0;
        return out;
    }
    function negVec2(out) {
        out.x = -out.x;
        out.y = -out.y;
        return out;
    }
    function addVec2(out, w) {
        out.x += w.x;
        out.y += w.y;
        return out;
    }
    function sumVec2(out, v, w) {
        out.x = v.x + w.x;
        out.y = v.x + w.y;
        return out;
    }
    function subVec2(out, w) {
        out.x -= w.x;
        out.y -= w.y;
        return out;
    }
    function diffVec2(out, v, w) {
        out.x = v.x - w.x;
        out.y = v.y - w.y;
        return out;
    }
    function scaleVec2(out, m) {
        out.x *= m;
        out.y *= m;
        return out;
    }
    function setMulVec2(out, m, w) {
        out.x = m * w.x;
        out.y = m * w.y;
        return out;
    }
    function addMulVec2(out, m, w) {
        out.x += m * w.x;
        out.y += m * w.y;
        return out;
    }
    function subMulVec2(out, m, w) {
        out.x -= m * w.x;
        out.y -= m * w.y;
        return out;
    }
    function combineVec2(out, am, a, bm, b) {
        out.x = am * a.x + bm * b.x;
        out.y = am * a.y + bm * b.y;
        return out;
    }
    function normalizeVec2Length(out) {
        var length = math_sqrt$4(out.x * out.x + out.y * out.y);
        if (length !== 0) {
            var invLength = 1 / length;
            out.x *= invLength;
            out.y *= invLength;
        }
        return length;
    }
    function normalizeVec2(out) {
        var length = math_sqrt$4(out.x * out.x + out.y * out.y);
        if (length > 0) {
            var invLength = 1 / length;
            out.x *= invLength;
            out.y *= invLength;
        }
        return out;
    }
    function crossVec2Num(out, v, w) {
        var x = w * v.y;
        var y = -w * v.x;
        out.x = x;
        out.y = y;
        return out;
    }
    function crossNumVec2(out, w, v) {
        var x = -w * v.y;
        var y = w * v.x;
        out.x = x;
        out.y = y;
        return out;
    }
    function crossVec2Vec2(a, b) {
        return a.x * b.y - a.y * b.x;
    }
    function dotVec2(a, b) {
        return a.x * b.x + a.y * b.y;
    }
    function lengthSqrVec2(a) {
        return a.x * a.x + a.y * a.y;
    }
    function distVec2(a, b) {
        var dx = a.x - b.x;
        var dy = a.y - b.y;
        return math_sqrt$4(dx * dx + dy * dy);
    }
    function distSqrVec2(a, b) {
        var dx = a.x - b.x;
        var dy = a.y - b.y;
        return dx * dx + dy * dy;
    }
    function setRotAngle(out, a) {
        out.c = math_cos$2(a);
        out.s = math_sin$2(a);
        return out;
    }
    function rotVec2(out, q, v) {
        out.x = q.c * v.x - q.s * v.y;
        out.y = q.s * v.x + q.c * v.y;
        return out;
    }
    function invRotVec2(out, q, v) {
        var x = q.c * v.x + q.s * v.y;
        var y = -q.s * v.x + q.c * v.y;
        out.x = x;
        out.y = y;
        return out;
    }
    function rerotVec2(out, before, after, v) {
        var x0 = before.c * v.x + before.s * v.y;
        var y0 = -before.s * v.x + before.c * v.y;
        var x = after.c * x0 - after.s * y0;
        var y = after.s * x0 + after.c * y0;
        out.x = x;
        out.y = y;
        return out;
    }
    function transform(x, y, a) {
        return { p: vec2(x, y), q: rotation(a) };
    }
    function copyTransform(out, transform) {
        out.p.x = transform.p.x;
        out.p.y = transform.p.y;
        out.q.s = transform.q.s;
        out.q.c = transform.q.c;
        return out;
    }
    function transformVec2(out, xf, v) {
        var x = xf.q.c * v.x - xf.q.s * v.y + xf.p.x;
        var y = xf.q.s * v.x + xf.q.c * v.y + xf.p.y;
        out.x = x;
        out.y = y;
        return out;
    }
    function invTransformVec2(out, xf, v) {
        var px = v.x - xf.p.x;
        var py = v.y - xf.p.y;
        var x = (xf.q.c * px + xf.q.s * py);
        var y = (-xf.q.s * px + xf.q.c * py);
        out.x = x;
        out.y = y;
        return out;
    }
    function retransformVec2(out, from, to, v) {
        var x0 = from.q.c * v.x - from.q.s * v.y + from.p.x;
        var y0 = from.q.s * v.x + from.q.c * v.y + from.p.y;
        var px = x0 - to.p.x;
        var py = y0 - to.p.y;
        var x = to.q.c * px + to.q.s * py;
        var y = -to.q.s * px + to.q.c * py;
        out.x = x;
        out.y = y;
        return out;
    }
    function invTransformTransform(out, a, b) {
        var c = a.q.c * b.q.c + a.q.s * b.q.s;
        var s = a.q.c * b.q.s - a.q.s * b.q.c;
        var x = a.q.c * (b.p.x - a.p.x) + a.q.s * (b.p.y - a.p.y);
        var y = -a.q.s * (b.p.x - a.p.x) + a.q.c * (b.p.y - a.p.y);
        out.q.c = c;
        out.q.s = s;
        out.p.x = x;
        out.p.y = y;
        return out;
    }

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_sin$1 = Math.sin;
    /** @internal */ var math_cos$1 = Math.cos;
    /** @internal */ var math_atan2$1 = Math.atan2;
    var Rot = /** @class */ (function () {
        /** Initialize from an angle in radians. */
        function Rot(angle) {
            if (!(this instanceof Rot)) {
                return new Rot(angle);
            }
            if (typeof angle === 'number') {
                this.setAngle(angle);
            }
            else if (typeof angle === 'object') {
                this.setRot(angle);
            }
            else {
                this.setIdentity();
            }
        }
        /** @internal */
        Rot.neo = function (angle) {
            var obj = Object.create(Rot.prototype);
            obj.setAngle(angle);
            return obj;
        };
        Rot.clone = function (rot) {
            var obj = Object.create(Rot.prototype);
            obj.s = rot.s;
            obj.c = rot.c;
            return obj;
        };
        Rot.identity = function () {
            var obj = Object.create(Rot.prototype);
            obj.s = 0.0;
            obj.c = 1.0;
            return obj;
        };
        Rot.isValid = function (obj) {
            if (obj === null || typeof obj === 'undefined') {
                return false;
            }
            return Number.isFinite(obj.s) && Number.isFinite(obj.c);
        };
        Rot.assert = function (o) {
        };
        /** Set to the identity rotation. */
        Rot.prototype.setIdentity = function () {
            this.s = 0.0;
            this.c = 1.0;
        };
        Rot.prototype.set = function (angle) {
            if (typeof angle === 'object') {
                this.s = angle.s;
                this.c = angle.c;
            }
            else {
                // TODO_ERIN optimize
                this.s = math_sin$1(angle);
                this.c = math_cos$1(angle);
            }
        };
        Rot.prototype.setRot = function (angle) {
            this.s = angle.s;
            this.c = angle.c;
        };
        /** Set using an angle in radians. */
        Rot.prototype.setAngle = function (angle) {
            // TODO_ERIN optimize
            this.s = math_sin$1(angle);
            this.c = math_cos$1(angle);
        };
        /** Get the angle in radians. */
        Rot.prototype.getAngle = function () {
            return math_atan2$1(this.s, this.c);
        };
        /** Get the x-axis. */
        Rot.prototype.getXAxis = function () {
            return Vec2.neo(this.c, this.s);
        };
        /** Get the y-axis. */
        Rot.prototype.getYAxis = function () {
            return Vec2.neo(-this.s, this.c);
        };
        Rot.mul = function (rot, m) {
            if ('c' in m && 's' in m) {
                // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
                // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
                // s = qs * rc + qc * rs
                // c = qc * rc - qs * rs
                var qr = Rot.identity();
                qr.s = rot.s * m.c + rot.c * m.s;
                qr.c = rot.c * m.c - rot.s * m.s;
                return qr;
            }
            else if ('x' in m && 'y' in m) {
                return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
            }
        };
        /** Multiply two rotations: q * r */
        Rot.mulRot = function (rot, m) {
            // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
            // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
            // s = qs * rc + qc * rs
            // c = qc * rc - qs * rs
            var qr = Rot.identity();
            qr.s = rot.s * m.c + rot.c * m.s;
            qr.c = rot.c * m.c - rot.s * m.s;
            return qr;
        };
        /** Rotate a vector */
        Rot.mulVec2 = function (rot, m) {
            return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
        };
        Rot.mulSub = function (rot, v, w) {
            var x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);
            var y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);
            return Vec2.neo(x, y);
        };
        Rot.mulT = function (rot, m) {
            if ('c' in m && 's' in m) {
                // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
                // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
                // s = qc * rs - qs * rc
                // c = qc * rc + qs * rs
                var qr = Rot.identity();
                qr.s = rot.c * m.s - rot.s * m.c;
                qr.c = rot.c * m.c + rot.s * m.s;
                return qr;
            }
            else if ('x' in m && 'y' in m) {
                return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
            }
        };
        /** Transpose multiply two rotations: qT * r */
        Rot.mulTRot = function (rot, m) {
            // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
            // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
            // s = qc * rs - qs * rc
            // c = qc * rc + qs * rs
            var qr = Rot.identity();
            qr.s = rot.c * m.s - rot.s * m.c;
            qr.c = rot.c * m.c + rot.s * m.s;
            return qr;
        };
        /** Inverse rotate a vector */
        Rot.mulTVec2 = function (rot, m) {
            return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
        };
        return Rot;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_atan2 = Math.atan2;
    /** @internal */ var math_PI$5 = Math.PI;
    /** @internal */ var temp$7 = vec2(0, 0);
    /**
     * This describes the motion of a body/shape for TOI computation. Shapes are
     * defined with respect to the body origin, which may not coincide with the
     * center of mass. However, to support dynamics we must interpolate the center
     * of mass position.
     */
    var Sweep = /** @class */ (function () {
        function Sweep() {
            /** Local center of mass position */
            this.localCenter = Vec2.zero();
            /** World center position */
            this.c = Vec2.zero();
            /** World angle */
            this.a = 0;
            /** Fraction of the current time step in the range [0,1], c0 and a0 are c and a at alpha0. */
            this.alpha0 = 0;
            this.c0 = Vec2.zero();
            this.a0 = 0;
        }
        /** @internal */
        Sweep.prototype.recycle = function () {
            zeroVec2(this.localCenter);
            zeroVec2(this.c);
            this.a = 0;
            this.alpha0 = 0;
            zeroVec2(this.c0);
            this.a0 = 0;
        };
        Sweep.prototype.setTransform = function (xf) {
            transformVec2(temp$7, xf, this.localCenter);
            copyVec2(this.c, temp$7);
            copyVec2(this.c0, temp$7);
            this.a = this.a0 = math_atan2(xf.q.s, xf.q.c);
        };
        Sweep.prototype.setLocalCenter = function (localCenter, xf) {
            copyVec2(this.localCenter, localCenter);
            transformVec2(temp$7, xf, this.localCenter);
            copyVec2(this.c, temp$7);
            copyVec2(this.c0, temp$7);
        };
        /**
         * Get the interpolated transform at a specific time.
         *
         * @param xf
         * @param beta A factor in [0,1], where 0 indicates alpha0
         */
        Sweep.prototype.getTransform = function (xf, beta) {
            if (beta === void 0) { beta = 0; }
            setRotAngle(xf.q, (1.0 - beta) * this.a0 + beta * this.a);
            combineVec2(xf.p, (1.0 - beta), this.c0, beta, this.c);
            // shift to origin
            subVec2(xf.p, rotVec2(temp$7, xf.q, this.localCenter));
        };
        /**
         * Advance the sweep forward, yielding a new initial state.
         *
         * @param alpha The new initial time
         */
        Sweep.prototype.advance = function (alpha) {
            var beta = (alpha - this.alpha0) / (1.0 - this.alpha0);
            combineVec2(this.c0, beta, this.c, 1 - beta, this.c0);
            this.a0 = beta * this.a + (1 - beta) * this.a0;
            this.alpha0 = alpha;
        };
        Sweep.prototype.forward = function () {
            this.a0 = this.a;
            copyVec2(this.c0, this.c);
        };
        /**
         * normalize the angles in radians to be between -pi and pi.
         */
        Sweep.prototype.normalize = function () {
            var a0 = mod(this.a0, -math_PI$5, +math_PI$5);
            this.a -= this.a0 - a0;
            this.a0 = a0;
        };
        Sweep.prototype.set = function (that) {
            copyVec2(this.localCenter, that.localCenter);
            copyVec2(this.c, that.c);
            this.a = that.a;
            this.alpha0 = that.alpha0;
            copyVec2(this.c0, that.c0);
            this.a0 = that.a0;
        };
        return Sweep;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * A transform contains translation and rotation. It is used to represent the
     * position and orientation of rigid frames. Initialize using a position vector
     * and a rotation.
     */
    var Transform = /** @class */ (function () {
        function Transform(position, rotation) {
            if (!(this instanceof Transform)) {
                return new Transform(position, rotation);
            }
            this.p = Vec2.zero();
            this.q = Rot.identity();
            if (typeof position !== 'undefined') {
                this.p.setVec2(position);
            }
            if (typeof rotation !== 'undefined') {
                this.q.setAngle(rotation);
            }
        }
        Transform.clone = function (xf) {
            var obj = Object.create(Transform.prototype);
            obj.p = Vec2.clone(xf.p);
            obj.q = Rot.clone(xf.q);
            return obj;
        };
        /** @internal */
        Transform.neo = function (position, rotation) {
            var obj = Object.create(Transform.prototype);
            obj.p = Vec2.clone(position);
            obj.q = Rot.clone(rotation);
            return obj;
        };
        Transform.identity = function () {
            var obj = Object.create(Transform.prototype);
            obj.p = Vec2.zero();
            obj.q = Rot.identity();
            return obj;
        };
        /** Set this to the identity transform */
        Transform.prototype.setIdentity = function () {
            this.p.setZero();
            this.q.setIdentity();
        };
        Transform.prototype.set = function (a, b) {
            if (typeof b === 'undefined') {
                this.p.set(a.p);
                this.q.set(a.q);
            }
            else {
                this.p.set(a);
                this.q.set(b);
            }
        };
        /** Set position and angle */
        Transform.prototype.setNum = function (position, rotation) {
            this.p.setVec2(position);
            this.q.setAngle(rotation);
        };
        Transform.prototype.setTransform = function (xf) {
            this.p.setVec2(xf.p);
            this.q.setRot(xf.q);
        };
        Transform.isValid = function (obj) {
            if (obj === null || typeof obj === 'undefined') {
                return false;
            }
            return Vec2.isValid(obj.p) && Rot.isValid(obj.q);
        };
        Transform.assert = function (o) {
        };
        // static mul(a: Transform, b: Vec2Value[]): Vec2[];
        // static mul(a: Transform, b: Transform[]): Transform[];
        Transform.mul = function (a, b) {
            if (Array.isArray(b)) {
                var arr = [];
                for (var i = 0; i < b.length; i++) {
                    arr[i] = Transform.mul(a, b[i]);
                }
                return arr;
            }
            else if ('x' in b && 'y' in b) {
                return Transform.mulVec2(a, b);
            }
            else if ('p' in b && 'q' in b) {
                return Transform.mulXf(a, b);
            }
        };
        Transform.mulAll = function (a, b) {
            var arr = [];
            for (var i = 0; i < b.length; i++) {
                arr[i] = Transform.mul(a, b[i]);
            }
            return arr;
        };
        /** @internal @deprecated */
        Transform.mulFn = function (a) {
            return function (b) {
                return Transform.mul(a, b);
            };
        };
        Transform.mulVec2 = function (a, b) {
            var x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;
            var y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;
            return Vec2.neo(x, y);
        };
        Transform.mulXf = function (a, b) {
            // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
            // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
            var xf = Transform.identity();
            xf.q = Rot.mulRot(a.q, b.q);
            xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);
            return xf;
        };
        Transform.mulT = function (a, b) {
            if ('x' in b && 'y' in b) {
                return Transform.mulTVec2(a, b);
            }
            else if ('p' in b && 'q' in b) {
                return Transform.mulTXf(a, b);
            }
        };
        Transform.mulTVec2 = function (a, b) {
            var px = b.x - a.p.x;
            var py = b.y - a.p.y;
            var x = (a.q.c * px + a.q.s * py);
            var y = (-a.q.s * px + a.q.c * py);
            return Vec2.neo(x, y);
        };
        Transform.mulTXf = function (a, b) {
            // v2 = A.q' * (B.q * v1 + B.p - A.p)
            // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
            var xf = Transform.identity();
            xf.q.setRot(Rot.mulTRot(a.q, b.q));
            xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));
            return xf;
        };
        return Transform;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    var Velocity = /** @class */ (function () {
        function Velocity() {
            /** linear */
            this.v = Vec2.zero();
            /** angular */
            this.w = 0;
        }
        return Velocity;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_sin = Math.sin;
    /** @internal */ var math_cos = Math.cos;
    var Position = /** @class */ (function () {
        function Position() {
            /** location */
            this.c = Vec2.zero();
            /** angle */
            this.a = 0;
        }
        // todo: cache sin/cos
        Position.prototype.getTransform = function (xf, p) {
            // xf.q = rotation(this.a);
            // xf.p = this.c - xf.q * p
            xf.q.c = math_cos(this.a);
            xf.q.s = math_sin(this.a);
            xf.p.x = this.c.x - (xf.q.c * p.x - xf.q.s * p.y);
            xf.p.y = this.c.y - (xf.q.s * p.x + xf.q.c * p.y);
            return xf;
        };
        return Position;
    }());
    function getTransform(xf, p, c, a) {
        // xf.q = rotation(a);
        // xf.p = this.c - xf.q * p
        xf.q.c = math_cos(a);
        xf.q.s = math_sin(a);
        xf.p.x = c.x - (xf.q.c * p.x - xf.q.s * p.y);
        xf.p.y = c.y - (xf.q.s * p.x + xf.q.c * p.y);
        return xf;
    }

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    // todo make shape an interface
    /**
     * A shape is used for collision detection. You can create a shape however you
     * like. Shapes used for simulation in World are created automatically when a
     * Fixture is created. Shapes may encapsulate one or more child shapes.
     */
    var Shape = /** @class */ (function () {
        function Shape() {
        }
        Shape.isValid = function (obj) {
            if (obj === null || typeof obj === 'undefined') {
                return false;
            }
            return typeof obj.m_type === 'string' && typeof obj.m_radius === 'number';
        };
        return Shape;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var synchronize_aabb1 = new AABB();
    /** @internal */ var synchronize_aabb2 = new AABB();
    /** @internal */ var displacement = vec2(0, 0);
    /** @internal */ var FixtureDefDefault = {
        userData: null,
        friction: 0.2,
        restitution: 0.0,
        density: 0.0,
        isSensor: false,
        filterGroupIndex: 0,
        filterCategoryBits: 0x0001,
        filterMaskBits: 0xFFFF
    };
    /**
     * This proxy is used internally to connect shape children to the broad-phase.
     */
    var FixtureProxy = /** @class */ (function () {
        function FixtureProxy(fixture, childIndex) {
            this.aabb = new AABB();
            this.fixture = fixture;
            this.childIndex = childIndex;
            this.proxyId;
        }
        return FixtureProxy;
    }());
    /**
     * A fixture is used to attach a shape to a body for collision detection. A
     * fixture inherits its transform from its parent. Fixtures hold additional
     * non-geometric data such as friction, collision filters, etc.
     *
     * To create a new Fixture use {@link Body.createFixture}.
     */
    var Fixture = /** @class */ (function () {
        /** @internal */
        function Fixture(body, shape, def) {
            if (shape.shape) {
                def = shape;
                shape = shape.shape;
            }
            else if (typeof def === 'number') {
                def = { density: def };
            }
            def = options(def, FixtureDefDefault);
            this.m_body = body;
            this.m_friction = def.friction;
            this.m_restitution = def.restitution;
            this.m_density = def.density;
            this.m_isSensor = def.isSensor;
            this.m_filterGroupIndex = def.filterGroupIndex;
            this.m_filterCategoryBits = def.filterCategoryBits;
            this.m_filterMaskBits = def.filterMaskBits;
            // TODO validate shape
            this.m_shape = shape; // .clone();
            this.m_next = null;
            this.m_proxies = [];
            this.m_proxyCount = 0;
            // fixture proxies are created here,
            // but they are activate in when a fixture is added to body
            var childCount = this.m_shape.getChildCount();
            for (var i = 0; i < childCount; ++i) {
                this.m_proxies[i] = new FixtureProxy(this, i);
            }
            this.m_userData = def.userData;
        }
        /** @internal Re-setup fixture. */
        Fixture.prototype._reset = function () {
            var body = this.getBody();
            var broadPhase = body.m_world.m_broadPhase;
            this.destroyProxies(broadPhase);
            if (this.m_shape._reset) {
                this.m_shape._reset();
            }
            var childCount = this.m_shape.getChildCount();
            for (var i = 0; i < childCount; ++i) {
                this.m_proxies[i] = new FixtureProxy(this, i);
            }
            this.createProxies(broadPhase, body.m_xf);
            body.resetMassData();
        };
        /** @internal */
        Fixture.prototype._serialize = function () {
            return {
                friction: this.m_friction,
                restitution: this.m_restitution,
                density: this.m_density,
                isSensor: this.m_isSensor,
                filterGroupIndex: this.m_filterGroupIndex,
                filterCategoryBits: this.m_filterCategoryBits,
                filterMaskBits: this.m_filterMaskBits,
                shape: this.m_shape,
            };
        };
        /** @internal */
        Fixture._deserialize = function (data, body, restore) {
            var shape = restore(Shape, data.shape);
            var fixture = shape && new Fixture(body, shape, data);
            return fixture;
        };
        /**
         * Get the type of the child shape. You can use this to down cast to the
         * concrete shape.
         */
        Fixture.prototype.getType = function () {
            return this.m_shape.m_type;
        };
        /**
         * Get the child shape. You can modify the child shape, however you should not
         * change the number of vertices because this will crash some collision caching
         * mechanisms. Manipulating the shape may lead to non-physical behavior.
         */
        Fixture.prototype.getShape = function () {
            return this.m_shape;
        };
        /**
         * A sensor shape collects contact information but never generates a collision
         * response.
         */
        Fixture.prototype.isSensor = function () {
            return this.m_isSensor;
        };
        /**
         * Set if this fixture is a sensor.
         */
        Fixture.prototype.setSensor = function (sensor) {
            if (sensor != this.m_isSensor) {
                this.m_body.setAwake(true);
                this.m_isSensor = sensor;
            }
        };
        // /**
        //  * Get the contact filtering data.
        //  */
        // getFilterData() {
        //   return this.m_filter;
        // }
        /**
         * Get the user data that was assigned in the fixture definition. Use this to
         * store your application specific data.
         */
        Fixture.prototype.getUserData = function () {
            return this.m_userData;
        };
        /**
         * Set the user data. Use this to store your application specific data.
         */
        Fixture.prototype.setUserData = function (data) {
            this.m_userData = data;
        };
        /**
         * Get the parent body of this fixture. This is null if the fixture is not
         * attached.
         */
        Fixture.prototype.getBody = function () {
            return this.m_body;
        };
        /**
         * Get the next fixture in the parent body's fixture list.
         */
        Fixture.prototype.getNext = function () {
            return this.m_next;
        };
        /**
         * Get the density of this fixture.
         */
        Fixture.prototype.getDensity = function () {
            return this.m_density;
        };
        /**
         * Set the density of this fixture. This will _not_ automatically adjust the
         * mass of the body. You must call Body.resetMassData to update the body's mass.
         */
        Fixture.prototype.setDensity = function (density) {
            this.m_density = density;
        };
        /**
         * Get the coefficient of friction, usually in the range [0,1].
         */
        Fixture.prototype.getFriction = function () {
            return this.m_friction;
        };
        /**
         * Set the coefficient of friction. This will not change the friction of
         * existing contacts.
         */
        Fixture.prototype.setFriction = function (friction) {
            this.m_friction = friction;
        };
        /**
         * Get the coefficient of restitution.
         */
        Fixture.prototype.getRestitution = function () {
            return this.m_restitution;
        };
        /**
         * Set the coefficient of restitution. This will not change the restitution of
         * existing contacts.
         */
        Fixture.prototype.setRestitution = function (restitution) {
            this.m_restitution = restitution;
        };
        /**
         * Test a point in world coordinates for containment in this fixture.
         */
        Fixture.prototype.testPoint = function (p) {
            return this.m_shape.testPoint(this.m_body.getTransform(), p);
        };
        /**
         * Cast a ray against this shape.
         */
        Fixture.prototype.rayCast = function (output, input, childIndex) {
            return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);
        };
        /**
         * Get the mass data for this fixture. The mass data is based on the density and
         * the shape. The rotational inertia is about the shape's origin. This operation
         * may be expensive.
         */
        Fixture.prototype.getMassData = function (massData) {
            this.m_shape.computeMass(massData, this.m_density);
        };
        /**
         * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a
         * more accurate AABB, compute it using the shape and the body transform.
         */
        Fixture.prototype.getAABB = function (childIndex) {
            return this.m_proxies[childIndex].aabb;
        };
        /**
         * These support body activation/deactivation.
         */
        Fixture.prototype.createProxies = function (broadPhase, xf) {
            // Create proxies in the broad-phase.
            this.m_proxyCount = this.m_shape.getChildCount();
            for (var i = 0; i < this.m_proxyCount; ++i) {
                var proxy = this.m_proxies[i];
                this.m_shape.computeAABB(proxy.aabb, xf, i);
                proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
            }
        };
        Fixture.prototype.destroyProxies = function (broadPhase) {
            // Destroy proxies in the broad-phase.
            for (var i = 0; i < this.m_proxyCount; ++i) {
                var proxy = this.m_proxies[i];
                broadPhase.destroyProxy(proxy.proxyId);
                proxy.proxyId = null;
            }
            this.m_proxyCount = 0;
        };
        /**
         * Updates this fixture proxy in broad-phase (with combined AABB of current and
         * next transformation).
         */
        Fixture.prototype.synchronize = function (broadPhase, xf1, xf2) {
            for (var i = 0; i < this.m_proxyCount; ++i) {
                var proxy = this.m_proxies[i];
                // Compute an AABB that covers the swept shape (may miss some rotation
                // effect).
                this.m_shape.computeAABB(synchronize_aabb1, xf1, proxy.childIndex);
                this.m_shape.computeAABB(synchronize_aabb2, xf2, proxy.childIndex);
                proxy.aabb.combine(synchronize_aabb1, synchronize_aabb2);
                diffVec2(displacement, xf2.p, xf1.p);
                broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);
            }
        };
        /**
         * Set the contact filtering data. This will not update contacts until the next
         * time step when either parent body is active and awake. This automatically
         * calls refilter.
         */
        Fixture.prototype.setFilterData = function (filter) {
            this.m_filterGroupIndex = filter.groupIndex;
            this.m_filterCategoryBits = filter.categoryBits;
            this.m_filterMaskBits = filter.maskBits;
            this.refilter();
        };
        Fixture.prototype.getFilterGroupIndex = function () {
            return this.m_filterGroupIndex;
        };
        Fixture.prototype.setFilterGroupIndex = function (groupIndex) {
            this.m_filterGroupIndex = groupIndex;
            this.refilter();
        };
        Fixture.prototype.getFilterCategoryBits = function () {
            return this.m_filterCategoryBits;
        };
        Fixture.prototype.setFilterCategoryBits = function (categoryBits) {
            this.m_filterCategoryBits = categoryBits;
            this.refilter();
        };
        Fixture.prototype.getFilterMaskBits = function () {
            return this.m_filterMaskBits;
        };
        Fixture.prototype.setFilterMaskBits = function (maskBits) {
            this.m_filterMaskBits = maskBits;
            this.refilter();
        };
        /**
         * Call this if you want to establish collision that was previously disabled by
         * ContactFilter.
         */
        Fixture.prototype.refilter = function () {
            if (this.m_body == null) {
                return;
            }
            // Flag associated contacts for filtering.
            var edge = this.m_body.getContactList();
            while (edge) {
                var contact = edge.contact;
                var fixtureA = contact.getFixtureA();
                var fixtureB = contact.getFixtureB();
                if (fixtureA == this || fixtureB == this) {
                    contact.flagForFiltering();
                }
                edge = edge.next;
            }
            var world = this.m_body.getWorld();
            if (world == null) {
                return;
            }
            // Touch each proxy so that new pairs may be created
            var broadPhase = world.m_broadPhase;
            for (var i = 0; i < this.m_proxyCount; ++i) {
                broadPhase.touchProxy(this.m_proxies[i].proxyId);
            }
        };
        /**
         * Implement this method to provide collision filtering, if you want finer
         * control over contact creation.
         *
         * Return true if contact calculations should be performed between these two
         * fixtures.
         *
         * Warning: for performance reasons this is only called when the AABBs begin to
         * overlap.
         */
        Fixture.prototype.shouldCollide = function (that) {
            if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {
                return that.m_filterGroupIndex > 0;
            }
            var collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;
            var collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;
            var collide = collideA && collideB;
            return collide;
        };
        return Fixture;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var STATIC = 'static';
    /** @internal */ var KINEMATIC = 'kinematic';
    /** @internal */ var DYNAMIC = 'dynamic';
    /** @internal */ var oldCenter = vec2(0, 0);
    /** @internal */ var localCenter = vec2(0, 0);
    /** @internal */ var shift = vec2(0, 0);
    /** @internal */ var temp$6 = vec2(0, 0);
    /** @internal */ var xf$2 = transform(0, 0, 0);
    /** @internal */ var BodyDefDefault = {
        type: STATIC,
        position: Vec2.zero(),
        angle: 0.0,
        linearVelocity: Vec2.zero(),
        angularVelocity: 0.0,
        linearDamping: 0.0,
        angularDamping: 0.0,
        fixedRotation: false,
        bullet: false,
        gravityScale: 1.0,
        allowSleep: true,
        awake: true,
        active: true,
        userData: null
    };
    /**
     * A rigid body composed of one or more fixtures.
     *
     * To create a new Body use {@link World.createBody}.
     */
    var Body = /** @class */ (function () {
        /** @internal */
        function Body(world, def) {
            def = options(def, BodyDefDefault);
            this.m_world = world;
            this.m_awakeFlag = def.awake;
            this.m_autoSleepFlag = def.allowSleep;
            this.m_bulletFlag = def.bullet;
            this.m_fixedRotationFlag = def.fixedRotation;
            this.m_activeFlag = def.active;
            this.m_islandFlag = false;
            this.m_toiFlag = false;
            this.m_userData = def.userData;
            this.m_type = def.type;
            if (this.m_type == DYNAMIC) {
                this.m_mass = 1.0;
                this.m_invMass = 1.0;
            }
            else {
                this.m_mass = 0.0;
                this.m_invMass = 0.0;
            }
            // Rotational inertia about the center of mass.
            this.m_I = 0.0;
            this.m_invI = 0.0;
            // the body origin transform
            this.m_xf = Transform.identity();
            this.m_xf.p.setVec2(def.position);
            this.m_xf.q.setAngle(def.angle);
            // the swept motion for CCD
            this.m_sweep = new Sweep();
            this.m_sweep.setTransform(this.m_xf);
            // position and velocity correction
            this.c_velocity = new Velocity();
            this.c_position = new Position();
            this.m_force = Vec2.zero();
            this.m_torque = 0.0;
            this.m_linearVelocity = Vec2.clone(def.linearVelocity);
            this.m_angularVelocity = def.angularVelocity;
            this.m_linearDamping = def.linearDamping;
            this.m_angularDamping = def.angularDamping;
            this.m_gravityScale = def.gravityScale;
            this.m_sleepTime = 0.0;
            this.m_jointList = null;
            this.m_contactList = null;
            this.m_fixtureList = null;
            this.m_prev = null;
            this.m_next = null;
            this.m_destroyed = false;
        }
        /** @internal */
        Body.prototype._serialize = function () {
            var fixtures = [];
            for (var f = this.m_fixtureList; f; f = f.m_next) {
                fixtures.push(f);
            }
            return {
                type: this.m_type,
                bullet: this.m_bulletFlag,
                position: this.m_xf.p,
                angle: this.m_xf.q.getAngle(),
                linearVelocity: this.m_linearVelocity,
                angularVelocity: this.m_angularVelocity,
                fixtures: fixtures,
            };
        };
        /** @internal */
        Body._deserialize = function (data, world, restore) {
            var body = new Body(world, data);
            if (data.fixtures) {
                for (var i = data.fixtures.length - 1; i >= 0; i--) {
                    var fixture = restore(Fixture, data.fixtures[i], body);
                    body._addFixture(fixture);
                }
            }
            return body;
        };
        Body.prototype.isWorldLocked = function () {
            return this.m_world && this.m_world.isLocked() ? true : false;
        };
        Body.prototype.getWorld = function () {
            return this.m_world;
        };
        Body.prototype.getNext = function () {
            return this.m_next;
        };
        Body.prototype.setUserData = function (data) {
            this.m_userData = data;
        };
        Body.prototype.getUserData = function () {
            return this.m_userData;
        };
        Body.prototype.getFixtureList = function () {
            return this.m_fixtureList;
        };
        Body.prototype.getJointList = function () {
            return this.m_jointList;
        };
        /**
         * Warning: this list changes during the time step and you may miss some
         * collisions if you don't use ContactListener.
         */
        Body.prototype.getContactList = function () {
            return this.m_contactList;
        };
        Body.prototype.isStatic = function () {
            return this.m_type == STATIC;
        };
        Body.prototype.isDynamic = function () {
            return this.m_type == DYNAMIC;
        };
        Body.prototype.isKinematic = function () {
            return this.m_type == KINEMATIC;
        };
        /**
         * This will alter the mass and velocity.
         */
        Body.prototype.setStatic = function () {
            this.setType(STATIC);
            return this;
        };
        Body.prototype.setDynamic = function () {
            this.setType(DYNAMIC);
            return this;
        };
        Body.prototype.setKinematic = function () {
            this.setType(KINEMATIC);
            return this;
        };
        /**
         * Get the type of the body.
         */
        Body.prototype.getType = function () {
            return this.m_type;
        };
        /**
         * Set the type of the body to "static", "kinematic" or "dynamic".
         * @param type The type of the body.
         */
        Body.prototype.setType = function (type) {
            if (this.isWorldLocked() == true) {
                return;
            }
            if (this.m_type == type) {
                return;
            }
            this.m_type = type;
            this.resetMassData();
            if (this.m_type == STATIC) {
                this.m_linearVelocity.setZero();
                this.m_angularVelocity = 0.0;
                this.m_sweep.forward();
                this.synchronizeFixtures();
            }
            this.setAwake(true);
            this.m_force.setZero();
            this.m_torque = 0.0;
            // Delete the attached contacts.
            var ce = this.m_contactList;
            while (ce) {
                var ce0 = ce;
                ce = ce.next;
                this.m_world.destroyContact(ce0.contact);
            }
            this.m_contactList = null;
            // Touch the proxies so that new contacts will be created (when appropriate)
            var broadPhase = this.m_world.m_broadPhase;
            for (var f = this.m_fixtureList; f; f = f.m_next) {
                for (var i = 0; i < f.m_proxyCount; ++i) {
                    broadPhase.touchProxy(f.m_proxies[i].proxyId);
                }
            }
        };
        Body.prototype.isBullet = function () {
            return this.m_bulletFlag;
        };
        /**
         * Should this body be treated like a bullet for continuous collision detection?
         */
        Body.prototype.setBullet = function (flag) {
            this.m_bulletFlag = !!flag;
        };
        Body.prototype.isSleepingAllowed = function () {
            return this.m_autoSleepFlag;
        };
        Body.prototype.setSleepingAllowed = function (flag) {
            this.m_autoSleepFlag = !!flag;
            if (this.m_autoSleepFlag == false) {
                this.setAwake(true);
            }
        };
        Body.prototype.isAwake = function () {
            return this.m_awakeFlag;
        };
        /**
         * Set the sleep state of the body. A sleeping body has very low CPU cost.
         *
         * @param flag Set to true to wake the body, false to put it to sleep.
         */
        Body.prototype.setAwake = function (flag) {
            if (flag) {
                this.m_awakeFlag = true;
                this.m_sleepTime = 0.0;
            }
            else {
                this.m_awakeFlag = false;
                this.m_sleepTime = 0.0;
                this.m_linearVelocity.setZero();
                this.m_angularVelocity = 0.0;
                this.m_force.setZero();
                this.m_torque = 0.0;
            }
        };
        Body.prototype.isActive = function () {
            return this.m_activeFlag;
        };
        /**
         * Set the active state of the body. An inactive body is not simulated and
         * cannot be collided with or woken up. If you pass a flag of true, all fixtures
         * will be added to the broad-phase. If you pass a flag of false, all fixtures
         * will be removed from the broad-phase and all contacts will be destroyed.
         * Fixtures and joints are otherwise unaffected.
         *
         * You may continue to create/destroy fixtures and joints on inactive bodies.
         * Fixtures on an inactive body are implicitly inactive and will not participate
         * in collisions, ray-casts, or queries. Joints connected to an inactive body
         * are implicitly inactive. An inactive body is still owned by a World object
         * and remains
         */
        Body.prototype.setActive = function (flag) {
            if (flag == this.m_activeFlag) {
                return;
            }
            this.m_activeFlag = !!flag;
            if (this.m_activeFlag) {
                // Create all proxies.
                var broadPhase = this.m_world.m_broadPhase;
                for (var f = this.m_fixtureList; f; f = f.m_next) {
                    f.createProxies(broadPhase, this.m_xf);
                }
                // Contacts are created at the beginning of the next
                this.m_world.m_newFixture = true;
            }
            else {
                // Destroy all proxies.
                var broadPhase = this.m_world.m_broadPhase;
                for (var f = this.m_fixtureList; f; f = f.m_next) {
                    f.destroyProxies(broadPhase);
                }
                // Destroy the attached contacts.
                var ce = this.m_contactList;
                while (ce) {
                    var ce0 = ce;
                    ce = ce.next;
                    this.m_world.destroyContact(ce0.contact);
                }
                this.m_contactList = null;
            }
        };
        Body.prototype.isFixedRotation = function () {
            return this.m_fixedRotationFlag;
        };
        /**
         * Set this body to have fixed rotation. This causes the mass to be reset.
         */
        Body.prototype.setFixedRotation = function (flag) {
            if (this.m_fixedRotationFlag == flag) {
                return;
            }
            this.m_fixedRotationFlag = !!flag;
            this.m_angularVelocity = 0.0;
            this.resetMassData();
        };
        /**
         * Get the world transform for the body's origin.
         */
        Body.prototype.getTransform = function () {
            return this.m_xf;
        };
        /**
         * Set the position of the body's origin and rotation. Manipulating a body's
         * transform may cause non-physical behavior. Note: contacts are updated on the
         * next call to World.step.
         *
         * @param position The world position of the body's local origin.
         * @param angle The world rotation in radians.
         */
        Body.prototype.setTransform = function (position, angle) {
            if (this.isWorldLocked() == true) {
                return;
            }
            this.m_xf.setNum(position, angle);
            this.m_sweep.setTransform(this.m_xf);
            var broadPhase = this.m_world.m_broadPhase;
            for (var f = this.m_fixtureList; f; f = f.m_next) {
                f.synchronize(broadPhase, this.m_xf, this.m_xf);
            }
            this.setAwake(true);
        };
        Body.prototype.synchronizeTransform = function () {
            this.m_sweep.getTransform(this.m_xf, 1);
        };
        /**
         * Update fixtures in broad-phase.
         */
        Body.prototype.synchronizeFixtures = function () {
            this.m_sweep.getTransform(xf$2, 0);
            var broadPhase = this.m_world.m_broadPhase;
            for (var f = this.m_fixtureList; f; f = f.m_next) {
                f.synchronize(broadPhase, xf$2, this.m_xf);
            }
        };
        /**
         * Used in TOI.
         */
        Body.prototype.advance = function (alpha) {
            // Advance to the new safe time. This doesn't sync the broad-phase.
            this.m_sweep.advance(alpha);
            copyVec2(this.m_sweep.c, this.m_sweep.c0);
            this.m_sweep.a = this.m_sweep.a0;
            this.m_sweep.getTransform(this.m_xf, 1);
        };
        /**
         * Get the world position for the body's origin.
         */
        Body.prototype.getPosition = function () {
            return this.m_xf.p;
        };
        Body.prototype.setPosition = function (p) {
            this.setTransform(p, this.m_sweep.a);
        };
        /**
         * Get the current world rotation angle in radians.
         */
        Body.prototype.getAngle = function () {
            return this.m_sweep.a;
        };
        Body.prototype.setAngle = function (angle) {
            this.setTransform(this.m_xf.p, angle);
        };
        /**
         * Get the world position of the center of mass.
         */
        Body.prototype.getWorldCenter = function () {
            return this.m_sweep.c;
        };
        /**
         * Get the local position of the center of mass.
         */
        Body.prototype.getLocalCenter = function () {
            return this.m_sweep.localCenter;
        };
        /**
         * Get the linear velocity of the center of mass.
         *
         * @return the linear velocity of the center of mass.
         */
        Body.prototype.getLinearVelocity = function () {
            return this.m_linearVelocity;
        };
        /**
         * Get the world linear velocity of a world point attached to this body.
         *
         * @param worldPoint A point in world coordinates.
         */
        Body.prototype.getLinearVelocityFromWorldPoint = function (worldPoint) {
            var localCenter = Vec2.sub(worldPoint, this.m_sweep.c);
            return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity, localCenter));
        };
        /**
         * Get the world velocity of a local point.
         *
         * @param localPoint A point in local coordinates.
         */
        Body.prototype.getLinearVelocityFromLocalPoint = function (localPoint) {
            return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));
        };
        /**
         * Set the linear velocity of the center of mass.
         *
         * @param v The new linear velocity of the center of mass.
         */
        Body.prototype.setLinearVelocity = function (v) {
            if (this.m_type == STATIC) {
                return;
            }
            if (Vec2.dot(v, v) > 0.0) {
                this.setAwake(true);
            }
            this.m_linearVelocity.setVec2(v);
        };
        /**
         * Get the angular velocity.
         *
         * @returns the angular velocity in radians/second.
         */
        Body.prototype.getAngularVelocity = function () {
            return this.m_angularVelocity;
        };
        /**
         * Set the angular velocity.
         *
         * @param omega The new angular velocity in radians/second.
         */
        Body.prototype.setAngularVelocity = function (w) {
            if (this.m_type == STATIC) {
                return;
            }
            if (w * w > 0.0) {
                this.setAwake(true);
            }
            this.m_angularVelocity = w;
        };
        Body.prototype.getLinearDamping = function () {
            return this.m_linearDamping;
        };
        Body.prototype.setLinearDamping = function (linearDamping) {
            this.m_linearDamping = linearDamping;
        };
        Body.prototype.getAngularDamping = function () {
            return this.m_angularDamping;
        };
        Body.prototype.setAngularDamping = function (angularDamping) {
            this.m_angularDamping = angularDamping;
        };
        Body.prototype.getGravityScale = function () {
            return this.m_gravityScale;
        };
        /**
         * Scale the gravity applied to this body.
         */
        Body.prototype.setGravityScale = function (scale) {
            this.m_gravityScale = scale;
        };
        /**
         * Get the total mass of the body.
         *
         * @returns The mass, usually in kilograms (kg).
         */
        Body.prototype.getMass = function () {
            return this.m_mass;
        };
        /**
         * Get the rotational inertia of the body about the local origin.
         *
         * @return the rotational inertia, usually in kg-m^2.
         */
        Body.prototype.getInertia = function () {
            return this.m_I + this.m_mass
                * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);
        };
        /**
         * Copy the mass data of the body to data.
         */
        Body.prototype.getMassData = function (data) {
            data.mass = this.m_mass;
            data.I = this.getInertia();
            copyVec2(data.center, this.m_sweep.localCenter);
        };
        /**
         * This resets the mass properties to the sum of the mass properties of the
         * fixtures. This normally does not need to be called unless you called
         * SetMassData to override the mass and you later want to reset the mass.
         */
        Body.prototype.resetMassData = function () {
            // Compute mass data from shapes. Each shape has its own density.
            this.m_mass = 0.0;
            this.m_invMass = 0.0;
            this.m_I = 0.0;
            this.m_invI = 0.0;
            zeroVec2(this.m_sweep.localCenter);
            // Static and kinematic bodies have zero mass.
            if (this.isStatic() || this.isKinematic()) {
                copyVec2(this.m_sweep.c0, this.m_xf.p);
                copyVec2(this.m_sweep.c, this.m_xf.p);
                this.m_sweep.a0 = this.m_sweep.a;
                return;
            }
            // Accumulate mass over all fixtures.
            zeroVec2(localCenter);
            for (var f = this.m_fixtureList; f; f = f.m_next) {
                if (f.m_density == 0.0) {
                    continue;
                }
                var massData = {
                    mass: 0,
                    center: vec2(0, 0),
                    I: 0
                };
                f.getMassData(massData);
                this.m_mass += massData.mass;
                addMulVec2(localCenter, massData.mass, massData.center);
                this.m_I += massData.I;
            }
            // Compute center of mass.
            if (this.m_mass > 0.0) {
                this.m_invMass = 1.0 / this.m_mass;
                setMulVec2(localCenter, this.m_invMass, localCenter);
            }
            else {
                // Force all dynamic bodies to have a positive mass.
                this.m_mass = 1.0;
                this.m_invMass = 1.0;
            }
            if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {
                // Center the inertia about the center of mass.
                this.m_I -= this.m_mass * dotVec2(localCenter, localCenter);
                this.m_invI = 1.0 / this.m_I;
            }
            else {
                this.m_I = 0.0;
                this.m_invI = 0.0;
            }
            // Move center of mass.
            copyVec2(oldCenter, this.m_sweep.c);
            this.m_sweep.setLocalCenter(localCenter, this.m_xf);
            // Update center of mass velocity.
            diffVec2(shift, this.m_sweep.c, oldCenter);
            crossNumVec2(temp$6, this.m_angularVelocity, shift);
            addVec2(this.m_linearVelocity, temp$6);
        };
        /**
         * Set the mass properties to override the mass properties of the fixtures. Note
         * that this changes the center of mass position. Note that creating or
         * destroying fixtures can also alter the mass. This function has no effect if
         * the body isn't dynamic.
         *
         * @param massData The mass properties.
         */
        Body.prototype.setMassData = function (massData) {
            if (this.isWorldLocked() == true) {
                return;
            }
            if (this.m_type != DYNAMIC) {
                return;
            }
            this.m_invMass = 0.0;
            this.m_I = 0.0;
            this.m_invI = 0.0;
            this.m_mass = massData.mass;
            if (this.m_mass <= 0.0) {
                this.m_mass = 1.0;
            }
            this.m_invMass = 1.0 / this.m_mass;
            if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {
                this.m_I = massData.I - this.m_mass * dotVec2(massData.center, massData.center);
                this.m_invI = 1.0 / this.m_I;
            }
            // Move center of mass.
            copyVec2(oldCenter, this.m_sweep.c);
            this.m_sweep.setLocalCenter(massData.center, this.m_xf);
            // Update center of mass velocity.
            diffVec2(shift, this.m_sweep.c, oldCenter);
            crossNumVec2(temp$6, this.m_angularVelocity, shift);
            addVec2(this.m_linearVelocity, temp$6);
        };
        /**
         * Apply a force at a world point. If the force is not applied at the center of
         * mass, it will generate a torque and affect the angular velocity. This wakes
         * up the body.
         *
         * @param force The world force vector, usually in Newtons (N).
         * @param point The world position of the point of application.
         * @param wake Also wake up the body
         */
        Body.prototype.applyForce = function (force, point, wake) {
            if (wake === void 0) { wake = true; }
            if (this.m_type != DYNAMIC) {
                return;
            }
            if (wake && this.m_awakeFlag == false) {
                this.setAwake(true);
            }
            // Don't accumulate a force if the body is sleeping.
            if (this.m_awakeFlag) {
                this.m_force.add(force);
                this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);
            }
        };
        /**
         * Apply a force to the center of mass. This wakes up the body.
         *
         * @param force The world force vector, usually in Newtons (N).
         * @param wake Also wake up the body
         */
        Body.prototype.applyForceToCenter = function (force, wake) {
            if (wake === void 0) { wake = true; }
            if (this.m_type != DYNAMIC) {
                return;
            }
            if (wake && this.m_awakeFlag == false) {
                this.setAwake(true);
            }
            // Don't accumulate a force if the body is sleeping
            if (this.m_awakeFlag) {
                this.m_force.add(force);
            }
        };
        /**
         * Apply a torque. This affects the angular velocity without affecting the
         * linear velocity of the center of mass. This wakes up the body.
         *
         * @param torque About the z-axis (out of the screen), usually in N-m.
         * @param wake Also wake up the body
         */
        Body.prototype.applyTorque = function (torque, wake) {
            if (wake === void 0) { wake = true; }
            if (this.m_type != DYNAMIC) {
                return;
            }
            if (wake && this.m_awakeFlag == false) {
                this.setAwake(true);
            }
            // Don't accumulate a force if the body is sleeping
            if (this.m_awakeFlag) {
                this.m_torque += torque;
            }
        };
        /**
         * Apply an impulse at a point. This immediately modifies the velocity. It also
         * modifies the angular velocity if the point of application is not at the
         * center of mass. This wakes up the body.
         *
         * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.
         * @param point The world position of the point of application.
         * @param wake Also wake up the body
         */
        Body.prototype.applyLinearImpulse = function (impulse, point, wake) {
            if (wake === void 0) { wake = true; }
            if (this.m_type != DYNAMIC) {
                return;
            }
            if (wake && this.m_awakeFlag == false) {
                this.setAwake(true);
            }
            // Don't accumulate velocity if the body is sleeping
            if (this.m_awakeFlag) {
                this.m_linearVelocity.addMul(this.m_invMass, impulse);
                this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);
            }
        };
        /**
         * Apply an angular impulse.
         *
         * @param impulse The angular impulse in units of kg*m*m/s
         * @param wake Also wake up the body
         */
        Body.prototype.applyAngularImpulse = function (impulse, wake) {
            if (wake === void 0) { wake = true; }
            if (this.m_type != DYNAMIC) {
                return;
            }
            if (wake && this.m_awakeFlag == false) {
                this.setAwake(true);
            }
            // Don't accumulate velocity if the body is sleeping
            if (this.m_awakeFlag) {
                this.m_angularVelocity += this.m_invI * impulse;
            }
        };
        /**
         * This is used to test if two bodies should collide.
         *
         * Bodies do not collide when:
         * - Neither of them is dynamic
         * - They are connected by a joint with collideConnected == false
         */
        Body.prototype.shouldCollide = function (that) {
            // At least one body should be dynamic.
            if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {
                return false;
            }
            // Does a joint prevent collision?
            for (var jn = this.m_jointList; jn; jn = jn.next) {
                if (jn.other == that) {
                    if (jn.joint.m_collideConnected == false) {
                        return false;
                    }
                }
            }
            return true;
        };
        /** @internal Used for deserialize. */
        Body.prototype._addFixture = function (fixture) {
            if (this.isWorldLocked() == true) {
                return null;
            }
            if (this.m_activeFlag) {
                var broadPhase = this.m_world.m_broadPhase;
                fixture.createProxies(broadPhase, this.m_xf);
            }
            fixture.m_next = this.m_fixtureList;
            this.m_fixtureList = fixture;
            // Adjust mass properties if needed.
            if (fixture.m_density > 0.0) {
                this.resetMassData();
            }
            // Let the world know we have a new fixture. This will cause new contacts
            // to be created at the beginning of the next time step.
            this.m_world.m_newFixture = true;
            return fixture;
        };
        // tslint:disable-next-line:typedef
        Body.prototype.createFixture = function (shape, fixdef) {
            if (this.isWorldLocked() == true) {
                return null;
            }
            var fixture = new Fixture(this, shape, fixdef);
            this._addFixture(fixture);
            return fixture;
        };
        /**
         * Destroy a fixture. This removes the fixture from the broad-phase and destroys
         * all contacts associated with this fixture. This will automatically adjust the
         * mass of the body if the body is dynamic and the fixture has positive density.
         * All fixtures attached to a body are implicitly destroyed when the body is
         * destroyed.
         *
         * Warning: This function is locked during callbacks.
         *
         * @param fixture The fixture to be removed.
         */
        Body.prototype.destroyFixture = function (fixture) {
            if (this.isWorldLocked() == true) {
                return;
            }
            if (this.m_fixtureList === fixture) {
                this.m_fixtureList = fixture.m_next;
            }
            else {
                var node = this.m_fixtureList;
                while (node != null) {
                    if (node.m_next === fixture) {
                        node.m_next = fixture.m_next;
                        break;
                    }
                    node = node.m_next;
                }
            }
            // Destroy any contacts associated with the fixture.
            var edge = this.m_contactList;
            while (edge) {
                var c = edge.contact;
                edge = edge.next;
                var fixtureA = c.getFixtureA();
                var fixtureB = c.getFixtureB();
                if (fixture == fixtureA || fixture == fixtureB) {
                    // This destroys the contact and removes it from
                    // this body's contact list.
                    this.m_world.destroyContact(c);
                }
            }
            if (this.m_activeFlag) {
                var broadPhase = this.m_world.m_broadPhase;
                fixture.destroyProxies(broadPhase);
            }
            fixture.m_body = null;
            fixture.m_next = null;
            this.m_world.publish('remove-fixture', fixture);
            // Reset the mass data.
            this.resetMassData();
        };
        /**
         * Get the corresponding world point of a local point.
         */
        Body.prototype.getWorldPoint = function (localPoint) {
            return Transform.mulVec2(this.m_xf, localPoint);
        };
        /**
         * Get the corresponding world vector of a local vector.
         */
        Body.prototype.getWorldVector = function (localVector) {
            return Rot.mulVec2(this.m_xf.q, localVector);
        };
        /**
         * Gets the corresponding local point of a world point.
         */
        Body.prototype.getLocalPoint = function (worldPoint) {
            return Transform.mulTVec2(this.m_xf, worldPoint);
        };
        /**
         * Gets the corresponding local vector of a world vector.
         */
        Body.prototype.getLocalVector = function (worldVector) {
            return Rot.mulTVec2(this.m_xf.q, worldVector);
        };
        /**
         * A static body does not move under simulation and behaves as if it has infinite mass.
         * Internally, zero is stored for the mass and the inverse mass.
         * Static bodies can be moved manually by the user.
         * A static body has zero velocity.
         * Static bodies do not collide with other static or kinematic bodies.
         */
        Body.STATIC = 'static';
        /**
         * A kinematic body moves under simulation according to its velocity.
         * Kinematic bodies do not respond to forces.
         * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.
         * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.
         * Kinematic bodies do not collide with other kinematic or static bodies.
         */
        Body.KINEMATIC = 'kinematic';
        /**
         * A dynamic body is fully simulated.
         * They can be moved manually by the user, but normally they move according to forces.
         * A dynamic body can collide with all body types.
         * A dynamic body always has finite, non-zero mass.
         * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.
         */
        Body.DYNAMIC = 'dynamic';
        return Body;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * A joint edge is used to connect bodies and joints together in a joint graph
     * where each body is a node and each joint is an edge. A joint edge belongs to
     * a doubly linked list maintained in each attached body. Each joint has two
     * joint nodes, one for each attached body.
     */
    var JointEdge = /** @class */ (function () {
        function JointEdge() {
            /**
             * provides quick access to the other body attached.
             */
            this.other = null;
            /**
             * the joint
             */
            this.joint = null;
            /**
             * prev the previous joint edge in the body's joint list
             */
            this.prev = null;
            /**
             * the next joint edge in the body's joint list
             */
            this.next = null;
        }
        return JointEdge;
    }());
    /**
     * The base joint class. Joints are used to constraint two bodies together in
     * various fashions. Some joints also feature limits and motors.
     */
    var Joint = /** @class */ (function () {
        function Joint(def, bodyA, bodyB) {
            /** @internal */ this.m_type = 'unknown-joint';
            /** @internal */ this.m_prev = null;
            /** @internal */ this.m_next = null;
            /** @internal */ this.m_edgeA = new JointEdge();
            /** @internal */ this.m_edgeB = new JointEdge();
            /** @internal */ this.m_islandFlag = false;
            bodyA = 'bodyA' in def ? def.bodyA : bodyA;
            bodyB = 'bodyB' in def ? def.bodyB : bodyB;
            this.m_bodyA = bodyA;
            this.m_bodyB = bodyB;
            this.m_collideConnected = !!def.collideConnected;
            this.m_userData = def.userData;
        }
        /**
         * Short-cut function to determine if either body is inactive.
         */
        Joint.prototype.isActive = function () {
            return this.m_bodyA.isActive() && this.m_bodyB.isActive();
        };
        /**
         * Get the type of the concrete joint.
         */
        Joint.prototype.getType = function () {
            return this.m_type;
        };
        /**
         * Get the first body attached to this joint.
         */
        Joint.prototype.getBodyA = function () {
            return this.m_bodyA;
        };
        /**
         * Get the second body attached to this joint.
         */
        Joint.prototype.getBodyB = function () {
            return this.m_bodyB;
        };
        /**
         * Get the next joint the world joint list.
         */
        Joint.prototype.getNext = function () {
            return this.m_next;
        };
        Joint.prototype.getUserData = function () {
            return this.m_userData;
        };
        Joint.prototype.setUserData = function (data) {
            this.m_userData = data;
        };
        /**
         * Get collide connected. Note: modifying the collide connect flag won't work
         * correctly because the flag is only checked when fixture AABBs begin to
         * overlap.
         */
        Joint.prototype.getCollideConnected = function () {
            return this.m_collideConnected;
        };
        /**
         * Shift the origin for any points stored in world coordinates.
         */
        Joint.prototype.shiftOrigin = function (newOrigin) { };
        return Joint;
    }());

    var stats = {
        gjkCalls: 0,
        gjkIters: 0,
        gjkMaxIters: 0,
        toiTime: 0,
        toiMaxTime: 0,
        toiCalls: 0,
        toiIters: 0,
        toiMaxIters: 0,
        toiRootIters: 0,
        toiMaxRootIters: 0,
        toString: function (newline) {
            newline = typeof newline === 'string' ? newline : '\n';
            var string = "";
            // tslint:disable-next-line:no-for-in
            for (var name_1 in this) {
                if (typeof this[name_1] !== 'function' && typeof this[name_1] !== 'object') {
                    string += name_1 + ': ' + this[name_1] + newline;
                }
            }
            return string;
        }
    };

    /** @internal */
    var now = function () {
        return Date.now();
    };
    /** @internal */
    var diff = function (time) {
        return Date.now() - time;
    };
    /** @internal */
    var Timer = {
        now: now,
        diff: diff,
    };

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_max$4 = Math.max;
    /** @internal */ var temp$5 = vec2(0, 0);
    /** @internal */ var normal$4 = vec2(0, 0);
    /** @internal */ var e12 = vec2(0, 0);
    /** @internal */ var e13 = vec2(0, 0);
    /** @internal */ var e23 = vec2(0, 0);
    /** @internal */ var temp1 = vec2(0, 0);
    /** @internal */ var temp2 = vec2(0, 0);
    /**
     * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.
     */
    stats.gjkCalls = 0;
    stats.gjkIters = 0;
    stats.gjkMaxIters = 0;
    /**
     * Input for Distance. You have to option to use the shape radii in the
     * computation. Even
     */
    var DistanceInput = /** @class */ (function () {
        function DistanceInput() {
            this.proxyA = new DistanceProxy();
            this.proxyB = new DistanceProxy();
            this.transformA = Transform.identity();
            this.transformB = Transform.identity();
            this.useRadii = false;
        }
        DistanceInput.prototype.recycle = function () {
            this.proxyA.recycle();
            this.proxyB.recycle();
            this.transformA.setIdentity();
            this.transformB.setIdentity();
            this.useRadii = false;
        };
        return DistanceInput;
    }());
    /**
     * Output for Distance.
     */
    var DistanceOutput = /** @class */ (function () {
        function DistanceOutput() {
            /** closest point on shapeA */
            this.pointA = vec2(0, 0);
            /** closest point on shapeB */
            this.pointB = vec2(0, 0);
            this.distance = 0;
            /** iterations number of GJK iterations used */
            this.iterations = 0;
        }
        DistanceOutput.prototype.recycle = function () {
            zeroVec2(this.pointA);
            zeroVec2(this.pointB);
            this.distance = 0;
            this.iterations = 0;
        };
        return DistanceOutput;
    }());
    /**
     * Used to warm start Distance. Set count to zero on first call.
     */
    var SimplexCache = /** @class */ (function () {
        function SimplexCache() {
            /** length or area */
            this.metric = 0;
            /** vertices on shape A */
            this.indexA = [];
            /** vertices on shape B */
            this.indexB = [];
            this.count = 0;
        }
        SimplexCache.prototype.recycle = function () {
            this.metric = 0;
            this.indexA.length = 0;
            this.indexB.length = 0;
            this.count = 0;
        };
        return SimplexCache;
    }());
    /**
     * Compute the closest points between two shapes. Supports any combination of:
     * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On
     * the first call set SimplexCache.count to zero.
     */
    var Distance = function (output, cache, input) {
        ++stats.gjkCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var xfA = input.transformA;
        var xfB = input.transformB;
        // Initialize the simplex.
        // const simplex = new Simplex();
        simplex.recycle();
        simplex.readCache(cache, proxyA, xfA, proxyB, xfB);
        // Get simplex vertices as an array.
        var vertices = simplex.m_v;
        var k_maxIters = SettingsInternal.maxDistanceIterations;
        // These store the vertices of the last simplex so that we
        // can check for duplicates and prevent cycling.
        var saveA = [];
        var saveB = []; // int[3]
        var saveCount = 0;
        // Main iteration loop.
        var iter = 0;
        while (iter < k_maxIters) {
            // Copy simplex so we can identify duplicates.
            saveCount = simplex.m_count;
            for (var i = 0; i < saveCount; ++i) {
                saveA[i] = vertices[i].indexA;
                saveB[i] = vertices[i].indexB;
            }
            simplex.solve();
            // If we have 3 points, then the origin is in the corresponding triangle.
            if (simplex.m_count === 3) {
                break;
            }
            // Get search direction.
            var d = simplex.getSearchDirection();
            // Ensure the search direction is numerically fit.
            if (lengthSqrVec2(d) < EPSILON * EPSILON) {
                // The origin is probably contained by a line segment
                // or triangle. Thus the shapes are overlapped.
                // We can't return zero here even though there may be overlap.
                // In case the simplex is a point, segment, or triangle it is difficult
                // to determine if the origin is contained in the CSO or very close to it.
                break;
            }
            // Compute a tentative new simplex vertex using support points.
            var vertex = vertices[simplex.m_count]; // SimplexVertex
            vertex.indexA = proxyA.getSupport(invRotVec2(temp$5, xfA.q, setMulVec2(temp$5, -1, d)));
            transformVec2(vertex.wA, xfA, proxyA.getVertex(vertex.indexA));
            vertex.indexB = proxyB.getSupport(invRotVec2(temp$5, xfB.q, d));
            transformVec2(vertex.wB, xfB, proxyB.getVertex(vertex.indexB));
            diffVec2(vertex.w, vertex.wB, vertex.wA);
            // Iteration count is equated to the number of support point calls.
            ++iter;
            ++stats.gjkIters;
            // Check for duplicate support points. This is the main termination
            // criteria.
            var duplicate = false;
            for (var i = 0; i < saveCount; ++i) {
                if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {
                    duplicate = true;
                    break;
                }
            }
            // If we found a duplicate support point we must exit to avoid cycling.
            if (duplicate) {
                break;
            }
            // New vertex is ok and needed.
            ++simplex.m_count;
        }
        stats.gjkMaxIters = math_max$4(stats.gjkMaxIters, iter);
        // Prepare output.
        simplex.getWitnessPoints(output.pointA, output.pointB);
        output.distance = distVec2(output.pointA, output.pointB);
        output.iterations = iter;
        // Cache the simplex.
        simplex.writeCache(cache);
        // Apply radii if requested.
        if (input.useRadii) {
            var rA = proxyA.m_radius;
            var rB = proxyB.m_radius;
            if (output.distance > rA + rB && output.distance > EPSILON) {
                // Shapes are still no overlapped.
                // Move the witness points to the outer surface.
                output.distance -= rA + rB;
                diffVec2(normal$4, output.pointB, output.pointA);
                normalizeVec2(normal$4);
                addMulVec2(output.pointA, rA, normal$4);
                subMulVec2(output.pointB, rB, normal$4);
            }
            else {
                // Shapes are overlapped when radii are considered.
                // Move the witness points to the middle.
                var p = diffVec2(temp$5, output.pointA, output.pointB);
                copyVec2(output.pointA, p);
                copyVec2(output.pointB, p);
                output.distance = 0.0;
            }
        }
    };
    /**
     * A distance proxy is used by the GJK algorithm. It encapsulates any shape.
     */
    var DistanceProxy = /** @class */ (function () {
        function DistanceProxy() {
            /** @internal */ this.m_vertices = [];
            // todo: remove this?
            /** @internal */ this.m_count = 0;
            /** @internal */ this.m_radius = 0;
        }
        DistanceProxy.prototype.recycle = function () {
            this.m_vertices.length = 0;
            this.m_count = 0;
            this.m_radius = 0;
        };
        /**
         * Get the vertex count.
         */
        DistanceProxy.prototype.getVertexCount = function () {
            return this.m_count;
        };
        /**
         * Get a vertex by index. Used by Distance.
         */
        DistanceProxy.prototype.getVertex = function (index) {
            return this.m_vertices[index];
        };
        /**
         * Get the supporting vertex index in the given direction.
         */
        DistanceProxy.prototype.getSupport = function (d) {
            var bestIndex = -1;
            var bestValue = -Infinity;
            for (var i = 0; i < this.m_count; ++i) {
                var value = dotVec2(this.m_vertices[i], d);
                if (value > bestValue) {
                    bestIndex = i;
                    bestValue = value;
                }
            }
            return bestIndex;
        };
        /**
         * Get the supporting vertex in the given direction.
         */
        DistanceProxy.prototype.getSupportVertex = function (d) {
            return this.m_vertices[this.getSupport(d)];
        };
        /**
         * Initialize the proxy using the given shape. The shape must remain in scope
         * while the proxy is in use.
         */
        DistanceProxy.prototype.set = function (shape, index) {
            shape.computeDistanceProxy(this, index);
        };
        /**
         * Initialize the proxy using a vertex cloud and radius. The vertices
         * must remain in scope while the proxy is in use.
         */
        DistanceProxy.prototype.setVertices = function (vertices, count, radius) {
            this.m_vertices = vertices;
            this.m_count = count;
            this.m_radius = radius;
        };
        return DistanceProxy;
    }());
    var SimplexVertex = /** @class */ (function () {
        function SimplexVertex() {
            /** support point in proxyA */
            this.wA = vec2(0, 0);
            /** wA index */
            this.indexA = 0;
            /** support point in proxyB */
            this.wB = vec2(0, 0);
            /** wB index */
            this.indexB = 0;
            /** wB - wA; */
            this.w = vec2(0, 0);
            /** barycentric coordinate for closest point */
            this.a = 0;
        }
        SimplexVertex.prototype.recycle = function () {
            this.indexA = 0;
            this.indexB = 0;
            zeroVec2(this.wA);
            zeroVec2(this.wB);
            zeroVec2(this.w);
            this.a = 0;
        };
        SimplexVertex.prototype.set = function (v) {
            this.indexA = v.indexA;
            this.indexB = v.indexB;
            copyVec2(this.wA, v.wA);
            copyVec2(this.wB, v.wB);
            copyVec2(this.w, v.w);
            this.a = v.a;
        };
        return SimplexVertex;
    }());
    /** @internal */ var searchDirection_reuse = vec2(0, 0);
    /** @internal */ var closestPoint_reuse = vec2(0, 0);
    var Simplex = /** @class */ (function () {
        function Simplex() {
            this.m_v1 = new SimplexVertex();
            this.m_v2 = new SimplexVertex();
            this.m_v3 = new SimplexVertex();
            this.m_v = [this.m_v1, this.m_v2, this.m_v3];
        }
        Simplex.prototype.recycle = function () {
            this.m_v1.recycle();
            this.m_v2.recycle();
            this.m_v3.recycle();
            this.m_count = 0;
        };
        /** @internal */ Simplex.prototype.toString = function () {
            if (this.m_count === 3) {
                return ["+" + this.m_count,
                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,
                    this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,
                    this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y
                ].toString();
            }
            else if (this.m_count === 2) {
                return ["+" + this.m_count,
                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,
                    this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y
                ].toString();
            }
            else if (this.m_count === 1) {
                return ["+" + this.m_count,
                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y
                ].toString();
            }
            else {
                return "+" + this.m_count;
            }
        };
        Simplex.prototype.readCache = function (cache, proxyA, transformA, proxyB, transformB) {
            // Copy data from cache.
            this.m_count = cache.count;
            for (var i = 0; i < this.m_count; ++i) {
                var v = this.m_v[i];
                v.indexA = cache.indexA[i];
                v.indexB = cache.indexB[i];
                var wALocal = proxyA.getVertex(v.indexA);
                var wBLocal = proxyB.getVertex(v.indexB);
                transformVec2(v.wA, transformA, wALocal);
                transformVec2(v.wB, transformB, wBLocal);
                diffVec2(v.w, v.wB, v.wA);
                v.a = 0.0;
            }
            // Compute the new simplex metric, if it is substantially different than
            // old metric then flush the simplex.
            if (this.m_count > 1) {
                var metric1 = cache.metric;
                var metric2 = this.getMetric();
                if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2 || metric2 < EPSILON) {
                    // Reset the simplex.
                    this.m_count = 0;
                }
            }
            // If the cache is empty or invalid...
            if (this.m_count === 0) {
                var v = this.m_v[0];
                v.indexA = 0;
                v.indexB = 0;
                var wALocal = proxyA.getVertex(0);
                var wBLocal = proxyB.getVertex(0);
                transformVec2(v.wA, transformA, wALocal);
                transformVec2(v.wB, transformB, wBLocal);
                diffVec2(v.w, v.wB, v.wA);
                v.a = 1.0;
                this.m_count = 1;
            }
        };
        Simplex.prototype.writeCache = function (cache) {
            cache.metric = this.getMetric();
            cache.count = this.m_count;
            for (var i = 0; i < this.m_count; ++i) {
                cache.indexA[i] = this.m_v[i].indexA;
                cache.indexB[i] = this.m_v[i].indexB;
            }
        };
        Simplex.prototype.getSearchDirection = function () {
            var v1 = this.m_v1;
            var v2 = this.m_v2;
            this.m_v3;
            switch (this.m_count) {
                case 1:
                    return setVec2(searchDirection_reuse, -v1.w.x, -v1.w.y);
                case 2: {
                    diffVec2(e12, v2.w, v1.w);
                    var sgn = -crossVec2Vec2(e12, v1.w);
                    if (sgn > 0.0) {
                        // Origin is left of e12.
                        return setVec2(searchDirection_reuse, -e12.y, e12.x);
                    }
                    else {
                        // Origin is right of e12.
                        return setVec2(searchDirection_reuse, e12.y, -e12.x);
                    }
                }
                default:
                    return zeroVec2(searchDirection_reuse);
            }
        };
        Simplex.prototype.getClosestPoint = function () {
            var v1 = this.m_v1;
            var v2 = this.m_v2;
            this.m_v3;
            switch (this.m_count) {
                case 0:
                    return zeroVec2(closestPoint_reuse);
                case 1:
                    return copyVec2(closestPoint_reuse, v1.w);
                case 2:
                    return combineVec2(closestPoint_reuse, v1.a, v1.w, v2.a, v2.w);
                case 3:
                    return zeroVec2(closestPoint_reuse);
                default:
                    return zeroVec2(closestPoint_reuse);
            }
        };
        Simplex.prototype.getWitnessPoints = function (pA, pB) {
            var v1 = this.m_v1;
            var v2 = this.m_v2;
            var v3 = this.m_v3;
            switch (this.m_count) {
                case 0:
                    break;
                case 1:
                    copyVec2(pA, v1.wA);
                    copyVec2(pB, v1.wB);
                    break;
                case 2:
                    combineVec2(pA, v1.a, v1.wA, v2.a, v2.wA);
                    combineVec2(pB, v1.a, v1.wB, v2.a, v2.wB);
                    break;
                case 3:
                    pB.x = pA.x = v1.a * v1.wA.x + v2.a * v2.wA.x + v3.a * v3.wA.x;
                    pB.y = pA.y = v1.a * v1.wA.y + v2.a * v2.wA.y + v3.a * v3.wA.y;
                    break;
            }
        };
        Simplex.prototype.getMetric = function () {
            switch (this.m_count) {
                case 0:
                    return 0.0;
                case 1:
                    return 0.0;
                case 2:
                    return distVec2(this.m_v1.w, this.m_v2.w);
                case 3:
                    return crossVec2Vec2(diffVec2(temp1, this.m_v2.w, this.m_v1.w), diffVec2(temp2, this.m_v3.w, this.m_v1.w));
                default:
                    return 0.0;
            }
        };
        Simplex.prototype.solve = function () {
            switch (this.m_count) {
                case 1:
                    break;
                case 2:
                    this.solve2();
                    break;
                case 3:
                    this.solve3();
                    break;
            }
        };
        // Solve a line segment using barycentric coordinates.
        //
        // p = a1 * w1 + a2 * w2
        // a1 + a2 = 1
        //
        // The vector from the origin to the closest point on the line is
        // perpendicular to the line.
        // e12 = w2 - w1
        // dot(p, e) = 0
        // a1 * dot(w1, e) + a2 * dot(w2, e) = 0
        //
        // 2-by-2 linear system
        // [1 1 ][a1] = [1]
        // [w1.e12 w2.e12][a2] = [0]
        //
        // Define
        // d12_1 = dot(w2, e12)
        // d12_2 = -dot(w1, e12)
        // d12 = d12_1 + d12_2
        //
        // Solution
        // a1 = d12_1 / d12
        // a2 = d12_2 / d12
        Simplex.prototype.solve2 = function () {
            var w1 = this.m_v1.w;
            var w2 = this.m_v2.w;
            diffVec2(e12, w2, w1);
            // w1 region
            var d12_2 = -dotVec2(w1, e12);
            if (d12_2 <= 0.0) {
                // a2 <= 0, so we clamp it to 0
                this.m_v1.a = 1.0;
                this.m_count = 1;
                return;
            }
            // w2 region
            var d12_1 = dotVec2(w2, e12);
            if (d12_1 <= 0.0) {
                // a1 <= 0, so we clamp it to 0
                this.m_v2.a = 1.0;
                this.m_count = 1;
                this.m_v1.set(this.m_v2);
                return;
            }
            // Must be in e12 region.
            var inv_d12 = 1.0 / (d12_1 + d12_2);
            this.m_v1.a = d12_1 * inv_d12;
            this.m_v2.a = d12_2 * inv_d12;
            this.m_count = 2;
        };
        // Possible regions:
        // - points[2]
        // - edge points[0]-points[2]
        // - edge points[1]-points[2]
        // - inside the triangle
        Simplex.prototype.solve3 = function () {
            var w1 = this.m_v1.w;
            var w2 = this.m_v2.w;
            var w3 = this.m_v3.w;
            // Edge12
            // [1 1 ][a1] = [1]
            // [w1.e12 w2.e12][a2] = [0]
            // a3 = 0
            diffVec2(e12, w2, w1);
            var w1e12 = dotVec2(w1, e12);
            var w2e12 = dotVec2(w2, e12);
            var d12_1 = w2e12;
            var d12_2 = -w1e12;
            // Edge13
            // [1 1 ][a1] = [1]
            // [w1.e13 w3.e13][a3] = [0]
            // a2 = 0
            diffVec2(e13, w3, w1);
            var w1e13 = dotVec2(w1, e13);
            var w3e13 = dotVec2(w3, e13);
            var d13_1 = w3e13;
            var d13_2 = -w1e13;
            // Edge23
            // [1 1 ][a2] = [1]
            // [w2.e23 w3.e23][a3] = [0]
            // a1 = 0
            diffVec2(e23, w3, w2);
            var w2e23 = dotVec2(w2, e23);
            var w3e23 = dotVec2(w3, e23);
            var d23_1 = w3e23;
            var d23_2 = -w2e23;
            // Triangle123
            var n123 = crossVec2Vec2(e12, e13);
            var d123_1 = n123 * crossVec2Vec2(w2, w3);
            var d123_2 = n123 * crossVec2Vec2(w3, w1);
            var d123_3 = n123 * crossVec2Vec2(w1, w2);
            // w1 region
            if (d12_2 <= 0.0 && d13_2 <= 0.0) {
                this.m_v1.a = 1.0;
                this.m_count = 1;
                return;
            }
            // e12
            if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
                var inv_d12 = 1.0 / (d12_1 + d12_2);
                this.m_v1.a = d12_1 * inv_d12;
                this.m_v2.a = d12_2 * inv_d12;
                this.m_count = 2;
                return;
            }
            // e13
            if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
                var inv_d13 = 1.0 / (d13_1 + d13_2);
                this.m_v1.a = d13_1 * inv_d13;
                this.m_v3.a = d13_2 * inv_d13;
                this.m_count = 2;
                this.m_v2.set(this.m_v3);
                return;
            }
            // w2 region
            if (d12_1 <= 0.0 && d23_2 <= 0.0) {
                this.m_v2.a = 1.0;
                this.m_count = 1;
                this.m_v1.set(this.m_v2);
                return;
            }
            // w3 region
            if (d13_1 <= 0.0 && d23_1 <= 0.0) {
                this.m_v3.a = 1.0;
                this.m_count = 1;
                this.m_v1.set(this.m_v3);
                return;
            }
            // e23
            if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
                var inv_d23 = 1.0 / (d23_1 + d23_2);
                this.m_v2.a = d23_1 * inv_d23;
                this.m_v3.a = d23_2 * inv_d23;
                this.m_count = 2;
                this.m_v1.set(this.m_v3);
                return;
            }
            // Must be in triangle123
            var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
            this.m_v1.a = d123_1 * inv_d123;
            this.m_v2.a = d123_2 * inv_d123;
            this.m_v3.a = d123_3 * inv_d123;
            this.m_count = 3;
        };
        return Simplex;
    }());
    /** @internal */ var simplex = new Simplex();
    /** @internal */ var input$1 = new DistanceInput();
    /** @internal */ var cache$1 = new SimplexCache();
    /** @internal */ var output$1 = new DistanceOutput();
    /**
     * Determine if two generic shapes overlap.
     */
    var testOverlap = function (shapeA, indexA, shapeB, indexB, xfA, xfB) {
        input$1.recycle();
        input$1.proxyA.set(shapeA, indexA);
        input$1.proxyB.set(shapeB, indexB);
        copyTransform(input$1.transformA, xfA);
        copyTransform(input$1.transformB, xfB);
        input$1.useRadii = true;
        output$1.recycle();
        cache$1.recycle();
        Distance(output$1, cache$1, input$1);
        return output$1.distance < 10.0 * EPSILON;
    };
    // legacy exports
    Distance.testOverlap = testOverlap;
    Distance.Input = DistanceInput;
    Distance.Output = DistanceOutput;
    Distance.Proxy = DistanceProxy;
    Distance.Cache = SimplexCache;
    /**
     * Input parameters for ShapeCast
     */
    var ShapeCastInput = /** @class */ (function () {
        function ShapeCastInput() {
            this.proxyA = new DistanceProxy();
            this.proxyB = new DistanceProxy();
            this.transformA = Transform.identity();
            this.transformB = Transform.identity();
            this.translationB = Vec2.zero();
        }
        ShapeCastInput.prototype.recycle = function () {
            this.proxyA.recycle();
            this.proxyB.recycle();
            this.transformA.setIdentity();
            this.transformB.setIdentity();
            zeroVec2(this.translationB);
        };
        return ShapeCastInput;
    }());
    /**
     * Output results for b2ShapeCast
     */
    var ShapeCastOutput = /** @class */ (function () {
        function ShapeCastOutput() {
            this.point = Vec2.zero();
            this.normal = Vec2.zero();
            this.lambda = 1.0;
            this.iterations = 0;
        }
        return ShapeCastOutput;
    }());
    /**
     * Perform a linear shape cast of shape B moving and shape A fixed. Determines
     * the hit point, normal, and translation fraction.
     *
     * @returns true if hit, false if there is no hit or an initial overlap
     */
    //
    // GJK-raycast
    // Algorithm by Gino van den Bergen.
    // "Smooth Mesh Contacts with GJK" in Game Physics Pearls. 2010
    var ShapeCast = function (output, input) {
        output.iterations = 0;
        output.lambda = 1.0;
        output.normal.setZero();
        output.point.setZero();
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var radiusA = math_max$4(proxyA.m_radius, SettingsInternal.polygonRadius);
        var radiusB = math_max$4(proxyB.m_radius, SettingsInternal.polygonRadius);
        var radius = radiusA + radiusB;
        var xfA = input.transformA;
        var xfB = input.transformB;
        var r = input.translationB;
        var n = Vec2.zero();
        var lambda = 0.0;
        // Initial simplex
        var simplex = new Simplex();
        simplex.m_count = 0;
        // Get simplex vertices as an array.
        var vertices = simplex.m_v;
        // Get support point in -r direction
        var indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(r)));
        var wA = Transform.mulVec2(xfA, proxyA.getVertex(indexA));
        var indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, r));
        var wB = Transform.mulVec2(xfB, proxyB.getVertex(indexB));
        var v = Vec2.sub(wA, wB);
        // Sigma is the target distance between polygons
        var sigma = math_max$4(SettingsInternal.polygonRadius, radius - SettingsInternal.polygonRadius);
        var tolerance = 0.5 * SettingsInternal.linearSlop;
        // Main iteration loop.
        var k_maxIters = 20;
        var iter = 0;
        while (iter < k_maxIters && v.length() - sigma > tolerance) {
            output.iterations += 1;
            // Support in direction -v (A - B)
            indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(v)));
            wA = Transform.mulVec2(xfA, proxyA.getVertex(indexA));
            indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, v));
            wB = Transform.mulVec2(xfB, proxyB.getVertex(indexB));
            var p = Vec2.sub(wA, wB);
            // -v is a normal at p
            v.normalize();
            // Intersect ray with plane
            var vp = Vec2.dot(v, p);
            var vr = Vec2.dot(v, r);
            if (vp - sigma > lambda * vr) {
                if (vr <= 0.0) {
                    return false;
                }
                lambda = (vp - sigma) / vr;
                if (lambda > 1.0) {
                    return false;
                }
                n.setMul(-1, v);
                simplex.m_count = 0;
            }
            // Reverse simplex since it works with B - A.
            // Shift by lambda * r because we want the closest point to the current clip point.
            // Note that the support point p is not shifted because we want the plane equation
            // to be formed in unshifted space.
            var vertex = vertices[simplex.m_count];
            vertex.indexA = indexB;
            vertex.wA = Vec2.combine(1, wB, lambda, r);
            vertex.indexB = indexA;
            vertex.wB = wA;
            vertex.w = Vec2.sub(vertex.wB, vertex.wA);
            vertex.a = 1.0;
            simplex.m_count += 1;
            switch (simplex.m_count) {
                case 1:
                    break;
                case 2:
                    simplex.solve2();
                    break;
                case 3:
                    simplex.solve3();
                    break;
            }
            // If we have 3 points, then the origin is in the corresponding triangle.
            if (simplex.m_count == 3) {
                // Overlap
                return false;
            }
            // Get search direction.
            v.setVec2(simplex.getClosestPoint());
            // Iteration count is equated to the number of support point calls.
            ++iter;
        }
        if (iter == 0) {
            // Initial overlap
            return false;
        }
        // Prepare output.
        var pointA = Vec2.zero();
        var pointB = Vec2.zero();
        simplex.getWitnessPoints(pointB, pointA);
        if (v.lengthSquared() > 0.0) {
            n.setMul(-1, v);
            n.normalize();
        }
        output.point = Vec2.combine(1, pointA, radiusA, n);
        output.normal = n;
        output.lambda = lambda;
        output.iterations = iter;
        return true;
    };

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$7 = Math.abs;
    /** @internal */ var math_max$3 = Math.max;
    /**
     * Input parameters for TimeOfImpact.
     */
    var TOIInput = /** @class */ (function () {
        function TOIInput() {
            this.proxyA = new DistanceProxy();
            this.proxyB = new DistanceProxy();
            this.sweepA = new Sweep();
            this.sweepB = new Sweep();
        }
        TOIInput.prototype.recycle = function () {
            this.proxyA.recycle();
            this.proxyB.recycle();
            this.sweepA.recycle();
            this.sweepB.recycle();
            this.tMax = -1;
        };
        return TOIInput;
    }());
    exports.TOIOutputState = void 0;
    (function (TOIOutputState) {
        TOIOutputState[TOIOutputState["e_unset"] = -1] = "e_unset";
        TOIOutputState[TOIOutputState["e_unknown"] = 0] = "e_unknown";
        TOIOutputState[TOIOutputState["e_failed"] = 1] = "e_failed";
        TOIOutputState[TOIOutputState["e_overlapped"] = 2] = "e_overlapped";
        TOIOutputState[TOIOutputState["e_touching"] = 3] = "e_touching";
        TOIOutputState[TOIOutputState["e_separated"] = 4] = "e_separated";
    })(exports.TOIOutputState || (exports.TOIOutputState = {}));
    /**
     * Output parameters for TimeOfImpact.
     */
    var TOIOutput = /** @class */ (function () {
        function TOIOutput() {
            this.state = exports.TOIOutputState.e_unset;
            this.t = -1;
        }
        TOIOutput.prototype.recycle = function () {
            this.state = exports.TOIOutputState.e_unset;
            this.t = -1;
        };
        return TOIOutput;
    }());
    stats.toiTime = 0;
    stats.toiMaxTime = 0;
    stats.toiCalls = 0;
    stats.toiIters = 0;
    stats.toiMaxIters = 0;
    stats.toiRootIters = 0;
    stats.toiMaxRootIters = 0;
    /** @internal */ var distanceInput = new DistanceInput();
    /** @internal */ var distanceOutput = new DistanceOutput();
    // this is passed to Distance and SeparationFunction
    /** @internal */ var cache = new SimplexCache();
    /** @internal */ var xfA$1 = transform(0, 0, 0);
    /** @internal */ var xfB$1 = transform(0, 0, 0);
    /** @internal */ var temp$4 = vec2(0, 0);
    /** @internal */ var pointA$2 = vec2(0, 0);
    /** @internal */ var pointB$2 = vec2(0, 0);
    /** @internal */ var normal$3 = vec2(0, 0);
    /** @internal */ var axisA = vec2(0, 0);
    /** @internal */ var axisB = vec2(0, 0);
    /** @internal */ var localPointA = vec2(0, 0);
    /** @internal */ var localPointB = vec2(0, 0);
    /**
     * Compute the upper bound on time before two shapes penetrate. Time is
     * represented as a fraction between [0,tMax]. This uses a swept separating axis
     * and may miss some intermediate, non-tunneling collisions. If you change the
     * time interval, you should call this function again.
     *
     * Note: use Distance to compute the contact point and normal at the time of
     * impact.
     *
     * CCD via the local separating axis method. This seeks progression by computing
     * the largest time at which separation is maintained.
     */
    var TimeOfImpact = function (output, input) {
        var timer = Timer.now();
        ++stats.toiCalls;
        output.state = exports.TOIOutputState.e_unknown;
        output.t = input.tMax;
        var proxyA = input.proxyA; // DistanceProxy
        var proxyB = input.proxyB; // DistanceProxy
        var sweepA = input.sweepA; // Sweep
        var sweepB = input.sweepB; // Sweep
        // Large rotations can make the root finder fail, so we normalize the
        // sweep angles.
        sweepA.normalize();
        sweepB.normalize();
        var tMax = input.tMax;
        var totalRadius = proxyA.m_radius + proxyB.m_radius;
        var target = math_max$3(SettingsInternal.linearSlop, totalRadius - 3.0 * SettingsInternal.linearSlop);
        var tolerance = 0.25 * SettingsInternal.linearSlop;
        var t1 = 0.0;
        var k_maxIterations = SettingsInternal.maxTOIIterations;
        var iter = 0;
        // Prepare input for distance query.
        // const cache = new SimplexCache();
        cache.recycle();
        distanceInput.proxyA.setVertices(proxyA.m_vertices, proxyA.m_count, proxyA.m_radius);
        distanceInput.proxyB.setVertices(proxyB.m_vertices, proxyB.m_count, proxyB.m_radius);
        distanceInput.useRadii = false;
        // The outer loop progressively attempts to compute new separating axes.
        // This loop terminates when an axis is repeated (no progress is made).
        while (true) {
            sweepA.getTransform(xfA$1, t1);
            sweepB.getTransform(xfB$1, t1);
            // Get the distance between shapes. We can also use the results
            // to get a separating axis.
            copyTransform(distanceInput.transformA, xfA$1);
            copyTransform(distanceInput.transformB, xfB$1);
            Distance(distanceOutput, cache, distanceInput);
            // If the shapes are overlapped, we give up on continuous collision.
            if (distanceOutput.distance <= 0.0) {
                // Failure!
                output.state = exports.TOIOutputState.e_overlapped;
                output.t = 0.0;
                break;
            }
            if (distanceOutput.distance < target + tolerance) {
                // Victory!
                output.state = exports.TOIOutputState.e_touching;
                output.t = t1;
                break;
            }
            // Initialize the separating axis.
            separationFunction.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);
            // if (false) {
            //   // Dump the curve seen by the root finder
            //   const N = 100;
            //   const dx = 1.0 / N;
            //   const xs = []; // [ N + 1 ];
            //   const fs = []; // [ N + 1 ];
            //   const x = 0.0;
            //   for (const i = 0; i <= N; ++i) {
            //     sweepA.getTransform(xfA, x);
            //     sweepB.getTransform(xfB, x);
            //     const f = fcn.evaluate(xfA, xfB) - target;
            //     printf("%g %g\n", x, f);
            //     xs[i] = x;
            //     fs[i] = f;
            //     x += dx;
            //   }
            // }
            // Compute the TOI on the separating axis. We do this by successively
            // resolving the deepest point. This loop is bounded by the number of
            // vertices.
            var done = false;
            var t2 = tMax;
            var pushBackIter = 0;
            while (true) {
                // Find the deepest point at t2. Store the witness point indices.
                var s2 = separationFunction.findMinSeparation(t2);
                // Is the final configuration separated?
                if (s2 > target + tolerance) {
                    // Victory!
                    output.state = exports.TOIOutputState.e_separated;
                    output.t = tMax;
                    done = true;
                    break;
                }
                // Has the separation reached tolerance?
                if (s2 > target - tolerance) {
                    // Advance the sweeps
                    t1 = t2;
                    break;
                }
                // Compute the initial separation of the witness points.
                var s1 = separationFunction.evaluate(t1);
                // Check for initial overlap. This might happen if the root finder
                // runs out of iterations.
                if (s1 < target - tolerance) {
                    output.state = exports.TOIOutputState.e_failed;
                    output.t = t1;
                    done = true;
                    break;
                }
                // Check for touching
                if (s1 <= target + tolerance) {
                    // Victory! t1 should hold the TOI (could be 0.0).
                    output.state = exports.TOIOutputState.e_touching;
                    output.t = t1;
                    done = true;
                    break;
                }
                // Compute 1D root of: f(x) - target = 0
                var rootIterCount = 0;
                var a1 = t1;
                var a2 = t2;
                while (true) {
                    // Use a mix of the secant rule and bisection.
                    var t = void 0;
                    if (rootIterCount & 1) {
                        // Secant rule to improve convergence.
                        t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
                    }
                    else {
                        // Bisection to guarantee progress.
                        t = 0.5 * (a1 + a2);
                    }
                    ++rootIterCount;
                    ++stats.toiRootIters;
                    var s = separationFunction.evaluate(t);
                    if (math_abs$7(s - target) < tolerance) {
                        // t2 holds a tentative value for t1
                        t2 = t;
                        break;
                    }
                    // Ensure we continue to bracket the root.
                    if (s > target) {
                        a1 = t;
                        s1 = s;
                    }
                    else {
                        a2 = t;
                        s2 = s;
                    }
                    if (rootIterCount === 50) {
                        break;
                    }
                }
                stats.toiMaxRootIters = math_max$3(stats.toiMaxRootIters, rootIterCount);
                ++pushBackIter;
                if (pushBackIter === SettingsInternal.maxPolygonVertices) {
                    break;
                }
            }
            ++iter;
            ++stats.toiIters;
            if (done) {
                break;
            }
            if (iter === k_maxIterations) {
                // Root finder got stuck. Semi-victory.
                output.state = exports.TOIOutputState.e_failed;
                output.t = t1;
                break;
            }
        }
        stats.toiMaxIters = math_max$3(stats.toiMaxIters, iter);
        var time = Timer.diff(timer);
        stats.toiMaxTime = math_max$3(stats.toiMaxTime, time);
        stats.toiTime += time;
        separationFunction.recycle();
    };
    var SeparationFunctionType;
    (function (SeparationFunctionType) {
        SeparationFunctionType[SeparationFunctionType["e_unset"] = -1] = "e_unset";
        SeparationFunctionType[SeparationFunctionType["e_points"] = 1] = "e_points";
        SeparationFunctionType[SeparationFunctionType["e_faceA"] = 2] = "e_faceA";
        SeparationFunctionType[SeparationFunctionType["e_faceB"] = 3] = "e_faceB";
    })(SeparationFunctionType || (SeparationFunctionType = {}));
    var SeparationFunction = /** @class */ (function () {
        function SeparationFunction() {
            // input cache
            // todo: maybe assign by copy instead of reference?
            this.m_proxyA = null;
            this.m_proxyB = null;
            this.m_sweepA = null;
            this.m_sweepB = null;
            // initialize cache
            this.m_type = SeparationFunctionType.e_unset;
            this.m_localPoint = vec2(0, 0);
            this.m_axis = vec2(0, 0);
            // compute output
            this.indexA = -1;
            this.indexB = -1;
        }
        SeparationFunction.prototype.recycle = function () {
            this.m_proxyA = null;
            this.m_proxyB = null;
            this.m_sweepA = null;
            this.m_sweepB = null;
            this.m_type = SeparationFunctionType.e_unset;
            zeroVec2(this.m_localPoint);
            zeroVec2(this.m_axis);
            this.indexA = -1;
            this.indexB = -1;
        };
        // TODO_ERIN might not need to return the separation
        SeparationFunction.prototype.initialize = function (cache, proxyA, sweepA, proxyB, sweepB, t1) {
            var count = cache.count;
            this.m_proxyA = proxyA;
            this.m_proxyB = proxyB;
            this.m_sweepA = sweepA;
            this.m_sweepB = sweepB;
            this.m_sweepA.getTransform(xfA$1, t1);
            this.m_sweepB.getTransform(xfB$1, t1);
            if (count === 1) {
                this.m_type = SeparationFunctionType.e_points;
                var localPointA_1 = this.m_proxyA.getVertex(cache.indexA[0]);
                var localPointB_1 = this.m_proxyB.getVertex(cache.indexB[0]);
                transformVec2(pointA$2, xfA$1, localPointA_1);
                transformVec2(pointB$2, xfB$1, localPointB_1);
                diffVec2(this.m_axis, pointB$2, pointA$2);
                var s = normalizeVec2Length(this.m_axis);
                return s;
            }
            else if (cache.indexA[0] === cache.indexA[1]) {
                // Two points on B and one on A.
                this.m_type = SeparationFunctionType.e_faceB;
                var localPointB1 = proxyB.getVertex(cache.indexB[0]);
                var localPointB2 = proxyB.getVertex(cache.indexB[1]);
                crossVec2Num(this.m_axis, diffVec2(temp$4, localPointB2, localPointB1), 1.0);
                normalizeVec2(this.m_axis);
                rotVec2(normal$3, xfB$1.q, this.m_axis);
                combineVec2(this.m_localPoint, 0.5, localPointB1, 0.5, localPointB2);
                transformVec2(pointB$2, xfB$1, this.m_localPoint);
                var localPointA_2 = proxyA.getVertex(cache.indexA[0]);
                var pointA_1 = Transform.mulVec2(xfA$1, localPointA_2);
                var s = dotVec2(pointA_1, normal$3) - dotVec2(pointB$2, normal$3);
                if (s < 0.0) {
                    negVec2(this.m_axis);
                    s = -s;
                }
                return s;
            }
            else {
                // Two points on A and one or two points on B.
                this.m_type = SeparationFunctionType.e_faceA;
                var localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);
                var localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);
                crossVec2Num(this.m_axis, diffVec2(temp$4, localPointA2, localPointA1), 1.0);
                normalizeVec2(this.m_axis);
                rotVec2(normal$3, xfA$1.q, this.m_axis);
                combineVec2(this.m_localPoint, 0.5, localPointA1, 0.5, localPointA2);
                transformVec2(pointA$2, xfA$1, this.m_localPoint);
                var localPointB_2 = this.m_proxyB.getVertex(cache.indexB[0]);
                transformVec2(pointB$2, xfB$1, localPointB_2);
                var s = dotVec2(pointB$2, normal$3) - dotVec2(pointA$2, normal$3);
                if (s < 0.0) {
                    negVec2(this.m_axis);
                    s = -s;
                }
                return s;
            }
        };
        SeparationFunction.prototype.compute = function (find, t) {
            // It was findMinSeparation and evaluate
            this.m_sweepA.getTransform(xfA$1, t);
            this.m_sweepB.getTransform(xfB$1, t);
            switch (this.m_type) {
                case SeparationFunctionType.e_points: {
                    if (find) {
                        invRotVec2(axisA, xfA$1.q, this.m_axis);
                        invRotVec2(axisB, xfB$1.q, setMulVec2(temp$4, -1, this.m_axis));
                        this.indexA = this.m_proxyA.getSupport(axisA);
                        this.indexB = this.m_proxyB.getSupport(axisB);
                    }
                    copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));
                    copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));
                    transformVec2(pointA$2, xfA$1, localPointA);
                    transformVec2(pointB$2, xfB$1, localPointB);
                    var sep = dotVec2(pointB$2, this.m_axis) - dotVec2(pointA$2, this.m_axis);
                    return sep;
                }
                case SeparationFunctionType.e_faceA: {
                    rotVec2(normal$3, xfA$1.q, this.m_axis);
                    transformVec2(pointA$2, xfA$1, this.m_localPoint);
                    if (find) {
                        invRotVec2(axisB, xfB$1.q, setMulVec2(temp$4, -1, normal$3));
                        this.indexA = -1;
                        this.indexB = this.m_proxyB.getSupport(axisB);
                    }
                    copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));
                    transformVec2(pointB$2, xfB$1, localPointB);
                    var sep = dotVec2(pointB$2, normal$3) - dotVec2(pointA$2, normal$3);
                    return sep;
                }
                case SeparationFunctionType.e_faceB: {
                    rotVec2(normal$3, xfB$1.q, this.m_axis);
                    transformVec2(pointB$2, xfB$1, this.m_localPoint);
                    if (find) {
                        invRotVec2(axisA, xfA$1.q, setMulVec2(temp$4, -1, normal$3));
                        this.indexB = -1;
                        this.indexA = this.m_proxyA.getSupport(axisA);
                    }
                    copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));
                    transformVec2(pointA$2, xfA$1, localPointA);
                    var sep = dotVec2(pointA$2, normal$3) - dotVec2(pointB$2, normal$3);
                    return sep;
                }
                default:
                    if (find) {
                        this.indexA = -1;
                        this.indexB = -1;
                    }
                    return 0.0;
            }
        };
        SeparationFunction.prototype.findMinSeparation = function (t) {
            return this.compute(true, t);
        };
        SeparationFunction.prototype.evaluate = function (t) {
            return this.compute(false, t);
        };
        return SeparationFunction;
    }());
    /** @internal */ var separationFunction = new SeparationFunction();
    // legacy exports
    TimeOfImpact.Input = TOIInput;
    TimeOfImpact.Output = TOIOutput;

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$6 = Math.abs;
    /** @internal */ var math_sqrt$3 = Math.sqrt;
    /** @internal */ var math_min$5 = Math.min;
    var TimeStep = /** @class */ (function () {
        function TimeStep() {
            /** time step */
            this.dt = 0;
            /** inverse time step (0 if dt == 0) */
            this.inv_dt = 0;
            this.velocityIterations = 0;
            this.positionIterations = 0;
            this.warmStarting = false;
            this.blockSolve = true;
            /** timestep ratio for variable timestep */
            this.inv_dt0 = 0.0;
            /** dt * inv_dt0 */
            this.dtRatio = 1;
        }
        TimeStep.prototype.reset = function (dt) {
            if (this.dt > 0.0) {
                this.inv_dt0 = this.inv_dt;
            }
            this.dt = dt;
            this.inv_dt = dt == 0 ? 0 : 1 / dt;
            this.dtRatio = dt * this.inv_dt0;
        };
        return TimeStep;
    }());
    // reuse
    /** @internal */ var s_subStep = new TimeStep();
    /** @internal */ var c = vec2(0, 0);
    /** @internal */ var v = vec2(0, 0);
    /** @internal */ var translation = vec2(0, 0);
    /** @internal */ var input = new TOIInput();
    /** @internal */ var output = new TOIOutput();
    /** @internal */ var backup = new Sweep();
    /** @internal */ var backup1 = new Sweep();
    /** @internal */ var backup2 = new Sweep();
    /**
     * Contact impulses for reporting. Impulses are used instead of forces because
     * sub-step forces may approach infinity for rigid body collisions. These match
     * up one-to-one with the contact points in Manifold.
     */
    var ContactImpulse = /** @class */ (function () {
        function ContactImpulse(contact) {
            this.contact = contact;
            this.normals = [];
            this.tangents = [];
        }
        ContactImpulse.prototype.recycle = function () {
            this.normals.length = 0;
            this.tangents.length = 0;
        };
        Object.defineProperty(ContactImpulse.prototype, "normalImpulses", {
            get: function () {
                var contact = this.contact;
                var normals = this.normals;
                normals.length = 0;
                for (var p = 0; p < contact.v_points.length; ++p) {
                    normals.push(contact.v_points[p].normalImpulse);
                }
                return normals;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ContactImpulse.prototype, "tangentImpulses", {
            get: function () {
                var contact = this.contact;
                var tangents = this.tangents;
                tangents.length = 0;
                for (var p = 0; p < contact.v_points.length; ++p) {
                    tangents.push(contact.v_points[p].tangentImpulse);
                }
                return tangents;
            },
            enumerable: false,
            configurable: true
        });
        return ContactImpulse;
    }());
    /**
     * Finds and solves islands. An island is a connected subset of the world.
     */
    var Solver = /** @class */ (function () {
        function Solver(world) {
            this.m_world = world;
            this.m_stack = [];
            this.m_bodies = [];
            this.m_contacts = [];
            this.m_joints = [];
        }
        Solver.prototype.clear = function () {
            this.m_stack.length = 0;
            this.m_bodies.length = 0;
            this.m_contacts.length = 0;
            this.m_joints.length = 0;
        };
        Solver.prototype.addBody = function (body) {
            this.m_bodies.push(body);
            // why?
            // body.c_position.c.setZero();
            // body.c_position.a = 0;
            // body.c_velocity.v.setZero();
            // body.c_velocity.w = 0;
        };
        Solver.prototype.addContact = function (contact) {
            // false && console.assert(contact instanceof Contact, 'Not a Contact!', contact);
            this.m_contacts.push(contact);
        };
        Solver.prototype.addJoint = function (joint) {
            this.m_joints.push(joint);
        };
        Solver.prototype.solveWorld = function (step) {
            var world = this.m_world;
            // Clear all the island flags.
            for (var b = world.m_bodyList; b; b = b.m_next) {
                b.m_islandFlag = false;
            }
            for (var c_1 = world.m_contactList; c_1; c_1 = c_1.m_next) {
                c_1.m_islandFlag = false;
            }
            for (var j = world.m_jointList; j; j = j.m_next) {
                j.m_islandFlag = false;
            }
            // Build and simulate all awake islands.
            var stack = this.m_stack;
            for (var seed = world.m_bodyList; seed; seed = seed.m_next) {
                if (seed.m_islandFlag) {
                    continue;
                }
                if (seed.isAwake() == false || seed.isActive() == false) {
                    continue;
                }
                // The seed can be dynamic or kinematic.
                if (seed.isStatic()) {
                    continue;
                }
                // Reset island and stack.
                this.clear();
                stack.push(seed);
                seed.m_islandFlag = true;
                // Perform a depth first search (DFS) on the constraint graph.
                while (stack.length > 0) {
                    // Grab the next body off the stack and add it to the island.
                    var b = stack.pop();
                    this.addBody(b);
                    // Make sure the body is awake (without resetting sleep timer).
                    b.m_awakeFlag = true;
                    // To keep islands as small as possible, we don't
                    // propagate islands across static bodies.
                    if (b.isStatic()) {
                        continue;
                    }
                    // Search all contacts connected to this body.
                    for (var ce = b.m_contactList; ce; ce = ce.next) {
                        var contact = ce.contact;
                        // Has this contact already been added to an island?
                        if (contact.m_islandFlag) {
                            continue;
                        }
                        // Is this contact solid and touching?
                        if (contact.isEnabled() == false || contact.isTouching() == false) {
                            continue;
                        }
                        // Skip sensors.
                        var sensorA = contact.m_fixtureA.m_isSensor;
                        var sensorB = contact.m_fixtureB.m_isSensor;
                        if (sensorA || sensorB) {
                            continue;
                        }
                        this.addContact(contact);
                        contact.m_islandFlag = true;
                        var other = ce.other;
                        // Was the other body already added to this island?
                        if (other.m_islandFlag) {
                            continue;
                        }
                        // false && console.assert(stack.length < world.m_bodyCount);
                        stack.push(other);
                        other.m_islandFlag = true;
                    }
                    // Search all joints connect to this body.
                    for (var je = b.m_jointList; je; je = je.next) {
                        if (je.joint.m_islandFlag == true) {
                            continue;
                        }
                        var other = je.other;
                        // Don't simulate joints connected to inactive bodies.
                        if (other.isActive() == false) {
                            continue;
                        }
                        this.addJoint(je.joint);
                        je.joint.m_islandFlag = true;
                        if (other.m_islandFlag) {
                            continue;
                        }
                        // false && console.assert(stack.length < world.m_bodyCount);
                        stack.push(other);
                        other.m_islandFlag = true;
                    }
                }
                this.solveIsland(step);
                // Post solve cleanup.
                for (var i = 0; i < this.m_bodies.length; ++i) {
                    // Allow static bodies to participate in other islands.
                    // TODO: are they added at all?
                    var b = this.m_bodies[i];
                    if (b.isStatic()) {
                        b.m_islandFlag = false;
                    }
                }
            }
        };
        Solver.prototype.solveIsland = function (step) {
            // B2: Island Solve
            var world = this.m_world;
            var gravity = world.m_gravity;
            var allowSleep = world.m_allowSleep;
            var h = step.dt;
            // Integrate velocities and apply damping. Initialize the body state.
            for (var i = 0; i < this.m_bodies.length; ++i) {
                var body = this.m_bodies[i];
                copyVec2(c, body.m_sweep.c);
                var a = body.m_sweep.a;
                copyVec2(v, body.m_linearVelocity);
                var w = body.m_angularVelocity;
                // Store positions for continuous collision.
                copyVec2(body.m_sweep.c0, body.m_sweep.c);
                body.m_sweep.a0 = body.m_sweep.a;
                if (body.isDynamic()) {
                    // Integrate velocities.
                    addMulVec2(v, h * body.m_gravityScale, gravity);
                    addMulVec2(v, h * body.m_invMass, body.m_force);
                    w += h * body.m_invI * body.m_torque;
                    /**
                     * <pre>
                     * Apply damping.
                     * ODE: dv/dt + c * v = 0
                     * Solution: v(t) = v0 * exp(-c * t)
                     * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
                     * v2 = exp(-c * dt) * v1
                     * Pade approximation:
                     * v2 = v1 * 1 / (1 + c * dt)
                     * </pre>
                     */
                    setMulVec2(v, 1.0 / (1.0 + h * body.m_linearDamping), v);
                    w *= 1.0 / (1.0 + h * body.m_angularDamping);
                }
                copyVec2(body.c_position.c, c);
                body.c_position.a = a;
                copyVec2(body.c_velocity.v, v);
                body.c_velocity.w = w;
            }
            for (var i = 0; i < this.m_contacts.length; ++i) {
                var contact = this.m_contacts[i];
                contact.initConstraint(step);
            }
            for (var i = 0; i < this.m_contacts.length; ++i) {
                var contact = this.m_contacts[i];
                contact.initVelocityConstraint(step);
            }
            if (step.warmStarting) {
                // Warm start.
                for (var i = 0; i < this.m_contacts.length; ++i) {
                    var contact = this.m_contacts[i];
                    contact.warmStartConstraint(step);
                }
            }
            for (var i = 0; i < this.m_joints.length; ++i) {
                var joint = this.m_joints[i];
                joint.initVelocityConstraints(step);
            }
            // Solve velocity constraints
            for (var i = 0; i < step.velocityIterations; ++i) {
                for (var j = 0; j < this.m_joints.length; ++j) {
                    var joint = this.m_joints[j];
                    joint.solveVelocityConstraints(step);
                }
                for (var j = 0; j < this.m_contacts.length; ++j) {
                    var contact = this.m_contacts[j];
                    contact.solveVelocityConstraint(step);
                }
            }
            // Store impulses for warm starting
            for (var i = 0; i < this.m_contacts.length; ++i) {
                var contact = this.m_contacts[i];
                contact.storeConstraintImpulses(step);
            }
            // Integrate positions
            for (var i = 0; i < this.m_bodies.length; ++i) {
                var body = this.m_bodies[i];
                copyVec2(c, body.c_position.c);
                var a = body.c_position.a;
                copyVec2(v, body.c_velocity.v);
                var w = body.c_velocity.w;
                // Check for large velocities
                setMulVec2(translation, h, v);
                var translationLengthSqr = lengthSqrVec2(translation);
                if (translationLengthSqr > SettingsInternal.maxTranslationSquared) {
                    var ratio = SettingsInternal.maxTranslation / math_sqrt$3(translationLengthSqr);
                    scaleVec2(v, ratio);
                }
                var rotation = h * w;
                if (rotation * rotation > SettingsInternal.maxRotationSquared) {
                    var ratio = SettingsInternal.maxRotation / math_abs$6(rotation);
                    w *= ratio;
                }
                // Integrate
                addMulVec2(c, h, v);
                a += h * w;
                copyVec2(body.c_position.c, c);
                body.c_position.a = a;
                copyVec2(body.c_velocity.v, v);
                body.c_velocity.w = w;
            }
            // Solve position constraints
            var positionSolved = false;
            for (var i = 0; i < step.positionIterations; ++i) {
                var minSeparation = 0.0;
                for (var j = 0; j < this.m_contacts.length; ++j) {
                    var contact = this.m_contacts[j];
                    var separation = contact.solvePositionConstraint(step);
                    minSeparation = math_min$5(minSeparation, separation);
                }
                // We can't expect minSpeparation >= -Settings.linearSlop because we don't
                // push the separation above -Settings.linearSlop.
                var contactsOkay = minSeparation >= -3.0 * SettingsInternal.linearSlop;
                var jointsOkay = true;
                for (var j = 0; j < this.m_joints.length; ++j) {
                    var joint = this.m_joints[j];
                    var jointOkay = joint.solvePositionConstraints(step);
                    jointsOkay = jointsOkay && jointOkay;
                }
                if (contactsOkay && jointsOkay) {
                    // Exit early if the position errors are small.
                    positionSolved = true;
                    break;
                }
            }
            // Copy state buffers back to the bodies
            for (var i = 0; i < this.m_bodies.length; ++i) {
                var body = this.m_bodies[i];
                copyVec2(body.m_sweep.c, body.c_position.c);
                body.m_sweep.a = body.c_position.a;
                copyVec2(body.m_linearVelocity, body.c_velocity.v);
                body.m_angularVelocity = body.c_velocity.w;
                body.synchronizeTransform();
            }
            this.postSolveIsland();
            if (allowSleep) {
                var minSleepTime = Infinity;
                var linTolSqr = SettingsInternal.linearSleepToleranceSqr;
                var angTolSqr = SettingsInternal.angularSleepToleranceSqr;
                for (var i = 0; i < this.m_bodies.length; ++i) {
                    var body = this.m_bodies[i];
                    if (body.isStatic()) {
                        continue;
                    }
                    if ((body.m_autoSleepFlag == false)
                        || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)
                        || (lengthSqrVec2(body.m_linearVelocity) > linTolSqr)) {
                        body.m_sleepTime = 0.0;
                        minSleepTime = 0.0;
                    }
                    else {
                        body.m_sleepTime += h;
                        minSleepTime = math_min$5(minSleepTime, body.m_sleepTime);
                    }
                }
                if (minSleepTime >= SettingsInternal.timeToSleep && positionSolved) {
                    for (var i = 0; i < this.m_bodies.length; ++i) {
                        var body = this.m_bodies[i];
                        body.setAwake(false);
                    }
                }
            }
        };
        /**
         * Find TOI contacts and solve them.
         */
        Solver.prototype.solveWorldTOI = function (step) {
            var world = this.m_world;
            if (world.m_stepComplete) {
                for (var b = world.m_bodyList; b; b = b.m_next) {
                    b.m_islandFlag = false;
                    b.m_sweep.alpha0 = 0.0;
                }
                for (var c_2 = world.m_contactList; c_2; c_2 = c_2.m_next) {
                    // Invalidate TOI
                    c_2.m_toiFlag = false;
                    c_2.m_islandFlag = false;
                    c_2.m_toiCount = 0;
                    c_2.m_toi = 1.0;
                }
            }
            // Find TOI events and solve them.
            while (true) {
                // Find the first TOI.
                var minContact = null;
                var minAlpha = 1.0;
                for (var c_3 = world.m_contactList; c_3; c_3 = c_3.m_next) {
                    // Is this contact disabled?
                    if (c_3.isEnabled() == false) {
                        continue;
                    }
                    // Prevent excessive sub-stepping.
                    if (c_3.m_toiCount > SettingsInternal.maxSubSteps) {
                        continue;
                    }
                    var alpha = 1.0;
                    if (c_3.m_toiFlag) {
                        // This contact has a valid cached TOI.
                        alpha = c_3.m_toi;
                    }
                    else {
                        var fA_1 = c_3.getFixtureA();
                        var fB_1 = c_3.getFixtureB();
                        // Is there a sensor?
                        if (fA_1.isSensor() || fB_1.isSensor()) {
                            continue;
                        }
                        var bA_1 = fA_1.getBody();
                        var bB_1 = fB_1.getBody();
                        var activeA = bA_1.isAwake() && !bA_1.isStatic();
                        var activeB = bB_1.isAwake() && !bB_1.isStatic();
                        // Is at least one body active (awake and dynamic or kinematic)?
                        if (activeA == false && activeB == false) {
                            continue;
                        }
                        var collideA = bA_1.isBullet() || !bA_1.isDynamic();
                        var collideB = bB_1.isBullet() || !bB_1.isDynamic();
                        // Are these two non-bullet dynamic bodies?
                        if (collideA == false && collideB == false) {
                            continue;
                        }
                        // Compute the TOI for this contact.
                        // Put the sweeps onto the same time interval.
                        var alpha0 = bA_1.m_sweep.alpha0;
                        if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {
                            alpha0 = bB_1.m_sweep.alpha0;
                            bA_1.m_sweep.advance(alpha0);
                        }
                        else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {
                            alpha0 = bA_1.m_sweep.alpha0;
                            bB_1.m_sweep.advance(alpha0);
                        }
                        var indexA = c_3.getChildIndexA();
                        var indexB = c_3.getChildIndexB();
                        bA_1.m_sweep;
                        bB_1.m_sweep;
                        // Compute the time of impact in interval [0, minTOI]
                        input.proxyA.set(fA_1.getShape(), indexA);
                        input.proxyB.set(fB_1.getShape(), indexB);
                        input.sweepA.set(bA_1.m_sweep);
                        input.sweepB.set(bB_1.m_sweep);
                        input.tMax = 1.0;
                        TimeOfImpact(output, input);
                        // Beta is the fraction of the remaining portion of the [time?].
                        var beta = output.t;
                        if (output.state == exports.TOIOutputState.e_touching) {
                            alpha = math_min$5(alpha0 + (1.0 - alpha0) * beta, 1.0);
                        }
                        else {
                            alpha = 1.0;
                        }
                        c_3.m_toi = alpha;
                        c_3.m_toiFlag = true;
                    }
                    if (alpha < minAlpha) {
                        // This is the minimum TOI found so far.
                        minContact = c_3;
                        minAlpha = alpha;
                    }
                }
                if (minContact == null || 1.0 - 10.0 * EPSILON < minAlpha) {
                    // No more TOI events. Done!
                    world.m_stepComplete = true;
                    break;
                }
                // Advance the bodies to the TOI.
                var fA = minContact.getFixtureA();
                var fB = minContact.getFixtureB();
                var bA = fA.getBody();
                var bB = fB.getBody();
                backup1.set(bA.m_sweep);
                backup2.set(bB.m_sweep);
                bA.advance(minAlpha);
                bB.advance(minAlpha);
                // The TOI contact likely has some new contact points.
                minContact.update(world);
                minContact.m_toiFlag = false;
                ++minContact.m_toiCount;
                // Is the contact solid?
                if (minContact.isEnabled() == false || minContact.isTouching() == false) {
                    // Restore the sweeps.
                    minContact.setEnabled(false);
                    bA.m_sweep.set(backup1);
                    bB.m_sweep.set(backup2);
                    bA.synchronizeTransform();
                    bB.synchronizeTransform();
                    continue;
                }
                bA.setAwake(true);
                bB.setAwake(true);
                // Build the island
                this.clear();
                this.addBody(bA);
                this.addBody(bB);
                this.addContact(minContact);
                bA.m_islandFlag = true;
                bB.m_islandFlag = true;
                minContact.m_islandFlag = true;
                // Get contacts on bodyA and bodyB.
                var bodies = [bA, bB];
                for (var i = 0; i < bodies.length; ++i) {
                    var body = bodies[i];
                    if (body.isDynamic()) {
                        for (var ce = body.m_contactList; ce; ce = ce.next) {
                            // if (this.m_bodyCount == this.m_bodyCapacity) { break; }
                            // if (this.m_contactCount == this.m_contactCapacity) { break; }
                            var contact = ce.contact;
                            // Has this contact already been added to the island?
                            if (contact.m_islandFlag) {
                                continue;
                            }
                            // Only add if either is static, kinematic or bullet.
                            var other = ce.other;
                            if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {
                                continue;
                            }
                            // Skip sensors.
                            var sensorA = contact.m_fixtureA.m_isSensor;
                            var sensorB = contact.m_fixtureB.m_isSensor;
                            if (sensorA || sensorB) {
                                continue;
                            }
                            // Tentatively advance the body to the TOI.
                            backup.set(other.m_sweep);
                            if (other.m_islandFlag == false) {
                                other.advance(minAlpha);
                            }
                            // Update the contact points
                            contact.update(world);
                            // Was the contact disabled by the user?
                            // Are there contact points?
                            if (contact.isEnabled() == false || contact.isTouching() == false) {
                                other.m_sweep.set(backup);
                                other.synchronizeTransform();
                                continue;
                            }
                            // Add the contact to the island
                            contact.m_islandFlag = true;
                            this.addContact(contact);
                            // Has the other body already been added to the island?
                            if (other.m_islandFlag) {
                                continue;
                            }
                            // Add the other body to the island.
                            other.m_islandFlag = true;
                            if (!other.isStatic()) {
                                other.setAwake(true);
                            }
                            this.addBody(other);
                        }
                    }
                }
                s_subStep.reset((1.0 - minAlpha) * step.dt);
                s_subStep.dtRatio = 1.0;
                s_subStep.positionIterations = 20;
                s_subStep.velocityIterations = step.velocityIterations;
                s_subStep.warmStarting = false;
                this.solveIslandTOI(s_subStep, bA, bB);
                // Reset island flags and synchronize broad-phase proxies.
                for (var i = 0; i < this.m_bodies.length; ++i) {
                    var body = this.m_bodies[i];
                    body.m_islandFlag = false;
                    if (!body.isDynamic()) {
                        continue;
                    }
                    body.synchronizeFixtures();
                    // Invalidate all contact TOIs on this displaced body.
                    for (var ce = body.m_contactList; ce; ce = ce.next) {
                        ce.contact.m_toiFlag = false;
                        ce.contact.m_islandFlag = false;
                    }
                }
                // Commit fixture proxy movements to the broad-phase so that new contacts
                // are created.
                // Also, some contacts can be destroyed.
                world.findNewContacts();
                if (world.m_subStepping) {
                    world.m_stepComplete = false;
                    break;
                }
            }
        };
        Solver.prototype.solveIslandTOI = function (subStep, toiA, toiB) {
            // Initialize the body state.
            for (var i = 0; i < this.m_bodies.length; ++i) {
                var body = this.m_bodies[i];
                copyVec2(body.c_position.c, body.m_sweep.c);
                body.c_position.a = body.m_sweep.a;
                copyVec2(body.c_velocity.v, body.m_linearVelocity);
                body.c_velocity.w = body.m_angularVelocity;
            }
            for (var i = 0; i < this.m_contacts.length; ++i) {
                var contact = this.m_contacts[i];
                contact.initConstraint(subStep);
            }
            // Solve position constraints.
            for (var i = 0; i < subStep.positionIterations; ++i) {
                var minSeparation = 0.0;
                for (var j = 0; j < this.m_contacts.length; ++j) {
                    var contact = this.m_contacts[j];
                    var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);
                    minSeparation = math_min$5(minSeparation, separation);
                }
                // We can't expect minSpeparation >= -Settings.linearSlop because we don't
                // push the separation above -Settings.linearSlop.
                var contactsOkay = minSeparation >= -1.5 * SettingsInternal.linearSlop;
                if (contactsOkay) {
                    break;
                }
            }
            var i; 
            // Leap of faith to new safe state.
            copyVec2(toiA.m_sweep.c0, toiA.c_position.c);
            toiA.m_sweep.a0 = toiA.c_position.a;
            copyVec2(toiB.m_sweep.c0, toiB.c_position.c);
            toiB.m_sweep.a0 = toiB.c_position.a;
            // No warm starting is needed for TOI events because warm
            // starting impulses were applied in the discrete solver.
            for (var i = 0; i < this.m_contacts.length; ++i) {
                var contact = this.m_contacts[i];
                contact.initVelocityConstraint(subStep);
            }
            // Solve velocity constraints.
            for (var i = 0; i < subStep.velocityIterations; ++i) {
                for (var j = 0; j < this.m_contacts.length; ++j) {
                    var contact = this.m_contacts[j];
                    contact.solveVelocityConstraint(subStep);
                }
            }
            // Don't store the TOI contact forces for warm starting
            // because they can be quite large.
            var h = subStep.dt;
            // Integrate positions
            for (var i = 0; i < this.m_bodies.length; ++i) {
                var body = this.m_bodies[i];
                copyVec2(c, body.c_position.c);
                var a = body.c_position.a;
                copyVec2(v, body.c_velocity.v);
                var w = body.c_velocity.w;
                // Check for large velocities
                setMulVec2(translation, h, v);
                var translationLengthSqr = lengthSqrVec2(translation);
                if (translationLengthSqr > SettingsInternal.maxTranslationSquared) {
                    var ratio = SettingsInternal.maxTranslation / math_sqrt$3(translationLengthSqr);
                    scaleVec2(v, ratio);
                }
                var rotation = h * w;
                if (rotation * rotation > SettingsInternal.maxRotationSquared) {
                    var ratio = SettingsInternal.maxRotation / math_abs$6(rotation);
                    w *= ratio;
                }
                // Integrate
                addMulVec2(c, h, v);
                a += h * w;
                copyVec2(body.c_position.c, c);
                body.c_position.a = a;
                copyVec2(body.c_velocity.v, v);
                body.c_velocity.w = w;
                // Sync bodies
                copyVec2(body.m_sweep.c, c);
                body.m_sweep.a = a;
                copyVec2(body.m_linearVelocity, v);
                body.m_angularVelocity = w;
                body.synchronizeTransform();
            }
            this.postSolveIsland();
        };
        /** @internal */
        Solver.prototype.postSolveIsland = function () {
            for (var c_5 = 0; c_5 < this.m_contacts.length; ++c_5) {
                var contact = this.m_contacts[c_5];
                this.m_world.postSolve(contact, contact.m_impulse);
            }
        };
        return Solver;
    }());
    // @ts-ignore
    Solver.TimeStep = TimeStep;

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * A 2-by-2 matrix. Stored in column-major order.
     */
    var Mat22 = /** @class */ (function () {
        function Mat22(a, b, c, d) {
            if (typeof a === 'object' && a !== null) {
                this.ex = Vec2.clone(a);
                this.ey = Vec2.clone(b);
            }
            else if (typeof a === 'number') {
                this.ex = Vec2.neo(a, c);
                this.ey = Vec2.neo(b, d);
            }
            else {
                this.ex = Vec2.zero();
                this.ey = Vec2.zero();
            }
        }
        /** @internal */
        Mat22.prototype.toString = function () {
            return JSON.stringify(this);
        };
        Mat22.isValid = function (obj) {
            if (obj === null || typeof obj === 'undefined') {
                return false;
            }
            return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);
        };
        Mat22.assert = function (o) {
        };
        Mat22.prototype.set = function (a, b, c, d) {
            if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'
                && typeof d === 'number') {
                this.ex.setNum(a, c);
                this.ey.setNum(b, d);
            }
            else if (typeof a === 'object' && typeof b === 'object') {
                this.ex.setVec2(a);
                this.ey.setVec2(b);
            }
            else if (typeof a === 'object') {
                this.ex.setVec2(a.ex);
                this.ey.setVec2(a.ey);
            }
            else ;
        };
        Mat22.prototype.setIdentity = function () {
            this.ex.x = 1.0;
            this.ey.x = 0.0;
            this.ex.y = 0.0;
            this.ey.y = 1.0;
        };
        Mat22.prototype.setZero = function () {
            this.ex.x = 0.0;
            this.ey.x = 0.0;
            this.ex.y = 0.0;
            this.ey.y = 0.0;
        };
        Mat22.prototype.getInverse = function () {
            var a = this.ex.x;
            var b = this.ey.x;
            var c = this.ex.y;
            var d = this.ey.y;
            var det = a * d - b * c;
            if (det !== 0.0) {
                det = 1.0 / det;
            }
            var imx = new Mat22();
            imx.ex.x = det * d;
            imx.ey.x = -det * b;
            imx.ex.y = -det * c;
            imx.ey.y = det * a;
            return imx;
        };
        /**
         * Solve A * x = b, where b is a column vector. This is more efficient than
         * computing the inverse in one-shot cases.
         */
        Mat22.prototype.solve = function (v) {
            var a = this.ex.x;
            var b = this.ey.x;
            var c = this.ex.y;
            var d = this.ey.y;
            var det = a * d - b * c;
            if (det !== 0.0) {
                det = 1.0 / det;
            }
            var w = Vec2.zero();
            w.x = det * (d * v.x - b * v.y);
            w.y = det * (a * v.y - c * v.x);
            return w;
        };
        Mat22.mul = function (mx, v) {
            if (v && 'x' in v && 'y' in v) {
                var x = mx.ex.x * v.x + mx.ey.x * v.y;
                var y = mx.ex.y * v.x + mx.ey.y * v.y;
                return Vec2.neo(x, y);
            }
            else if (v && 'ex' in v && 'ey' in v) { // Mat22
                // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
                var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;
                var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;
                var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;
                var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;
                return new Mat22(a, b, c, d);
            }
        };
        Mat22.mulVec2 = function (mx, v) {
            var x = mx.ex.x * v.x + mx.ey.x * v.y;
            var y = mx.ex.y * v.x + mx.ey.y * v.y;
            return Vec2.neo(x, y);
        };
        Mat22.mulMat22 = function (mx, v) {
            // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
            var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;
            var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;
            var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;
            var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;
            return new Mat22(a, b, c, d);
        };
        Mat22.mulT = function (mx, v) {
            if (v && 'x' in v && 'y' in v) { // Vec2
                return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));
            }
            else if (v && 'ex' in v && 'ey' in v) { // Mat22
                var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));
                var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));
                return new Mat22(c1, c2);
            }
        };
        Mat22.mulTVec2 = function (mx, v) {
            return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));
        };
        Mat22.mulTMat22 = function (mx, v) {
            var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));
            var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));
            return new Mat22(c1, c2);
        };
        Mat22.abs = function (mx) {
            return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));
        };
        Mat22.add = function (mx1, mx2) {
            return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));
        };
        return Mat22;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_sqrt$2 = Math.sqrt;
    /** @internal */ var pointA$1 = vec2(0, 0);
    /** @internal */ var pointB$1 = vec2(0, 0);
    /** @internal */ var temp$3 = vec2(0, 0);
    /** @internal */ var cA$1 = vec2(0, 0);
    /** @internal */ var cB$1 = vec2(0, 0);
    /** @internal */ var dist = vec2(0, 0);
    /** @internal */ var planePoint$2 = vec2(0, 0);
    /** @internal */ var clipPoint$1 = vec2(0, 0);
    exports.ManifoldType = void 0;
    (function (ManifoldType) {
        ManifoldType[ManifoldType["e_unset"] = -1] = "e_unset";
        ManifoldType[ManifoldType["e_circles"] = 0] = "e_circles";
        ManifoldType[ManifoldType["e_faceA"] = 1] = "e_faceA";
        ManifoldType[ManifoldType["e_faceB"] = 2] = "e_faceB";
    })(exports.ManifoldType || (exports.ManifoldType = {}));
    exports.ContactFeatureType = void 0;
    (function (ContactFeatureType) {
        ContactFeatureType[ContactFeatureType["e_unset"] = -1] = "e_unset";
        ContactFeatureType[ContactFeatureType["e_vertex"] = 0] = "e_vertex";
        ContactFeatureType[ContactFeatureType["e_face"] = 1] = "e_face";
    })(exports.ContactFeatureType || (exports.ContactFeatureType = {}));
    /**
     * This is used for determining the state of contact points.
     */
    exports.PointState = void 0;
    (function (PointState) {
        /** Point does not exist */
        PointState[PointState["nullState"] = 0] = "nullState";
        /** Point was added in the update */
        PointState[PointState["addState"] = 1] = "addState";
        /** Point persisted across the update */
        PointState[PointState["persistState"] = 2] = "persistState";
        /** Point was removed in the update */
        PointState[PointState["removeState"] = 3] = "removeState";
    })(exports.PointState || (exports.PointState = {}));
    /**
     * Used for computing contact manifolds.
     */
    var ClipVertex = /** @class */ (function () {
        function ClipVertex() {
            this.v = vec2(0, 0);
            this.id = new ContactID();
        }
        ClipVertex.prototype.set = function (o) {
            copyVec2(this.v, o.v);
            this.id.set(o.id);
        };
        ClipVertex.prototype.recycle = function () {
            zeroVec2(this.v);
            this.id.recycle();
        };
        return ClipVertex;
    }());
    /**
     * A manifold for two touching convex shapes. Manifolds are created in `evaluate`
     * method of Contact subclasses.
     *
     * Supported manifold types are e_faceA or e_faceB for clip point versus plane
     * with radius and e_circles point versus point with radius.
     *
     * We store contacts in this way so that position correction can account for
     * movement, which is critical for continuous physics. All contact scenarios
     * must be expressed in one of these types. This structure is stored across time
     * steps, so we keep it small.
     */
    var Manifold = /** @class */ (function () {
        function Manifold() {
            /**
             * Usage depends on manifold type:
             * - circles: not used
             * - faceA: the normal on polygonA
             * - faceB: the normal on polygonB
             */
            this.localNormal = vec2(0, 0);
            /**
             * Usage depends on manifold type:
             * - circles: the local center of circleA
             * - faceA: the center of faceA
             * - faceB: the center of faceB
             */
            this.localPoint = vec2(0, 0);
            /** The points of contact */
            this.points = [new ManifoldPoint(), new ManifoldPoint()];
            /** The number of manifold points */
            this.pointCount = 0;
        }
        Manifold.prototype.set = function (that) {
            this.type = that.type;
            copyVec2(this.localNormal, that.localNormal);
            copyVec2(this.localPoint, that.localPoint);
            this.pointCount = that.pointCount;
            this.points[0].set(that.points[0]);
            this.points[1].set(that.points[1]);
        };
        Manifold.prototype.recycle = function () {
            this.type = exports.ManifoldType.e_unset;
            zeroVec2(this.localNormal);
            zeroVec2(this.localPoint);
            this.pointCount = 0;
            this.points[0].recycle();
            this.points[1].recycle();
        };
        /**
         * Evaluate the manifold with supplied transforms. This assumes modest motion
         * from the original state. This does not change the point count, impulses, etc.
         * The radii must come from the shapes that generated the manifold.
         */
        Manifold.prototype.getWorldManifold = function (wm, xfA, radiusA, xfB, radiusB) {
            if (this.pointCount == 0) {
                return wm;
            }
            wm = wm || new WorldManifold();
            wm.pointCount = this.pointCount;
            var normal = wm.normal;
            var points = wm.points;
            var separations = wm.separations;
            switch (this.type) {
                case exports.ManifoldType.e_circles: {
                    setVec2(normal, 1.0, 0.0);
                    var manifoldPoint = this.points[0];
                    transformVec2(pointA$1, xfA, this.localPoint);
                    transformVec2(pointB$1, xfB, manifoldPoint.localPoint);
                    diffVec2(dist, pointB$1, pointA$1);
                    var lengthSqr = lengthSqrVec2(dist);
                    if (lengthSqr > EPSILON * EPSILON) {
                        var length_1 = math_sqrt$2(lengthSqr);
                        setMulVec2(normal, 1 / length_1, dist);
                    }
                    combineVec2(cA$1, 1, pointA$1, radiusA, normal);
                    combineVec2(cB$1, 1, pointB$1, -radiusB, normal);
                    combineVec2(points[0], 0.5, cA$1, 0.5, cB$1);
                    separations[0] = dotVec2(diffVec2(temp$3, cB$1, cA$1), normal);
                    break;
                }
                case exports.ManifoldType.e_faceA: {
                    rotVec2(normal, xfA.q, this.localNormal);
                    transformVec2(planePoint$2, xfA, this.localPoint);
                    for (var i = 0; i < this.pointCount; ++i) {
                        var manifoldPoint = this.points[i];
                        transformVec2(clipPoint$1, xfB, manifoldPoint.localPoint);
                        combineVec2(cA$1, 1, clipPoint$1, radiusA - dotVec2(diffVec2(temp$3, clipPoint$1, planePoint$2), normal), normal);
                        combineVec2(cB$1, 1, clipPoint$1, -radiusB, normal);
                        combineVec2(points[i], 0.5, cA$1, 0.5, cB$1);
                        separations[i] = dotVec2(diffVec2(temp$3, cB$1, cA$1), normal);
                    }
                    break;
                }
                case exports.ManifoldType.e_faceB: {
                    rotVec2(normal, xfB.q, this.localNormal);
                    transformVec2(planePoint$2, xfB, this.localPoint);
                    for (var i = 0; i < this.pointCount; ++i) {
                        var manifoldPoint = this.points[i];
                        transformVec2(clipPoint$1, xfA, manifoldPoint.localPoint);
                        combineVec2(cB$1, 1, clipPoint$1, radiusB - dotVec2(diffVec2(temp$3, clipPoint$1, planePoint$2), normal), normal);
                        combineVec2(cA$1, 1, clipPoint$1, -radiusA, normal);
                        combineVec2(points[i], 0.5, cA$1, 0.5, cB$1);
                        separations[i] = dotVec2(diffVec2(temp$3, cA$1, cB$1), normal);
                    }
                    // Ensure normal points from A to B.
                    negVec2(normal);
                    break;
                }
            }
            return wm;
        };
        Manifold.clipSegmentToLine = clipSegmentToLine;
        Manifold.ClipVertex = ClipVertex;
        Manifold.getPointStates = getPointStates;
        Manifold.PointState = exports.PointState;
        return Manifold;
    }());
    /**
     * A manifold point is a contact point belonging to a contact manifold. It holds
     * details related to the geometry and dynamics of the contact points.
     *
     * This structure is stored across time steps, so we keep it small.
     *
     * Note: impulses are used for internal caching and may not provide reliable
     * contact forces, especially for high speed collisions.
     */
    var ManifoldPoint = /** @class */ (function () {
        function ManifoldPoint() {
            /**
             * Usage depends on manifold type:
             * - circles: the local center of circleB
             * - faceA: the local center of circleB or the clip point of polygonB
             * - faceB: the clip point of polygonA
             */
            this.localPoint = vec2(0, 0);
            /**
             * The non-penetration impulse
             */
            this.normalImpulse = 0;
            /**
             * The friction impulse
             */
            this.tangentImpulse = 0;
            /**
             * Uniquely identifies a contact point between two shapes to facilitate warm starting
             */
            this.id = new ContactID();
        }
        ManifoldPoint.prototype.set = function (that) {
            copyVec2(this.localPoint, that.localPoint);
            this.normalImpulse = that.normalImpulse;
            this.tangentImpulse = that.tangentImpulse;
            this.id.set(that.id);
        };
        ManifoldPoint.prototype.recycle = function () {
            zeroVec2(this.localPoint);
            this.normalImpulse = 0;
            this.tangentImpulse = 0;
            this.id.recycle();
        };
        return ManifoldPoint;
    }());
    /**
     * Contact ids to facilitate warm starting.
     *
     * ContactFeature: The features that intersect to form the contact point.
     */
    var ContactID = /** @class */ (function () {
        function ContactID() {
            /**
             * Used to quickly compare contact ids.
             */
            this.key = -1;
            /** ContactFeature index on shapeA */
            this.indexA = -1;
            /** ContactFeature index on shapeB */
            this.indexB = -1;
            /** ContactFeature type on shapeA */
            this.typeA = exports.ContactFeatureType.e_unset;
            /** ContactFeature type on shapeB */
            this.typeB = exports.ContactFeatureType.e_unset;
        }
        ContactID.prototype.setFeatures = function (indexA, typeA, indexB, typeB) {
            this.indexA = indexA;
            this.indexB = indexB;
            this.typeA = typeA;
            this.typeB = typeB;
            this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;
        };
        ContactID.prototype.set = function (that) {
            this.indexA = that.indexA;
            this.indexB = that.indexB;
            this.typeA = that.typeA;
            this.typeB = that.typeB;
            this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;
        };
        ContactID.prototype.swapFeatures = function () {
            var indexA = this.indexA;
            var indexB = this.indexB;
            var typeA = this.typeA;
            var typeB = this.typeB;
            this.indexA = indexB;
            this.indexB = indexA;
            this.typeA = typeB;
            this.typeB = typeA;
            this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;
        };
        ContactID.prototype.recycle = function () {
            this.indexA = 0;
            this.indexB = 0;
            this.typeA = exports.ContactFeatureType.e_unset;
            this.typeB = exports.ContactFeatureType.e_unset;
            this.key = -1;
        };
        return ContactID;
    }());
    /**
     * This is used to compute the current state of a contact manifold.
     */
    var WorldManifold = /** @class */ (function () {
        function WorldManifold() {
            /** World vector pointing from A to B */
            this.normal = vec2(0, 0);
            /** World contact point (point of intersection) */
            this.points = [vec2(0, 0), vec2(0, 0)]; // [maxManifoldPoints]
            /** A negative value indicates overlap, in meters */
            this.separations = [0, 0]; // [maxManifoldPoints]
            /** The number of manifold points */
            this.pointCount = 0;
        }
        WorldManifold.prototype.recycle = function () {
            zeroVec2(this.normal);
            zeroVec2(this.points[0]);
            zeroVec2(this.points[1]);
            this.separations[0] = 0;
            this.separations[1] = 0;
            this.pointCount = 0;
        };
        return WorldManifold;
    }());
    /**
     * Compute the point states given two manifolds. The states pertain to the
     * transition from manifold1 to manifold2. So state1 is either persist or remove
     * while state2 is either add or persist.
     */
    function getPointStates(state1, state2, manifold1, manifold2) {
        // state1, state2: PointState[Settings.maxManifoldPoints]
        // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {
        // state1[i] = PointState.nullState;
        // state2[i] = PointState.nullState;
        // }
        // Detect persists and removes.
        for (var i = 0; i < manifold1.pointCount; ++i) {
            var id = manifold1.points[i].id;
            state1[i] = exports.PointState.removeState;
            for (var j = 0; j < manifold2.pointCount; ++j) {
                if (manifold2.points[j].id.key === id.key) {
                    state1[i] = exports.PointState.persistState;
                    break;
                }
            }
        }
        // Detect persists and adds.
        for (var i = 0; i < manifold2.pointCount; ++i) {
            var id = manifold2.points[i].id;
            state2[i] = exports.PointState.addState;
            for (var j = 0; j < manifold1.pointCount; ++j) {
                if (manifold1.points[j].id.key === id.key) {
                    state2[i] = exports.PointState.persistState;
                    break;
                }
            }
        }
    }
    /**
     * Clipping for contact manifolds. Sutherland-Hodgman clipping.
     */
    function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {
        // Start with no output points
        var numOut = 0;
        // Calculate the distance of end points to the line
        var distance0 = dotVec2(normal, vIn[0].v) - offset;
        var distance1 = dotVec2(normal, vIn[1].v) - offset;
        // If the points are behind the plane
        if (distance0 <= 0.0)
            vOut[numOut++].set(vIn[0]);
        if (distance1 <= 0.0)
            vOut[numOut++].set(vIn[1]);
        // If the points are on different sides of the plane
        if (distance0 * distance1 < 0.0) {
            // Find intersection point of edge and plane
            var interp = distance0 / (distance0 - distance1);
            combineVec2(vOut[numOut].v, 1 - interp, vIn[0].v, interp, vIn[1].v);
            // VertexA is hitting edgeB.
            vOut[numOut].id.setFeatures(vertexIndexA, exports.ContactFeatureType.e_vertex, vIn[0].id.indexB, exports.ContactFeatureType.e_face);
            ++numOut;
        }
        return numOut;
    }

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_sqrt$1 = Math.sqrt;
    /** @internal */ var math_max$2 = Math.max;
    /** @internal */ var math_min$4 = Math.min;
    /** @internal */ var contactPool = new Pool({
        create: function () {
            return new Contact();
        },
        release: function (contact) {
            contact.recycle();
        }
    });
    /** @internal */ var oldManifold = new Manifold();
    /** @internal */ var worldManifold = new WorldManifold();
    /**
     * A contact edge is used to connect bodies and contacts together in a contact
     * graph where each body is a node and each contact is an edge. A contact edge
     * belongs to a doubly linked list maintained in each attached body. Each
     * contact has two contact nodes, one for each attached body.
     */
    var ContactEdge = /** @class */ (function () {
        function ContactEdge(contact) {
            this.prev = null;
            this.next = null;
            this.other = null;
            this.contact = contact;
        }
        /** @internal */
        ContactEdge.prototype.recycle = function () {
            this.prev = null;
            this.next = null;
            this.other = null;
        };
        return ContactEdge;
    }());
    /**
     * Friction mixing law. The idea is to allow either fixture to drive the
     * friction to zero. For example, anything slides on ice.
     */
    function mixFriction(friction1, friction2) {
        return math_sqrt$1(friction1 * friction2);
    }
    /**
     * Restitution mixing law. The idea is allow for anything to bounce off an
     * inelastic surface. For example, a superball bounces on anything.
     */
    function mixRestitution(restitution1, restitution2) {
        return restitution1 > restitution2 ? restitution1 : restitution2;
    }
    // TODO: move this to Settings?
    /** @internal */ var s_registers = [];
    // TODO: merge with ManifoldPoint?
    var VelocityConstraintPoint = /** @class */ (function () {
        function VelocityConstraintPoint() {
            this.rA = vec2(0, 0);
            this.rB = vec2(0, 0);
            this.normalImpulse = 0;
            this.tangentImpulse = 0;
            this.normalMass = 0;
            this.tangentMass = 0;
            this.velocityBias = 0;
        }
        VelocityConstraintPoint.prototype.recycle = function () {
            zeroVec2(this.rA);
            zeroVec2(this.rB);
            this.normalImpulse = 0;
            this.tangentImpulse = 0;
            this.normalMass = 0;
            this.tangentMass = 0;
            this.velocityBias = 0;
        };
        return VelocityConstraintPoint;
    }());
    /** @internal */ var cA = vec2(0, 0);
    /** @internal */ var vA = vec2(0, 0);
    /** @internal */ var cB = vec2(0, 0);
    /** @internal */ var vB = vec2(0, 0);
    /** @internal */ var tangent$1 = vec2(0, 0);
    /** @internal */ var xfA = transform(0, 0, 0);
    /** @internal */ var xfB = transform(0, 0, 0);
    /** @internal */ var pointA = vec2(0, 0);
    /** @internal */ var pointB = vec2(0, 0);
    /** @internal */ var clipPoint = vec2(0, 0);
    /** @internal */ var planePoint$1 = vec2(0, 0);
    /** @internal */ var rA = vec2(0, 0);
    /** @internal */ var rB = vec2(0, 0);
    /** @internal */ var P$1 = vec2(0, 0);
    /** @internal */ var normal$2 = vec2(0, 0);
    /** @internal */ var point = vec2(0, 0);
    /** @internal */ var dv = vec2(0, 0);
    /** @internal */ var dv1 = vec2(0, 0);
    /** @internal */ var dv2 = vec2(0, 0);
    /** @internal */ var b = vec2(0, 0);
    /** @internal */ var a = vec2(0, 0);
    /** @internal */ var x = vec2(0, 0);
    /** @internal */ var d = vec2(0, 0);
    /** @internal */ var P1 = vec2(0, 0);
    /** @internal */ var P2 = vec2(0, 0);
    /** @internal */ var temp$2 = vec2(0, 0);
    /**
     * The class manages contact between two shapes. A contact exists for each
     * overlapping AABB in the broad-phase (except if filtered). Therefore a contact
     * object may exist that has no contact points.
     */
    var Contact = /** @class */ (function () {
        function Contact() {
            // Nodes for connecting bodies.
            /** @internal */
            this.m_nodeA = new ContactEdge(this);
            /** @internal */
            this.m_nodeB = new ContactEdge(this);
            /** @internal */
            this.m_fixtureA = null;
            /** @internal */
            this.m_fixtureB = null;
            /** @internal */
            this.m_indexA = -1;
            /** @internal */
            this.m_indexB = -1;
            /** @internal */
            this.m_evaluateFcn = null;
            /** @internal */
            this.m_manifold = new Manifold();
            /** @internal */
            this.m_prev = null;
            /** @internal */
            this.m_next = null;
            /** @internal */
            this.m_toi = 1.0;
            /** @internal */
            this.m_toiCount = 0;
            /** @internal This contact has a valid TOI in m_toi */
            this.m_toiFlag = false;
            /** @internal */
            this.m_friction = 0.0;
            /** @internal */
            this.m_restitution = 0.0;
            /** @internal */
            this.m_tangentSpeed = 0.0;
            /** @internal This contact can be disabled (by user) */
            this.m_enabledFlag = true;
            /** @internal Used when crawling contact graph when forming islands. */
            this.m_islandFlag = false;
            /** @internal Set when the shapes are touching. */
            this.m_touchingFlag = false;
            /** @internal This contact needs filtering because a fixture filter was changed. */
            this.m_filterFlag = false;
            /** @internal This bullet contact had a TOI event */
            this.m_bulletHitFlag = false;
            /** @internal Contact reporting impulse object cache */
            this.m_impulse = new ContactImpulse(this);
            // VelocityConstraint
            /** @internal */
            this.v_points = [new VelocityConstraintPoint(), new VelocityConstraintPoint()]; // [maxManifoldPoints];
            /** @internal */
            this.v_normal = vec2(0, 0);
            /** @internal */ this.v_normalMass = new Mat22();
            /** @internal */ this.v_K = new Mat22();
            /** @internal */ this.v_pointCount = 0;
            /** @internal */ this.v_tangentSpeed = 0;
            /** @internal */ this.v_friction = 0;
            /** @internal */ this.v_restitution = 0;
            /** @internal */ this.v_invMassA = 0;
            /** @internal */ this.v_invMassB = 0;
            /** @internal */ this.v_invIA = 0;
            /** @internal */ this.v_invIB = 0;
            // PositionConstraint
            /** @internal */ this.p_localPoints = [vec2(0, 0), vec2(0, 0)]; // [maxManifoldPoints];
            /** @internal */ this.p_localNormal = vec2(0, 0);
            /** @internal */ this.p_localPoint = vec2(0, 0);
            /** @internal */ this.p_localCenterA = vec2(0, 0);
            /** @internal */ this.p_localCenterB = vec2(0, 0);
            /** @internal */ this.p_type = exports.ManifoldType.e_unset;
            /** @internal */ this.p_radiusA = 0;
            /** @internal */ this.p_radiusB = 0;
            /** @internal */ this.p_pointCount = 0;
            /** @internal */ this.p_invMassA = 0;
            /** @internal */ this.p_invMassB = 0;
            /** @internal */ this.p_invIA = 0;
            /** @internal */ this.p_invIB = 0;
        }
        /** @internal */
        Contact.prototype.initialize = function (fA, indexA, fB, indexB, evaluateFcn) {
            this.m_fixtureA = fA;
            this.m_fixtureB = fB;
            this.m_indexA = indexA;
            this.m_indexB = indexB;
            this.m_evaluateFcn = evaluateFcn;
            this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
            this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
        };
        /** @internal */
        Contact.prototype.recycle = function () {
            this.m_nodeA.recycle();
            this.m_nodeB.recycle();
            this.m_fixtureA = null;
            this.m_fixtureB = null;
            this.m_indexA = -1;
            this.m_indexB = -1;
            this.m_evaluateFcn = null;
            this.m_manifold.recycle();
            this.m_prev = null;
            this.m_next = null;
            this.m_toi = 1;
            this.m_toiCount = 0;
            this.m_toiFlag = false;
            this.m_friction = 0;
            this.m_restitution = 0;
            this.m_tangentSpeed = 0;
            this.m_enabledFlag = true;
            this.m_islandFlag = false;
            this.m_touchingFlag = false;
            this.m_filterFlag = false;
            this.m_bulletHitFlag = false;
            this.m_impulse.recycle();
            // VelocityConstraint
            for (var _i = 0, _a = this.v_points; _i < _a.length; _i++) {
                var point_1 = _a[_i];
                point_1.recycle();
            }
            zeroVec2(this.v_normal);
            this.v_normalMass.setZero();
            this.v_K.setZero();
            this.v_pointCount = 0;
            this.v_tangentSpeed = 0;
            this.v_friction = 0;
            this.v_restitution = 0;
            this.v_invMassA = 0;
            this.v_invMassB = 0;
            this.v_invIA = 0;
            this.v_invIB = 0;
            // PositionConstraint
            for (var _b = 0, _c = this.p_localPoints; _b < _c.length; _b++) {
                var point_2 = _c[_b];
                zeroVec2(point_2);
            }
            zeroVec2(this.p_localNormal);
            zeroVec2(this.p_localPoint);
            zeroVec2(this.p_localCenterA);
            zeroVec2(this.p_localCenterB);
            this.p_type = exports.ManifoldType.e_unset;
            this.p_radiusA = 0;
            this.p_radiusB = 0;
            this.p_pointCount = 0;
            this.p_invMassA = 0;
            this.p_invMassB = 0;
            this.p_invIA = 0;
            this.p_invIB = 0;
        };
        Contact.prototype.initConstraint = function (step) {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            if (bodyA === null || bodyB === null)
                return;
            var shapeA = fixtureA.m_shape;
            var shapeB = fixtureB.m_shape;
            if (shapeA === null || shapeB === null)
                return;
            var manifold = this.m_manifold;
            var pointCount = manifold.pointCount;
            this.v_invMassA = bodyA.m_invMass;
            this.v_invMassB = bodyB.m_invMass;
            this.v_invIA = bodyA.m_invI;
            this.v_invIB = bodyB.m_invI;
            this.v_friction = this.m_friction;
            this.v_restitution = this.m_restitution;
            this.v_tangentSpeed = this.m_tangentSpeed;
            this.v_pointCount = pointCount;
            this.v_K.setZero();
            this.v_normalMass.setZero();
            this.p_invMassA = bodyA.m_invMass;
            this.p_invMassB = bodyB.m_invMass;
            this.p_invIA = bodyA.m_invI;
            this.p_invIB = bodyB.m_invI;
            copyVec2(this.p_localCenterA, bodyA.m_sweep.localCenter);
            copyVec2(this.p_localCenterB, bodyB.m_sweep.localCenter);
            this.p_radiusA = shapeA.m_radius;
            this.p_radiusB = shapeB.m_radius;
            this.p_type = manifold.type;
            copyVec2(this.p_localNormal, manifold.localNormal);
            copyVec2(this.p_localPoint, manifold.localPoint);
            this.p_pointCount = pointCount;
            for (var j = 0; j < SettingsInternal.maxManifoldPoints; ++j) {
                this.v_points[j].recycle();
                zeroVec2(this.p_localPoints[j]);
            }
            for (var j = 0; j < pointCount; ++j) {
                var cp = manifold.points[j];
                var vcp = this.v_points[j];
                if (step.warmStarting) {
                    vcp.normalImpulse = step.dtRatio * cp.normalImpulse;
                    vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;
                }
                copyVec2(this.p_localPoints[j], cp.localPoint);
            }
        };
        /**
         * Get the contact manifold. Do not modify the manifold unless you understand
         * the internals of the library.
         */
        Contact.prototype.getManifold = function () {
            return this.m_manifold;
        };
        /**
         * Get the world manifold.
         */
        Contact.prototype.getWorldManifold = function (worldManifold) {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            if (bodyA === null || bodyB === null)
                return;
            var shapeA = fixtureA.m_shape;
            var shapeB = fixtureB.m_shape;
            if (shapeA === null || shapeB === null)
                return;
            return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);
        };
        /**
         * Enable/disable this contact. This can be used inside the pre-solve contact
         * listener. The contact is only disabled for the current time step (or sub-step
         * in continuous collisions).
         */
        Contact.prototype.setEnabled = function (flag) {
            this.m_enabledFlag = !!flag;
        };
        /**
         * Has this contact been disabled?
         */
        Contact.prototype.isEnabled = function () {
            return this.m_enabledFlag;
        };
        /**
         * Is this contact touching?
         */
        Contact.prototype.isTouching = function () {
            return this.m_touchingFlag;
        };
        /**
         * Get the next contact in the world's contact list.
         */
        Contact.prototype.getNext = function () {
            return this.m_next;
        };
        /**
         * Get fixture A in this contact.
         */
        Contact.prototype.getFixtureA = function () {
            return this.m_fixtureA;
        };
        /**
         * Get fixture B in this contact.
         */
        Contact.prototype.getFixtureB = function () {
            return this.m_fixtureB;
        };
        /**
         * Get the child primitive index for fixture A.
         */
        Contact.prototype.getChildIndexA = function () {
            return this.m_indexA;
        };
        /**
         * Get the child primitive index for fixture B.
         */
        Contact.prototype.getChildIndexB = function () {
            return this.m_indexB;
        };
        /**
         * Flag this contact for filtering. Filtering will occur the next time step.
         */
        Contact.prototype.flagForFiltering = function () {
            this.m_filterFlag = true;
        };
        /**
         * Override the default friction mixture. You can call this in
         * ContactListener.preSolve. This value persists until set or reset.
         */
        Contact.prototype.setFriction = function (friction) {
            this.m_friction = friction;
        };
        /**
         * Get the friction.
         */
        Contact.prototype.getFriction = function () {
            return this.m_friction;
        };
        /**
         * Reset the friction mixture to the default value.
         */
        Contact.prototype.resetFriction = function () {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            this.m_friction = mixFriction(fixtureA.m_friction, fixtureB.m_friction);
        };
        /**
         * Override the default restitution mixture. You can call this in
         * ContactListener.preSolve. The value persists until you set or reset.
         */
        Contact.prototype.setRestitution = function (restitution) {
            this.m_restitution = restitution;
        };
        /**
         * Get the restitution.
         */
        Contact.prototype.getRestitution = function () {
            return this.m_restitution;
        };
        /**
         * Reset the restitution to the default value.
         */
        Contact.prototype.resetRestitution = function () {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            this.m_restitution = mixRestitution(fixtureA.m_restitution, fixtureB.m_restitution);
        };
        /**
         * Set the desired tangent speed for a conveyor belt behavior. In meters per
         * second.
         */
        Contact.prototype.setTangentSpeed = function (speed) {
            this.m_tangentSpeed = speed;
        };
        /**
         * Get the desired tangent speed. In meters per second.
         */
        Contact.prototype.getTangentSpeed = function () {
            return this.m_tangentSpeed;
        };
        /**
         * Called by Update method, and implemented by subclasses.
         */
        Contact.prototype.evaluate = function (manifold, xfA, xfB) {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            this.m_evaluateFcn(manifold, xfA, fixtureA, this.m_indexA, xfB, fixtureB, this.m_indexB);
        };
        /**
         * Updates the contact manifold and touching status.
         *
         * Note: do not assume the fixture AABBs are overlapping or are valid.
         *
         * @param listener.beginContact
         * @param listener.endContact
         * @param listener.preSolve
         */
        Contact.prototype.update = function (listener) {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            if (bodyA === null || bodyB === null)
                return;
            var shapeA = fixtureA.m_shape;
            var shapeB = fixtureB.m_shape;
            if (shapeA === null || shapeB === null)
                return;
            // Re-enable this contact.
            this.m_enabledFlag = true;
            var touching = false;
            var wasTouching = this.m_touchingFlag;
            var sensorA = fixtureA.m_isSensor;
            var sensorB = fixtureB.m_isSensor;
            var sensor = sensorA || sensorB;
            var xfA = bodyA.m_xf;
            var xfB = bodyB.m_xf;
            // Is this contact a sensor?
            if (sensor) {
                touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
                // Sensors don't generate manifolds.
                this.m_manifold.pointCount = 0;
            }
            else {
                oldManifold.recycle();
                oldManifold.set(this.m_manifold);
                this.m_manifold.recycle();
                this.evaluate(this.m_manifold, xfA, xfB);
                touching = this.m_manifold.pointCount > 0;
                // Match old contact ids to new contact ids and copy the
                // stored impulses to warm start the solver.
                for (var i = 0; i < this.m_manifold.pointCount; ++i) {
                    var nmp = this.m_manifold.points[i];
                    nmp.normalImpulse = 0.0;
                    nmp.tangentImpulse = 0.0;
                    for (var j = 0; j < oldManifold.pointCount; ++j) {
                        var omp = oldManifold.points[j];
                        if (omp.id.key === nmp.id.key) {
                            nmp.normalImpulse = omp.normalImpulse;
                            nmp.tangentImpulse = omp.tangentImpulse;
                            break;
                        }
                    }
                }
                if (touching !== wasTouching) {
                    bodyA.setAwake(true);
                    bodyB.setAwake(true);
                }
            }
            this.m_touchingFlag = touching;
            var hasListener = typeof listener === 'object' && listener !== null;
            if (!wasTouching && touching && hasListener) {
                listener.beginContact(this);
            }
            if (wasTouching && !touching && hasListener) {
                listener.endContact(this);
            }
            if (!sensor && touching && hasListener && oldManifold) {
                listener.preSolve(this, oldManifold);
            }
        };
        Contact.prototype.solvePositionConstraint = function (step) {
            return this._solvePositionConstraint(step, null, null);
        };
        Contact.prototype.solvePositionConstraintTOI = function (step, toiA, toiB) {
            return this._solvePositionConstraint(step, toiA, toiB);
        };
        Contact.prototype._solvePositionConstraint = function (step, toiA, toiB) {
            var toi = toiA !== null && toiB !== null ? true : false;
            var minSeparation = 0.0;
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return minSeparation;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            if (bodyA === null || bodyB === null)
                return minSeparation;
            bodyA.c_velocity;
            bodyB.c_velocity;
            var positionA = bodyA.c_position;
            var positionB = bodyB.c_position;
            var localCenterA = this.p_localCenterA;
            var localCenterB = this.p_localCenterB;
            var mA = 0.0;
            var iA = 0.0;
            if (!toi || (bodyA === toiA || bodyA === toiB)) {
                mA = this.p_invMassA;
                iA = this.p_invIA;
            }
            var mB = 0.0;
            var iB = 0.0;
            if (!toi || (bodyB === toiA || bodyB === toiB)) {
                mB = this.p_invMassB;
                iB = this.p_invIB;
            }
            copyVec2(cA, positionA.c);
            var aA = positionA.a;
            copyVec2(cB, positionB.c);
            var aB = positionB.a;
            // Solve normal constraints
            for (var j = 0; j < this.p_pointCount; ++j) {
                getTransform(xfA, localCenterA, cA, aA);
                getTransform(xfB, localCenterB, cB, aB);
                // PositionSolverManifold
                var separation = void 0;
                switch (this.p_type) {
                    case exports.ManifoldType.e_circles: {
                        transformVec2(pointA, xfA, this.p_localPoint);
                        transformVec2(pointB, xfB, this.p_localPoints[0]);
                        diffVec2(normal$2, pointB, pointA);
                        normalizeVec2(normal$2);
                        combineVec2(point, 0.5, pointA, 0.5, pointB);
                        separation = dotVec2(pointB, normal$2) - dotVec2(pointA, normal$2) - this.p_radiusA - this.p_radiusB;
                        break;
                    }
                    case exports.ManifoldType.e_faceA: {
                        rotVec2(normal$2, xfA.q, this.p_localNormal);
                        transformVec2(planePoint$1, xfA, this.p_localPoint);
                        transformVec2(clipPoint, xfB, this.p_localPoints[j]);
                        separation = dotVec2(clipPoint, normal$2) - dotVec2(planePoint$1, normal$2) - this.p_radiusA - this.p_radiusB;
                        copyVec2(point, clipPoint);
                        break;
                    }
                    case exports.ManifoldType.e_faceB: {
                        rotVec2(normal$2, xfB.q, this.p_localNormal);
                        transformVec2(planePoint$1, xfB, this.p_localPoint);
                        transformVec2(clipPoint, xfA, this.p_localPoints[j]);
                        separation = dotVec2(clipPoint, normal$2) - dotVec2(planePoint$1, normal$2) - this.p_radiusA - this.p_radiusB;
                        copyVec2(point, clipPoint);
                        // Ensure normal points from A to B
                        negVec2(normal$2);
                        break;
                    }
                    // todo: what should we do here?
                    default: {
                        return minSeparation;
                    }
                }
                diffVec2(rA, point, cA);
                diffVec2(rB, point, cB);
                // Track max constraint error.
                minSeparation = math_min$4(minSeparation, separation);
                var baumgarte = toi ? SettingsInternal.toiBaugarte : SettingsInternal.baumgarte;
                var linearSlop = SettingsInternal.linearSlop;
                var maxLinearCorrection = SettingsInternal.maxLinearCorrection;
                // Prevent large corrections and allow slop.
                var C = clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);
                // Compute the effective mass.
                var rnA = crossVec2Vec2(rA, normal$2);
                var rnB = crossVec2Vec2(rB, normal$2);
                var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                // Compute normal impulse
                var impulse = K > 0.0 ? -C / K : 0.0;
                setMulVec2(P$1, impulse, normal$2);
                subMulVec2(cA, mA, P$1);
                aA -= iA * crossVec2Vec2(rA, P$1);
                addMulVec2(cB, mB, P$1);
                aB += iB * crossVec2Vec2(rB, P$1);
            }
            copyVec2(positionA.c, cA);
            positionA.a = aA;
            copyVec2(positionB.c, cB);
            positionB.a = aB;
            return minSeparation;
        };
        Contact.prototype.initVelocityConstraint = function (step) {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            if (bodyA === null || bodyB === null)
                return;
            var velocityA = bodyA.c_velocity;
            var velocityB = bodyB.c_velocity;
            var positionA = bodyA.c_position;
            var positionB = bodyB.c_position;
            var radiusA = this.p_radiusA;
            var radiusB = this.p_radiusB;
            var manifold = this.m_manifold;
            var mA = this.v_invMassA;
            var mB = this.v_invMassB;
            var iA = this.v_invIA;
            var iB = this.v_invIB;
            var localCenterA = this.p_localCenterA;
            var localCenterB = this.p_localCenterB;
            copyVec2(cA, positionA.c);
            var aA = positionA.a;
            copyVec2(vA, velocityA.v);
            var wA = velocityA.w;
            copyVec2(cB, positionB.c);
            var aB = positionB.a;
            copyVec2(vB, velocityB.v);
            var wB = velocityB.w;
            getTransform(xfA, localCenterA, cA, aA);
            getTransform(xfB, localCenterB, cB, aB);
            worldManifold.recycle();
            manifold.getWorldManifold(worldManifold, xfA, radiusA, xfB, radiusB);
            copyVec2(this.v_normal, worldManifold.normal);
            for (var j = 0; j < this.v_pointCount; ++j) {
                var vcp = this.v_points[j]; // VelocityConstraintPoint
                var wmp = worldManifold.points[j];
                diffVec2(vcp.rA, wmp, cA);
                diffVec2(vcp.rB, wmp, cB);
                var rnA = crossVec2Vec2(vcp.rA, this.v_normal);
                var rnB = crossVec2Vec2(vcp.rB, this.v_normal);
                var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;
                crossVec2Num(tangent$1, this.v_normal, 1.0);
                var rtA = crossVec2Vec2(vcp.rA, tangent$1);
                var rtB = crossVec2Vec2(vcp.rB, tangent$1);
                var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
                vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;
                // Setup a velocity bias for restitution.
                vcp.velocityBias = 0.0;
                var vRel = 0;
                vRel += dotVec2(this.v_normal, vB);
                vRel += dotVec2(this.v_normal, crossNumVec2(temp$2, wB, vcp.rB));
                vRel -= dotVec2(this.v_normal, vA);
                vRel -= dotVec2(this.v_normal, crossNumVec2(temp$2, wA, vcp.rA));
                if (vRel < -SettingsInternal.velocityThreshold) {
                    vcp.velocityBias = -this.v_restitution * vRel;
                }
            }
            // If we have two points, then prepare the block solver.
            if (this.v_pointCount == 2 && step.blockSolve) {
                var vcp1 = this.v_points[0]; // VelocityConstraintPoint
                var vcp2 = this.v_points[1]; // VelocityConstraintPoint
                var rn1A = crossVec2Vec2(vcp1.rA, this.v_normal);
                var rn1B = crossVec2Vec2(vcp1.rB, this.v_normal);
                var rn2A = crossVec2Vec2(vcp2.rA, this.v_normal);
                var rn2B = crossVec2Vec2(vcp2.rB, this.v_normal);
                var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
                var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
                var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
                // Ensure a reasonable condition number.
                var k_maxConditionNumber = 1000.0;
                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                    // K is safe to invert.
                    this.v_K.ex.setNum(k11, k12);
                    this.v_K.ey.setNum(k12, k22);
                    // this.v_normalMass.set(this.v_K.getInverse());
                    var a_1 = this.v_K.ex.x;
                    var b_1 = this.v_K.ey.x;
                    var c = this.v_K.ex.y;
                    var d_1 = this.v_K.ey.y;
                    var det = a_1 * d_1 - b_1 * c;
                    if (det !== 0.0) {
                        det = 1.0 / det;
                    }
                    this.v_normalMass.ex.x = det * d_1;
                    this.v_normalMass.ey.x = -det * b_1;
                    this.v_normalMass.ex.y = -det * c;
                    this.v_normalMass.ey.y = det * a_1;
                }
                else {
                    // The constraints are redundant, just use one.
                    // TODO_ERIN use deepest?
                    this.v_pointCount = 1;
                }
            }
            copyVec2(positionA.c, cA);
            positionA.a = aA;
            copyVec2(velocityA.v, vA);
            velocityA.w = wA;
            copyVec2(positionB.c, cB);
            positionB.a = aB;
            copyVec2(velocityB.v, vB);
            velocityB.w = wB;
        };
        Contact.prototype.warmStartConstraint = function (step) {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            if (bodyA === null || bodyB === null)
                return;
            var velocityA = bodyA.c_velocity;
            var velocityB = bodyB.c_velocity;
            bodyA.c_position;
            bodyB.c_position;
            var mA = this.v_invMassA;
            var iA = this.v_invIA;
            var mB = this.v_invMassB;
            var iB = this.v_invIB;
            copyVec2(vA, velocityA.v);
            var wA = velocityA.w;
            copyVec2(vB, velocityB.v);
            var wB = velocityB.w;
            copyVec2(normal$2, this.v_normal);
            crossVec2Num(tangent$1, normal$2, 1.0);
            for (var j = 0; j < this.v_pointCount; ++j) {
                var vcp = this.v_points[j]; // VelocityConstraintPoint
                combineVec2(P$1, vcp.normalImpulse, normal$2, vcp.tangentImpulse, tangent$1);
                wA -= iA * crossVec2Vec2(vcp.rA, P$1);
                subMulVec2(vA, mA, P$1);
                wB += iB * crossVec2Vec2(vcp.rB, P$1);
                addMulVec2(vB, mB, P$1);
            }
            copyVec2(velocityA.v, vA);
            velocityA.w = wA;
            copyVec2(velocityB.v, vB);
            velocityB.w = wB;
        };
        Contact.prototype.storeConstraintImpulses = function (step) {
            var manifold = this.m_manifold;
            for (var j = 0; j < this.v_pointCount; ++j) {
                manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;
                manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;
            }
        };
        Contact.prototype.solveVelocityConstraint = function (step) {
            var fixtureA = this.m_fixtureA;
            var fixtureB = this.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            if (bodyA === null || bodyB === null)
                return;
            var velocityA = bodyA.c_velocity;
            bodyA.c_position;
            var velocityB = bodyB.c_velocity;
            bodyB.c_position;
            var mA = this.v_invMassA;
            var iA = this.v_invIA;
            var mB = this.v_invMassB;
            var iB = this.v_invIB;
            copyVec2(vA, velocityA.v);
            var wA = velocityA.w;
            copyVec2(vB, velocityB.v);
            var wB = velocityB.w;
            copyVec2(normal$2, this.v_normal);
            crossVec2Num(tangent$1, normal$2, 1.0);
            var friction = this.v_friction;
            // Solve tangent constraints first because non-penetration is more important
            // than friction.
            for (var j = 0; j < this.v_pointCount; ++j) {
                var vcp = this.v_points[j]; // VelocityConstraintPoint
                // Relative velocity at contact
                zeroVec2(dv);
                addVec2(dv, vB);
                addVec2(dv, crossNumVec2(temp$2, wB, vcp.rB));
                subVec2(dv, vA);
                subVec2(dv, crossNumVec2(temp$2, wA, vcp.rA));
                // Compute tangent force
                var vt = dotVec2(dv, tangent$1) - this.v_tangentSpeed;
                var lambda = vcp.tangentMass * (-vt);
                // Clamp the accumulated force
                var maxFriction = friction * vcp.normalImpulse;
                var newImpulse = clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
                lambda = newImpulse - vcp.tangentImpulse;
                vcp.tangentImpulse = newImpulse;
                // Apply contact impulse
                setMulVec2(P$1, lambda, tangent$1);
                subMulVec2(vA, mA, P$1);
                wA -= iA * crossVec2Vec2(vcp.rA, P$1);
                addMulVec2(vB, mB, P$1);
                wB += iB * crossVec2Vec2(vcp.rB, P$1);
            }
            // Solve normal constraints
            if (this.v_pointCount == 1 || step.blockSolve == false) {
                for (var i = 0; i < this.v_pointCount; ++i) {
                    var vcp = this.v_points[i]; // VelocityConstraintPoint
                    // Relative velocity at contact
                    zeroVec2(dv);
                    addVec2(dv, vB);
                    addVec2(dv, crossNumVec2(temp$2, wB, vcp.rB));
                    subVec2(dv, vA);
                    subVec2(dv, crossNumVec2(temp$2, wA, vcp.rA));
                    // Compute normal impulse
                    var vn = dotVec2(dv, normal$2);
                    var lambda = -vcp.normalMass * (vn - vcp.velocityBias);
                    // Clamp the accumulated impulse
                    var newImpulse = math_max$2(vcp.normalImpulse + lambda, 0.0);
                    lambda = newImpulse - vcp.normalImpulse;
                    vcp.normalImpulse = newImpulse;
                    // Apply contact impulse
                    setMulVec2(P$1, lambda, normal$2);
                    subMulVec2(vA, mA, P$1);
                    wA -= iA * crossVec2Vec2(vcp.rA, P$1);
                    addMulVec2(vB, mB, P$1);
                    wB += iB * crossVec2Vec2(vcp.rB, P$1);
                }
            }
            else {
                // Block solver developed in collaboration with Dirk Gregorius (back in
                // 01/07 on Box2D_Lite).
                // Build the mini LCP for this contact patch
                //
                // vn = A * x + b, vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2
                //
                // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
                // b = vn0 - velocityBias
                //
                // The system is solved using the "Total enumeration method" (s. Murty).
                // The complementary constraint vn_i * x_i
                // implies that we must have in any solution either vn_i = 0 or x_i = 0.
                // So for the 2D contact problem the cases
                // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and
                // vn1 = 0 need to be tested. The first valid
                // solution that satisfies the problem is chosen.
                //
                // In order to account of the accumulated impulse 'a' (because of the
                // iterative nature of the solver which only requires
                // that the accumulated impulse is clamped and not the incremental
                // impulse) we change the impulse variable (x_i).
                //
                // Substitute:
                //
                // x = a + d
                //
                // a := old total impulse
                // x := new total impulse
                // d := incremental impulse
                //
                // For the current iteration we extend the formula for the incremental
                // impulse
                // to compute the new total impulse:
                //
                // vn = A * d + b
                // = A * (x - a) + b
                // = A * x + b - A * a
                // = A * x + b'
                // b' = b - A * a;
                var vcp1 = this.v_points[0]; // VelocityConstraintPoint
                var vcp2 = this.v_points[1]; // VelocityConstraintPoint
                setVec2(a, vcp1.normalImpulse, vcp2.normalImpulse);
                // Relative velocity at contact
                // let dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));
                zeroVec2(dv1);
                addVec2(dv1, vB);
                addVec2(dv1, crossNumVec2(temp$2, wB, vcp1.rB));
                subVec2(dv1, vA);
                subVec2(dv1, crossNumVec2(temp$2, wA, vcp1.rA));
                // let dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));
                zeroVec2(dv2);
                addVec2(dv2, vB);
                addVec2(dv2, crossNumVec2(temp$2, wB, vcp2.rB));
                subVec2(dv2, vA);
                subVec2(dv2, crossNumVec2(temp$2, wA, vcp2.rA));
                // Compute normal velocity
                var vn1 = dotVec2(dv1, normal$2);
                var vn2 = dotVec2(dv2, normal$2);
                setVec2(b, vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);
                // Compute b'
                // b.sub(Mat22.mulVec2(this.v_K, a));
                b.x -= this.v_K.ex.x * a.x + this.v_K.ey.x * a.y;
                b.y -= this.v_K.ex.y * a.x + this.v_K.ey.y * a.y;
                // NOT_USED(k_errorTol);
                while (true) {
                    //
                    // Case 1: vn = 0
                    //
                    // 0 = A * x + b'
                    //
                    // Solve for x:
                    //
                    // x = - inv(A) * b'
                    //
                    // const x = Mat22.mulVec2(this.v_normalMass, b).neg();
                    zeroVec2(x);
                    x.x = -(this.v_normalMass.ex.x * b.x + this.v_normalMass.ey.x * b.y);
                    x.y = -(this.v_normalMass.ex.y * b.x + this.v_normalMass.ey.y * b.y);
                    if (x.x >= 0.0 && x.y >= 0.0) {
                        // Get the incremental impulse
                        diffVec2(d, x, a);
                        // Apply incremental impulse
                        setMulVec2(P1, d.x, normal$2);
                        setMulVec2(P2, d.y, normal$2);
                        // vA.subCombine(mA, P1, mA, P2);
                        subMulVec2(vA, mA, P1);
                        subMulVec2(vA, mA, P2);
                        wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));
                        // vB.addCombine(mB, P1, mB, P2);
                        addMulVec2(vB, mB, P1);
                        addMulVec2(vB, mB, P2);
                        wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));
                        // Accumulate
                        vcp1.normalImpulse = x.x;
                        vcp2.normalImpulse = x.y;
                        break;
                    }
                    //
                    // Case 2: vn1 = 0 and x2 = 0
                    //
                    // 0 = a11 * x1 + a12 * 0 + b1'
                    // vn2 = a21 * x1 + a22 * 0 + b2'
                    //
                    x.x = -vcp1.normalMass * b.x;
                    x.y = 0.0;
                    vn1 = 0.0;
                    vn2 = this.v_K.ex.y * x.x + b.y;
                    if (x.x >= 0.0 && vn2 >= 0.0) {
                        // Get the incremental impulse
                        diffVec2(d, x, a);
                        // Apply incremental impulse
                        setMulVec2(P1, d.x, normal$2);
                        setMulVec2(P2, d.y, normal$2);
                        // vA.subCombine(mA, P1, mA, P2);
                        subMulVec2(vA, mA, P1);
                        subMulVec2(vA, mA, P2);
                        wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));
                        // vB.addCombine(mB, P1, mB, P2);
                        addMulVec2(vB, mB, P1);
                        addMulVec2(vB, mB, P2);
                        wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));
                        // Accumulate
                        vcp1.normalImpulse = x.x;
                        vcp2.normalImpulse = x.y;
                        break;
                    }
                    //
                    // Case 3: vn2 = 0 and x1 = 0
                    //
                    // vn1 = a11 * 0 + a12 * x2 + b1'
                    // 0 = a21 * 0 + a22 * x2 + b2'
                    //
                    x.x = 0.0;
                    x.y = -vcp2.normalMass * b.y;
                    vn1 = this.v_K.ey.x * x.y + b.x;
                    vn2 = 0.0;
                    if (x.y >= 0.0 && vn1 >= 0.0) {
                        // Resubstitute for the incremental impulse
                        diffVec2(d, x, a);
                        // Apply incremental impulse
                        setMulVec2(P1, d.x, normal$2);
                        setMulVec2(P2, d.y, normal$2);
                        // vA.subCombine(mA, P1, mA, P2);
                        subMulVec2(vA, mA, P1);
                        subMulVec2(vA, mA, P2);
                        wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));
                        // vB.addCombine(mB, P1, mB, P2);
                        addMulVec2(vB, mB, P1);
                        addMulVec2(vB, mB, P2);
                        wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));
                        // Accumulate
                        vcp1.normalImpulse = x.x;
                        vcp2.normalImpulse = x.y;
                        break;
                    }
                    //
                    // Case 4: x1 = 0 and x2 = 0
                    //
                    // vn1 = b1
                    // vn2 = b2;
                    //
                    x.x = 0.0;
                    x.y = 0.0;
                    vn1 = b.x;
                    vn2 = b.y;
                    if (vn1 >= 0.0 && vn2 >= 0.0) {
                        // Resubstitute for the incremental impulse
                        diffVec2(d, x, a);
                        // Apply incremental impulse
                        setMulVec2(P1, d.x, normal$2);
                        setMulVec2(P2, d.y, normal$2);
                        // vA.subCombine(mA, P1, mA, P2);
                        subMulVec2(vA, mA, P1);
                        subMulVec2(vA, mA, P2);
                        wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));
                        // vB.addCombine(mB, P1, mB, P2);
                        addMulVec2(vB, mB, P1);
                        addMulVec2(vB, mB, P2);
                        wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));
                        // Accumulate
                        vcp1.normalImpulse = x.x;
                        vcp2.normalImpulse = x.y;
                        break;
                    }
                    // No solution, give up. This is hit sometimes, but it doesn't seem to
                    // matter.
                    break;
                }
            }
            copyVec2(velocityA.v, vA);
            velocityA.w = wA;
            copyVec2(velocityB.v, vB);
            velocityB.w = wB;
        };
        /** @internal */
        Contact.addType = function (type1, type2, callback) {
            s_registers[type1] = s_registers[type1] || {};
            s_registers[type1][type2] = callback;
        };
        /** @internal */
        Contact.create = function (fixtureA, indexA, fixtureB, indexB) {
            var typeA = fixtureA.m_shape.m_type;
            var typeB = fixtureB.m_shape.m_type;
            var contact = contactPool.allocate();
            var evaluateFcn;
            if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {
                contact.initialize(fixtureA, indexA, fixtureB, indexB, evaluateFcn);
            }
            else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {
                contact.initialize(fixtureB, indexB, fixtureA, indexA, evaluateFcn);
            }
            else {
                return null;
            }
            // Contact creation may swap fixtures.
            fixtureA = contact.m_fixtureA;
            fixtureB = contact.m_fixtureB;
            indexA = contact.getChildIndexA();
            indexB = contact.getChildIndexB();
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            // Connect to body A
            contact.m_nodeA.contact = contact;
            contact.m_nodeA.other = bodyB;
            contact.m_nodeA.prev = null;
            contact.m_nodeA.next = bodyA.m_contactList;
            if (bodyA.m_contactList != null) {
                bodyA.m_contactList.prev = contact.m_nodeA;
            }
            bodyA.m_contactList = contact.m_nodeA;
            // Connect to body B
            contact.m_nodeB.contact = contact;
            contact.m_nodeB.other = bodyA;
            contact.m_nodeB.prev = null;
            contact.m_nodeB.next = bodyB.m_contactList;
            if (bodyB.m_contactList != null) {
                bodyB.m_contactList.prev = contact.m_nodeB;
            }
            bodyB.m_contactList = contact.m_nodeB;
            // Wake up the bodies
            if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {
                bodyA.setAwake(true);
                bodyB.setAwake(true);
            }
            return contact;
        };
        /** @internal */
        Contact.destroy = function (contact, listener) {
            var fixtureA = contact.m_fixtureA;
            var fixtureB = contact.m_fixtureB;
            if (fixtureA === null || fixtureB === null)
                return;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            if (bodyA === null || bodyB === null)
                return;
            if (contact.isTouching()) {
                listener.endContact(contact);
            }
            // Remove from body 1
            if (contact.m_nodeA.prev) {
                contact.m_nodeA.prev.next = contact.m_nodeA.next;
            }
            if (contact.m_nodeA.next) {
                contact.m_nodeA.next.prev = contact.m_nodeA.prev;
            }
            if (contact.m_nodeA == bodyA.m_contactList) {
                bodyA.m_contactList = contact.m_nodeA.next;
            }
            // Remove from body 2
            if (contact.m_nodeB.prev) {
                contact.m_nodeB.prev.next = contact.m_nodeB.next;
            }
            if (contact.m_nodeB.next) {
                contact.m_nodeB.next.prev = contact.m_nodeB.prev;
            }
            if (contact.m_nodeB == bodyB.m_contactList) {
                bodyB.m_contactList = contact.m_nodeB.next;
            }
            if (contact.m_manifold.pointCount > 0 && !fixtureA.m_isSensor && !fixtureB.m_isSensor) {
                bodyA.setAwake(true);
                bodyB.setAwake(true);
            }
            // const typeA = fixtureA.getType();
            // const typeB = fixtureB.getType();
            // const destroyFcn = s_registers[typeA][typeB].destroyFcn;
            // if (typeof destroyFcn === 'function') {
            //   destroyFcn(contact);
            // }
            contactPool.release(contact);
        };
        return Contact;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var WorldDefDefault = {
        gravity: Vec2.zero(),
        allowSleep: true,
        warmStarting: true,
        continuousPhysics: true,
        subStepping: false,
        blockSolve: true,
        velocityIterations: 8,
        positionIterations: 3
    };
    var World = /** @class */ (function () {
        /**
         * @param def World definition or gravity vector.
         */
        function World(def) {
            if (!(this instanceof World)) {
                return new World(def);
            }
            this.s_step = new TimeStep();
            if (def && Vec2.isValid(def)) {
                def = { gravity: def };
            }
            def = options(def, WorldDefDefault);
            this.m_solver = new Solver(this);
            this.m_broadPhase = new BroadPhase();
            this.m_contactList = null;
            this.m_contactCount = 0;
            this.m_bodyList = null;
            this.m_bodyCount = 0;
            this.m_jointList = null;
            this.m_jointCount = 0;
            this.m_stepComplete = true;
            this.m_allowSleep = def.allowSleep;
            this.m_gravity = Vec2.clone(def.gravity);
            this.m_clearForces = true;
            this.m_newFixture = false;
            this.m_locked = false;
            // These are for debugging the solver.
            this.m_warmStarting = def.warmStarting;
            this.m_continuousPhysics = def.continuousPhysics;
            this.m_subStepping = def.subStepping;
            this.m_blockSolve = def.blockSolve;
            this.m_velocityIterations = def.velocityIterations;
            this.m_positionIterations = def.positionIterations;
            this.m_t = 0;
        }
        /** @internal */
        World.prototype._serialize = function () {
            var bodies = [];
            var joints = [];
            for (var b = this.getBodyList(); b; b = b.getNext()) {
                bodies.push(b);
            }
            for (var j = this.getJointList(); j; j = j.getNext()) {
                // @ts-ignore
                if (typeof j._serialize === 'function') {
                    joints.push(j);
                }
            }
            return {
                gravity: this.m_gravity,
                bodies: bodies,
                joints: joints,
            };
        };
        /** @internal */
        World._deserialize = function (data, context, restore) {
            if (!data) {
                return new World();
            }
            var world = new World(data.gravity);
            if (data.bodies) {
                for (var i = data.bodies.length - 1; i >= 0; i -= 1) {
                    world._addBody(restore(Body, data.bodies[i], world));
                }
            }
            if (data.joints) {
                for (var i = data.joints.length - 1; i >= 0; i--) {
                    world.createJoint(restore(Joint, data.joints[i], world));
                }
            }
            return world;
        };
        /**
         * Get the world body list. With the returned body, use Body.getNext to get the
         * next body in the world list. A null body indicates the end of the list.
         *
         * @return the head of the world body list.
         */
        World.prototype.getBodyList = function () {
            return this.m_bodyList;
        };
        /**
         * Get the world joint list. With the returned joint, use Joint.getNext to get
         * the next joint in the world list. A null joint indicates the end of the list.
         *
         * @return the head of the world joint list.
         */
        World.prototype.getJointList = function () {
            return this.m_jointList;
        };
        /**
         * Get the world contact list. With the returned contact, use Contact.getNext to
         * get the next contact in the world list. A null contact indicates the end of
         * the list.
         *
         * Warning: contacts are created and destroyed in the middle of a time step.
         * Use ContactListener to avoid missing contacts.
         *
         * @return the head of the world contact list.
         */
        World.prototype.getContactList = function () {
            return this.m_contactList;
        };
        World.prototype.getBodyCount = function () {
            return this.m_bodyCount;
        };
        World.prototype.getJointCount = function () {
            return this.m_jointCount;
        };
        /**
         * Get the number of contacts (each may have 0 or more contact points).
         */
        World.prototype.getContactCount = function () {
            return this.m_contactCount;
        };
        /**
         * Change the global gravity vector.
         */
        World.prototype.setGravity = function (gravity) {
            this.m_gravity = gravity;
        };
        /**
         * Get the global gravity vector.
         */
        World.prototype.getGravity = function () {
            return this.m_gravity;
        };
        /**
         * Is the world locked (in the middle of a time step).
         */
        World.prototype.isLocked = function () {
            return this.m_locked;
        };
        /**
         * Enable/disable sleep.
         */
        World.prototype.setAllowSleeping = function (flag) {
            if (flag == this.m_allowSleep) {
                return;
            }
            this.m_allowSleep = flag;
            if (this.m_allowSleep == false) {
                for (var b = this.m_bodyList; b; b = b.m_next) {
                    b.setAwake(true);
                }
            }
        };
        World.prototype.getAllowSleeping = function () {
            return this.m_allowSleep;
        };
        /**
         * Enable/disable warm starting. For testing.
         */
        World.prototype.setWarmStarting = function (flag) {
            this.m_warmStarting = flag;
        };
        World.prototype.getWarmStarting = function () {
            return this.m_warmStarting;
        };
        /**
         * Enable/disable continuous physics. For testing.
         */
        World.prototype.setContinuousPhysics = function (flag) {
            this.m_continuousPhysics = flag;
        };
        World.prototype.getContinuousPhysics = function () {
            return this.m_continuousPhysics;
        };
        /**
         * Enable/disable single stepped continuous physics. For testing.
         */
        World.prototype.setSubStepping = function (flag) {
            this.m_subStepping = flag;
        };
        World.prototype.getSubStepping = function () {
            return this.m_subStepping;
        };
        /**
         * Set flag to control automatic clearing of forces after each time step.
         */
        World.prototype.setAutoClearForces = function (flag) {
            this.m_clearForces = flag;
        };
        /**
         * Get the flag that controls automatic clearing of forces after each time step.
         */
        World.prototype.getAutoClearForces = function () {
            return this.m_clearForces;
        };
        /**
         * Manually clear the force buffer on all bodies. By default, forces are cleared
         * automatically after each call to step. The default behavior is modified by
         * calling setAutoClearForces. The purpose of this function is to support
         * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step
         * under a variable frame-rate. When you perform sub-stepping you will disable
         * auto clearing of forces and instead call clearForces after all sub-steps are
         * complete in one pass of your game loop.
         *
         * See {@link World.setAutoClearForces}
         */
        World.prototype.clearForces = function () {
            for (var body = this.m_bodyList; body; body = body.getNext()) {
                body.m_force.setZero();
                body.m_torque = 0.0;
            }
        };
        /**
         * Query the world for all fixtures that potentially overlap the provided AABB.
         *
         * @param aabb The query box.
         * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.
         */
        World.prototype.queryAABB = function (aabb, callback) {
            var broadPhase = this.m_broadPhase;
            this.m_broadPhase.query(aabb, function (proxyId) {
                var proxy = broadPhase.getUserData(proxyId);
                return callback(proxy.fixture);
            });
        };
        /**
         * Ray-cast the world for all fixtures in the path of the ray. Your callback
         * controls whether you get the closest point, any point, or n-points. The
         * ray-cast ignores shapes that contain the starting point.
         *
         * @param point1 The ray starting point
         * @param point2 The ray ending point
         * @param callback A user implemented callback function.
         */
        World.prototype.rayCast = function (point1, point2, callback) {
            var broadPhase = this.m_broadPhase;
            this.m_broadPhase.rayCast({
                maxFraction: 1.0,
                p1: point1,
                p2: point2
            }, function (input, proxyId) {
                var proxy = broadPhase.getUserData(proxyId);
                var fixture = proxy.fixture;
                var index = proxy.childIndex;
                // @ts-ignore
                var output = {}; // TODO GC
                var hit = fixture.rayCast(output, input, index);
                if (hit) {
                    var fraction = output.fraction;
                    var point = Vec2.add(Vec2.mulNumVec2((1.0 - fraction), input.p1), Vec2.mulNumVec2(fraction, input.p2));
                    return callback(fixture, point, output.normal, fraction);
                }
                return input.maxFraction;
            });
        };
        /**
         * Get the number of broad-phase proxies.
         */
        World.prototype.getProxyCount = function () {
            return this.m_broadPhase.getProxyCount();
        };
        /**
         * Get the height of broad-phase dynamic tree.
         */
        World.prototype.getTreeHeight = function () {
            return this.m_broadPhase.getTreeHeight();
        };
        /**
         * Get the balance of broad-phase dynamic tree.
         */
        World.prototype.getTreeBalance = function () {
            return this.m_broadPhase.getTreeBalance();
        };
        /**
         * Get the quality metric of broad-phase dynamic tree. The smaller the better.
         * The minimum is 1.
         */
        World.prototype.getTreeQuality = function () {
            return this.m_broadPhase.getTreeQuality();
        };
        /**
         * Shift the world origin. Useful for large worlds. The body shift formula is:
         * position -= newOrigin
         *
         * @param newOrigin The new origin with respect to the old origin
         */
        World.prototype.shiftOrigin = function (newOrigin) {
            if (this.m_locked) {
                return;
            }
            for (var b = this.m_bodyList; b; b = b.m_next) {
                b.m_xf.p.sub(newOrigin);
                b.m_sweep.c0.sub(newOrigin);
                b.m_sweep.c.sub(newOrigin);
            }
            for (var j = this.m_jointList; j; j = j.m_next) {
                j.shiftOrigin(newOrigin);
            }
            this.m_broadPhase.shiftOrigin(newOrigin);
        };
        /** @internal Used for deserialize. */
        World.prototype._addBody = function (body) {
            if (this.isLocked()) {
                return;
            }
            // Add to world doubly linked list.
            body.m_prev = null;
            body.m_next = this.m_bodyList;
            if (this.m_bodyList) {
                this.m_bodyList.m_prev = body;
            }
            this.m_bodyList = body;
            ++this.m_bodyCount;
        };
        // tslint:disable-next-line:typedef
        /** @internal */ World.prototype.createBody = function (arg1, arg2) {
            if (this.isLocked()) {
                return null;
            }
            var def = {};
            if (!arg1) ;
            else if (Vec2.isValid(arg1)) {
                def = { position: arg1, angle: arg2 };
            }
            else if (typeof arg1 === 'object') {
                def = arg1;
            }
            var body = new Body(this, def);
            this._addBody(body);
            return body;
        };
        // tslint:disable-next-line:typedef
        /** @internal */ World.prototype.createDynamicBody = function (arg1, arg2) {
            var def = {};
            if (!arg1) ;
            else if (Vec2.isValid(arg1)) {
                def = { position: arg1, angle: arg2 };
            }
            else if (typeof arg1 === 'object') {
                def = arg1;
            }
            def.type = 'dynamic';
            return this.createBody(def);
        };
        // tslint:disable-next-line:typedef
        World.prototype.createKinematicBody = function (arg1, arg2) {
            var def = {};
            if (!arg1) ;
            else if (Vec2.isValid(arg1)) {
                def = { position: arg1, angle: arg2 };
            }
            else if (typeof arg1 === 'object') {
                def = arg1;
            }
            def.type = 'kinematic';
            return this.createBody(def);
        };
        /**
         * Destroy a rigid body given a definition. No reference to the definition is
         * retained.
         *
         * Warning: This automatically deletes all associated shapes and joints.
         *
         * Warning: This function is locked during callbacks.
         */
        World.prototype.destroyBody = function (b) {
            if (this.isLocked()) {
                return;
            }
            if (b.m_destroyed) {
                return false;
            }
            // Delete the attached joints.
            var je = b.m_jointList;
            while (je) {
                var je0 = je;
                je = je.next;
                this.publish('remove-joint', je0.joint);
                this.destroyJoint(je0.joint);
                b.m_jointList = je;
            }
            b.m_jointList = null;
            // Delete the attached contacts.
            var ce = b.m_contactList;
            while (ce) {
                var ce0 = ce;
                ce = ce.next;
                this.destroyContact(ce0.contact);
                b.m_contactList = ce;
            }
            b.m_contactList = null;
            // Delete the attached fixtures. This destroys broad-phase proxies.
            var f = b.m_fixtureList;
            while (f) {
                var f0 = f;
                f = f.m_next;
                this.publish('remove-fixture', f0);
                f0.destroyProxies(this.m_broadPhase);
                b.m_fixtureList = f;
            }
            b.m_fixtureList = null;
            // Remove world body list.
            if (b.m_prev) {
                b.m_prev.m_next = b.m_next;
            }
            if (b.m_next) {
                b.m_next.m_prev = b.m_prev;
            }
            if (b == this.m_bodyList) {
                this.m_bodyList = b.m_next;
            }
            b.m_destroyed = true;
            --this.m_bodyCount;
            this.publish('remove-body', b);
            return true;
        };
        /**
         * Create a joint to constrain bodies together. No reference to the definition
         * is retained. This may cause the connected bodies to cease colliding.
         *
         * Warning: This function is locked during callbacks.
         */
        World.prototype.createJoint = function (joint) {
            if (this.isLocked()) {
                return null;
            }
            // Connect to the world list.
            joint.m_prev = null;
            joint.m_next = this.m_jointList;
            if (this.m_jointList) {
                this.m_jointList.m_prev = joint;
            }
            this.m_jointList = joint;
            ++this.m_jointCount;
            // Connect to the bodies' doubly linked lists.
            joint.m_edgeA.joint = joint;
            joint.m_edgeA.other = joint.m_bodyB;
            joint.m_edgeA.prev = null;
            joint.m_edgeA.next = joint.m_bodyA.m_jointList;
            if (joint.m_bodyA.m_jointList)
                joint.m_bodyA.m_jointList.prev = joint.m_edgeA;
            joint.m_bodyA.m_jointList = joint.m_edgeA;
            joint.m_edgeB.joint = joint;
            joint.m_edgeB.other = joint.m_bodyA;
            joint.m_edgeB.prev = null;
            joint.m_edgeB.next = joint.m_bodyB.m_jointList;
            if (joint.m_bodyB.m_jointList)
                joint.m_bodyB.m_jointList.prev = joint.m_edgeB;
            joint.m_bodyB.m_jointList = joint.m_edgeB;
            // If the joint prevents collisions, then flag any contacts for filtering.
            if (joint.m_collideConnected == false) {
                for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {
                    if (edge.other == joint.m_bodyA) {
                        // Flag the contact for filtering at the next time step (where either
                        // body is awake).
                        edge.contact.flagForFiltering();
                    }
                }
            }
            // Note: creating a joint doesn't wake the bodies.
            return joint;
        };
        /**
         * Destroy a joint. This may cause the connected bodies to begin colliding.
         * Warning: This function is locked during callbacks.
         */
        World.prototype.destroyJoint = function (joint) {
            if (this.isLocked()) {
                return;
            }
            // Remove from the doubly linked list.
            if (joint.m_prev) {
                joint.m_prev.m_next = joint.m_next;
            }
            if (joint.m_next) {
                joint.m_next.m_prev = joint.m_prev;
            }
            if (joint == this.m_jointList) {
                this.m_jointList = joint.m_next;
            }
            // Disconnect from bodies.
            var bodyA = joint.m_bodyA;
            var bodyB = joint.m_bodyB;
            // Wake up connected bodies.
            bodyA.setAwake(true);
            bodyB.setAwake(true);
            // Remove from body 1.
            if (joint.m_edgeA.prev) {
                joint.m_edgeA.prev.next = joint.m_edgeA.next;
            }
            if (joint.m_edgeA.next) {
                joint.m_edgeA.next.prev = joint.m_edgeA.prev;
            }
            if (joint.m_edgeA == bodyA.m_jointList) {
                bodyA.m_jointList = joint.m_edgeA.next;
            }
            joint.m_edgeA.prev = null;
            joint.m_edgeA.next = null;
            // Remove from body 2
            if (joint.m_edgeB.prev) {
                joint.m_edgeB.prev.next = joint.m_edgeB.next;
            }
            if (joint.m_edgeB.next) {
                joint.m_edgeB.next.prev = joint.m_edgeB.prev;
            }
            if (joint.m_edgeB == bodyB.m_jointList) {
                bodyB.m_jointList = joint.m_edgeB.next;
            }
            joint.m_edgeB.prev = null;
            joint.m_edgeB.next = null;
            --this.m_jointCount;
            // If the joint prevents collisions, then flag any contacts for filtering.
            if (joint.m_collideConnected == false) {
                var edge = bodyB.getContactList();
                while (edge) {
                    if (edge.other == bodyA) {
                        // Flag the contact for filtering at the next time step (where either
                        // body is awake).
                        edge.contact.flagForFiltering();
                    }
                    edge = edge.next;
                }
            }
            this.publish('remove-joint', joint);
        };
        /**
         * Take a time step. This performs collision detection, integration, and
         * constraint solution.
         *
         * Broad-phase, narrow-phase, solve and solve time of impacts.
         *
         * @param timeStep Time step, this should not vary.
         */
        World.prototype.step = function (timeStep, velocityIterations, positionIterations) {
            this.publish('pre-step', timeStep);
            if ((velocityIterations | 0) !== velocityIterations) {
                // TODO: remove this in future
                velocityIterations = 0;
            }
            velocityIterations = velocityIterations || this.m_velocityIterations;
            positionIterations = positionIterations || this.m_positionIterations;
            // If new fixtures were added, we need to find the new contacts.
            if (this.m_newFixture) {
                this.findNewContacts();
                this.m_newFixture = false;
            }
            this.m_locked = true;
            this.s_step.reset(timeStep);
            this.s_step.velocityIterations = velocityIterations;
            this.s_step.positionIterations = positionIterations;
            this.s_step.warmStarting = this.m_warmStarting;
            this.s_step.blockSolve = this.m_blockSolve;
            // Update contacts. This is where some contacts are destroyed.
            this.updateContacts();
            // Integrate velocities, solve velocity constraints, and integrate positions.
            if (this.m_stepComplete && timeStep > 0.0) {
                this.m_solver.solveWorld(this.s_step);
                // Synchronize fixtures, check for out of range bodies.
                for (var b = this.m_bodyList; b; b = b.getNext()) {
                    // If a body was not in an island then it did not move.
                    if (b.m_islandFlag == false) {
                        continue;
                    }
                    if (b.isStatic()) {
                        continue;
                    }
                    // Update fixtures (for broad-phase).
                    b.synchronizeFixtures();
                }
                // Look for new contacts.
                this.findNewContacts();
            }
            // Handle TOI events.
            if (this.m_continuousPhysics && timeStep > 0.0) {
                this.m_solver.solveWorldTOI(this.s_step);
            }
            if (this.m_clearForces) {
                this.clearForces();
            }
            this.m_locked = false;
            this.publish('post-step', timeStep);
        };
        /**
         * @internal
         * Call this method to find new contacts.
         */
        World.prototype.findNewContacts = function () {
            var _this = this;
            this.m_broadPhase.updatePairs(function (proxyA, proxyB) { return _this.createContact(proxyA, proxyB); });
        };
        /**
         * @internal
         * Callback for broad-phase.
         */
        World.prototype.createContact = function (proxyA, proxyB) {
            var fixtureA = proxyA.fixture;
            var fixtureB = proxyB.fixture;
            var indexA = proxyA.childIndex;
            var indexB = proxyB.childIndex;
            var bodyA = fixtureA.getBody();
            var bodyB = fixtureB.getBody();
            // Are the fixtures on the same body?
            if (bodyA == bodyB) {
                return;
            }
            // TODO_ERIN use a hash table to remove a potential bottleneck when both
            // bodies have a lot of contacts.
            // Does a contact already exist?
            var edge = bodyB.getContactList(); // ContactEdge
            while (edge) {
                if (edge.other == bodyA) {
                    var fA = edge.contact.getFixtureA();
                    var fB = edge.contact.getFixtureB();
                    var iA = edge.contact.getChildIndexA();
                    var iB = edge.contact.getChildIndexB();
                    if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {
                        // A contact already exists.
                        return;
                    }
                    if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {
                        // A contact already exists.
                        return;
                    }
                }
                edge = edge.next;
            }
            if (bodyB.shouldCollide(bodyA) == false) {
                return;
            }
            if (fixtureB.shouldCollide(fixtureA) == false) {
                return;
            }
            // Call the factory.
            var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);
            if (contact == null) {
                return;
            }
            // Insert into the world.
            contact.m_prev = null;
            if (this.m_contactList != null) {
                contact.m_next = this.m_contactList;
                this.m_contactList.m_prev = contact;
            }
            this.m_contactList = contact;
            ++this.m_contactCount;
        };
        /**
         * @internal
         * Removes old non-overlapping contacts, applies filters and updates contacts.
         */
        World.prototype.updateContacts = function () {
            // Update awake contacts.
            var c;
            var next_c = this.m_contactList;
            while (c = next_c) {
                next_c = c.getNext();
                var fixtureA = c.getFixtureA();
                var fixtureB = c.getFixtureB();
                var indexA = c.getChildIndexA();
                var indexB = c.getChildIndexB();
                var bodyA = fixtureA.getBody();
                var bodyB = fixtureB.getBody();
                // Is this contact flagged for filtering?
                if (c.m_filterFlag) {
                    if (bodyB.shouldCollide(bodyA) == false) {
                        this.destroyContact(c);
                        continue;
                    }
                    if (fixtureB.shouldCollide(fixtureA) == false) {
                        this.destroyContact(c);
                        continue;
                    }
                    // Clear the filtering flag.
                    c.m_filterFlag = false;
                }
                var activeA = bodyA.isAwake() && !bodyA.isStatic();
                var activeB = bodyB.isAwake() && !bodyB.isStatic();
                // At least one body must be awake and it must be dynamic or kinematic.
                if (activeA == false && activeB == false) {
                    continue;
                }
                var proxyIdA = fixtureA.m_proxies[indexA].proxyId;
                var proxyIdB = fixtureB.m_proxies[indexB].proxyId;
                var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);
                // Here we destroy contacts that cease to overlap in the broad-phase.
                if (overlap == false) {
                    this.destroyContact(c);
                    continue;
                }
                // The contact persists.
                c.update(this);
            }
        };
        /** @internal */
        World.prototype.destroyContact = function (contact) {
            // Remove from the world.
            if (contact.m_prev) {
                contact.m_prev.m_next = contact.m_next;
            }
            if (contact.m_next) {
                contact.m_next.m_prev = contact.m_prev;
            }
            if (contact == this.m_contactList) {
                this.m_contactList = contact.m_next;
            }
            Contact.destroy(contact, this);
            --this.m_contactCount;
        };
        /**
         * Register an event listener.
         */
        // tslint:disable-next-line:typedef
        World.prototype.on = function (name, listener) {
            if (typeof name !== 'string' || typeof listener !== 'function') {
                return this;
            }
            if (!this._listeners) {
                this._listeners = {};
            }
            if (!this._listeners[name]) {
                this._listeners[name] = [];
            }
            this._listeners[name].push(listener);
            return this;
        };
        /**
         * Remove an event listener.
         */
        // tslint:disable-next-line:typedef
        World.prototype.off = function (name, listener) {
            if (typeof name !== 'string' || typeof listener !== 'function') {
                return this;
            }
            var listeners = this._listeners && this._listeners[name];
            if (!listeners || !listeners.length) {
                return this;
            }
            var index = listeners.indexOf(listener);
            if (index >= 0) {
                listeners.splice(index, 1);
            }
            return this;
        };
        World.prototype.publish = function (name, arg1, arg2, arg3) {
            var listeners = this._listeners && this._listeners[name];
            if (!listeners || !listeners.length) {
                return 0;
            }
            for (var l = 0; l < listeners.length; l++) {
                listeners[l].call(this, arg1, arg2, arg3);
            }
            return listeners.length;
        };
        /** @internal */
        World.prototype.beginContact = function (contact) {
            this.publish('begin-contact', contact);
        };
        /** @internal */
        World.prototype.endContact = function (contact) {
            this.publish('end-contact', contact);
        };
        /** @internal */
        World.prototype.preSolve = function (contact, oldManifold) {
            this.publish('pre-solve', contact, oldManifold);
        };
        /** @internal */
        World.prototype.postSolve = function (contact, impulse) {
            this.publish('post-solve', contact, impulse);
        };
        return World;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    var Vec3 = /** @class */ (function () {
        function Vec3(x, y, z) {
            if (!(this instanceof Vec3)) {
                return new Vec3(x, y, z);
            }
            if (typeof x === 'undefined') {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
            else if (typeof x === 'object') {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
            }
            else {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }
        /** @internal */
        Vec3.prototype._serialize = function () {
            return {
                x: this.x,
                y: this.y,
                z: this.z
            };
        };
        /** @internal */
        Vec3._deserialize = function (data) {
            var obj = Object.create(Vec3.prototype);
            obj.x = data.x;
            obj.y = data.y;
            obj.z = data.z;
            return obj;
        };
        /** @internal */
        Vec3.neo = function (x, y, z) {
            var obj = Object.create(Vec3.prototype);
            obj.x = x;
            obj.y = y;
            obj.z = z;
            return obj;
        };
        Vec3.zero = function () {
            var obj = Object.create(Vec3.prototype);
            obj.x = 0;
            obj.y = 0;
            obj.z = 0;
            return obj;
        };
        Vec3.clone = function (v) {
            return Vec3.neo(v.x, v.y, v.z);
        };
        /** @internal */
        Vec3.prototype.toString = function () {
            return JSON.stringify(this);
        };
        /** Does this vector contain finite coordinates? */
        Vec3.isValid = function (obj) {
            if (obj === null || typeof obj === 'undefined') {
                return false;
            }
            return Number.isFinite(obj.x) && Number.isFinite(obj.y) && Number.isFinite(obj.z);
        };
        Vec3.assert = function (o) {
        };
        Vec3.prototype.setZero = function () {
            this.x = 0.0;
            this.y = 0.0;
            this.z = 0.0;
            return this;
        };
        Vec3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Vec3.prototype.add = function (w) {
            this.x += w.x;
            this.y += w.y;
            this.z += w.z;
            return this;
        };
        Vec3.prototype.sub = function (w) {
            this.x -= w.x;
            this.y -= w.y;
            this.z -= w.z;
            return this;
        };
        Vec3.prototype.mul = function (m) {
            this.x *= m;
            this.y *= m;
            this.z *= m;
            return this;
        };
        Vec3.areEqual = function (v, w) {
            return v === w ||
                typeof v === 'object' && v !== null &&
                    typeof w === 'object' && w !== null &&
                    v.x === w.x && v.y === w.y && v.z === w.z;
        };
        /** Dot product on two vectors */
        Vec3.dot = function (v, w) {
            return v.x * w.x + v.y * w.y + v.z * w.z;
        };
        /** Cross product on two vectors */
        Vec3.cross = function (v, w) {
            return new Vec3(v.y * w.z - v.z * w.y, v.z * w.x - v.x * w.z, v.x * w.y - v.y * w.x);
        };
        Vec3.add = function (v, w) {
            return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);
        };
        Vec3.sub = function (v, w) {
            return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);
        };
        Vec3.mul = function (v, m) {
            return new Vec3(m * v.x, m * v.y, m * v.z);
        };
        Vec3.prototype.neg = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        };
        Vec3.neg = function (v) {
            return new Vec3(-v.x, -v.y, -v.z);
        };
        return Vec3;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var v1$2 = vec2(0, 0);
    /** @internal */ var v2$1 = vec2(0, 0);
    /**
     * A line segment (edge) shape. These can be connected in chains or loops to
     * other edge shapes. The connectivity information is used to ensure correct
     * contact normals.
     */
    var EdgeShape = /** @class */ (function (_super) {
        __extends(EdgeShape, _super);
        function EdgeShape(v1, v2) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof EdgeShape)) {
                return new EdgeShape(v1, v2);
            }
            _this = _super.call(this) || this;
            _this.m_type = EdgeShape.TYPE;
            _this.m_radius = SettingsInternal.polygonRadius;
            _this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();
            _this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();
            _this.m_vertex0 = Vec2.zero();
            _this.m_vertex3 = Vec2.zero();
            _this.m_hasVertex0 = false;
            _this.m_hasVertex3 = false;
            return _this;
        }
        /** @internal */
        EdgeShape.prototype._serialize = function () {
            return {
                type: this.m_type,
                vertex1: this.m_vertex1,
                vertex2: this.m_vertex2,
                vertex0: this.m_vertex0,
                vertex3: this.m_vertex3,
                hasVertex0: this.m_hasVertex0,
                hasVertex3: this.m_hasVertex3,
            };
        };
        /** @internal */
        EdgeShape._deserialize = function (data) {
            var shape = new EdgeShape(data.vertex1, data.vertex2);
            if (shape.m_hasVertex0) {
                shape.setPrevVertex(data.vertex0);
            }
            if (shape.m_hasVertex3) {
                shape.setNextVertex(data.vertex3);
            }
            return shape;
        };
        /** @internal */
        EdgeShape.prototype._reset = function () {
            // noop
        };
        EdgeShape.prototype.getRadius = function () {
            return this.m_radius;
        };
        EdgeShape.prototype.getType = function () {
            return this.m_type;
        };
        /** @internal @deprecated */
        EdgeShape.prototype.setNext = function (v) {
            return this.setNextVertex(v);
        };
        /**
         * Optional next vertex, used for smooth collision.
         */
        EdgeShape.prototype.setNextVertex = function (v) {
            if (v) {
                this.m_vertex3.setVec2(v);
                this.m_hasVertex3 = true;
            }
            else {
                this.m_vertex3.setZero();
                this.m_hasVertex3 = false;
            }
            return this;
        };
        /**
         * Optional next vertex, used for smooth collision.
         */
        EdgeShape.prototype.getNextVertex = function () {
            return this.m_vertex3;
        };
        /** @internal @deprecated */
        EdgeShape.prototype.setPrev = function (v) {
            return this.setPrevVertex(v);
        };
        /**
         * Optional prev vertex, used for smooth collision.
         */
        EdgeShape.prototype.setPrevVertex = function (v) {
            if (v) {
                this.m_vertex0.setVec2(v);
                this.m_hasVertex0 = true;
            }
            else {
                this.m_vertex0.setZero();
                this.m_hasVertex0 = false;
            }
            return this;
        };
        /**
         * Optional prev vertex, used for smooth collision.
         */
        EdgeShape.prototype.getPrevVertex = function () {
            return this.m_vertex0;
        };
        /**
         * Set this as an isolated edge.
         */
        EdgeShape.prototype._set = function (v1, v2) {
            this.m_vertex1.setVec2(v1);
            this.m_vertex2.setVec2(v2);
            this.m_hasVertex0 = false;
            this.m_hasVertex3 = false;
            return this;
        };
        /**
         * @internal @deprecated Shapes should be treated as immutable.
         *
         * clone the concrete shape.
         */
        EdgeShape.prototype._clone = function () {
            var clone = new EdgeShape();
            clone.m_type = this.m_type;
            clone.m_radius = this.m_radius;
            clone.m_vertex1.setVec2(this.m_vertex1);
            clone.m_vertex2.setVec2(this.m_vertex2);
            clone.m_vertex0.setVec2(this.m_vertex0);
            clone.m_vertex3.setVec2(this.m_vertex3);
            clone.m_hasVertex0 = this.m_hasVertex0;
            clone.m_hasVertex3 = this.m_hasVertex3;
            return clone;
        };
        /**
         * Get the number of child primitives.
         */
        EdgeShape.prototype.getChildCount = function () {
            return 1;
        };
        /**
         * Test a point for containment in this shape. This only works for convex
         * shapes.
         *
         * @param xf The shape world transform.
         * @param p A point in world coordinates.
         */
        EdgeShape.prototype.testPoint = function (xf, p) {
            return false;
        };
        /**
         * Cast a ray against a child shape.
         *
         * @param output The ray-cast results.
         * @param input The ray-cast input parameters.
         * @param xf The transform to be applied to the shape.
         * @param childIndex The child shape index
         */
        EdgeShape.prototype.rayCast = function (output, input, xf, childIndex) {
            // p = p1 + t * d
            // v = v1 + s * e
            // p1 + t * d = v1 + s * e
            // s * e - t * d = p1 - v1
            // NOT_USED(childIndex);
            // Put the ray into the edge's frame of reference.
            var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));
            var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));
            var d = Vec2.sub(p2, p1);
            var v1 = this.m_vertex1;
            var v2 = this.m_vertex2;
            var e = Vec2.sub(v2, v1);
            var normal = Vec2.neo(e.y, -e.x);
            normal.normalize();
            // q = p1 + t * d
            // dot(normal, q - v1) = 0
            // dot(normal, p1 - v1) + t * dot(normal, d) = 0
            var numerator = Vec2.dot(normal, Vec2.sub(v1, p1));
            var denominator = Vec2.dot(normal, d);
            if (denominator == 0.0) {
                return false;
            }
            var t = numerator / denominator;
            if (t < 0.0 || input.maxFraction < t) {
                return false;
            }
            var q = Vec2.add(p1, Vec2.mulNumVec2(t, d));
            // q = v1 + s * r
            // s = dot(q - v1, r) / dot(r, r)
            var r = Vec2.sub(v2, v1);
            var rr = Vec2.dot(r, r);
            if (rr == 0.0) {
                return false;
            }
            var s = Vec2.dot(Vec2.sub(q, v1), r) / rr;
            if (s < 0.0 || 1.0 < s) {
                return false;
            }
            output.fraction = t;
            if (numerator > 0.0) {
                output.normal = Rot.mulVec2(xf.q, normal).neg();
            }
            else {
                output.normal = Rot.mulVec2(xf.q, normal);
            }
            return true;
        };
        /**
         * Given a transform, compute the associated axis aligned bounding box for a
         * child shape.
         *
         * @param aabb Returns the axis aligned box.
         * @param xf The world transform of the shape.
         * @param childIndex The child shape
         */
        EdgeShape.prototype.computeAABB = function (aabb, xf, childIndex) {
            transformVec2(v1$2, xf, this.m_vertex1);
            transformVec2(v2$1, xf, this.m_vertex2);
            AABB.combinePoints(aabb, v1$2, v2$1);
            AABB.extend(aabb, this.m_radius);
        };
        /**
         * Compute the mass properties of this shape using its dimensions and density.
         * The inertia tensor is computed about the local origin.
         *
         * @param massData Returns the mass data for this shape.
         * @param density The density in kilograms per meter squared.
         */
        EdgeShape.prototype.computeMass = function (massData, density) {
            massData.mass = 0.0;
            combineVec2(massData.center, 0.5, this.m_vertex1, 0.5, this.m_vertex2);
            massData.I = 0.0;
        };
        EdgeShape.prototype.computeDistanceProxy = function (proxy) {
            proxy.m_vertices[0] = this.m_vertex1;
            proxy.m_vertices[1] = this.m_vertex2;
            proxy.m_vertices.length = 2;
            proxy.m_count = 2;
            proxy.m_radius = this.m_radius;
        };
        EdgeShape.TYPE = 'edge';
        return EdgeShape;
    }(Shape));
    var Edge = EdgeShape;

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var v1$1 = vec2(0, 0);
    /** @internal */ var v2 = vec2(0, 0);
    /**
     * A chain shape is a free form sequence of line segments. The chain has
     * two-sided collision, so you can use inside and outside collision. Therefore,
     * you may use any winding order. Connectivity information is used to create
     * smooth collisions.
     *
     * WARNING: The chain will not collide properly if there are self-intersections.
     */
    var ChainShape = /** @class */ (function (_super) {
        __extends(ChainShape, _super);
        function ChainShape(vertices, loop) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof ChainShape)) {
                return new ChainShape(vertices, loop);
            }
            _this = _super.call(this) || this;
            _this.m_type = ChainShape.TYPE;
            _this.m_radius = SettingsInternal.polygonRadius;
            _this.m_vertices = [];
            _this.m_count = 0;
            _this.m_prevVertex = null;
            _this.m_nextVertex = null;
            _this.m_hasPrevVertex = false;
            _this.m_hasNextVertex = false;
            _this.m_isLoop = !!loop;
            if (vertices && vertices.length) {
                if (loop) {
                    _this._createLoop(vertices);
                }
                else {
                    _this._createChain(vertices);
                }
            }
            return _this;
        }
        /** @internal */
        ChainShape.prototype._serialize = function () {
            var data = {
                type: this.m_type,
                vertices: this.m_vertices,
                isLoop: this.m_isLoop,
                hasPrevVertex: this.m_hasPrevVertex,
                hasNextVertex: this.m_hasNextVertex,
                prevVertex: null,
                nextVertex: null,
            };
            if (this.m_prevVertex) {
                data.prevVertex = this.m_prevVertex;
            }
            if (this.m_nextVertex) {
                data.nextVertex = this.m_nextVertex;
            }
            return data;
        };
        /** @internal */
        ChainShape._deserialize = function (data, fixture, restore) {
            var vertices = [];
            if (data.vertices) {
                for (var i = 0; i < data.vertices.length; i++) {
                    vertices.push(restore(Vec2, data.vertices[i]));
                }
            }
            var shape = new ChainShape(vertices, data.isLoop);
            if (data.prevVertex) {
                shape.setPrevVertex(data.prevVertex);
            }
            if (data.nextVertex) {
                shape.setNextVertex(data.nextVertex);
            }
            return shape;
        };
        // clear() {
        //   this.m_vertices.length = 0;
        //   this.m_count = 0;
        // }
        ChainShape.prototype.getType = function () {
            return this.m_type;
        };
        ChainShape.prototype.getRadius = function () {
            return this.m_radius;
        };
        /**
         * @internal
         * Create a loop. This automatically adjusts connectivity.
         *
         * @param vertices an array of vertices, these are copied
         * @param count the vertex count
         */
        ChainShape.prototype._createLoop = function (vertices) {
            if (vertices.length < 3) {
                return;
            }
            for (var i = 1; i < vertices.length; ++i) {
                vertices[i - 1];
                vertices[i];
            }
            this.m_vertices = [];
            this.m_count = vertices.length + 1;
            for (var i = 0; i < vertices.length; ++i) {
                this.m_vertices[i] = Vec2.clone(vertices[i]);
            }
            this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);
            this.m_prevVertex = this.m_vertices[this.m_count - 2];
            this.m_nextVertex = this.m_vertices[1];
            this.m_hasPrevVertex = true;
            this.m_hasNextVertex = true;
            return this;
        };
        /**
         * @internal
         * Create a chain with isolated end vertices.
         *
         * @param vertices an array of vertices, these are copied
         */
        ChainShape.prototype._createChain = function (vertices) {
            for (var i = 1; i < vertices.length; ++i) {
                // If the code crashes here, it means your vertices are too close together.
                vertices[i - 1];
                vertices[i];
            }
            this.m_count = vertices.length;
            for (var i = 0; i < vertices.length; ++i) {
                this.m_vertices[i] = Vec2.clone(vertices[i]);
            }
            this.m_hasPrevVertex = false;
            this.m_hasNextVertex = false;
            this.m_prevVertex = null;
            this.m_nextVertex = null;
            return this;
        };
        /** @internal */
        ChainShape.prototype._reset = function () {
            if (this.m_isLoop) {
                this._createLoop(this.m_vertices);
            }
            else {
                this._createChain(this.m_vertices);
            }
        };
        /**
         * Establish connectivity to a vertex that precedes the first vertex. Don't call
         * this for loops.
         */
        ChainShape.prototype.setPrevVertex = function (prevVertex) {
            this.m_prevVertex = prevVertex;
            this.m_hasPrevVertex = true;
        };
        ChainShape.prototype.getPrevVertex = function () {
            return this.m_prevVertex;
        };
        /**
         * Establish connectivity to a vertex that follows the last vertex. Don't call
         * this for loops.
         */
        ChainShape.prototype.setNextVertex = function (nextVertex) {
            this.m_nextVertex = nextVertex;
            this.m_hasNextVertex = true;
        };
        ChainShape.prototype.getNextVertex = function () {
            return this.m_nextVertex;
        };
        /**
         * @internal @deprecated Shapes should be treated as immutable.
         *
         * clone the concrete shape.
         */
        ChainShape.prototype._clone = function () {
            var clone = new ChainShape();
            clone._createChain(this.m_vertices);
            clone.m_type = this.m_type;
            clone.m_radius = this.m_radius;
            clone.m_prevVertex = this.m_prevVertex;
            clone.m_nextVertex = this.m_nextVertex;
            clone.m_hasPrevVertex = this.m_hasPrevVertex;
            clone.m_hasNextVertex = this.m_hasNextVertex;
            return clone;
        };
        /**
         * Get the number of child primitives.
         */
        ChainShape.prototype.getChildCount = function () {
            // edge count = vertex count - 1
            return this.m_count - 1;
        };
        // Get a child edge.
        ChainShape.prototype.getChildEdge = function (edge, childIndex) {
            edge.m_type = EdgeShape.TYPE;
            edge.m_radius = this.m_radius;
            edge.m_vertex1 = this.m_vertices[childIndex];
            edge.m_vertex2 = this.m_vertices[childIndex + 1];
            if (childIndex > 0) {
                edge.m_vertex0 = this.m_vertices[childIndex - 1];
                edge.m_hasVertex0 = true;
            }
            else {
                edge.m_vertex0 = this.m_prevVertex;
                edge.m_hasVertex0 = this.m_hasPrevVertex;
            }
            if (childIndex < this.m_count - 2) {
                edge.m_vertex3 = this.m_vertices[childIndex + 2];
                edge.m_hasVertex3 = true;
            }
            else {
                edge.m_vertex3 = this.m_nextVertex;
                edge.m_hasVertex3 = this.m_hasNextVertex;
            }
        };
        ChainShape.prototype.getVertex = function (index) {
            if (index < this.m_count) {
                return this.m_vertices[index];
            }
            else {
                return this.m_vertices[0];
            }
        };
        ChainShape.prototype.isLoop = function () {
            return this.m_isLoop;
        };
        /**
         * Test a point for containment in this shape. This only works for convex
         * shapes.
         *
         * This always return false.
         *
         * @param xf The shape world transform.
         * @param p A point in world coordinates.
         */
        ChainShape.prototype.testPoint = function (xf, p) {
            return false;
        };
        /**
         * Cast a ray against a child shape.
         *
         * @param output The ray-cast results.
         * @param input The ray-cast input parameters.
         * @param xf The transform to be applied to the shape.
         * @param childIndex The child shape index
         */
        ChainShape.prototype.rayCast = function (output, input, xf, childIndex) {
            var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));
            return edgeShape.rayCast(output, input, xf, 0);
        };
        /**
         * Given a transform, compute the associated axis aligned bounding box for a
         * child shape.
         *
         * @param aabb Returns the axis aligned box.
         * @param xf The world transform of the shape.
         * @param childIndex The child shape
         */
        ChainShape.prototype.computeAABB = function (aabb, xf, childIndex) {
            transformVec2(v1$1, xf, this.getVertex(childIndex));
            transformVec2(v2, xf, this.getVertex(childIndex + 1));
            AABB.combinePoints(aabb, v1$1, v2);
        };
        /**
         * Compute the mass properties of this shape using its dimensions and density.
         * The inertia tensor is computed about the local origin.
         *
         * Chains have zero mass.
         *
         * @param massData Returns the mass data for this shape.
         * @param density The density in kilograms per meter squared.
         */
        ChainShape.prototype.computeMass = function (massData, density) {
            massData.mass = 0.0;
            zeroVec2(massData.center);
            massData.I = 0.0;
        };
        ChainShape.prototype.computeDistanceProxy = function (proxy, childIndex) {
            proxy.m_vertices[0] = this.getVertex(childIndex);
            proxy.m_vertices[1] = this.getVertex(childIndex + 1);
            proxy.m_count = 2;
            proxy.m_radius = this.m_radius;
        };
        ChainShape.TYPE = 'chain';
        return ChainShape;
    }(Shape));
    var Chain = ChainShape;

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_max$1 = Math.max;
    /** @internal */ var math_min$3 = Math.min;
    /** @internal */ var temp$1 = vec2(0, 0);
    /** @internal */ var e$1 = vec2(0, 0);
    /** @internal */ var e1$1 = vec2(0, 0);
    /** @internal */ var e2$1 = vec2(0, 0);
    /** @internal */ var center = vec2(0, 0);
    /** @internal */ var s = vec2(0, 0);
    /**
     * A convex polygon. It is assumed that the interior of the polygon is to the
     * left of each edge. Polygons have a maximum number of vertices equal to
     * Settings.maxPolygonVertices. In most cases you should not need many vertices
     * for a convex polygon. extends Shape
     */
    var PolygonShape = /** @class */ (function (_super) {
        __extends(PolygonShape, _super);
        function PolygonShape(vertices) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof PolygonShape)) {
                return new PolygonShape(vertices);
            }
            _this = _super.call(this) || this;
            _this.m_type = PolygonShape.TYPE;
            _this.m_radius = SettingsInternal.polygonRadius;
            _this.m_centroid = Vec2.zero();
            _this.m_vertices = [];
            _this.m_normals = [];
            _this.m_count = 0;
            if (vertices && vertices.length) {
                _this._set(vertices);
            }
            return _this;
        }
        /** @internal */
        PolygonShape.prototype._serialize = function () {
            return {
                type: this.m_type,
                vertices: this.m_vertices,
            };
        };
        /** @internal */
        PolygonShape._deserialize = function (data, fixture, restore) {
            var vertices = [];
            if (data.vertices) {
                for (var i = 0; i < data.vertices.length; i++) {
                    vertices.push(restore(Vec2, data.vertices[i]));
                }
            }
            var shape = new PolygonShape(vertices);
            return shape;
        };
        PolygonShape.prototype.getType = function () {
            return this.m_type;
        };
        PolygonShape.prototype.getRadius = function () {
            return this.m_radius;
        };
        /**
         * @internal @deprecated Shapes should be treated as immutable.
         *
         * clone the concrete shape.
         */
        PolygonShape.prototype._clone = function () {
            var clone = new PolygonShape();
            clone.m_type = this.m_type;
            clone.m_radius = this.m_radius;
            clone.m_count = this.m_count;
            clone.m_centroid.setVec2(this.m_centroid);
            for (var i = 0; i < this.m_count; i++) {
                clone.m_vertices.push(this.m_vertices[i].clone());
            }
            for (var i = 0; i < this.m_normals.length; i++) {
                clone.m_normals.push(this.m_normals[i].clone());
            }
            return clone;
        };
        /**
         * Get the number of child primitives.
         */
        PolygonShape.prototype.getChildCount = function () {
            return 1;
        };
        /** @internal */ PolygonShape.prototype._reset = function () {
            this._set(this.m_vertices);
        };
        /**
         * @internal
         *
         * Create a convex hull from the given array of local points. The count must be
         * in the range [3, Settings.maxPolygonVertices].
         *
         * Warning: the points may be re-ordered, even if they form a convex polygon
         * Warning: collinear points are handled but not removed. Collinear points may
         * lead to poor stacking behavior.
         */
        PolygonShape.prototype._set = function (vertices) {
            if (vertices.length < 3) {
                this._setAsBox(1.0, 1.0);
                return;
            }
            var n = math_min$3(vertices.length, SettingsInternal.maxPolygonVertices);
            // Perform welding and copy vertices into local buffer.
            var ps = []; // [Settings.maxPolygonVertices];
            for (var i = 0; i < n; ++i) {
                var v = vertices[i];
                var unique = true;
                for (var j = 0; j < ps.length; ++j) {
                    if (Vec2.distanceSquared(v, ps[j]) < 0.25 * SettingsInternal.linearSlopSquared) {
                        unique = false;
                        break;
                    }
                }
                if (unique) {
                    ps.push(Vec2.clone(v));
                }
            }
            n = ps.length;
            if (n < 3) {
                this._setAsBox(1.0, 1.0);
                return;
            }
            // Create the convex hull using the Gift wrapping algorithm
            // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm
            // Find the right most point on the hull (in case of multiple points bottom most is used)
            var i0 = 0;
            var x0 = ps[0].x;
            for (var i = 1; i < n; ++i) {
                var x = ps[i].x;
                if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {
                    i0 = i;
                    x0 = x;
                }
            }
            var hull = []; // [Settings.maxPolygonVertices];
            var m = 0;
            var ih = i0;
            while (true) {
                hull[m] = ih;
                var ie = 0;
                for (var j = 1; j < n; ++j) {
                    if (ie === ih) {
                        ie = j;
                        continue;
                    }
                    var r = Vec2.sub(ps[ie], ps[hull[m]]);
                    var v = Vec2.sub(ps[j], ps[hull[m]]);
                    var c = Vec2.crossVec2Vec2(r, v);
                    // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping
                    if (c < 0.0) {
                        ie = j;
                    }
                    // Collinearity check
                    if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {
                        ie = j;
                    }
                }
                ++m;
                ih = ie;
                if (ie === i0) {
                    break;
                }
            }
            if (m < 3) {
                this._setAsBox(1.0, 1.0);
                return;
            }
            this.m_count = m;
            // Copy vertices.
            this.m_vertices = [];
            for (var i = 0; i < m; ++i) {
                this.m_vertices[i] = ps[hull[i]];
            }
            // Compute normals. Ensure the edges have non-zero length.
            for (var i = 0; i < m; ++i) {
                var i1 = i;
                var i2 = i + 1 < m ? i + 1 : 0;
                var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);
                this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);
                this.m_normals[i].normalize();
            }
            // Compute the polygon centroid.
            this.m_centroid = computeCentroid(this.m_vertices, m);
        };
        /** @internal */ PolygonShape.prototype._setAsBox = function (hx, hy, center, angle) {
            // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()
            this.m_vertices[0] = Vec2.neo(hx, -hy);
            this.m_vertices[1] = Vec2.neo(hx, hy);
            this.m_vertices[2] = Vec2.neo(-hx, hy);
            this.m_vertices[3] = Vec2.neo(-hx, -hy);
            this.m_normals[0] = Vec2.neo(1.0, 0.0);
            this.m_normals[1] = Vec2.neo(0.0, 1.0);
            this.m_normals[2] = Vec2.neo(-1.0, 0.0);
            this.m_normals[3] = Vec2.neo(0.0, -1.0);
            this.m_count = 4;
            if (center && Vec2.isValid(center)) {
                angle = angle || 0;
                copyVec2(this.m_centroid, center);
                var xf = Transform.identity();
                xf.p.setVec2(center);
                xf.q.setAngle(angle);
                // Transform vertices and normals.
                for (var i = 0; i < this.m_count; ++i) {
                    this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);
                    this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);
                }
            }
        };
        /**
         * Test a point for containment in this shape. This only works for convex
         * shapes.
         *
         * @param xf The shape world transform.
         * @param p A point in world coordinates.
         */
        PolygonShape.prototype.testPoint = function (xf, p) {
            var pLocal = invTransformVec2(temp$1, xf, p);
            for (var i = 0; i < this.m_count; ++i) {
                var dot = dotVec2(this.m_normals[i], pLocal) - dotVec2(this.m_normals[i], this.m_vertices[i]);
                if (dot > 0.0) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Cast a ray against a child shape.
         *
         * @param output The ray-cast results.
         * @param input The ray-cast input parameters.
         * @param xf The transform to be applied to the shape.
         * @param childIndex The child shape index
         */
        PolygonShape.prototype.rayCast = function (output, input, xf, childIndex) {
            // Put the ray into the polygon's frame of reference.
            var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));
            var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));
            var d = Vec2.sub(p2, p1);
            var lower = 0.0;
            var upper = input.maxFraction;
            var index = -1;
            for (var i = 0; i < this.m_count; ++i) {
                // p = p1 + a * d
                // dot(normal, p - v) = 0
                // dot(normal, p1 - v) + a * dot(normal, d) = 0
                var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));
                var denominator = Vec2.dot(this.m_normals[i], d);
                if (denominator == 0.0) {
                    if (numerator < 0.0) {
                        return false;
                    }
                }
                else {
                    // Note: we want this predicate without division:
                    // lower < numerator / denominator, where denominator < 0
                    // Since denominator < 0, we have to flip the inequality:
                    // lower < numerator / denominator <==> denominator * lower > numerator.
                    if (denominator < 0.0 && numerator < lower * denominator) {
                        // Increase lower.
                        // The segment enters this half-space.
                        lower = numerator / denominator;
                        index = i;
                    }
                    else if (denominator > 0.0 && numerator < upper * denominator) {
                        // Decrease upper.
                        // The segment exits this half-space.
                        upper = numerator / denominator;
                    }
                }
                // The use of epsilon here causes the assert on lower to trip
                // in some cases. Apparently the use of epsilon was to make edge
                // shapes work, but now those are handled separately.
                // if (upper < lower - matrix.EPSILON)
                if (upper < lower) {
                    return false;
                }
            }
            if (index >= 0) {
                output.fraction = lower;
                output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);
                return true;
            }
            return false;
        };
        /**
         * Given a transform, compute the associated axis aligned bounding box for a
         * child shape.
         *
         * @param aabb Returns the axis aligned box.
         * @param xf The world transform of the shape.
         * @param childIndex The child shape
         */
        PolygonShape.prototype.computeAABB = function (aabb, xf, childIndex) {
            var minX = Infinity;
            var minY = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            for (var i = 0; i < this.m_count; ++i) {
                var v = transformVec2(temp$1, xf, this.m_vertices[i]);
                minX = math_min$3(minX, v.x);
                maxX = math_max$1(maxX, v.x);
                minY = math_min$3(minY, v.y);
                maxY = math_max$1(maxY, v.y);
            }
            setVec2(aabb.lowerBound, minX - this.m_radius, minY - this.m_radius);
            setVec2(aabb.upperBound, maxX + this.m_radius, maxY + this.m_radius);
        };
        /**
         * Compute the mass properties of this shape using its dimensions and density.
         * The inertia tensor is computed about the local origin.
         *
         * @param massData Returns the mass data for this shape.
         * @param density The density in kilograms per meter squared.
         */
        PolygonShape.prototype.computeMass = function (massData, density) {
            zeroVec2(center);
            var area = 0.0;
            var I = 0.0;
            // s is the reference point for forming triangles.
            // It's location doesn't change the result (except for rounding error).
            zeroVec2(s);
            // This code would put the reference point inside the polygon.
            for (var i = 0; i < this.m_count; ++i) {
                addVec2(s, this.m_vertices[i]);
            }
            setMulVec2(s, 1.0 / this.m_count, s);
            var k_inv3 = 1.0 / 3.0;
            for (var i = 0; i < this.m_count; ++i) {
                // Triangle vertices.
                diffVec2(e1$1, this.m_vertices[i], s);
                if (i + 1 < this.m_count) {
                    diffVec2(e2$1, this.m_vertices[i + 1], s);
                }
                else {
                    diffVec2(e2$1, this.m_vertices[0], s);
                }
                var D = crossVec2Vec2(e1$1, e2$1);
                var triangleArea = 0.5 * D;
                area += triangleArea;
                // Area weighted centroid
                combineVec2(center, 1, center, triangleArea * k_inv3, e1$1);
                combineVec2(center, 1, center, triangleArea * k_inv3, e2$1);
                var ex1 = e1$1.x;
                var ey1 = e1$1.y;
                var ex2 = e2$1.x;
                var ey2 = e2$1.y;
                var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
                var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
                I += (0.25 * k_inv3 * D) * (intx2 + inty2);
            }
            // Total mass
            massData.mass = density * area;
            setMulVec2(center, 1.0 / area, center);
            sumVec2(massData.center, center, s);
            // Inertia tensor relative to the local origin (point s).
            massData.I = density * I;
            // Shift to center of mass then to original body origin.
            massData.I += massData.mass * (dotVec2(massData.center, massData.center) - dotVec2(center, center));
        };
        /**
         * Validate convexity. This is a very time consuming operation.
         * @returns true if valid
         */
        PolygonShape.prototype.validate = function () {
            for (var i = 0; i < this.m_count; ++i) {
                var i1 = i;
                var i2 = i < this.m_count - 1 ? i1 + 1 : 0;
                var p = this.m_vertices[i1];
                diffVec2(e$1, this.m_vertices[i2], p);
                for (var j = 0; j < this.m_count; ++j) {
                    if (j == i1 || j == i2) {
                        continue;
                    }
                    var c = crossVec2Vec2(e$1, diffVec2(temp$1, this.m_vertices[j], p));
                    if (c < 0.0) {
                        return false;
                    }
                }
            }
            return true;
        };
        PolygonShape.prototype.computeDistanceProxy = function (proxy) {
            for (var i = 0; i < this.m_count; ++i) {
                proxy.m_vertices[i] = this.m_vertices[i];
            }
            proxy.m_vertices.length = this.m_count;
            proxy.m_count = this.m_count;
            proxy.m_radius = this.m_radius;
        };
        PolygonShape.TYPE = 'polygon';
        return PolygonShape;
    }(Shape));
    /** @internal */ function computeCentroid(vs, count) {
        var c = Vec2.zero();
        var area = 0.0;
        // pRef is the reference point for forming triangles.
        // It's location doesn't change the result (except for rounding error).
        var pRef = Vec2.zero();
        var i; 
        var inv3 = 1.0 / 3.0;
        for (var i = 0; i < count; ++i) {
            // Triangle vertices.
            var p1 = pRef;
            var p2 = vs[i];
            var p3 = i + 1 < count ? vs[i + 1] : vs[0];
            var e1_1 = Vec2.sub(p2, p1);
            var e2_1 = Vec2.sub(p3, p1);
            var D = Vec2.crossVec2Vec2(e1_1, e2_1);
            var triangleArea = 0.5 * D;
            area += triangleArea;
            // Area weighted centroid
            c.addMul(triangleArea * inv3, p1);
            c.addMul(triangleArea * inv3, p2);
            c.addMul(triangleArea * inv3, p3);
        }
        c.mul(1.0 / area);
        return c;
    }
    var Polygon = PolygonShape;

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * A rectangle polygon which extend PolygonShape.
     */
    var BoxShape = /** @class */ (function (_super) {
        __extends(BoxShape, _super);
        function BoxShape(hx, hy, center, angle) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof BoxShape)) {
                return new BoxShape(hx, hy, center, angle);
            }
            _this = _super.call(this) || this;
            _this._setAsBox(hx, hy, center, angle);
            return _this;
        }
        BoxShape.TYPE = 'polygon';
        return BoxShape;
    }(PolygonShape));
    var Box = BoxShape;

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_sqrt = Math.sqrt;
    /** @internal */ var math_PI$4 = Math.PI;
    /** @internal */ var temp = vec2(0, 0);
    var CircleShape = /** @class */ (function (_super) {
        __extends(CircleShape, _super);
        function CircleShape(a, b) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof CircleShape)) {
                return new CircleShape(a, b);
            }
            _this = _super.call(this) || this;
            _this.m_type = CircleShape.TYPE;
            _this.m_p = Vec2.zero();
            _this.m_radius = 1;
            if (typeof a === 'object' && Vec2.isValid(a)) {
                _this.m_p.setVec2(a);
                if (typeof b === 'number') {
                    _this.m_radius = b;
                }
            }
            else if (typeof a === 'number') {
                _this.m_radius = a;
            }
            return _this;
        }
        /** @internal */
        CircleShape.prototype._serialize = function () {
            return {
                type: this.m_type,
                p: this.m_p,
                radius: this.m_radius,
            };
        };
        /** @internal */
        CircleShape._deserialize = function (data) {
            return new CircleShape(data.p, data.radius);
        };
        /** @internal */
        CircleShape.prototype._reset = function () {
            // noop
        };
        CircleShape.prototype.getType = function () {
            return this.m_type;
        };
        CircleShape.prototype.getRadius = function () {
            return this.m_radius;
        };
        CircleShape.prototype.getCenter = function () {
            return this.m_p;
        };
        /**
         * @internal @deprecated Shapes should be treated as immutable.
         *
         * clone the concrete shape.
         */
        CircleShape.prototype._clone = function () {
            var clone = new CircleShape();
            clone.m_type = this.m_type;
            clone.m_radius = this.m_radius;
            clone.m_p = this.m_p.clone();
            return clone;
        };
        /**
         * Get the number of child primitives.
         */
        CircleShape.prototype.getChildCount = function () {
            return 1;
        };
        /**
         * Test a point for containment in this shape. This only works for convex
         * shapes.
         *
         * @param xf The shape world transform.
         * @param p A point in world coordinates.
         */
        CircleShape.prototype.testPoint = function (xf, p) {
            var center = transformVec2(temp, xf, this.m_p);
            return distSqrVec2(p, center) <= this.m_radius * this.m_radius;
        };
        /**
         * Cast a ray against a child shape.
         *
         * @param output The ray-cast results.
         * @param input The ray-cast input parameters.
         * @param xf The transform to be applied to the shape.
         * @param childIndex The child shape index
         */
        CircleShape.prototype.rayCast = function (output, input, xf, childIndex) {
            // Collision Detection in Interactive 3D Environments by Gino van den Bergen
            // From Section 3.1.2
            // x = s + a * r
            // norm(x) = radius
            var position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));
            var s = Vec2.sub(input.p1, position);
            var b = Vec2.dot(s, s) - this.m_radius * this.m_radius;
            // Solve quadratic equation.
            var r = Vec2.sub(input.p2, input.p1);
            var c = Vec2.dot(s, r);
            var rr = Vec2.dot(r, r);
            var sigma = c * c - rr * b;
            // Check for negative discriminant and short segment.
            if (sigma < 0.0 || rr < EPSILON) {
                return false;
            }
            // Find the point of intersection of the line with the circle.
            var a = -(c + math_sqrt(sigma));
            // Is the intersection point on the segment?
            if (0.0 <= a && a <= input.maxFraction * rr) {
                a /= rr;
                output.fraction = a;
                output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));
                output.normal.normalize();
                return true;
            }
            return false;
        };
        /**
         * Given a transform, compute the associated axis aligned bounding box for a
         * child shape.
         *
         * @param aabb Returns the axis aligned box.
         * @param xf The world transform of the shape.
         * @param childIndex The child shape
         */
        CircleShape.prototype.computeAABB = function (aabb, xf, childIndex) {
            var p = transformVec2(temp, xf, this.m_p);
            setVec2(aabb.lowerBound, p.x - this.m_radius, p.y - this.m_radius);
            setVec2(aabb.upperBound, p.x + this.m_radius, p.y + this.m_radius);
        };
        /**
         * Compute the mass properties of this shape using its dimensions and density.
         * The inertia tensor is computed about the local origin.
         *
         * @param massData Returns the mass data for this shape.
         * @param density The density in kilograms per meter squared.
         */
        CircleShape.prototype.computeMass = function (massData, density) {
            massData.mass = density * math_PI$4 * this.m_radius * this.m_radius;
            copyVec2(massData.center, this.m_p);
            // inertia about the local origin
            massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + lengthSqrVec2(this.m_p));
        };
        CircleShape.prototype.computeDistanceProxy = function (proxy) {
            proxy.m_vertices[0] = this.m_p;
            proxy.m_vertices.length = 1;
            proxy.m_count = 1;
            proxy.m_radius = this.m_radius;
        };
        CircleShape.TYPE = 'circle';
        return CircleShape;
    }(Shape));
    var Circle = CircleShape;

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$5 = Math.abs;
    /** @internal */ var math_PI$3 = Math.PI;
    /** @internal */ var DEFAULTS$a = {
        frequencyHz: 0.0,
        dampingRatio: 0.0
    };
    /**
     * A distance joint constrains two points on two bodies to remain at a fixed
     * distance from each other. You can view this as a massless, rigid rod.
     */
    var DistanceJoint = /** @class */ (function (_super) {
        __extends(DistanceJoint, _super);
        function DistanceJoint(def, bodyA, bodyB, anchorA, anchorB) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof DistanceJoint)) {
                return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);
            }
            // order of constructor arguments is changed in v0.2
            if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {
                var temp = bodyB;
                bodyB = anchorA;
                anchorA = temp;
            }
            def = options(def, DEFAULTS$a);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = DistanceJoint.TYPE;
            // Solver shared
            _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());
            _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());
            _this.m_length = Number.isFinite(def.length) ? def.length :
                Vec2.distance(bodyA.getWorldPoint(_this.m_localAnchorA), bodyB.getWorldPoint(_this.m_localAnchorB));
            _this.m_frequencyHz = def.frequencyHz;
            _this.m_dampingRatio = def.dampingRatio;
            _this.m_impulse = 0.0;
            _this.m_gamma = 0.0;
            _this.m_bias = 0.0;
            return _this;
            // 1-D constrained system
            // m (v2 - v1) = lambda
            // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.
            // x2 = x1 + h * v2
            // 1-D mass-damper-spring system
            // m (v2 - v1) + h * d * v2 + h * k *
            // C = norm(p2 - p1) - L
            // u = (p2 - p1) / norm(p2 - p1)
            // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))
            // J = [-u -cross(r1, u) u cross(r2, u)]
            // K = J * invM * JT
            // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2
        }
        /** @internal */
        DistanceJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                frequencyHz: this.m_frequencyHz,
                dampingRatio: this.m_dampingRatio,
                localAnchorA: this.m_localAnchorA,
                localAnchorB: this.m_localAnchorB,
                length: this.m_length,
                impulse: this.m_impulse,
                gamma: this.m_gamma,
                bias: this.m_bias,
            };
        };
        /** @internal */
        DistanceJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            var joint = new DistanceJoint(data);
            return joint;
        };
        /** @internal */
        DistanceJoint.prototype._setAnchors = function (def) {
            if (def.anchorA) {
                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
            }
            else if (def.localAnchorA) {
                this.m_localAnchorA.setVec2(def.localAnchorA);
            }
            if (def.anchorB) {
                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
            }
            else if (def.localAnchorB) {
                this.m_localAnchorB.setVec2(def.localAnchorB);
            }
            if (def.length > 0) {
                this.m_length = +def.length;
            }
            else if (def.length < 0) ;
            else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {
                this.m_length = Vec2.distance(this.m_bodyA.getWorldPoint(this.m_localAnchorA), this.m_bodyB.getWorldPoint(this.m_localAnchorB));
            }
        };
        /**
         * The local anchor point relative to bodyA's origin.
         */
        DistanceJoint.prototype.getLocalAnchorA = function () {
            return this.m_localAnchorA;
        };
        /**
         * The local anchor point relative to bodyB's origin.
         */
        DistanceJoint.prototype.getLocalAnchorB = function () {
            return this.m_localAnchorB;
        };
        /**
         * Set the natural length. Manipulating the length can lead to non-physical
         * behavior when the frequency is zero.
         */
        DistanceJoint.prototype.setLength = function (length) {
            this.m_length = length;
        };
        /**
         * Get the natural length.
         */
        DistanceJoint.prototype.getLength = function () {
            return this.m_length;
        };
        DistanceJoint.prototype.setFrequency = function (hz) {
            this.m_frequencyHz = hz;
        };
        DistanceJoint.prototype.getFrequency = function () {
            return this.m_frequencyHz;
        };
        DistanceJoint.prototype.setDampingRatio = function (ratio) {
            this.m_dampingRatio = ratio;
        };
        DistanceJoint.prototype.getDampingRatio = function () {
            return this.m_dampingRatio;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        DistanceJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        DistanceJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        DistanceJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        DistanceJoint.prototype.getReactionTorque = function (inv_dt) {
            return 0.0;
        };
        DistanceJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));
            // Handle singularity.
            var length = this.m_u.length();
            if (length > SettingsInternal.linearSlop) {
                this.m_u.mul(1.0 / length);
            }
            else {
                this.m_u.setNum(0.0, 0.0);
            }
            var crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);
            var crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);
            var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;
            // Compute the effective mass matrix.
            this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
            if (this.m_frequencyHz > 0.0) {
                var C = length - this.m_length;
                // Frequency
                var omega = 2.0 * math_PI$3 * this.m_frequencyHz;
                // Damping coefficient
                var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
                // Spring stiffness
                var k = this.m_mass * omega * omega;
                // magic formulas
                var h = step.dt;
                this.m_gamma = h * (d + h * k);
                this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;
                this.m_bias = C * h * k * this.m_gamma;
                invMass += this.m_gamma;
                this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
            }
            else {
                this.m_gamma = 0.0;
                this.m_bias = 0.0;
            }
            if (step.warmStarting) {
                // Scale the impulse to support a variable time step.
                this.m_impulse *= step.dtRatio;
                var P = Vec2.mulNumVec2(this.m_impulse, this.m_u);
                vA.subMul(this.m_invMassA, P);
                wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);
                vB.addMul(this.m_invMassB, P);
                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);
            }
            else {
                this.m_impulse = 0.0;
            }
            this.m_bodyA.c_velocity.v.setVec2(vA);
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v.setVec2(vB);
            this.m_bodyB.c_velocity.w = wB;
        };
        DistanceJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            // Cdot = dot(u, v + cross(w, r))
            var vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));
            var vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));
            var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);
            var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
            this.m_impulse += impulse;
            var P = Vec2.mulNumVec2(impulse, this.m_u);
            vA.subMul(this.m_invMassA, P);
            wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);
            vB.addMul(this.m_invMassB, P);
            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);
            this.m_bodyA.c_velocity.v.setVec2(vA);
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v.setVec2(vB);
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        DistanceJoint.prototype.solvePositionConstraints = function (step) {
            if (this.m_frequencyHz > 0.0) {
                // There is no position correction for soft distance constraints.
                return true;
            }
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
            var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
            var u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));
            var length = u.normalize();
            var C = clamp(length - this.m_length, -SettingsInternal.maxLinearCorrection, SettingsInternal.maxLinearCorrection);
            var impulse = -this.m_mass * C;
            var P = Vec2.mulNumVec2(impulse, u);
            cA.subMul(this.m_invMassA, P);
            aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);
            cB.addMul(this.m_invMassB, P);
            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);
            this.m_bodyA.c_position.c.setVec2(cA);
            this.m_bodyA.c_position.a = aA;
            this.m_bodyB.c_position.c.setVec2(cB);
            this.m_bodyB.c_position.a = aB;
            return math_abs$5(C) < SettingsInternal.linearSlop;
        };
        DistanceJoint.TYPE = 'distance-joint';
        return DistanceJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var DEFAULTS$9 = {
        maxForce: 0.0,
        maxTorque: 0.0,
    };
    /**
     * Friction joint. This is used for top-down friction. It provides 2D
     * translational friction and angular friction.
     */
    var FrictionJoint = /** @class */ (function (_super) {
        __extends(FrictionJoint, _super);
        function FrictionJoint(def, bodyA, bodyB, anchor) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof FrictionJoint)) {
                return new FrictionJoint(def, bodyA, bodyB, anchor);
            }
            def = options(def, DEFAULTS$9);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = FrictionJoint.TYPE;
            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
            // Solver shared
            _this.m_linearImpulse = Vec2.zero();
            _this.m_angularImpulse = 0.0;
            _this.m_maxForce = def.maxForce;
            _this.m_maxTorque = def.maxTorque;
            return _this;
            // Point-to-point constraint
            // Cdot = v2 - v1
            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
            // J = [-I -r1_skew I r2_skew ]
            // Identity used:
            // w k % (rx i + ry j) = w * (-ry i + rx j)
            // Angle constraint
            // Cdot = w2 - w1
            // J = [0 0 -1 0 0 1]
            // K = invI1 + invI2
        }
        /** @internal */
        FrictionJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                maxForce: this.m_maxForce,
                maxTorque: this.m_maxTorque,
                localAnchorA: this.m_localAnchorA,
                localAnchorB: this.m_localAnchorB,
            };
        };
        /** @internal */
        FrictionJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            var joint = new FrictionJoint(data);
            return joint;
        };
        /** @internal */
        FrictionJoint.prototype._setAnchors = function (def) {
            if (def.anchorA) {
                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
            }
            else if (def.localAnchorA) {
                this.m_localAnchorA.setVec2(def.localAnchorA);
            }
            if (def.anchorB) {
                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
            }
            else if (def.localAnchorB) {
                this.m_localAnchorB.setVec2(def.localAnchorB);
            }
        };
        /**
         * The local anchor point relative to bodyA's origin.
         */
        FrictionJoint.prototype.getLocalAnchorA = function () {
            return this.m_localAnchorA;
        };
        /**
         * The local anchor point relative to bodyB's origin.
         */
        FrictionJoint.prototype.getLocalAnchorB = function () {
            return this.m_localAnchorB;
        };
        /**
         * Set the maximum friction force in N.
         */
        FrictionJoint.prototype.setMaxForce = function (force) {
            this.m_maxForce = force;
        };
        /**
         * Get the maximum friction force in N.
         */
        FrictionJoint.prototype.getMaxForce = function () {
            return this.m_maxForce;
        };
        /**
         * Set the maximum friction torque in N*m.
         */
        FrictionJoint.prototype.setMaxTorque = function (torque) {
            this.m_maxTorque = torque;
        };
        /**
         * Get the maximum friction torque in N*m.
         */
        FrictionJoint.prototype.getMaxTorque = function () {
            return this.m_maxTorque;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        FrictionJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        FrictionJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        FrictionJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        FrictionJoint.prototype.getReactionTorque = function (inv_dt) {
            return inv_dt * this.m_angularImpulse;
        };
        FrictionJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            // Compute the effective mass matrix.
            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            // J = [-I -r1_skew I r2_skew]
            // [ 0 -1 0 1]
            // r_skew = [-ry; rx]
            // Matlab
            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var K = new Mat22();
            K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y
                * this.m_rB.y;
            K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
            K.ey.x = K.ex.y;
            K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x
                * this.m_rB.x;
            this.m_linearMass = K.getInverse();
            this.m_angularMass = iA + iB;
            if (this.m_angularMass > 0.0) {
                this.m_angularMass = 1.0 / this.m_angularMass;
            }
            if (step.warmStarting) {
                // Scale impulses to support a variable time step.
                this.m_linearImpulse.mul(step.dtRatio);
                this.m_angularImpulse *= step.dtRatio;
                var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);
                vA.subMul(mA, P);
                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);
                vB.addMul(mB, P);
                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);
            }
            else {
                this.m_linearImpulse.setZero();
                this.m_angularImpulse = 0.0;
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        FrictionJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var h = step.dt;
            // Solve angular friction
            {
                var Cdot = wB - wA;
                var impulse = -this.m_angularMass * Cdot;
                var oldImpulse = this.m_angularImpulse;
                var maxImpulse = h * this.m_maxTorque;
                this.m_angularImpulse = clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
                impulse = this.m_angularImpulse - oldImpulse;
                wA -= iA * impulse;
                wB += iB * impulse;
            }
            // Solve linear friction
            {
                var Cdot = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA)));
                var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));
                var oldImpulse = this.m_linearImpulse;
                this.m_linearImpulse.add(impulse);
                var maxImpulse = h * this.m_maxForce;
                if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {
                    this.m_linearImpulse.normalize();
                    this.m_linearImpulse.mul(maxImpulse);
                }
                impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);
                vA.subMul(mA, impulse);
                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);
                vB.addMul(mB, impulse);
                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        FrictionJoint.prototype.solvePositionConstraints = function (step) {
            return true;
        };
        FrictionJoint.TYPE = 'friction-joint';
        return FrictionJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * A 3-by-3 matrix. Stored in column-major order.
     */
    var Mat33 = /** @class */ (function () {
        function Mat33(a, b, c) {
            if (typeof a === 'object' && a !== null) {
                this.ex = Vec3.clone(a);
                this.ey = Vec3.clone(b);
                this.ez = Vec3.clone(c);
            }
            else {
                this.ex = Vec3.zero();
                this.ey = Vec3.zero();
                this.ez = Vec3.zero();
            }
        }
        /** @internal */
        Mat33.prototype.toString = function () {
            return JSON.stringify(this);
        };
        Mat33.isValid = function (obj) {
            if (obj === null || typeof obj === 'undefined') {
                return false;
            }
            return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);
        };
        Mat33.assert = function (o) {
        };
        /**
         * Set this matrix to all zeros.
         */
        Mat33.prototype.setZero = function () {
            this.ex.setZero();
            this.ey.setZero();
            this.ez.setZero();
            return this;
        };
        /**
         * Solve A * x = b, where b is a column vector. This is more efficient than
         * computing the inverse in one-shot cases.
         */
        Mat33.prototype.solve33 = function (v) {
            // let det = matrix.dotVec3(this.ex, matrix.newCrossVec3(this.ey, this.ez));
            var cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;
            var cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;
            var cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;
            var det = this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z;
            if (det !== 0.0) {
                det = 1.0 / det;
            }
            var r = new Vec3();
            // r.x = det * matrix.dotVec3(v, matrix.newCrossVec3(this.ey, this.ez));
            cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;
            cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;
            cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;
            r.x = det * (v.x * cross_x + v.y * cross_y + v.z * cross_z);
            // r.y = det * matrix.dotVec3(this.ex, matrix.newCrossVec3(v, this.ez));
            cross_x = v.y * this.ez.z - v.z * this.ez.y;
            cross_y = v.z * this.ez.x - v.x * this.ez.z;
            cross_z = v.x * this.ez.y - v.y * this.ez.x;
            r.y = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);
            // r.z = det * matrix.dotVec3(this.ex, matrix.newCrossVec3(this.ey, v));
            cross_x = this.ey.y * v.z - this.ey.z * v.y;
            cross_y = this.ey.z * v.x - this.ey.x * v.z;
            cross_z = this.ey.x * v.y - this.ey.y * v.x;
            r.z = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);
            return r;
        };
        /**
         * Solve A * x = b, where b is a column vector. This is more efficient than
         * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix
         * equation.
         */
        Mat33.prototype.solve22 = function (v) {
            var a11 = this.ex.x;
            var a12 = this.ey.x;
            var a21 = this.ex.y;
            var a22 = this.ey.y;
            var det = a11 * a22 - a12 * a21;
            if (det !== 0.0) {
                det = 1.0 / det;
            }
            var r = Vec2.zero();
            r.x = det * (a22 * v.x - a12 * v.y);
            r.y = det * (a11 * v.y - a21 * v.x);
            return r;
        };
        /**
         * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if
         * singular.
         */
        Mat33.prototype.getInverse22 = function (M) {
            var a = this.ex.x;
            var b = this.ey.x;
            var c = this.ex.y;
            var d = this.ey.y;
            var det = a * d - b * c;
            if (det !== 0.0) {
                det = 1.0 / det;
            }
            M.ex.x = det * d;
            M.ey.x = -det * b;
            M.ex.z = 0.0;
            M.ex.y = -det * c;
            M.ey.y = det * a;
            M.ey.z = 0.0;
            M.ez.x = 0.0;
            M.ez.y = 0.0;
            M.ez.z = 0.0;
        };
        /**
         * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix
         * if singular.
         */
        Mat33.prototype.getSymInverse33 = function (M) {
            var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));
            if (det !== 0.0) {
                det = 1.0 / det;
            }
            var a11 = this.ex.x;
            var a12 = this.ey.x;
            var a13 = this.ez.x;
            var a22 = this.ey.y;
            var a23 = this.ez.y;
            var a33 = this.ez.z;
            M.ex.x = det * (a22 * a33 - a23 * a23);
            M.ex.y = det * (a13 * a23 - a12 * a33);
            M.ex.z = det * (a12 * a23 - a13 * a22);
            M.ey.x = M.ex.y;
            M.ey.y = det * (a11 * a33 - a13 * a13);
            M.ey.z = det * (a13 * a12 - a11 * a23);
            M.ez.x = M.ex.z;
            M.ez.y = M.ey.z;
            M.ez.z = det * (a11 * a22 - a12 * a12);
        };
        Mat33.mul = function (a, b) {
            if (b && 'z' in b && 'y' in b && 'x' in b) {
                var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
                var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
                var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
                return new Vec3(x, y, z);
            }
            else if (b && 'y' in b && 'x' in b) {
                var x = a.ex.x * b.x + a.ey.x * b.y;
                var y = a.ex.y * b.x + a.ey.y * b.y;
                return Vec2.neo(x, y);
            }
        };
        Mat33.mulVec3 = function (a, b) {
            var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
            var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
            var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
            return new Vec3(x, y, z);
        };
        Mat33.mulVec2 = function (a, b) {
            var x = a.ex.x * b.x + a.ey.x * b.y;
            var y = a.ex.y * b.x + a.ey.y * b.y;
            return Vec2.neo(x, y);
        };
        Mat33.add = function (a, b) {
            return new Mat33(Vec3.add(a.ex, b.ex), Vec3.add(a.ey, b.ey), Vec3.add(a.ez, b.ez));
        };
        return Mat33;
    }());

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$4 = Math.abs;
    // todo: use string?
    /** @internal */ var LimitState$2;
    (function (LimitState) {
        LimitState[LimitState["inactiveLimit"] = 0] = "inactiveLimit";
        LimitState[LimitState["atLowerLimit"] = 1] = "atLowerLimit";
        LimitState[LimitState["atUpperLimit"] = 2] = "atUpperLimit";
        LimitState[LimitState["equalLimits"] = 3] = "equalLimits";
    })(LimitState$2 || (LimitState$2 = {}));
    /** @internal */ var DEFAULTS$8 = {
        lowerAngle: 0.0,
        upperAngle: 0.0,
        maxMotorTorque: 0.0,
        motorSpeed: 0.0,
        enableLimit: false,
        enableMotor: false
    };
    /**
     * A revolute joint constrains two bodies to share a common point while they are
     * free to rotate about the point. The relative rotation about the shared point
     * is the joint angle. You can limit the relative rotation with a joint limit
     * that specifies a lower and upper angle. You can use a motor to drive the
     * relative rotation about the shared point. A maximum motor torque is provided
     * so that infinite forces are not generated.
     */
    var RevoluteJoint = /** @class */ (function (_super) {
        __extends(RevoluteJoint, _super);
        function RevoluteJoint(def, bodyA, bodyB, anchor) {
            var _a, _b, _c, _d, _e, _f;
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof RevoluteJoint)) {
                return new RevoluteJoint(def, bodyA, bodyB, anchor);
            }
            def = def !== null && def !== void 0 ? def : {};
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_mass = new Mat33();
            _this.m_limitState = LimitState$2.inactiveLimit;
            _this.m_type = RevoluteJoint.TYPE;
            if (Vec2.isValid(anchor)) {
                _this.m_localAnchorA = bodyA.getLocalPoint(anchor);
            }
            else if (Vec2.isValid(def.localAnchorA)) {
                _this.m_localAnchorA = Vec2.clone(def.localAnchorA);
            }
            else {
                _this.m_localAnchorA = Vec2.zero();
            }
            if (Vec2.isValid(anchor)) {
                _this.m_localAnchorB = bodyB.getLocalPoint(anchor);
            }
            else if (Vec2.isValid(def.localAnchorB)) {
                _this.m_localAnchorB = Vec2.clone(def.localAnchorB);
            }
            else {
                _this.m_localAnchorB = Vec2.zero();
            }
            if (Number.isFinite(def.referenceAngle)) {
                _this.m_referenceAngle = def.referenceAngle;
            }
            else {
                _this.m_referenceAngle = bodyB.getAngle() - bodyA.getAngle();
            }
            _this.m_impulse = new Vec3();
            _this.m_motorImpulse = 0.0;
            _this.m_lowerAngle = (_a = def.lowerAngle) !== null && _a !== void 0 ? _a : DEFAULTS$8.lowerAngle;
            _this.m_upperAngle = (_b = def.upperAngle) !== null && _b !== void 0 ? _b : DEFAULTS$8.upperAngle;
            _this.m_maxMotorTorque = (_c = def.maxMotorTorque) !== null && _c !== void 0 ? _c : DEFAULTS$8.maxMotorTorque;
            _this.m_motorSpeed = (_d = def.motorSpeed) !== null && _d !== void 0 ? _d : DEFAULTS$8.motorSpeed;
            _this.m_enableLimit = (_e = def.enableLimit) !== null && _e !== void 0 ? _e : DEFAULTS$8.enableLimit;
            _this.m_enableMotor = (_f = def.enableMotor) !== null && _f !== void 0 ? _f : DEFAULTS$8.enableMotor;
            return _this;
            // Point-to-point constraint
            // C = p2 - p1
            // Cdot = v2 - v1
            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
            // J = [-I -r1_skew I r2_skew ]
            // Identity used:
            // w k % (rx i + ry j) = w * (-ry i + rx j)
            // Motor constraint
            // Cdot = w2 - w1
            // J = [0 0 -1 0 0 1]
            // K = invI1 + invI2
        }
        /** @internal */
        RevoluteJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                lowerAngle: this.m_lowerAngle,
                upperAngle: this.m_upperAngle,
                maxMotorTorque: this.m_maxMotorTorque,
                motorSpeed: this.m_motorSpeed,
                enableLimit: this.m_enableLimit,
                enableMotor: this.m_enableMotor,
                localAnchorA: this.m_localAnchorA,
                localAnchorB: this.m_localAnchorB,
                referenceAngle: this.m_referenceAngle,
            };
        };
        /** @internal */
        RevoluteJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            var joint = new RevoluteJoint(data);
            return joint;
        };
        /** @internal */
        RevoluteJoint.prototype._setAnchors = function (def) {
            if (def.anchorA) {
                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
            }
            else if (def.localAnchorA) {
                this.m_localAnchorA.setVec2(def.localAnchorA);
            }
            if (def.anchorB) {
                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
            }
            else if (def.localAnchorB) {
                this.m_localAnchorB.setVec2(def.localAnchorB);
            }
        };
        /**
         * The local anchor point relative to bodyA's origin.
         */
        RevoluteJoint.prototype.getLocalAnchorA = function () {
            return this.m_localAnchorA;
        };
        /**
         * The local anchor point relative to bodyB's origin.
         */
        RevoluteJoint.prototype.getLocalAnchorB = function () {
            return this.m_localAnchorB;
        };
        /**
         * Get the reference angle.
         */
        RevoluteJoint.prototype.getReferenceAngle = function () {
            return this.m_referenceAngle;
        };
        /**
         * Get the current joint angle in radians.
         */
        RevoluteJoint.prototype.getJointAngle = function () {
            var bA = this.m_bodyA;
            var bB = this.m_bodyB;
            return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
        };
        /**
         * Get the current joint angle speed in radians per second.
         */
        RevoluteJoint.prototype.getJointSpeed = function () {
            var bA = this.m_bodyA;
            var bB = this.m_bodyB;
            return bB.m_angularVelocity - bA.m_angularVelocity;
        };
        /**
         * Is the joint motor enabled?
         */
        RevoluteJoint.prototype.isMotorEnabled = function () {
            return this.m_enableMotor;
        };
        /**
         * Enable/disable the joint motor.
         */
        RevoluteJoint.prototype.enableMotor = function (flag) {
            if (flag == this.m_enableMotor)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_enableMotor = flag;
        };
        /**
         * Get the current motor torque given the inverse time step. Unit is N*m.
         */
        RevoluteJoint.prototype.getMotorTorque = function (inv_dt) {
            return inv_dt * this.m_motorImpulse;
        };
        /**
         * Set the motor speed in radians per second.
         */
        RevoluteJoint.prototype.setMotorSpeed = function (speed) {
            if (speed == this.m_motorSpeed)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_motorSpeed = speed;
        };
        /**
         * Get the motor speed in radians per second.
         */
        RevoluteJoint.prototype.getMotorSpeed = function () {
            return this.m_motorSpeed;
        };
        /**
         * Set the maximum motor torque, usually in N-m.
         */
        RevoluteJoint.prototype.setMaxMotorTorque = function (torque) {
            if (torque == this.m_maxMotorTorque)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_maxMotorTorque = torque;
        };
        RevoluteJoint.prototype.getMaxMotorTorque = function () {
            return this.m_maxMotorTorque;
        };
        /**
         * Is the joint limit enabled?
         */
        RevoluteJoint.prototype.isLimitEnabled = function () {
            return this.m_enableLimit;
        };
        /**
         * Enable/disable the joint limit.
         */
        RevoluteJoint.prototype.enableLimit = function (flag) {
            if (flag != this.m_enableLimit) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_enableLimit = flag;
                this.m_impulse.z = 0.0;
            }
        };
        /**
         * Get the lower joint limit in radians.
         */
        RevoluteJoint.prototype.getLowerLimit = function () {
            return this.m_lowerAngle;
        };
        /**
         * Get the upper joint limit in radians.
         */
        RevoluteJoint.prototype.getUpperLimit = function () {
            return this.m_upperAngle;
        };
        /**
         * Set the joint limits in radians.
         */
        RevoluteJoint.prototype.setLimits = function (lower, upper) {
            if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_impulse.z = 0.0;
                this.m_lowerAngle = lower;
                this.m_upperAngle = upper;
            }
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        RevoluteJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        RevoluteJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force given the inverse time step. Unit is N.
         */
        RevoluteJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
        };
        /**
         * Get the reaction torque due to the joint limit given the inverse time step.
         * Unit is N*m.
         */
        RevoluteJoint.prototype.getReactionTorque = function (inv_dt) {
            return inv_dt * this.m_impulse.z;
        };
        RevoluteJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            // J = [-I -r1_skew I r2_skew]
            // [ 0 -1 0 1]
            // r_skew = [-ry; rx]
            // Matlab
            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var fixedRotation = (iA + iB === 0.0);
            this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
            this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
            this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
            this.m_mass.ex.y = this.m_mass.ey.x;
            this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
            this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
            this.m_mass.ex.z = this.m_mass.ez.x;
            this.m_mass.ey.z = this.m_mass.ez.y;
            this.m_mass.ez.z = iA + iB;
            this.m_motorMass = iA + iB;
            if (this.m_motorMass > 0.0) {
                this.m_motorMass = 1.0 / this.m_motorMass;
            }
            if (this.m_enableMotor == false || fixedRotation) {
                this.m_motorImpulse = 0.0;
            }
            if (this.m_enableLimit && fixedRotation == false) {
                var jointAngle = aB - aA - this.m_referenceAngle;
                if (math_abs$4(this.m_upperAngle - this.m_lowerAngle) < 2.0 * SettingsInternal.angularSlop) {
                    this.m_limitState = LimitState$2.equalLimits;
                }
                else if (jointAngle <= this.m_lowerAngle) {
                    if (this.m_limitState != LimitState$2.atLowerLimit) {
                        this.m_impulse.z = 0.0;
                    }
                    this.m_limitState = LimitState$2.atLowerLimit;
                }
                else if (jointAngle >= this.m_upperAngle) {
                    if (this.m_limitState != LimitState$2.atUpperLimit) {
                        this.m_impulse.z = 0.0;
                    }
                    this.m_limitState = LimitState$2.atUpperLimit;
                }
                else {
                    this.m_limitState = LimitState$2.inactiveLimit;
                    this.m_impulse.z = 0.0;
                }
            }
            else {
                this.m_limitState = LimitState$2.inactiveLimit;
            }
            if (step.warmStarting) {
                // Scale impulses to support a variable time step.
                this.m_impulse.mul(step.dtRatio);
                this.m_motorImpulse *= step.dtRatio;
                var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
                vA.subMul(mA, P);
                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);
                vB.addMul(mB, P);
                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);
            }
            else {
                this.m_impulse.setZero();
                this.m_motorImpulse = 0.0;
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        RevoluteJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var fixedRotation = (iA + iB === 0.0);
            // Solve motor constraint.
            if (this.m_enableMotor && this.m_limitState != LimitState$2.equalLimits && fixedRotation == false) {
                var Cdot = wB - wA - this.m_motorSpeed;
                var impulse = -this.m_motorMass * Cdot;
                var oldImpulse = this.m_motorImpulse;
                var maxImpulse = step.dt * this.m_maxMotorTorque;
                this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                impulse = this.m_motorImpulse - oldImpulse;
                wA -= iA * impulse;
                wB += iB * impulse;
            }
            // Solve limit constraint.
            if (this.m_enableLimit && this.m_limitState != LimitState$2.inactiveLimit && fixedRotation == false) {
                var Cdot1 = Vec2.zero();
                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));
                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));
                var Cdot2 = wB - wA;
                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);
                var impulse = Vec3.neg(this.m_mass.solve33(Cdot));
                if (this.m_limitState == LimitState$2.equalLimits) {
                    this.m_impulse.add(impulse);
                }
                else if (this.m_limitState == LimitState$2.atLowerLimit) {
                    var newImpulse = this.m_impulse.z + impulse.z;
                    if (newImpulse < 0.0) {
                        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));
                        var reduced = this.m_mass.solve22(rhs);
                        impulse.x = reduced.x;
                        impulse.y = reduced.y;
                        impulse.z = -this.m_impulse.z;
                        this.m_impulse.x += reduced.x;
                        this.m_impulse.y += reduced.y;
                        this.m_impulse.z = 0.0;
                    }
                    else {
                        this.m_impulse.add(impulse);
                    }
                }
                else if (this.m_limitState == LimitState$2.atUpperLimit) {
                    var newImpulse = this.m_impulse.z + impulse.z;
                    if (newImpulse > 0.0) {
                        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));
                        var reduced = this.m_mass.solve22(rhs);
                        impulse.x = reduced.x;
                        impulse.y = reduced.y;
                        impulse.z = -this.m_impulse.z;
                        this.m_impulse.x += reduced.x;
                        this.m_impulse.y += reduced.y;
                        this.m_impulse.z = 0.0;
                    }
                    else {
                        this.m_impulse.add(impulse);
                    }
                }
                var P = Vec2.neo(impulse.x, impulse.y);
                vA.subMul(mA, P);
                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);
                vB.addMul(mB, P);
                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);
            }
            else {
                // Solve point-to-point constraint
                var Cdot = Vec2.zero();
                Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));
                Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));
                var impulse = this.m_mass.solve22(Vec2.neg(Cdot));
                this.m_impulse.x += impulse.x;
                this.m_impulse.y += impulse.y;
                vA.subMul(mA, impulse);
                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);
                vB.addMul(mB, impulse);
                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        RevoluteJoint.prototype.solvePositionConstraints = function (step) {
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var angularError = 0.0;
            var positionError = 0.0;
            var fixedRotation = (this.m_invIA + this.m_invIB == 0.0);
            // Solve angular limit constraint.
            if (this.m_enableLimit && this.m_limitState != LimitState$2.inactiveLimit && fixedRotation == false) {
                var angle = aB - aA - this.m_referenceAngle;
                var limitImpulse = 0.0;
                if (this.m_limitState == LimitState$2.equalLimits) {
                    // Prevent large angular corrections
                    var C = clamp(angle - this.m_lowerAngle, -SettingsInternal.maxAngularCorrection, SettingsInternal.maxAngularCorrection);
                    limitImpulse = -this.m_motorMass * C;
                    angularError = math_abs$4(C);
                }
                else if (this.m_limitState == LimitState$2.atLowerLimit) {
                    var C = angle - this.m_lowerAngle;
                    angularError = -C;
                    // Prevent large angular corrections and allow some slop.
                    C = clamp(C + SettingsInternal.angularSlop, -SettingsInternal.maxAngularCorrection, 0.0);
                    limitImpulse = -this.m_motorMass * C;
                }
                else if (this.m_limitState == LimitState$2.atUpperLimit) {
                    var C = angle - this.m_upperAngle;
                    angularError = C;
                    // Prevent large angular corrections and allow some slop.
                    C = clamp(C - SettingsInternal.angularSlop, 0.0, SettingsInternal.maxAngularCorrection);
                    limitImpulse = -this.m_motorMass * C;
                }
                aA -= this.m_invIA * limitImpulse;
                aB += this.m_invIB * limitImpulse;
            }
            // Solve point-to-point constraint.
            {
                qA.setAngle(aA);
                qB.setAngle(aB);
                var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
                var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
                var C = Vec2.zero();
                C.addCombine(1, cB, 1, rB);
                C.subCombine(1, cA, 1, rA);
                positionError = C.length();
                var mA = this.m_invMassA;
                var mB = this.m_invMassB;
                var iA = this.m_invIA;
                var iB = this.m_invIB;
                var K = new Mat22();
                K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
                K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
                K.ey.x = K.ex.y;
                K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
                var impulse = Vec2.neg(K.solve(C));
                cA.subMul(mA, impulse);
                aA -= iA * Vec2.crossVec2Vec2(rA, impulse);
                cB.addMul(mB, impulse);
                aB += iB * Vec2.crossVec2Vec2(rB, impulse);
            }
            this.m_bodyA.c_position.c.setVec2(cA);
            this.m_bodyA.c_position.a = aA;
            this.m_bodyB.c_position.c.setVec2(cB);
            this.m_bodyB.c_position.a = aB;
            return positionError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;
        };
        RevoluteJoint.TYPE = 'revolute-joint';
        return RevoluteJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$3 = Math.abs;
    /** @internal */ var math_max = Math.max;
    /** @internal */ var math_min$2 = Math.min;
    /** @internal */ var LimitState$1;
    (function (LimitState) {
        LimitState[LimitState["inactiveLimit"] = 0] = "inactiveLimit";
        LimitState[LimitState["atLowerLimit"] = 1] = "atLowerLimit";
        LimitState[LimitState["atUpperLimit"] = 2] = "atUpperLimit";
        LimitState[LimitState["equalLimits"] = 3] = "equalLimits";
    })(LimitState$1 || (LimitState$1 = {}));
    /** @internal */ var DEFAULTS$7 = {
        enableLimit: false,
        lowerTranslation: 0.0,
        upperTranslation: 0.0,
        enableMotor: false,
        maxMotorForce: 0.0,
        motorSpeed: 0.0
    };
    /**
     * A prismatic joint. This joint provides one degree of freedom: translation
     * along an axis fixed in bodyA. Relative rotation is prevented. You can use a
     * joint limit to restrict the range of motion and a joint motor to drive the
     * motion or to model joint friction.
     */
    var PrismaticJoint = /** @class */ (function (_super) {
        __extends(PrismaticJoint, _super);
        function PrismaticJoint(def, bodyA, bodyB, anchor, axis) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof PrismaticJoint)) {
                return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);
            }
            def = options(def, DEFAULTS$7);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = PrismaticJoint.TYPE;
            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
            _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));
            _this.m_localXAxisA.normalize();
            _this.m_localYAxisA = Vec2.crossNumVec2(1.0, _this.m_localXAxisA);
            _this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();
            _this.m_impulse = new Vec3();
            _this.m_motorMass = 0.0;
            _this.m_motorImpulse = 0.0;
            _this.m_lowerTranslation = def.lowerTranslation;
            _this.m_upperTranslation = def.upperTranslation;
            _this.m_maxMotorForce = def.maxMotorForce;
            _this.m_motorSpeed = def.motorSpeed;
            _this.m_enableLimit = def.enableLimit;
            _this.m_enableMotor = def.enableMotor;
            _this.m_limitState = LimitState$1.inactiveLimit;
            _this.m_axis = Vec2.zero();
            _this.m_perp = Vec2.zero();
            _this.m_K = new Mat33();
            return _this;
            // Linear constraint (point-to-line)
            // d = p2 - p1 = x2 + r2 - x1 - r1
            // C = dot(perp, d)
            // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -
            // cross(w1, r1))
            // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +
            // dot(cross(r2, perp), v2)
            // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]
            //
            // Angular constraint
            // C = a2 - a1 + a_initial
            // Cdot = w2 - w1
            // J = [0 0 -1 0 0 1]
            //
            // K = J * invM * JT
            //
            // J = [-a -s1 a s2]
            // [0 -1 0 1]
            // a = perp
            // s1 = cross(d + r1, a) = cross(p2 - x1, a)
            // s2 = cross(r2, a) = cross(p2 - x2, a)
            // Motor/Limit linear constraint
            // C = dot(ax1, d)
            // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +
            // dot(cross(r2, ax1), v2)
            // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]
            // Block Solver
            // We develop a block solver that includes the joint limit. This makes the
            // limit stiff (inelastic) even
            // when the mass has poor distribution (leading to large torques about the
            // joint anchor points).
            //
            // The Jacobian has 3 rows:
            // J = [-uT -s1 uT s2] // linear
            // [0 -1 0 1] // angular
            // [-vT -a1 vT a2] // limit
            //
            // u = perp
            // v = axis
            // s1 = cross(d + r1, u), s2 = cross(r2, u)
            // a1 = cross(d + r1, v), a2 = cross(r2, v)
            // M * (v2 - v1) = JT * df
            // J * v2 = bias
            //
            // v2 = v1 + invM * JT * df
            // J * (v1 + invM * JT * df) = bias
            // K * df = bias - J * v1 = -Cdot
            // K = J * invM * JT
            // Cdot = J * v1 - bias
            //
            // Now solve for f2.
            // df = f2 - f1
            // K * (f2 - f1) = -Cdot
            // f2 = invK * (-Cdot) + f1
            //
            // Clamp accumulated limit impulse.
            // lower: f2(3) = max(f2(3), 0)
            // upper: f2(3) = min(f2(3), 0)
            //
            // Solve for correct f2(1:2)
            // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1
            // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)
            // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +
            // K(1:2,1:2) * f1(1:2)
            // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +
            // f1(1:2)
            //
            // Now compute impulse to be applied:
            // df = f2 - f1
        }
        /** @internal */
        PrismaticJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                lowerTranslation: this.m_lowerTranslation,
                upperTranslation: this.m_upperTranslation,
                maxMotorForce: this.m_maxMotorForce,
                motorSpeed: this.m_motorSpeed,
                enableLimit: this.m_enableLimit,
                enableMotor: this.m_enableMotor,
                localAnchorA: this.m_localAnchorA,
                localAnchorB: this.m_localAnchorB,
                localAxisA: this.m_localXAxisA,
                referenceAngle: this.m_referenceAngle,
            };
        };
        /** @internal */
        PrismaticJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            data.localAxisA = Vec2.clone(data.localAxisA);
            var joint = new PrismaticJoint(data);
            return joint;
        };
        /** @internal */
        PrismaticJoint.prototype._setAnchors = function (def) {
            if (def.anchorA) {
                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
            }
            else if (def.localAnchorA) {
                this.m_localAnchorA.setVec2(def.localAnchorA);
            }
            if (def.anchorB) {
                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
            }
            else if (def.localAnchorB) {
                this.m_localAnchorB.setVec2(def.localAnchorB);
            }
            if (def.localAxisA) {
                this.m_localXAxisA.setVec2(def.localAxisA);
                this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));
            }
        };
        /**
         * The local anchor point relative to bodyA's origin.
         */
        PrismaticJoint.prototype.getLocalAnchorA = function () {
            return this.m_localAnchorA;
        };
        /**
         * The local anchor point relative to bodyB's origin.
         */
        PrismaticJoint.prototype.getLocalAnchorB = function () {
            return this.m_localAnchorB;
        };
        /**
         * The local joint axis relative to bodyA.
         */
        PrismaticJoint.prototype.getLocalAxisA = function () {
            return this.m_localXAxisA;
        };
        /**
         * Get the reference angle.
         */
        PrismaticJoint.prototype.getReferenceAngle = function () {
            return this.m_referenceAngle;
        };
        /**
         * Get the current joint translation, usually in meters.
         */
        PrismaticJoint.prototype.getJointTranslation = function () {
            var pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
            var pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
            var d = Vec2.sub(pB, pA);
            var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);
            var translation = Vec2.dot(d, axis);
            return translation;
        };
        /**
         * Get the current joint translation speed, usually in meters per second.
         */
        PrismaticJoint.prototype.getJointSpeed = function () {
            var bA = this.m_bodyA;
            var bB = this.m_bodyB;
            var rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter));
            var rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter));
            var p1 = Vec2.add(bA.m_sweep.c, rA);
            var p2 = Vec2.add(bB.m_sweep.c, rB);
            var d = Vec2.sub(p2, p1);
            var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA);
            var vA = bA.m_linearVelocity;
            var vB = bB.m_linearVelocity;
            var wA = bA.m_angularVelocity;
            var wB = bB.m_angularVelocity;
            var speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis)) + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA)));
            return speed;
        };
        /**
         * Is the joint limit enabled?
         */
        PrismaticJoint.prototype.isLimitEnabled = function () {
            return this.m_enableLimit;
        };
        /**
         * Enable/disable the joint limit.
         */
        PrismaticJoint.prototype.enableLimit = function (flag) {
            if (flag != this.m_enableLimit) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_enableLimit = flag;
                this.m_impulse.z = 0.0;
            }
        };
        /**
         * Get the lower joint limit, usually in meters.
         */
        PrismaticJoint.prototype.getLowerLimit = function () {
            return this.m_lowerTranslation;
        };
        /**
         * Get the upper joint limit, usually in meters.
         */
        PrismaticJoint.prototype.getUpperLimit = function () {
            return this.m_upperTranslation;
        };
        /**
         * Set the joint limits, usually in meters.
         */
        PrismaticJoint.prototype.setLimits = function (lower, upper) {
            if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_lowerTranslation = lower;
                this.m_upperTranslation = upper;
                this.m_impulse.z = 0.0;
            }
        };
        /**
         * Is the joint motor enabled?
         */
        PrismaticJoint.prototype.isMotorEnabled = function () {
            return this.m_enableMotor;
        };
        /**
         * Enable/disable the joint motor.
         */
        PrismaticJoint.prototype.enableMotor = function (flag) {
            if (flag == this.m_enableMotor)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_enableMotor = flag;
        };
        /**
         * Set the motor speed, usually in meters per second.
         */
        PrismaticJoint.prototype.setMotorSpeed = function (speed) {
            if (speed == this.m_motorSpeed)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_motorSpeed = speed;
        };
        /**
         * Set the maximum motor force, usually in N.
         */
        PrismaticJoint.prototype.setMaxMotorForce = function (force) {
            if (force == this.m_maxMotorForce)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_maxMotorForce = force;
        };
        PrismaticJoint.prototype.getMaxMotorForce = function () {
            return this.m_maxMotorForce;
        };
        /**
         * Get the motor speed, usually in meters per second.
         */
        PrismaticJoint.prototype.getMotorSpeed = function () {
            return this.m_motorSpeed;
        };
        /**
         * Get the current motor force given the inverse time step, usually in N.
         */
        PrismaticJoint.prototype.getMotorForce = function (inv_dt) {
            return inv_dt * this.m_motorImpulse;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        PrismaticJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        PrismaticJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        PrismaticJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        PrismaticJoint.prototype.getReactionTorque = function (inv_dt) {
            return inv_dt * this.m_impulse.y;
        };
        PrismaticJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            // Compute the effective masses.
            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            var d = Vec2.zero();
            d.addCombine(1, cB, 1, rB);
            d.subCombine(1, cA, 1, rA);
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            // Compute motor Jacobian and effective mass.
            {
                this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);
                this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);
                this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);
                this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2
                    * this.m_a2;
                if (this.m_motorMass > 0.0) {
                    this.m_motorMass = 1.0 / this.m_motorMass;
                }
            }
            // Prismatic constraint.
            {
                this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);
                this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);
                this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);
                Vec2.crossVec2Vec2(rA, this.m_perp);
                var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
                var k12 = iA * this.m_s1 + iB * this.m_s2;
                var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
                var k22 = iA + iB;
                if (k22 == 0.0) {
                    // For bodies with fixed rotation.
                    k22 = 1.0;
                }
                var k23 = iA * this.m_a1 + iB * this.m_a2;
                var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
                this.m_K.ex.set(k11, k12, k13);
                this.m_K.ey.set(k12, k22, k23);
                this.m_K.ez.set(k13, k23, k33);
            }
            // Compute motor and limit terms.
            if (this.m_enableLimit) {
                var jointTranslation = Vec2.dot(this.m_axis, d);
                if (math_abs$3(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * SettingsInternal.linearSlop) {
                    this.m_limitState = LimitState$1.equalLimits;
                }
                else if (jointTranslation <= this.m_lowerTranslation) {
                    if (this.m_limitState != LimitState$1.atLowerLimit) {
                        this.m_limitState = LimitState$1.atLowerLimit;
                        this.m_impulse.z = 0.0;
                    }
                }
                else if (jointTranslation >= this.m_upperTranslation) {
                    if (this.m_limitState != LimitState$1.atUpperLimit) {
                        this.m_limitState = LimitState$1.atUpperLimit;
                        this.m_impulse.z = 0.0;
                    }
                }
                else {
                    this.m_limitState = LimitState$1.inactiveLimit;
                    this.m_impulse.z = 0.0;
                }
            }
            else {
                this.m_limitState = LimitState$1.inactiveLimit;
                this.m_impulse.z = 0.0;
            }
            if (this.m_enableMotor == false) {
                this.m_motorImpulse = 0.0;
            }
            if (step.warmStarting) {
                // Account for variable time step.
                this.m_impulse.mul(step.dtRatio);
                this.m_motorImpulse *= step.dtRatio;
                var P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse
                    + this.m_impulse.z, this.m_axis);
                var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y
                    + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
                var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y
                    + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
                vA.subMul(mA, P);
                wA -= iA * LA;
                vB.addMul(mB, P);
                wB += iB * LB;
            }
            else {
                this.m_impulse.setZero();
                this.m_motorImpulse = 0.0;
            }
            this.m_bodyA.c_velocity.v.setVec2(vA);
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v.setVec2(vB);
            this.m_bodyB.c_velocity.w = wB;
        };
        PrismaticJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            // Solve linear motor constraint.
            if (this.m_enableMotor && this.m_limitState != LimitState$1.equalLimits) {
                var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB
                    - this.m_a1 * wA;
                var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
                var oldImpulse = this.m_motorImpulse;
                var maxImpulse = step.dt * this.m_maxMotorForce;
                this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                impulse = this.m_motorImpulse - oldImpulse;
                var P = Vec2.mulNumVec2(impulse, this.m_axis);
                var LA = impulse * this.m_a1;
                var LB = impulse * this.m_a2;
                vA.subMul(mA, P);
                wA -= iA * LA;
                vB.addMul(mB, P);
                wB += iB * LB;
            }
            var Cdot1 = Vec2.zero();
            Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;
            Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;
            Cdot1.y = wB - wA;
            if (this.m_enableLimit && this.m_limitState != LimitState$1.inactiveLimit) {
                // Solve prismatic and limit constraint in block form.
                var Cdot2 = 0;
                Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;
                Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;
                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);
                var f1 = Vec3.clone(this.m_impulse);
                var df = this.m_K.solve33(Vec3.neg(Cdot));
                this.m_impulse.add(df);
                if (this.m_limitState == LimitState$1.atLowerLimit) {
                    this.m_impulse.z = math_max(this.m_impulse.z, 0.0);
                }
                else if (this.m_limitState == LimitState$1.atUpperLimit) {
                    this.m_impulse.z = math_min$2(this.m_impulse.z, 0.0);
                }
                // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +
                // f1(1:2)
                var b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y));
                var f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y));
                this.m_impulse.x = f2r.x;
                this.m_impulse.y = f2r.y;
                df = Vec3.sub(this.m_impulse, f1);
                var P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis);
                var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;
                var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;
                vA.subMul(mA, P);
                wA -= iA * LA;
                vB.addMul(mB, P);
                wB += iB * LB;
            }
            else {
                // Limit is inactive, just solve the prismatic constraint in block form.
                var df = this.m_K.solve22(Vec2.neg(Cdot1));
                this.m_impulse.x += df.x;
                this.m_impulse.y += df.y;
                var P = Vec2.mulNumVec2(df.x, this.m_perp);
                var LA = df.x * this.m_s1 + df.y;
                var LB = df.x * this.m_s2 + df.y;
                vA.subMul(mA, P);
                wA -= iA * LA;
                vB.addMul(mB, P);
                wB += iB * LB;
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        PrismaticJoint.prototype.solvePositionConstraints = function (step) {
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            // Compute fresh Jacobians
            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            var d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));
            var axis = Rot.mulVec2(qA, this.m_localXAxisA);
            var a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis);
            var a2 = Vec2.crossVec2Vec2(rB, axis);
            var perp = Rot.mulVec2(qA, this.m_localYAxisA);
            var s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp);
            var s2 = Vec2.crossVec2Vec2(rB, perp);
            var impulse = new Vec3();
            var C1 = Vec2.zero();
            C1.x = Vec2.dot(perp, d);
            C1.y = aB - aA - this.m_referenceAngle;
            var linearError = math_abs$3(C1.x);
            var angularError = math_abs$3(C1.y);
            var linearSlop = SettingsInternal.linearSlop;
            var maxLinearCorrection = SettingsInternal.maxLinearCorrection;
            var active = false; // bool
            var C2 = 0.0;
            if (this.m_enableLimit) {
                var translation = Vec2.dot(axis, d);
                if (math_abs$3(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {
                    // Prevent large angular corrections
                    C2 = clamp(translation, -maxLinearCorrection, maxLinearCorrection);
                    linearError = math_max(linearError, math_abs$3(translation));
                    active = true;
                }
                else if (translation <= this.m_lowerTranslation) {
                    // Prevent large linear corrections and allow some slop.
                    C2 = clamp(translation - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0.0);
                    linearError = Math
                        .max(linearError, this.m_lowerTranslation - translation);
                    active = true;
                }
                else if (translation >= this.m_upperTranslation) {
                    // Prevent large linear corrections and allow some slop.
                    C2 = clamp(translation - this.m_upperTranslation - linearSlop, 0.0, maxLinearCorrection);
                    linearError = Math
                        .max(linearError, translation - this.m_upperTranslation);
                    active = true;
                }
            }
            if (active) {
                var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
                var k12 = iA * s1 + iB * s2;
                var k13 = iA * s1 * a1 + iB * s2 * a2;
                var k22 = iA + iB;
                if (k22 == 0.0) {
                    // For fixed rotation
                    k22 = 1.0;
                }
                var k23 = iA * a1 + iB * a2;
                var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
                var K = new Mat33();
                K.ex.set(k11, k12, k13);
                K.ey.set(k12, k22, k23);
                K.ez.set(k13, k23, k33);
                var C = new Vec3();
                C.x = C1.x;
                C.y = C1.y;
                C.z = C2;
                impulse = K.solve33(Vec3.neg(C));
            }
            else {
                var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
                var k12 = iA * s1 + iB * s2;
                var k22 = iA + iB;
                if (k22 == 0.0) {
                    k22 = 1.0;
                }
                var K = new Mat22();
                K.ex.setNum(k11, k12);
                K.ey.setNum(k12, k22);
                var impulse1 = K.solve(Vec2.neg(C1));
                impulse.x = impulse1.x;
                impulse.y = impulse1.y;
                impulse.z = 0.0;
            }
            var P = Vec2.combine(impulse.x, perp, impulse.z, axis);
            var LA = impulse.x * s1 + impulse.y + impulse.z * a1;
            var LB = impulse.x * s2 + impulse.y + impulse.z * a2;
            cA.subMul(mA, P);
            aA -= iA * LA;
            cB.addMul(mB, P);
            aB += iB * LB;
            this.m_bodyA.c_position.c = cA;
            this.m_bodyA.c_position.a = aA;
            this.m_bodyB.c_position.c = cB;
            this.m_bodyB.c_position.a = aB;
            return linearError <= SettingsInternal.linearSlop
                && angularError <= SettingsInternal.angularSlop;
        };
        PrismaticJoint.TYPE = 'prismatic-joint';
        return PrismaticJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var DEFAULTS$6 = {
        ratio: 1.0
    };
    /**
     * A gear joint is used to connect two joints together. Either joint can be a
     * revolute or prismatic joint. You specify a gear ratio to bind the motions
     * together: coordinate1 + ratio * coordinate2 = constant
     *
     * The ratio can be negative or positive. If one joint is a revolute joint and
     * the other joint is a prismatic joint, then the ratio will have units of
     * length or units of 1/length. Warning: You have to manually destroy the gear
     * joint if joint1 or joint2 is destroyed.
     *
     * This definition requires two existing revolute or prismatic joints (any
     * combination will work).
     */
    var GearJoint = /** @class */ (function (_super) {
        __extends(GearJoint, _super);
        function GearJoint(def, bodyA, bodyB, joint1, joint2, ratio) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof GearJoint)) {
                return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);
            }
            def = options(def, DEFAULTS$6);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = GearJoint.TYPE;
            _this.m_joint1 = joint1 ? joint1 : def.joint1;
            _this.m_joint2 = joint2 ? joint2 : def.joint2;
            _this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;
            _this.m_type1 = _this.m_joint1.getType();
            _this.m_type2 = _this.m_joint2.getType();
            // joint1 connects body A to body C
            // joint2 connects body B to body D
            var coordinateA;
            var coordinateB;
            // TODO_ERIN there might be some problem with the joint edges in Joint.
            _this.m_bodyC = _this.m_joint1.getBodyA();
            _this.m_bodyA = _this.m_joint1.getBodyB();
            // Get geometry of joint1
            var xfA = _this.m_bodyA.m_xf;
            var aA = _this.m_bodyA.m_sweep.a;
            var xfC = _this.m_bodyC.m_xf;
            var aC = _this.m_bodyC.m_sweep.a;
            if (_this.m_type1 === RevoluteJoint.TYPE) {
                var revolute = _this.m_joint1;
                _this.m_localAnchorC = revolute.m_localAnchorA;
                _this.m_localAnchorA = revolute.m_localAnchorB;
                _this.m_referenceAngleA = revolute.m_referenceAngle;
                _this.m_localAxisC = Vec2.zero();
                coordinateA = aA - aC - _this.m_referenceAngleA;
            }
            else {
                var prismatic = _this.m_joint1;
                _this.m_localAnchorC = prismatic.m_localAnchorA;
                _this.m_localAnchorA = prismatic.m_localAnchorB;
                _this.m_referenceAngleA = prismatic.m_referenceAngle;
                _this.m_localAxisC = prismatic.m_localXAxisA;
                var pC = _this.m_localAnchorC;
                var pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, _this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));
                coordinateA = Vec2.dot(pA, _this.m_localAxisC) - Vec2.dot(pC, _this.m_localAxisC);
            }
            _this.m_bodyD = _this.m_joint2.getBodyA();
            _this.m_bodyB = _this.m_joint2.getBodyB();
            // Get geometry of joint2
            var xfB = _this.m_bodyB.m_xf;
            var aB = _this.m_bodyB.m_sweep.a;
            var xfD = _this.m_bodyD.m_xf;
            var aD = _this.m_bodyD.m_sweep.a;
            if (_this.m_type2 === RevoluteJoint.TYPE) {
                var revolute = _this.m_joint2;
                _this.m_localAnchorD = revolute.m_localAnchorA;
                _this.m_localAnchorB = revolute.m_localAnchorB;
                _this.m_referenceAngleB = revolute.m_referenceAngle;
                _this.m_localAxisD = Vec2.zero();
                coordinateB = aB - aD - _this.m_referenceAngleB;
            }
            else {
                var prismatic = _this.m_joint2;
                _this.m_localAnchorD = prismatic.m_localAnchorA;
                _this.m_localAnchorB = prismatic.m_localAnchorB;
                _this.m_referenceAngleB = prismatic.m_referenceAngle;
                _this.m_localAxisD = prismatic.m_localXAxisA;
                var pD = _this.m_localAnchorD;
                var pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, _this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));
                coordinateB = Vec2.dot(pB, _this.m_localAxisD) - Vec2.dot(pD, _this.m_localAxisD);
            }
            _this.m_constant = coordinateA + _this.m_ratio * coordinateB;
            _this.m_impulse = 0.0;
            return _this;
            // Gear Joint:
            // C0 = (coordinate1 + ratio * coordinate2)_initial
            // C = (coordinate1 + ratio * coordinate2) - C0 = 0
            // J = [J1 ratio * J2]
            // K = J * invM * JT
            // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T
            //
            // Revolute:
            // coordinate = rotation
            // Cdot = angularVelocity
            // J = [0 0 1]
            // K = J * invM * JT = invI
            //
            // Prismatic:
            // coordinate = dot(p - pg, ug)
            // Cdot = dot(v + cross(w, r), ug)
            // J = [ug cross(r, ug)]
            // K = J * invM * JT = invMass + invI * cross(r, ug)^2
        }
        /** @internal */
        GearJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                joint1: this.m_joint1,
                joint2: this.m_joint2,
                ratio: this.m_ratio,
                // _constant: this.m_constant,
            };
        };
        /** @internal */
        GearJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            data.joint1 = restore(Joint, data.joint1, world);
            data.joint2 = restore(Joint, data.joint2, world);
            var joint = new GearJoint(data);
            // if (data._constant) joint.m_constant = data._constant;
            return joint;
        };
        /**
         * Get the first joint.
         */
        GearJoint.prototype.getJoint1 = function () {
            return this.m_joint1;
        };
        /**
         * Get the second joint.
         */
        GearJoint.prototype.getJoint2 = function () {
            return this.m_joint2;
        };
        /**
         * Set the gear ratio.
         */
        GearJoint.prototype.setRatio = function (ratio) {
            this.m_ratio = ratio;
        };
        /**
         * Get the gear ratio.
         */
        GearJoint.prototype.getRatio = function () {
            return this.m_ratio;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        GearJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        GearJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        GearJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        GearJoint.prototype.getReactionTorque = function (inv_dt) {
            var L = this.m_impulse * this.m_JwA;
            return inv_dt * L;
        };
        GearJoint.prototype.initVelocityConstraints = function (step) {
            this.m_lcA = this.m_bodyA.m_sweep.localCenter;
            this.m_lcB = this.m_bodyB.m_sweep.localCenter;
            this.m_lcC = this.m_bodyC.m_sweep.localCenter;
            this.m_lcD = this.m_bodyD.m_sweep.localCenter;
            this.m_mA = this.m_bodyA.m_invMass;
            this.m_mB = this.m_bodyB.m_invMass;
            this.m_mC = this.m_bodyC.m_invMass;
            this.m_mD = this.m_bodyD.m_invMass;
            this.m_iA = this.m_bodyA.m_invI;
            this.m_iB = this.m_bodyB.m_invI;
            this.m_iC = this.m_bodyC.m_invI;
            this.m_iD = this.m_bodyD.m_invI;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var aC = this.m_bodyC.c_position.a;
            var vC = this.m_bodyC.c_velocity.v;
            var wC = this.m_bodyC.c_velocity.w;
            var aD = this.m_bodyD.c_position.a;
            var vD = this.m_bodyD.c_velocity.v;
            var wD = this.m_bodyD.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var qC = Rot.neo(aC);
            var qD = Rot.neo(aD);
            this.m_mass = 0.0;
            if (this.m_type1 == RevoluteJoint.TYPE) {
                this.m_JvAC = Vec2.zero();
                this.m_JwA = 1.0;
                this.m_JwC = 1.0;
                this.m_mass += this.m_iA + this.m_iC;
            }
            else {
                var u = Rot.mulVec2(qC, this.m_localAxisC);
                var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);
                var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);
                this.m_JvAC = u;
                this.m_JwC = Vec2.crossVec2Vec2(rC, u);
                this.m_JwA = Vec2.crossVec2Vec2(rA, u);
                this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
            }
            if (this.m_type2 == RevoluteJoint.TYPE) {
                this.m_JvBD = Vec2.zero();
                this.m_JwB = this.m_ratio;
                this.m_JwD = this.m_ratio;
                this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
            }
            else {
                var u = Rot.mulVec2(qD, this.m_localAxisD);
                var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
                var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
                this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);
                this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);
                this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);
                this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
            }
            // Compute effective mass.
            this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;
            if (step.warmStarting) {
                vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);
                wA += this.m_iA * this.m_impulse * this.m_JwA;
                vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);
                wB += this.m_iB * this.m_impulse * this.m_JwB;
                vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);
                wC -= this.m_iC * this.m_impulse * this.m_JwC;
                vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);
                wD -= this.m_iD * this.m_impulse * this.m_JwD;
            }
            else {
                this.m_impulse = 0.0;
            }
            this.m_bodyA.c_velocity.v.setVec2(vA);
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v.setVec2(vB);
            this.m_bodyB.c_velocity.w = wB;
            this.m_bodyC.c_velocity.v.setVec2(vC);
            this.m_bodyC.c_velocity.w = wC;
            this.m_bodyD.c_velocity.v.setVec2(vD);
            this.m_bodyD.c_velocity.w = wD;
        };
        GearJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var vC = this.m_bodyC.c_velocity.v;
            var wC = this.m_bodyC.c_velocity.w;
            var vD = this.m_bodyD.c_velocity.v;
            var wD = this.m_bodyD.c_velocity.w;
            var Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC) + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD);
            Cdot += (this.m_JwA * wA - this.m_JwC * wC) + (this.m_JwB * wB - this.m_JwD * wD);
            var impulse = -this.m_mass * Cdot;
            this.m_impulse += impulse;
            vA.addMul(this.m_mA * impulse, this.m_JvAC);
            wA += this.m_iA * impulse * this.m_JwA;
            vB.addMul(this.m_mB * impulse, this.m_JvBD);
            wB += this.m_iB * impulse * this.m_JwB;
            vC.subMul(this.m_mC * impulse, this.m_JvAC);
            wC -= this.m_iC * impulse * this.m_JwC;
            vD.subMul(this.m_mD * impulse, this.m_JvBD);
            wD -= this.m_iD * impulse * this.m_JwD;
            this.m_bodyA.c_velocity.v.setVec2(vA);
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v.setVec2(vB);
            this.m_bodyB.c_velocity.w = wB;
            this.m_bodyC.c_velocity.v.setVec2(vC);
            this.m_bodyC.c_velocity.w = wC;
            this.m_bodyD.c_velocity.v.setVec2(vD);
            this.m_bodyD.c_velocity.w = wD;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        GearJoint.prototype.solvePositionConstraints = function (step) {
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var cC = this.m_bodyC.c_position.c;
            var aC = this.m_bodyC.c_position.a;
            var cD = this.m_bodyD.c_position.c;
            var aD = this.m_bodyD.c_position.a;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var qC = Rot.neo(aC);
            var qD = Rot.neo(aD);
            var linearError = 0.0;
            var coordinateA;
            var coordinateB;
            var JvAC;
            var JvBD;
            var JwA;
            var JwB;
            var JwC;
            var JwD;
            var mass = 0.0;
            if (this.m_type1 == RevoluteJoint.TYPE) {
                JvAC = Vec2.zero();
                JwA = 1.0;
                JwC = 1.0;
                mass += this.m_iA + this.m_iC;
                coordinateA = aA - aC - this.m_referenceAngleA;
            }
            else {
                var u = Rot.mulVec2(qC, this.m_localAxisC);
                var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);
                var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);
                JvAC = u;
                JwC = Vec2.crossVec2Vec2(rC, u);
                JwA = Vec2.crossVec2Vec2(rA, u);
                mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;
                var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC);
                var pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC)));
                coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);
            }
            if (this.m_type2 == RevoluteJoint.TYPE) {
                JvBD = Vec2.zero();
                JwB = this.m_ratio;
                JwD = this.m_ratio;
                mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
                coordinateB = aB - aD - this.m_referenceAngleB;
            }
            else {
                var u = Rot.mulVec2(qD, this.m_localAxisD);
                var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
                var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
                JvBD = Vec2.mulNumVec2(this.m_ratio, u);
                JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);
                JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);
                mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;
                var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD);
                var pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD)));
                coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);
            }
            var C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant;
            var impulse = 0.0;
            if (mass > 0.0) {
                impulse = -C / mass;
            }
            cA.addMul(this.m_mA * impulse, JvAC);
            aA += this.m_iA * impulse * JwA;
            cB.addMul(this.m_mB * impulse, JvBD);
            aB += this.m_iB * impulse * JwB;
            cC.subMul(this.m_mC * impulse, JvAC);
            aC -= this.m_iC * impulse * JwC;
            cD.subMul(this.m_mD * impulse, JvBD);
            aD -= this.m_iD * impulse * JwD;
            this.m_bodyA.c_position.c.setVec2(cA);
            this.m_bodyA.c_position.a = aA;
            this.m_bodyB.c_position.c.setVec2(cB);
            this.m_bodyB.c_position.a = aB;
            this.m_bodyC.c_position.c.setVec2(cC);
            this.m_bodyC.c_position.a = aC;
            this.m_bodyD.c_position.c.setVec2(cD);
            this.m_bodyD.c_position.a = aD;
            // TODO_ERIN not implemented
            return linearError < SettingsInternal.linearSlop;
        };
        GearJoint.TYPE = 'gear-joint';
        return GearJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var DEFAULTS$5 = {
        maxForce: 1.0,
        maxTorque: 1.0,
        correctionFactor: 0.3
    };
    /**
     * A motor joint is used to control the relative motion between two bodies. A
     * typical usage is to control the movement of a dynamic body with respect to
     * the ground.
     */
    var MotorJoint = /** @class */ (function (_super) {
        __extends(MotorJoint, _super);
        function MotorJoint(def, bodyA, bodyB) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof MotorJoint)) {
                return new MotorJoint(def, bodyA, bodyB);
            }
            def = options(def, DEFAULTS$5);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = MotorJoint.TYPE;
            _this.m_linearOffset = Number.isFinite(def.linearOffset) ? Vec2.clone(def.linearOffset) : bodyA.getLocalPoint(bodyB.getPosition());
            _this.m_angularOffset = Number.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();
            _this.m_linearImpulse = Vec2.zero();
            _this.m_angularImpulse = 0.0;
            _this.m_maxForce = def.maxForce;
            _this.m_maxTorque = def.maxTorque;
            _this.m_correctionFactor = def.correctionFactor;
            return _this;
            // Point-to-point constraint
            // Cdot = v2 - v1
            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
            // J = [-I -r1_skew I r2_skew ]
            // Identity used:
            // w k % (rx i + ry j) = w * (-ry i + rx j)
            //
            // r1 = offset - c1
            // r2 = -c2
            // Angle constraint
            // Cdot = w2 - w1
            // J = [0 0 -1 0 0 1]
            // K = invI1 + invI2
        }
        /** @internal */
        MotorJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                maxForce: this.m_maxForce,
                maxTorque: this.m_maxTorque,
                correctionFactor: this.m_correctionFactor,
                linearOffset: this.m_linearOffset,
                angularOffset: this.m_angularOffset,
            };
        };
        /** @internal */
        MotorJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            var joint = new MotorJoint(data);
            return joint;
        };
        /** @internal */
        MotorJoint.prototype._setAnchors = function (def) {
        };
        /**
         * Set the maximum friction force in N.
         */
        MotorJoint.prototype.setMaxForce = function (force) {
            this.m_maxForce = force;
        };
        /**
         * Get the maximum friction force in N.
         */
        MotorJoint.prototype.getMaxForce = function () {
            return this.m_maxForce;
        };
        /**
         * Set the maximum friction torque in N*m.
         */
        MotorJoint.prototype.setMaxTorque = function (torque) {
            this.m_maxTorque = torque;
        };
        /**
         * Get the maximum friction torque in N*m.
         */
        MotorJoint.prototype.getMaxTorque = function () {
            return this.m_maxTorque;
        };
        /**
         * Set the position correction factor in the range [0,1].
         */
        MotorJoint.prototype.setCorrectionFactor = function (factor) {
            this.m_correctionFactor = factor;
        };
        /**
         * Get the position correction factor in the range [0,1].
         */
        MotorJoint.prototype.getCorrectionFactor = function () {
            return this.m_correctionFactor;
        };
        /**
         * Set/get the target linear offset, in frame A, in meters.
         */
        MotorJoint.prototype.setLinearOffset = function (linearOffset) {
            if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_linearOffset.set(linearOffset);
            }
        };
        MotorJoint.prototype.getLinearOffset = function () {
            return this.m_linearOffset;
        };
        /**
         * Set/get the target angular offset, in radians.
         */
        MotorJoint.prototype.setAngularOffset = function (angularOffset) {
            if (angularOffset != this.m_angularOffset) {
                this.m_bodyA.setAwake(true);
                this.m_bodyB.setAwake(true);
                this.m_angularOffset = angularOffset;
            }
        };
        MotorJoint.prototype.getAngularOffset = function () {
            return this.m_angularOffset;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        MotorJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getPosition();
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        MotorJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getPosition();
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        MotorJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        MotorJoint.prototype.getReactionTorque = function (inv_dt) {
            return inv_dt * this.m_angularImpulse;
        };
        MotorJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            // Compute the effective mass matrix.
            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_linearOffset, this.m_localCenterA));
            this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));
            // J = [-I -r1_skew I r2_skew]
            // r_skew = [-ry; rx]
            // Matlab
            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            // Upper 2 by 2 of K for point to point
            var K = new Mat22();
            K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
            K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
            K.ey.x = K.ex.y;
            K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
            this.m_linearMass = K.getInverse();
            this.m_angularMass = iA + iB;
            if (this.m_angularMass > 0.0) {
                this.m_angularMass = 1.0 / this.m_angularMass;
            }
            this.m_linearError = Vec2.zero();
            this.m_linearError.addCombine(1, cB, 1, this.m_rB);
            this.m_linearError.subCombine(1, cA, 1, this.m_rA);
            this.m_angularError = aB - aA - this.m_angularOffset;
            if (step.warmStarting) {
                // Scale impulses to support a variable time step.
                this.m_linearImpulse.mul(step.dtRatio);
                this.m_angularImpulse *= step.dtRatio;
                var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);
                vA.subMul(mA, P);
                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);
                vB.addMul(mB, P);
                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);
            }
            else {
                this.m_linearImpulse.setZero();
                this.m_angularImpulse = 0.0;
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        MotorJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var h = step.dt;
            var inv_h = step.inv_dt;
            // Solve angular friction
            {
                var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
                var impulse = -this.m_angularMass * Cdot;
                var oldImpulse = this.m_angularImpulse;
                var maxImpulse = h * this.m_maxTorque;
                this.m_angularImpulse = clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
                impulse = this.m_angularImpulse - oldImpulse;
                wA -= iA * impulse;
                wB += iB * impulse;
            }
            // Solve linear friction
            {
                var Cdot = Vec2.zero();
                Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));
                Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));
                Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);
                var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));
                var oldImpulse = Vec2.clone(this.m_linearImpulse);
                this.m_linearImpulse.add(impulse);
                var maxImpulse = h * this.m_maxForce;
                this.m_linearImpulse.clamp(maxImpulse);
                impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);
                vA.subMul(mA, impulse);
                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);
                vB.addMul(mB, impulse);
                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        MotorJoint.prototype.solvePositionConstraints = function (step) {
            return true;
        };
        MotorJoint.TYPE = 'motor-joint';
        return MotorJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_PI$2 = Math.PI;
    /** @internal */ var DEFAULTS$4 = {
        maxForce: 0.0,
        frequencyHz: 5.0,
        dampingRatio: 0.7
    };
    /**
     * A mouse joint is used to make a point on a body track a specified world
     * point. This a soft constraint with a maximum force. This allows the
     * constraint to stretch and without applying huge forces.
     *
     * You need to call setTarget(target) every time that mouse is
     * moved, to track the new location of the mouse.
     *
     * NOTE: this joint is not documented in the manual because it was developed to
     * be used in the testbed. If you want to learn how to use the mouse joint, look
     * at the testbed.
     */
    var MouseJoint = /** @class */ (function (_super) {
        __extends(MouseJoint, _super);
        function MouseJoint(def, bodyA, bodyB, target) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof MouseJoint)) {
                return new MouseJoint(def, bodyA, bodyB, target);
            }
            def = options(def, DEFAULTS$4);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = MouseJoint.TYPE;
            if (Vec2.isValid(target)) {
                _this.m_targetA = Vec2.clone(target);
            }
            else if (Vec2.isValid(def.target)) {
                _this.m_targetA = Vec2.clone(def.target);
            }
            else {
                _this.m_targetA = Vec2.zero();
            }
            _this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), _this.m_targetA);
            _this.m_maxForce = def.maxForce;
            _this.m_impulse = Vec2.zero();
            _this.m_frequencyHz = def.frequencyHz;
            _this.m_dampingRatio = def.dampingRatio;
            _this.m_beta = 0.0;
            _this.m_gamma = 0.0;
            // Solver temp
            _this.m_rB = Vec2.zero();
            _this.m_localCenterB = Vec2.zero();
            _this.m_invMassB = 0.0;
            _this.m_invIB = 0.0;
            _this.m_mass = new Mat22();
            _this.m_C = Vec2.zero();
            return _this;
            // p = attached point, m = mouse point
            // C = p - m
            // Cdot = v
            // = v + cross(w, r)
            // J = [I r_skew]
            // Identity used:
            // w k % (rx i + ry j) = w * (-ry i + rx j)
        }
        /** @internal */
        MouseJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                target: this.m_targetA,
                maxForce: this.m_maxForce,
                frequencyHz: this.m_frequencyHz,
                dampingRatio: this.m_dampingRatio,
                _localAnchorB: this.m_localAnchorB,
            };
        };
        /** @internal */
        MouseJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            data.target = Vec2.clone(data.target);
            var joint = new MouseJoint(data);
            if (data._localAnchorB) {
                joint.m_localAnchorB = data._localAnchorB;
            }
            return joint;
        };
        /**
         * Use this to update the target point.
         */
        MouseJoint.prototype.setTarget = function (target) {
            if (Vec2.areEqual(target, this.m_targetA))
                return;
            this.m_bodyB.setAwake(true);
            this.m_targetA.set(target);
        };
        MouseJoint.prototype.getTarget = function () {
            return this.m_targetA;
        };
        /**
         * Set the maximum force in Newtons.
         */
        MouseJoint.prototype.setMaxForce = function (force) {
            this.m_maxForce = force;
        };
        /**
         * Get the maximum force in Newtons.
         */
        MouseJoint.prototype.getMaxForce = function () {
            return this.m_maxForce;
        };
        /**
         * Set the frequency in Hertz.
         */
        MouseJoint.prototype.setFrequency = function (hz) {
            this.m_frequencyHz = hz;
        };
        /**
         * Get the frequency in Hertz.
         */
        MouseJoint.prototype.getFrequency = function () {
            return this.m_frequencyHz;
        };
        /**
         * Set the damping ratio (dimensionless).
         */
        MouseJoint.prototype.setDampingRatio = function (ratio) {
            this.m_dampingRatio = ratio;
        };
        /**
         * Get the damping ratio (dimensionless).
         */
        MouseJoint.prototype.getDampingRatio = function () {
            return this.m_dampingRatio;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        MouseJoint.prototype.getAnchorA = function () {
            return Vec2.clone(this.m_targetA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        MouseJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        MouseJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.mulNumVec2(inv_dt, this.m_impulse);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        MouseJoint.prototype.getReactionTorque = function (inv_dt) {
            return inv_dt * 0.0;
        };
        /**
         * Shift the origin for any points stored in world coordinates.
         */
        MouseJoint.prototype.shiftOrigin = function (newOrigin) {
            this.m_targetA.sub(newOrigin);
        };
        MouseJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIB = this.m_bodyB.m_invI;
            var position = this.m_bodyB.c_position;
            var velocity = this.m_bodyB.c_velocity;
            var cB = position.c;
            var aB = position.a;
            var vB = velocity.v;
            var wB = velocity.w;
            var qB = Rot.neo(aB);
            var mass = this.m_bodyB.getMass();
            // Frequency
            var omega = 2.0 * math_PI$2 * this.m_frequencyHz;
            // Damping coefficient
            var d = 2.0 * mass * this.m_dampingRatio * omega;
            // Spring stiffness
            var k = mass * (omega * omega);
            // magic formulas
            // gamma has units of inverse mass.
            // beta has units of inverse time.
            var h = step.dt;
            this.m_gamma = h * (d + h * k);
            if (this.m_gamma != 0.0) {
                this.m_gamma = 1.0 / this.m_gamma;
            }
            this.m_beta = h * k * this.m_gamma;
            // Compute the effective mass matrix.
            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *
            // invI2 * skew(r2)]
            // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y
            // -r1.x*r1.y]
            // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]
            var K = new Mat22();
            K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y
                + this.m_gamma;
            K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
            K.ey.x = K.ex.y;
            K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x
                + this.m_gamma;
            this.m_mass = K.getInverse();
            this.m_C.setVec2(cB);
            this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);
            this.m_C.mul(this.m_beta);
            // Cheat with some damping
            wB *= 0.98;
            if (step.warmStarting) {
                this.m_impulse.mul(step.dtRatio);
                vB.addMul(this.m_invMassB, this.m_impulse);
                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);
            }
            else {
                this.m_impulse.setZero();
            }
            velocity.v.setVec2(vB);
            velocity.w = wB;
        };
        MouseJoint.prototype.solveVelocityConstraints = function (step) {
            var velocity = this.m_bodyB.c_velocity;
            var vB = Vec2.clone(velocity.v);
            var wB = velocity.w;
            // Cdot = v + cross(w, r)
            var Cdot = Vec2.crossNumVec2(wB, this.m_rB);
            Cdot.add(vB);
            Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);
            Cdot.neg();
            var impulse = Mat22.mulVec2(this.m_mass, Cdot);
            var oldImpulse = Vec2.clone(this.m_impulse);
            this.m_impulse.add(impulse);
            var maxImpulse = step.dt * this.m_maxForce;
            this.m_impulse.clamp(maxImpulse);
            impulse = Vec2.sub(this.m_impulse, oldImpulse);
            vB.addMul(this.m_invMassB, impulse);
            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);
            velocity.v.setVec2(vB);
            velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        MouseJoint.prototype.solvePositionConstraints = function (step) {
            return true;
        };
        MouseJoint.TYPE = 'mouse-joint';
        return MouseJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$2 = Math.abs;
    /** @internal */ var DEFAULTS$3 = {
        collideConnected: true
    };
    /**
     * The pulley joint is connected to two bodies and two fixed ground points. The
     * pulley supports a ratio such that: length1 + ratio * length2 <= constant
     *
     * Yes, the force transmitted is scaled by the ratio.
     *
     * Warning: the pulley joint can get a bit squirrelly by itself. They often work
     * better when combined with prismatic joints. You should also cover the the
     * anchor points with static shapes to prevent one side from going to zero
     * length.
     */
    var PulleyJoint = /** @class */ (function (_super) {
        __extends(PulleyJoint, _super);
        function PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof PulleyJoint)) {
                return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);
            }
            def = options(def, DEFAULTS$3);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = PulleyJoint.TYPE;
            _this.m_groundAnchorA = Vec2.clone(groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0));
            _this.m_groundAnchorB = Vec2.clone(groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0));
            _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0));
            _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0));
            _this.m_lengthA = Number.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);
            _this.m_lengthB = Number.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);
            _this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;
            _this.m_constant = _this.m_lengthA + _this.m_ratio * _this.m_lengthB;
            _this.m_impulse = 0.0;
            return _this;
            // Pulley:
            // length1 = norm(p1 - s1)
            // length2 = norm(p2 - s2)
            // C0 = (length1 + ratio * length2)_initial
            // C = C0 - (length1 + ratio * length2)
            // u1 = (p1 - s1) / norm(p1 - s1)
            // u2 = (p2 - s2) / norm(p2 - s2)
            // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))
            // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]
            // K = J * invM * JT
            // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *
            // cross(r2, u2)^2)
        }
        PulleyJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                groundAnchorA: this.m_groundAnchorA,
                groundAnchorB: this.m_groundAnchorB,
                localAnchorA: this.m_localAnchorA,
                localAnchorB: this.m_localAnchorB,
                lengthA: this.m_lengthA,
                lengthB: this.m_lengthB,
                ratio: this.m_ratio,
            };
        };
        /** @internal */
        PulleyJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            var joint = new PulleyJoint(data);
            return joint;
        };
        /**
         * Get the first ground anchor.
         */
        PulleyJoint.prototype.getGroundAnchorA = function () {
            return this.m_groundAnchorA;
        };
        /**
         * Get the second ground anchor.
         */
        PulleyJoint.prototype.getGroundAnchorB = function () {
            return this.m_groundAnchorB;
        };
        /**
         * Get the current length of the segment attached to bodyA.
         */
        PulleyJoint.prototype.getLengthA = function () {
            return this.m_lengthA;
        };
        /**
         * Get the current length of the segment attached to bodyB.
         */
        PulleyJoint.prototype.getLengthB = function () {
            return this.m_lengthB;
        };
        /**
         * Get the pulley ratio.
         */
        PulleyJoint.prototype.getRatio = function () {
            return this.m_ratio;
        };
        /**
         * Get the current length of the segment attached to bodyA.
         */
        PulleyJoint.prototype.getCurrentLengthA = function () {
            var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
            var s = this.m_groundAnchorA;
            return Vec2.distance(p, s);
        };
        /**
         * Get the current length of the segment attached to bodyB.
         */
        PulleyJoint.prototype.getCurrentLengthB = function () {
            var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
            var s = this.m_groundAnchorB;
            return Vec2.distance(p, s);
        };
        /**
         * Shift the origin for any points stored in world coordinates.
         *
         * @param newOrigin
         */
        PulleyJoint.prototype.shiftOrigin = function (newOrigin) {
            this.m_groundAnchorA.sub(newOrigin);
            this.m_groundAnchorB.sub(newOrigin);
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        PulleyJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        PulleyJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        PulleyJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        PulleyJoint.prototype.getReactionTorque = function (inv_dt) {
            return 0.0;
        };
        PulleyJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            // Get the pulley axes.
            this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);
            this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);
            var lengthA = this.m_uA.length();
            var lengthB = this.m_uB.length();
            if (lengthA > 10.0 * SettingsInternal.linearSlop) {
                this.m_uA.mul(1.0 / lengthA);
            }
            else {
                this.m_uA.setZero();
            }
            if (lengthB > 10.0 * SettingsInternal.linearSlop) {
                this.m_uB.mul(1.0 / lengthB);
            }
            else {
                this.m_uB.setZero();
            }
            // Compute effective mass.
            var ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA);
            var ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB);
            var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
            var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
            this.m_mass = mA + this.m_ratio * this.m_ratio * mB;
            if (this.m_mass > 0.0) {
                this.m_mass = 1.0 / this.m_mass;
            }
            if (step.warmStarting) {
                // Scale impulses to support variable time steps.
                this.m_impulse *= step.dtRatio;
                // Warm starting.
                var PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);
                var PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);
                vA.addMul(this.m_invMassA, PA);
                wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);
                vB.addMul(this.m_invMassB, PB);
                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);
            }
            else {
                this.m_impulse = 0.0;
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        PulleyJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));
            var vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));
            var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio * Vec2.dot(this.m_uB, vpB);
            var impulse = -this.m_mass * Cdot;
            this.m_impulse += impulse;
            var PA = Vec2.mulNumVec2(-impulse, this.m_uA);
            var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB);
            vA.addMul(this.m_invMassA, PA);
            wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);
            vB.addMul(this.m_invMassB, PB);
            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        PulleyJoint.prototype.solvePositionConstraints = function (step) {
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            // Get the pulley axes.
            var uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);
            var uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);
            var lengthA = uA.length();
            var lengthB = uB.length();
            if (lengthA > 10.0 * SettingsInternal.linearSlop) {
                uA.mul(1.0 / lengthA);
            }
            else {
                uA.setZero();
            }
            if (lengthB > 10.0 * SettingsInternal.linearSlop) {
                uB.mul(1.0 / lengthB);
            }
            else {
                uB.setZero();
            }
            // Compute effective mass.
            var ruA = Vec2.crossVec2Vec2(rA, uA);
            var ruB = Vec2.crossVec2Vec2(rB, uB);
            var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
            var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
            var mass = mA + this.m_ratio * this.m_ratio * mB;
            if (mass > 0.0) {
                mass = 1.0 / mass;
            }
            var C = this.m_constant - lengthA - this.m_ratio * lengthB;
            var linearError = math_abs$2(C);
            var impulse = -mass * C;
            var PA = Vec2.mulNumVec2(-impulse, uA);
            var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB);
            cA.addMul(this.m_invMassA, PA);
            aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);
            cB.addMul(this.m_invMassB, PB);
            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);
            this.m_bodyA.c_position.c = cA;
            this.m_bodyA.c_position.a = aA;
            this.m_bodyB.c_position.c = cB;
            this.m_bodyB.c_position.a = aB;
            return linearError < SettingsInternal.linearSlop;
        };
        PulleyJoint.TYPE = 'pulley-joint';
        return PulleyJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_min$1 = Math.min;
    /** @internal */ var LimitState;
    (function (LimitState) {
        LimitState[LimitState["inactiveLimit"] = 0] = "inactiveLimit";
        LimitState[LimitState["atLowerLimit"] = 1] = "atLowerLimit";
        LimitState[LimitState["atUpperLimit"] = 2] = "atUpperLimit";
        LimitState[LimitState["equalLimits"] = 3] = "equalLimits";
    })(LimitState || (LimitState = {}));
    /** @internal */ var DEFAULTS$2 = {
        maxLength: 0.0,
    };
    /**
     * A rope joint enforces a maximum distance between two points on two bodies. It
     * has no other effect.
     *
     * Warning: if you attempt to change the maximum length during the simulation
     * you will get some non-physical behavior.
     *
     * A model that would allow you to dynamically modify the length would have some
     * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you
     * want to dynamically control length.
     */
    var RopeJoint = /** @class */ (function (_super) {
        __extends(RopeJoint, _super);
        function RopeJoint(def, bodyA, bodyB, anchor) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof RopeJoint)) {
                return new RopeJoint(def, bodyA, bodyB, anchor);
            }
            def = options(def, DEFAULTS$2);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = RopeJoint.TYPE;
            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0));
            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0));
            _this.m_maxLength = def.maxLength;
            _this.m_mass = 0.0;
            _this.m_impulse = 0.0;
            _this.m_length = 0.0;
            _this.m_state = LimitState.inactiveLimit;
            return _this;
            // Limit:
            // C = norm(pB - pA) - L
            // u = (pB - pA) / norm(pB - pA)
            // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))
            // J = [-u -cross(rA, u) u cross(rB, u)]
            // K = J * invM * JT
            // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2
        }
        /** @internal */
        RopeJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                localAnchorA: this.m_localAnchorA,
                localAnchorB: this.m_localAnchorB,
                maxLength: this.m_maxLength,
            };
        };
        /** @internal */
        RopeJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            var joint = new RopeJoint(data);
            return joint;
        };
        /**
         * The local anchor point relative to bodyA's origin.
         */
        RopeJoint.prototype.getLocalAnchorA = function () {
            return this.m_localAnchorA;
        };
        /**
         * The local anchor point relative to bodyB's origin.
         */
        RopeJoint.prototype.getLocalAnchorB = function () {
            return this.m_localAnchorB;
        };
        /**
         * Set the maximum length of the rope.
         */
        RopeJoint.prototype.setMaxLength = function (length) {
            this.m_maxLength = length;
        };
        /**
         * Get the maximum length of the rope.
         */
        RopeJoint.prototype.getMaxLength = function () {
            return this.m_maxLength;
        };
        RopeJoint.prototype.getLimitState = function () {
            // TODO LimitState
            return this.m_state;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        RopeJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        RopeJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        RopeJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        RopeJoint.prototype.getReactionTorque = function (inv_dt) {
            return 0.0;
        };
        RopeJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
            this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
            this.m_u = Vec2.zero();
            this.m_u.addCombine(1, cB, 1, this.m_rB);
            this.m_u.subCombine(1, cA, 1, this.m_rA);
            this.m_length = this.m_u.length();
            var C = this.m_length - this.m_maxLength;
            if (C > 0.0) {
                this.m_state = LimitState.atUpperLimit;
            }
            else {
                this.m_state = LimitState.inactiveLimit;
            }
            if (this.m_length > SettingsInternal.linearSlop) {
                this.m_u.mul(1.0 / this.m_length);
            }
            else {
                this.m_u.setZero();
                this.m_mass = 0.0;
                this.m_impulse = 0.0;
                return;
            }
            // Compute effective mass.
            var crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u);
            var crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u);
            var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;
            this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
            if (step.warmStarting) {
                // Scale the impulse to support a variable time step.
                this.m_impulse *= step.dtRatio;
                var P = Vec2.mulNumVec2(this.m_impulse, this.m_u);
                vA.subMul(this.m_invMassA, P);
                wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);
                vB.addMul(this.m_invMassB, P);
                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);
            }
            else {
                this.m_impulse = 0.0;
            }
            this.m_bodyA.c_velocity.v.setVec2(vA);
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v.setVec2(vB);
            this.m_bodyB.c_velocity.w = wB;
        };
        RopeJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            // Cdot = dot(u, v + cross(w, r))
            var vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA);
            var vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB);
            var C = this.m_length - this.m_maxLength;
            var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA));
            // Predictive constraint.
            if (C < 0.0) {
                Cdot += step.inv_dt * C;
            }
            var impulse = -this.m_mass * Cdot;
            var oldImpulse = this.m_impulse;
            this.m_impulse = math_min$1(0.0, this.m_impulse + impulse);
            impulse = this.m_impulse - oldImpulse;
            var P = Vec2.mulNumVec2(impulse, this.m_u);
            vA.subMul(this.m_invMassA, P);
            wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);
            vB.addMul(this.m_invMassB, P);
            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        RopeJoint.prototype.solvePositionConstraints = function (step) {
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
            var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
            var u = Vec2.zero();
            u.addCombine(1, cB, 1, rB);
            u.subCombine(1, cA, 1, rA);
            var length = u.normalize();
            var C = length - this.m_maxLength;
            C = clamp(C, 0.0, SettingsInternal.maxLinearCorrection);
            var impulse = -this.m_mass * C;
            var P = Vec2.mulNumVec2(impulse, u);
            cA.subMul(this.m_invMassA, P);
            aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);
            cB.addMul(this.m_invMassB, P);
            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);
            this.m_bodyA.c_position.c.setVec2(cA);
            this.m_bodyA.c_position.a = aA;
            this.m_bodyB.c_position.c.setVec2(cB);
            this.m_bodyB.c_position.a = aB;
            return length - this.m_maxLength < SettingsInternal.linearSlop;
        };
        RopeJoint.TYPE = 'rope-joint';
        return RopeJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs$1 = Math.abs;
    /** @internal */ var math_PI$1 = Math.PI;
    /** @internal */ var DEFAULTS$1 = {
        frequencyHz: 0.0,
        dampingRatio: 0.0,
    };
    /**
     * A weld joint essentially glues two bodies together. A weld joint may distort
     * somewhat because the island constraint solver is approximate.
     */
    var WeldJoint = /** @class */ (function (_super) {
        __extends(WeldJoint, _super);
        function WeldJoint(def, bodyA, bodyB, anchor) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof WeldJoint)) {
                return new WeldJoint(def, bodyA, bodyB, anchor);
            }
            def = options(def, DEFAULTS$1);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_type = WeldJoint.TYPE;
            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
            _this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();
            _this.m_frequencyHz = def.frequencyHz;
            _this.m_dampingRatio = def.dampingRatio;
            _this.m_impulse = new Vec3();
            _this.m_bias = 0.0;
            _this.m_gamma = 0.0;
            // Solver temp
            _this.m_rA;
            _this.m_rB;
            _this.m_localCenterA;
            _this.m_localCenterB;
            _this.m_invMassA;
            _this.m_invMassB;
            _this.m_invIA;
            _this.m_invIB;
            _this.m_mass = new Mat33();
            return _this;
            // Point-to-point constraint
            // C = p2 - p1
            // Cdot = v2 - v1
            // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)
            // J = [-I -r1_skew I r2_skew ]
            // Identity used:
            // w k % (rx i + ry j) = w * (-ry i + rx j)
            // Angle constraint
            // C = angle2 - angle1 - referenceAngle
            // Cdot = w2 - w1
            // J = [0 0 -1 0 0 1]
            // K = invI1 + invI2
        }
        /** @internal */
        WeldJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                frequencyHz: this.m_frequencyHz,
                dampingRatio: this.m_dampingRatio,
                localAnchorA: this.m_localAnchorA,
                localAnchorB: this.m_localAnchorB,
                referenceAngle: this.m_referenceAngle,
            };
        };
        /** @internal */
        WeldJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            var joint = new WeldJoint(data);
            return joint;
        };
        /** @internal */
        WeldJoint.prototype._setAnchors = function (def) {
            if (def.anchorA) {
                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
            }
            else if (def.localAnchorA) {
                this.m_localAnchorA.setVec2(def.localAnchorA);
            }
            if (def.anchorB) {
                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
            }
            else if (def.localAnchorB) {
                this.m_localAnchorB.setVec2(def.localAnchorB);
            }
        };
        /**
         * The local anchor point relative to bodyA's origin.
         */
        WeldJoint.prototype.getLocalAnchorA = function () {
            return this.m_localAnchorA;
        };
        /**
         * The local anchor point relative to bodyB's origin.
         */
        WeldJoint.prototype.getLocalAnchorB = function () {
            return this.m_localAnchorB;
        };
        /**
         * Get the reference angle.
         */
        WeldJoint.prototype.getReferenceAngle = function () {
            return this.m_referenceAngle;
        };
        /**
         * Set frequency in Hz.
         */
        WeldJoint.prototype.setFrequency = function (hz) {
            this.m_frequencyHz = hz;
        };
        /**
         * Get frequency in Hz.
         */
        WeldJoint.prototype.getFrequency = function () {
            return this.m_frequencyHz;
        };
        /**
         * Set damping ratio.
         */
        WeldJoint.prototype.setDampingRatio = function (ratio) {
            this.m_dampingRatio = ratio;
        };
        /**
         * Get damping ratio.
         */
        WeldJoint.prototype.getDampingRatio = function () {
            return this.m_dampingRatio;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        WeldJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        WeldJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        WeldJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        WeldJoint.prototype.getReactionTorque = function (inv_dt) {
            return inv_dt * this.m_impulse.z;
        };
        WeldJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            // J = [-I -r1_skew I r2_skew]
            // [ 0 -1 0 1]
            // r_skew = [-ry; rx]
            // Matlab
            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var K = new Mat33();
            K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y
                * iB;
            K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
            K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
            K.ex.y = K.ey.x;
            K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x
                * iB;
            K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
            K.ex.z = K.ez.x;
            K.ey.z = K.ez.y;
            K.ez.z = iA + iB;
            if (this.m_frequencyHz > 0.0) {
                K.getInverse22(this.m_mass);
                var invM = iA + iB;
                var m = invM > 0.0 ? 1.0 / invM : 0.0;
                var C = aB - aA - this.m_referenceAngle;
                // Frequency
                var omega = 2.0 * math_PI$1 * this.m_frequencyHz;
                // Damping coefficient
                var d = 2.0 * m * this.m_dampingRatio * omega;
                // Spring stiffness
                var k = m * omega * omega;
                // magic formulas
                var h = step.dt;
                this.m_gamma = h * (d + h * k);
                this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;
                this.m_bias = C * h * k * this.m_gamma;
                invM += this.m_gamma;
                this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;
            }
            else if (K.ez.z == 0.0) {
                K.getInverse22(this.m_mass);
                this.m_gamma = 0.0;
                this.m_bias = 0.0;
            }
            else {
                K.getSymInverse33(this.m_mass);
                this.m_gamma = 0.0;
                this.m_bias = 0.0;
            }
            if (step.warmStarting) {
                // Scale impulses to support a variable time step.
                this.m_impulse.mul(step.dtRatio);
                var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);
                vA.subMul(mA, P);
                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);
                vB.addMul(mB, P);
                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);
            }
            else {
                this.m_impulse.setZero();
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        WeldJoint.prototype.solveVelocityConstraints = function (step) {
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            if (this.m_frequencyHz > 0.0) {
                var Cdot2 = wB - wA;
                var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
                this.m_impulse.z += impulse2;
                wA -= iA * impulse2;
                wB += iB * impulse2;
                var Cdot1 = Vec2.zero();
                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));
                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));
                var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1));
                this.m_impulse.x += impulse1.x;
                this.m_impulse.y += impulse1.y;
                var P = Vec2.clone(impulse1);
                vA.subMul(mA, P);
                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);
                vB.addMul(mB, P);
                wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);
            }
            else {
                var Cdot1 = Vec2.zero();
                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));
                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));
                var Cdot2 = wB - wA;
                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);
                var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot));
                this.m_impulse.add(impulse);
                var P = Vec2.neo(impulse.x, impulse.y);
                vA.subMul(mA, P);
                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);
                vB.addMul(mB, P);
                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);
            }
            this.m_bodyA.c_velocity.v = vA;
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v = vB;
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        WeldJoint.prototype.solvePositionConstraints = function (step) {
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            var positionError;
            var angularError;
            var K = new Mat33();
            K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
            K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
            K.ez.x = -rA.y * iA - rB.y * iB;
            K.ex.y = K.ey.x;
            K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
            K.ez.y = rA.x * iA + rB.x * iB;
            K.ex.z = K.ez.x;
            K.ey.z = K.ez.y;
            K.ez.z = iA + iB;
            if (this.m_frequencyHz > 0.0) {
                var C1 = Vec2.zero();
                C1.addCombine(1, cB, 1, rB);
                C1.subCombine(1, cA, 1, rA);
                positionError = C1.length();
                angularError = 0.0;
                var P = Vec2.neg(K.solve22(C1));
                cA.subMul(mA, P);
                aA -= iA * Vec2.crossVec2Vec2(rA, P);
                cB.addMul(mB, P);
                aB += iB * Vec2.crossVec2Vec2(rB, P);
            }
            else {
                var C1 = Vec2.zero();
                C1.addCombine(1, cB, 1, rB);
                C1.subCombine(1, cA, 1, rA);
                var C2 = aB - aA - this.m_referenceAngle;
                positionError = C1.length();
                angularError = math_abs$1(C2);
                var C = new Vec3(C1.x, C1.y, C2);
                var impulse = new Vec3();
                if (K.ez.z > 0.0) {
                    impulse = Vec3.neg(K.solve33(C));
                }
                else {
                    var impulse2 = Vec2.neg(K.solve22(C1));
                    impulse.set(impulse2.x, impulse2.y, 0.0);
                }
                var P = Vec2.neo(impulse.x, impulse.y);
                cA.subMul(mA, P);
                aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);
                cB.addMul(mB, P);
                aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);
            }
            this.m_bodyA.c_position.c = cA;
            this.m_bodyA.c_position.a = aA;
            this.m_bodyB.c_position.c = cB;
            this.m_bodyB.c_position.a = aB;
            return positionError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;
        };
        WeldJoint.TYPE = 'weld-joint';
        return WeldJoint;
    }(Joint));

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_abs = Math.abs;
    /** @internal */ var math_PI = Math.PI;
    /** @internal */ var DEFAULTS = {
        enableMotor: false,
        maxMotorTorque: 0.0,
        motorSpeed: 0.0,
        frequencyHz: 2.0,
        dampingRatio: 0.7,
    };
    /**
     * A wheel joint. This joint provides two degrees of freedom: translation along
     * an axis fixed in bodyA and rotation in the plane. In other words, it is a
     * point to line constraint with a rotational motor and a linear spring/damper.
     * This joint is designed for vehicle suspensions.
     */
    var WheelJoint = /** @class */ (function (_super) {
        __extends(WheelJoint, _super);
        function WheelJoint(def, bodyA, bodyB, anchor, axis) {
            var _this = this;
            // @ts-ignore
            if (!(_this instanceof WheelJoint)) {
                return new WheelJoint(def, bodyA, bodyB, anchor, axis);
            }
            def = options(def, DEFAULTS);
            _this = _super.call(this, def, bodyA, bodyB) || this;
            bodyA = _this.m_bodyA;
            bodyB = _this.m_bodyB;
            _this.m_ax = Vec2.zero();
            _this.m_ay = Vec2.zero();
            _this.m_type = WheelJoint.TYPE;
            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
            if (Vec2.isValid(axis)) {
                _this.m_localXAxisA = bodyA.getLocalVector(axis);
            }
            else if (Vec2.isValid(def.localAxisA)) {
                _this.m_localXAxisA = Vec2.clone(def.localAxisA);
            }
            else if (Vec2.isValid(def.localAxis)) {
                // localAxis is renamed to localAxisA, this is for backward compatibility
                _this.m_localXAxisA = Vec2.clone(def.localAxis);
            }
            else {
                _this.m_localXAxisA = Vec2.neo(1.0, 0.0);
            }
            _this.m_localYAxisA = Vec2.crossNumVec2(1.0, _this.m_localXAxisA);
            _this.m_mass = 0.0;
            _this.m_impulse = 0.0;
            _this.m_motorMass = 0.0;
            _this.m_motorImpulse = 0.0;
            _this.m_springMass = 0.0;
            _this.m_springImpulse = 0.0;
            _this.m_maxMotorTorque = def.maxMotorTorque;
            _this.m_motorSpeed = def.motorSpeed;
            _this.m_enableMotor = def.enableMotor;
            _this.m_frequencyHz = def.frequencyHz;
            _this.m_dampingRatio = def.dampingRatio;
            _this.m_bias = 0.0;
            _this.m_gamma = 0.0;
            return _this;
            // Linear constraint (point-to-line)
            // d = pB - pA = xB + rB - xA - rA
            // C = dot(ay, d)
            // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,
            // rA))
            // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,
            // ay), vB)
            // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]
            // Spring linear constraint
            // C = dot(ax, d)
            // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +
            // dot(cross(rB, ax), vB)
            // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]
            // Motor rotational constraint
            // Cdot = wB - wA
            // J = [0 0 -1 0 0 1]
        }
        /** @internal */
        WheelJoint.prototype._serialize = function () {
            return {
                type: this.m_type,
                bodyA: this.m_bodyA,
                bodyB: this.m_bodyB,
                collideConnected: this.m_collideConnected,
                enableMotor: this.m_enableMotor,
                maxMotorTorque: this.m_maxMotorTorque,
                motorSpeed: this.m_motorSpeed,
                frequencyHz: this.m_frequencyHz,
                dampingRatio: this.m_dampingRatio,
                localAnchorA: this.m_localAnchorA,
                localAnchorB: this.m_localAnchorB,
                localAxisA: this.m_localXAxisA,
            };
        };
        /** @internal */
        WheelJoint._deserialize = function (data, world, restore) {
            data = __assign({}, data);
            data.bodyA = restore(Body, data.bodyA, world);
            data.bodyB = restore(Body, data.bodyB, world);
            var joint = new WheelJoint(data);
            return joint;
        };
        /** @internal */
        WheelJoint.prototype._setAnchors = function (def) {
            if (def.anchorA) {
                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));
            }
            else if (def.localAnchorA) {
                this.m_localAnchorA.setVec2(def.localAnchorA);
            }
            if (def.anchorB) {
                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));
            }
            else if (def.localAnchorB) {
                this.m_localAnchorB.setVec2(def.localAnchorB);
            }
            if (def.localAxisA) {
                this.m_localXAxisA.setVec2(def.localAxisA);
                this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));
            }
        };
        /**
         * The local anchor point relative to bodyA's origin.
         */
        WheelJoint.prototype.getLocalAnchorA = function () {
            return this.m_localAnchorA;
        };
        /**
         * The local anchor point relative to bodyB's origin.
         */
        WheelJoint.prototype.getLocalAnchorB = function () {
            return this.m_localAnchorB;
        };
        /**
         * The local joint axis relative to bodyA.
         */
        WheelJoint.prototype.getLocalAxisA = function () {
            return this.m_localXAxisA;
        };
        /**
         * Get the current joint translation, usually in meters.
         */
        WheelJoint.prototype.getJointTranslation = function () {
            var bA = this.m_bodyA;
            var bB = this.m_bodyB;
            var pA = bA.getWorldPoint(this.m_localAnchorA);
            var pB = bB.getWorldPoint(this.m_localAnchorB);
            var d = Vec2.sub(pB, pA);
            var axis = bA.getWorldVector(this.m_localXAxisA);
            var translation = Vec2.dot(d, axis);
            return translation;
        };
        /**
         * Get the current joint translation speed, usually in meters per second.
         */
        WheelJoint.prototype.getJointSpeed = function () {
            var wA = this.m_bodyA.m_angularVelocity;
            var wB = this.m_bodyB.m_angularVelocity;
            return wB - wA;
        };
        /**
         * Is the joint motor enabled?
         */
        WheelJoint.prototype.isMotorEnabled = function () {
            return this.m_enableMotor;
        };
        /**
         * Enable/disable the joint motor.
         */
        WheelJoint.prototype.enableMotor = function (flag) {
            if (flag == this.m_enableMotor)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_enableMotor = flag;
        };
        /**
         * Set the motor speed, usually in radians per second.
         */
        WheelJoint.prototype.setMotorSpeed = function (speed) {
            if (speed == this.m_motorSpeed)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_motorSpeed = speed;
        };
        /**
         * Get the motor speed, usually in radians per second.
         */
        WheelJoint.prototype.getMotorSpeed = function () {
            return this.m_motorSpeed;
        };
        /**
         * Set/Get the maximum motor force, usually in N-m.
         */
        WheelJoint.prototype.setMaxMotorTorque = function (torque) {
            if (torque == this.m_maxMotorTorque)
                return;
            this.m_bodyA.setAwake(true);
            this.m_bodyB.setAwake(true);
            this.m_maxMotorTorque = torque;
        };
        WheelJoint.prototype.getMaxMotorTorque = function () {
            return this.m_maxMotorTorque;
        };
        /**
         * Get the current motor torque given the inverse time step, usually in N-m.
         */
        WheelJoint.prototype.getMotorTorque = function (inv_dt) {
            return inv_dt * this.m_motorImpulse;
        };
        /**
         * Set/Get the spring frequency in hertz. Setting the frequency to zero disables
         * the spring.
         */
        WheelJoint.prototype.setSpringFrequencyHz = function (hz) {
            this.m_frequencyHz = hz;
        };
        WheelJoint.prototype.getSpringFrequencyHz = function () {
            return this.m_frequencyHz;
        };
        /**
         * Set/Get the spring damping ratio
         */
        WheelJoint.prototype.setSpringDampingRatio = function (ratio) {
            this.m_dampingRatio = ratio;
        };
        WheelJoint.prototype.getSpringDampingRatio = function () {
            return this.m_dampingRatio;
        };
        /**
         * Get the anchor point on bodyA in world coordinates.
         */
        WheelJoint.prototype.getAnchorA = function () {
            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
        };
        /**
         * Get the anchor point on bodyB in world coordinates.
         */
        WheelJoint.prototype.getAnchorB = function () {
            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
        };
        /**
         * Get the reaction force on bodyB at the joint anchor in Newtons.
         */
        WheelJoint.prototype.getReactionForce = function (inv_dt) {
            return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);
        };
        /**
         * Get the reaction torque on bodyB in N*m.
         */
        WheelJoint.prototype.getReactionTorque = function (inv_dt) {
            return inv_dt * this.m_motorImpulse;
        };
        WheelJoint.prototype.initVelocityConstraints = function (step) {
            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
            this.m_invMassA = this.m_bodyA.m_invMass;
            this.m_invMassB = this.m_bodyB.m_invMass;
            this.m_invIA = this.m_bodyA.m_invI;
            this.m_invIB = this.m_bodyB.m_invI;
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            // Compute the effective masses.
            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            var d = Vec2.zero();
            d.addCombine(1, cB, 1, rB);
            d.subCombine(1, cA, 1, rA);
            // Point to line constraint
            {
                this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);
                this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);
                this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);
                this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy
                    * this.m_sBy;
                if (this.m_mass > 0.0) {
                    this.m_mass = 1.0 / this.m_mass;
                }
            }
            // Spring constraint
            this.m_springMass = 0.0;
            this.m_bias = 0.0;
            this.m_gamma = 0.0;
            if (this.m_frequencyHz > 0.0) {
                this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);
                this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);
                this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);
                var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx
                    * this.m_sBx;
                if (invMass > 0.0) {
                    this.m_springMass = 1.0 / invMass;
                    var C = Vec2.dot(d, this.m_ax);
                    // Frequency
                    var omega = 2.0 * math_PI * this.m_frequencyHz;
                    // Damping coefficient
                    var damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega;
                    // Spring stiffness
                    var k = this.m_springMass * omega * omega;
                    // magic formulas
                    var h = step.dt;
                    this.m_gamma = h * (damp + h * k);
                    if (this.m_gamma > 0.0) {
                        this.m_gamma = 1.0 / this.m_gamma;
                    }
                    this.m_bias = C * h * k * this.m_gamma;
                    this.m_springMass = invMass + this.m_gamma;
                    if (this.m_springMass > 0.0) {
                        this.m_springMass = 1.0 / this.m_springMass;
                    }
                }
            }
            else {
                this.m_springImpulse = 0.0;
            }
            // Rotational motor
            if (this.m_enableMotor) {
                this.m_motorMass = iA + iB;
                if (this.m_motorMass > 0.0) {
                    this.m_motorMass = 1.0 / this.m_motorMass;
                }
            }
            else {
                this.m_motorMass = 0.0;
                this.m_motorImpulse = 0.0;
            }
            if (step.warmStarting) {
                // Account for variable time step.
                this.m_impulse *= step.dtRatio;
                this.m_springImpulse *= step.dtRatio;
                this.m_motorImpulse *= step.dtRatio;
                var P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);
                var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
                var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
                vA.subMul(this.m_invMassA, P);
                wA -= this.m_invIA * LA;
                vB.addMul(this.m_invMassB, P);
                wB += this.m_invIB * LB;
            }
            else {
                this.m_impulse = 0.0;
                this.m_springImpulse = 0.0;
                this.m_motorImpulse = 0.0;
            }
            this.m_bodyA.c_velocity.v.setVec2(vA);
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v.setVec2(vB);
            this.m_bodyB.c_velocity.w = wB;
        };
        WheelJoint.prototype.solveVelocityConstraints = function (step) {
            var mA = this.m_invMassA;
            var mB = this.m_invMassB;
            var iA = this.m_invIA;
            var iB = this.m_invIB;
            var vA = this.m_bodyA.c_velocity.v;
            var wA = this.m_bodyA.c_velocity.w;
            var vB = this.m_bodyB.c_velocity.v;
            var wB = this.m_bodyB.c_velocity.w;
            // Solve spring constraint
            {
                var Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx * wB - this.m_sAx * wA;
                var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
                this.m_springImpulse += impulse;
                var P = Vec2.mulNumVec2(impulse, this.m_ax);
                var LA = impulse * this.m_sAx;
                var LB = impulse * this.m_sBx;
                vA.subMul(mA, P);
                wA -= iA * LA;
                vB.addMul(mB, P);
                wB += iB * LB;
            }
            // Solve rotational motor constraint
            {
                var Cdot = wB - wA - this.m_motorSpeed;
                var impulse = -this.m_motorMass * Cdot;
                var oldImpulse = this.m_motorImpulse;
                var maxImpulse = step.dt * this.m_maxMotorTorque;
                this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                impulse = this.m_motorImpulse - oldImpulse;
                wA -= iA * impulse;
                wB += iB * impulse;
            }
            // Solve point to line constraint
            {
                var Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy * wB - this.m_sAy * wA;
                var impulse = -this.m_mass * Cdot;
                this.m_impulse += impulse;
                var P = Vec2.mulNumVec2(impulse, this.m_ay);
                var LA = impulse * this.m_sAy;
                var LB = impulse * this.m_sBy;
                vA.subMul(mA, P);
                wA -= iA * LA;
                vB.addMul(mB, P);
                wB += iB * LB;
            }
            this.m_bodyA.c_velocity.v.setVec2(vA);
            this.m_bodyA.c_velocity.w = wA;
            this.m_bodyB.c_velocity.v.setVec2(vB);
            this.m_bodyB.c_velocity.w = wB;
        };
        /**
         * This returns true if the position errors are within tolerance.
         */
        WheelJoint.prototype.solvePositionConstraints = function (step) {
            var cA = this.m_bodyA.c_position.c;
            var aA = this.m_bodyA.c_position.a;
            var cB = this.m_bodyB.c_position.c;
            var aB = this.m_bodyB.c_position.a;
            var qA = Rot.neo(aA);
            var qB = Rot.neo(aB);
            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
            var d = Vec2.zero();
            d.addCombine(1, cB, 1, rB);
            d.subCombine(1, cA, 1, rA);
            var ay = Rot.mulVec2(qA, this.m_localYAxisA);
            var sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay);
            var sBy = Vec2.crossVec2Vec2(rB, ay);
            var C = Vec2.dot(d, ay);
            var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
            var impulse = k != 0.0 ? -C / k : 0.0;
            var P = Vec2.mulNumVec2(impulse, ay);
            var LA = impulse * sAy;
            var LB = impulse * sBy;
            cA.subMul(this.m_invMassA, P);
            aA -= this.m_invIA * LA;
            cB.addMul(this.m_invMassB, P);
            aB += this.m_invIB * LB;
            this.m_bodyA.c_position.c.setVec2(cA);
            this.m_bodyA.c_position.a = aA;
            this.m_bodyB.c_position.c.setVec2(cB);
            this.m_bodyB.c_position.a = aB;
            return math_abs(C) <= SettingsInternal.linearSlop;
        };
        WheelJoint.TYPE = 'wheel-joint';
        return WheelJoint;
    }(Joint));

    var SID = 0;
    function Serializer(opts) {
        var _a;
        opts = opts || {};
        var rootClass = opts.rootClass || World;
        var preSerialize = opts.preSerialize || function (obj) { return obj; };
        var postSerialize = opts.postSerialize || function (data, obj) { return data; };
        var preDeserialize = opts.preDeserialize || function (data) { return data; };
        var postDeserialize = opts.postDeserialize || function (obj, data) { return obj; };
        // This is used to create ref objects during serialize
        var refTypes = {
            World: World,
            Body: Body,
            Joint: Joint,
            Fixture: Fixture,
            Shape: Shape,
        };
        // This is used by restore to deserialize objects and refs
        var restoreTypes = __assign({ Vec2: Vec2,
            Vec3: Vec3 }, refTypes);
        var CLASS_BY_TYPE_PROP = (_a = {},
            _a[Body.STATIC] = Body,
            _a[Body.DYNAMIC] = Body,
            _a[Body.KINEMATIC] = Body,
            _a[ChainShape.TYPE] = ChainShape,
            _a[BoxShape.TYPE] = BoxShape,
            _a[EdgeShape.TYPE] = EdgeShape,
            _a[PolygonShape.TYPE] = PolygonShape,
            _a[CircleShape.TYPE] = CircleShape,
            _a[DistanceJoint.TYPE] = DistanceJoint,
            _a[FrictionJoint.TYPE] = FrictionJoint,
            _a[GearJoint.TYPE] = GearJoint,
            _a[MotorJoint.TYPE] = MotorJoint,
            _a[MouseJoint.TYPE] = MouseJoint,
            _a[PrismaticJoint.TYPE] = PrismaticJoint,
            _a[PulleyJoint.TYPE] = PulleyJoint,
            _a[RevoluteJoint.TYPE] = RevoluteJoint,
            _a[RopeJoint.TYPE] = RopeJoint,
            _a[WeldJoint.TYPE] = WeldJoint,
            _a[WheelJoint.TYPE] = WheelJoint,
            _a);
        this.toJson = function (root) {
            var json = [];
            var queue = [root];
            var refMap = {};
            function storeRef(value, typeName) {
                value.__sid = value.__sid || ++SID;
                if (!refMap[value.__sid]) {
                    queue.push(value);
                    var index = json.length + queue.length;
                    var ref = {
                        refIndex: index,
                        refType: typeName
                    };
                    refMap[value.__sid] = ref;
                }
                return refMap[value.__sid];
            }
            function serialize(obj) {
                obj = preSerialize(obj);
                var data = obj._serialize();
                data = postSerialize(data, obj);
                return data;
            }
            function toJson(value, top) {
                if (typeof value !== 'object' || value === null) {
                    return value;
                }
                if (typeof value._serialize === 'function') {
                    if (value !== top) {
                        // tslint:disable-next-line:no-for-in
                        for (var typeName in refTypes) {
                            if (value instanceof refTypes[typeName]) {
                                return storeRef(value, typeName);
                            }
                        }
                    }
                    value = serialize(value);
                }
                if (Array.isArray(value)) {
                    var newValue = [];
                    for (var key = 0; key < value.length; key++) {
                        newValue[key] = toJson(value[key]);
                    }
                    value = newValue;
                }
                else {
                    var newValue = {};
                    // tslint:disable-next-line:no-for-in
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            newValue[key] = toJson(value[key]);
                        }
                    }
                    value = newValue;
                }
                return value;
            }
            while (queue.length) {
                var obj = queue.shift();
                var str = toJson(obj, obj);
                json.push(str);
            }
            return json;
        };
        this.fromJson = function (json) {
            var refMap = {};
            function findDeserilizer(data, cls) {
                if (!cls || !cls._deserialize) {
                    cls = CLASS_BY_TYPE_PROP[data.type];
                }
                return cls && cls._deserialize;
            }
            /**
             * Deserialize a data object.
             */
            function deserialize(cls, data, ctx) {
                var deserializer = findDeserilizer(data, cls);
                if (!deserializer) {
                    return;
                }
                data = preDeserialize(data);
                var obj = deserializer(data, ctx, restoreRef);
                obj = postDeserialize(obj, data);
                return obj;
            }
            /**
             * Restore a ref object or deserialize a data object.
             *
             * This is passed as callback to class deserializers.
             */
            function restoreRef(cls, ref, ctx) {
                if (!ref.refIndex) {
                    return cls && cls._deserialize && deserialize(cls, ref, ctx);
                }
                cls = restoreTypes[ref.refType] || cls;
                var index = ref.refIndex;
                if (!refMap[index]) {
                    var data = json[index];
                    var obj = deserialize(cls, data, ctx);
                    refMap[index] = obj;
                }
                return refMap[index];
            }
            var root = rootClass._deserialize(json[0], null, restoreRef);
            return root;
        };
    }
    var serializer = new Serializer();
    Serializer.toJson = serializer.toJson;
    Serializer.fromJson = serializer.fromJson;

    var Testbed = /** @class */ (function () {
        function Testbed() {
            /** World viewbox width. */
            this.width = 80;
            /** World viewbox height. */
            this.height = 60;
            /** World viewbox center vertical offset. */
            this.x = 0;
            /** World viewbox center horizontal offset. */
            this.y = -10;
            this.scaleY = -1;
            /** World simulation step frequency */
            this.hz = 60;
            /** World simulation speed, default is 1 */
            this.speed = 1;
            this.ratio = 16;
            this.background = '#222222';
            this.activeKeys = {};
            /** callback, to be implemented by user */
            this.step = function (dt, t) {
                return;
            };
            /** callback, to be implemented by user */
            this.keydown = function (keyCode, label) {
                return;
            };
            /** callback, to be implemented by user */
            this.keyup = function (keyCode, label) {
                return;
            };
            this.statusText = '';
            this.statusMap = {};
        }
        Testbed.mount = function (options) {
            throw new Error('Not implemented');
        };
        Testbed.prototype.status = function (a, b) {
            if (typeof b !== 'undefined') {
                var key_1 = a;
                var value_1 = b;
                if (typeof value_1 !== 'function' && typeof value_1 !== 'object') {
                    this.statusMap[key_1] = value_1;
                }
            }
            else if (a && typeof a === 'object') {
                // tslint:disable-next-line:no-for-in
                for (var key_2 in a) {
                    var value_2 = a[key_2];
                    if (typeof value_2 !== 'function' && typeof value_2 !== 'object') {
                        this.statusMap[key_2] = value_2;
                    }
                }
            }
            else if (typeof a === 'string') {
                this.statusText = a;
            }
            var newline = '\n';
            var text = this.statusText || '';
            for (var key in this.statusMap) {
                var value = this.statusMap[key];
                if (typeof value === 'function')
                    continue;
                text += (text && newline) + key + ': ' + value;
            }
            this._status(text);
        };
        Testbed.prototype.info = function (text) {
            this._info(text);
        };
        Testbed.prototype.color = function (r, g, b) {
            r = r * 256 | 0;
            g = g * 256 | 0;
            b = b * 256 | 0;
            return 'rgb(' + r + ', ' + g + ', ' + b + ')';
        };
        return Testbed;
    }());
    /** @internal */
    function testbed(a, b) {
        var callback;
        var options;
        if (typeof a === 'function') {
            callback = a;
            options = b;
        }
        else if (typeof b === 'function') {
            callback = b;
            options = a;
        }
        else {
            options = a !== null && a !== void 0 ? a : b;
        }
        var testbed = Testbed.mount(options);
        if (callback) {
            // this is for backwards compatibility
            var world = callback(testbed) || testbed.world;
            testbed.start(world);
        }
        else {
            return testbed;
        }
    }

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);
    /** @internal */ function CircleCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
        CollideCircles(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
    }
    /** @internal */ var pA = vec2(0, 0);
    /** @internal */ var pB = vec2(0, 0);
    var CollideCircles = function (manifold, circleA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        transformVec2(pA, xfA, circleA.m_p);
        transformVec2(pB, xfB, circleB.m_p);
        var distSqr = distSqrVec2(pB, pA);
        var rA = circleA.m_radius;
        var rB = circleB.m_radius;
        var radius = rA + rB;
        if (distSqr > radius * radius) {
            return;
        }
        manifold.type = exports.ManifoldType.e_circles;
        copyVec2(manifold.localPoint, circleA.m_p);
        zeroVec2(manifold.localNormal);
        manifold.pointCount = 1;
        copyVec2(manifold.points[0].localPoint, circleB.m_p);
        // manifold.points[0].id.key = 0;
        manifold.points[0].id.setFeatures(0, exports.ContactFeatureType.e_vertex, 0, exports.ContactFeatureType.e_vertex);
    };

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);
    Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);
    /** @internal */ function EdgeCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
        var shapeA = fixtureA.getShape();
        var shapeB = fixtureB.getShape();
        CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
    }
    function ChainCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
        var chain = fixtureA.getShape();
        var edge = new EdgeShape();
        chain.getChildEdge(edge, indexA);
        var shapeA = edge;
        var shapeB = fixtureB.getShape();
        CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
    }
    /** @internal */ var e = vec2(0, 0);
    /** @internal */ var e1 = vec2(0, 0);
    /** @internal */ var e2 = vec2(0, 0);
    /** @internal */ var Q = vec2(0, 0);
    /** @internal */ var P = vec2(0, 0);
    /** @internal */ var n$2 = vec2(0, 0);
    // Compute contact points for edge versus circle.
    // This accounts for edge connectivity.
    var CollideEdgeCircle = function (manifold, edgeA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        // Compute circle in frame of edge
        retransformVec2(Q, xfB, xfA, circleB.m_p);
        var A = edgeA.m_vertex1;
        var B = edgeA.m_vertex2;
        diffVec2(e, B, A);
        // Barycentric coordinates
        var u = dotVec2(e, B) - dotVec2(e, Q);
        var v = dotVec2(e, Q) - dotVec2(e, A);
        var radius = edgeA.m_radius + circleB.m_radius;
        // Region A
        if (v <= 0.0) {
            copyVec2(P, A);
            var dd_1 = distSqrVec2(Q, A);
            if (dd_1 > radius * radius) {
                return;
            }
            // Is there an edge connected to A?
            if (edgeA.m_hasVertex0) {
                var A1 = edgeA.m_vertex0;
                var B1 = A;
                diffVec2(e1, B1, A1);
                var u1 = dotVec2(e1, B1) - dotVec2(e1, Q);
                // Is the circle in Region AB of the previous edge?
                if (u1 > 0.0) {
                    return;
                }
            }
            manifold.type = exports.ManifoldType.e_circles;
            zeroVec2(manifold.localNormal);
            copyVec2(manifold.localPoint, P);
            manifold.pointCount = 1;
            copyVec2(manifold.points[0].localPoint, circleB.m_p);
            // manifold.points[0].id.key = 0;
            manifold.points[0].id.setFeatures(0, exports.ContactFeatureType.e_vertex, 0, exports.ContactFeatureType.e_vertex);
            return;
        }
        // Region B
        if (u <= 0.0) {
            copyVec2(P, B);
            var dd_2 = distSqrVec2(Q, P);
            if (dd_2 > radius * radius) {
                return;
            }
            // Is there an edge connected to B?
            if (edgeA.m_hasVertex3) {
                var B2 = edgeA.m_vertex3;
                var A2 = B;
                diffVec2(e2, B2, A2);
                var v2 = dotVec2(e2, Q) - dotVec2(e2, A2);
                // Is the circle in Region AB of the next edge?
                if (v2 > 0.0) {
                    return;
                }
            }
            manifold.type = exports.ManifoldType.e_circles;
            zeroVec2(manifold.localNormal);
            copyVec2(manifold.localPoint, P);
            manifold.pointCount = 1;
            copyVec2(manifold.points[0].localPoint, circleB.m_p);
            // manifold.points[0].id.key = 0;
            manifold.points[0].id.setFeatures(1, exports.ContactFeatureType.e_vertex, 0, exports.ContactFeatureType.e_vertex);
            return;
        }
        // Region AB
        var den = lengthSqrVec2(e);
        combineVec2(P, u / den, A, v / den, B);
        var dd = distSqrVec2(Q, P);
        if (dd > radius * radius) {
            return;
        }
        crossNumVec2(n$2, 1, e);
        if (dotVec2(n$2, Q) - dotVec2(n$2, A) < 0.0) {
            negVec2(n$2);
        }
        normalizeVec2(n$2);
        manifold.type = exports.ManifoldType.e_faceA;
        copyVec2(manifold.localNormal, n$2);
        copyVec2(manifold.localPoint, A);
        manifold.pointCount = 1;
        copyVec2(manifold.points[0].localPoint, circleB.m_p);
        // manifold.points[0].id.key = 0;
        manifold.points[0].id.setFeatures(0, exports.ContactFeatureType.e_face, 0, exports.ContactFeatureType.e_vertex);
    };

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var incidentEdge = [new ClipVertex(), new ClipVertex()];
    /** @internal */ var clipPoints1$1 = [new ClipVertex(), new ClipVertex()];
    /** @internal */ var clipPoints2$1 = [new ClipVertex(), new ClipVertex()];
    /** @internal */ var clipSegmentToLineNormal = vec2(0, 0);
    /** @internal */ var v1 = vec2(0, 0);
    /** @internal */ var n$1 = vec2(0, 0);
    /** @internal */ var xf$1 = transform(0, 0, 0);
    /** @internal */ var v11 = vec2(0, 0);
    /** @internal */ var v12 = vec2(0, 0);
    /** @internal */ var localTangent = vec2(0, 0);
    /** @internal */ var localNormal = vec2(0, 0);
    /** @internal */ var planePoint = vec2(0, 0);
    /** @internal */ var tangent = vec2(0, 0);
    /** @internal */ var normal$1 = vec2(0, 0);
    /** @internal */ var normal1$1 = vec2(0, 0);
    Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);
    /** @internal */ function PolygonContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
        CollidePolygons(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
    }
    /**
     * Find the max separation between poly1 and poly2 using edge normals from
     * poly1.
     */
    /** @internal */ function findMaxSeparation(poly1, xf1, poly2, xf2, output) {
        var count1 = poly1.m_count;
        var count2 = poly2.m_count;
        var n1s = poly1.m_normals;
        var v1s = poly1.m_vertices;
        var v2s = poly2.m_vertices;
        invTransformTransform(xf$1, xf2, xf1);
        var bestIndex = 0;
        var maxSeparation = -Infinity;
        for (var i = 0; i < count1; ++i) {
            // Get poly1 normal in frame2.
            rotVec2(n$1, xf$1.q, n1s[i]);
            transformVec2(v1, xf$1, v1s[i]);
            // Find deepest point for normal i.
            var si = Infinity;
            for (var j = 0; j < count2; ++j) {
                var sij = dotVec2(n$1, v2s[j]) - dotVec2(n$1, v1);
                if (sij < si) {
                    si = sij;
                }
            }
            if (si > maxSeparation) {
                maxSeparation = si;
                bestIndex = i;
            }
        }
        // used to keep last FindMaxSeparation call values
        output.maxSeparation = maxSeparation;
        output.bestIndex = bestIndex;
    }
    /** @internal */ function findIncidentEdge(clipVertex, poly1, xf1, edge1, poly2, xf2) {
        var normals1 = poly1.m_normals;
        var count2 = poly2.m_count;
        var vertices2 = poly2.m_vertices;
        var normals2 = poly2.m_normals;
        // Get the normal of the reference edge in poly2's frame.
        rerotVec2(normal1$1, xf2.q, xf1.q, normals1[edge1]);
        // Find the incident edge on poly2.
        var index = 0;
        var minDot = Infinity;
        for (var i = 0; i < count2; ++i) {
            var dot = dotVec2(normal1$1, normals2[i]);
            if (dot < minDot) {
                minDot = dot;
                index = i;
            }
        }
        // Build the clip vertices for the incident edge.
        var i1 = index;
        var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
        transformVec2(clipVertex[0].v, xf2, vertices2[i1]);
        clipVertex[0].id.setFeatures(edge1, exports.ContactFeatureType.e_face, i1, exports.ContactFeatureType.e_vertex);
        transformVec2(clipVertex[1].v, xf2, vertices2[i2]);
        clipVertex[1].id.setFeatures(edge1, exports.ContactFeatureType.e_face, i2, exports.ContactFeatureType.e_vertex);
    }
    /** @internal */ var maxSeparation = {
        maxSeparation: 0,
        bestIndex: 0,
    };
    /**
     *
     * Find edge normal of max separation on A - return if separating axis is found<br>
     * Find edge normal of max separation on B - return if separation axis is found<br>
     * Choose reference edge as min(minA, minB)<br>
     * Find incident edge<br>
     * Clip
     *
     * The normal points from 1 to 2
     */
    var CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
        manifold.pointCount = 0;
        var totalRadius = polyA.m_radius + polyB.m_radius;
        findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);
        var edgeA = maxSeparation.bestIndex;
        var separationA = maxSeparation.maxSeparation;
        if (separationA > totalRadius)
            return;
        findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);
        var edgeB = maxSeparation.bestIndex;
        var separationB = maxSeparation.maxSeparation;
        if (separationB > totalRadius)
            return;
        var poly1; // reference polygon
        var poly2; // incident polygon
        var xf1;
        var xf2;
        var edge1; // reference edge
        var flip;
        var k_tol = 0.1 * SettingsInternal.linearSlop;
        if (separationB > separationA + k_tol) {
            poly1 = polyB;
            poly2 = polyA;
            xf1 = xfB;
            xf2 = xfA;
            edge1 = edgeB;
            manifold.type = exports.ManifoldType.e_faceB;
            flip = true;
        }
        else {
            poly1 = polyA;
            poly2 = polyB;
            xf1 = xfA;
            xf2 = xfB;
            edge1 = edgeA;
            manifold.type = exports.ManifoldType.e_faceA;
            flip = false;
        }
        incidentEdge[0].recycle(), incidentEdge[1].recycle();
        findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
        var count1 = poly1.m_count;
        var vertices1 = poly1.m_vertices;
        var iv1 = edge1;
        var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
        copyVec2(v11, vertices1[iv1]);
        copyVec2(v12, vertices1[iv2]);
        diffVec2(localTangent, v12, v11);
        normalizeVec2(localTangent);
        crossVec2Num(localNormal, localTangent, 1.0);
        combineVec2(planePoint, 0.5, v11, 0.5, v12);
        rotVec2(tangent, xf1.q, localTangent);
        crossVec2Num(normal$1, tangent, 1.0);
        transformVec2(v11, xf1, v11);
        transformVec2(v12, xf1, v12);
        // Face offset.
        var frontOffset = dotVec2(normal$1, v11);
        // Side offsets, extended by polytope skin thickness.
        var sideOffset1 = -dotVec2(tangent, v11) + totalRadius;
        var sideOffset2 = dotVec2(tangent, v12) + totalRadius;
        // Clip incident edge against extruded edge1 side edges.
        clipPoints1$1[0].recycle(), clipPoints1$1[1].recycle();
        clipPoints2$1[0].recycle(), clipPoints2$1[1].recycle();
        // Clip to box side 1
        setVec2(clipSegmentToLineNormal, -tangent.x, -tangent.y);
        var np1 = clipSegmentToLine(clipPoints1$1, incidentEdge, clipSegmentToLineNormal, sideOffset1, iv1);
        if (np1 < 2) {
            return;
        }
        // Clip to negative box side 1
        setVec2(clipSegmentToLineNormal, tangent.x, tangent.y);
        var np2 = clipSegmentToLine(clipPoints2$1, clipPoints1$1, clipSegmentToLineNormal, sideOffset2, iv2);
        if (np2 < 2) {
            return;
        }
        // Now clipPoints2 contains the clipped points.
        copyVec2(manifold.localNormal, localNormal);
        copyVec2(manifold.localPoint, planePoint);
        var pointCount = 0;
        for (var i = 0; i < clipPoints2$1.length /* maxManifoldPoints */; ++i) {
            var separation = dotVec2(normal$1, clipPoints2$1[i].v) - frontOffset;
            if (separation <= totalRadius) {
                var cp = manifold.points[pointCount];
                invTransformVec2(cp.localPoint, xf2, clipPoints2$1[i].v);
                cp.id.set(clipPoints2$1[i].id);
                if (flip) {
                    // Swap features
                    cp.id.swapFeatures();
                }
                ++pointCount;
            }
        }
        manifold.pointCount = pointCount;
    };

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);
    /** @internal */ function PolygonCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
        CollidePolygonCircle(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
    }
    /** @internal */ var cLocal = vec2(0, 0);
    /** @internal */ var faceCenter = vec2(0, 0);
    var CollidePolygonCircle = function (manifold, polygonA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        // Compute circle position in the frame of the polygon.
        retransformVec2(cLocal, xfB, xfA, circleB.m_p);
        // Find the min separating edge.
        var normalIndex = 0;
        var separation = -Infinity;
        var radius = polygonA.m_radius + circleB.m_radius;
        var vertexCount = polygonA.m_count;
        var vertices = polygonA.m_vertices;
        var normals = polygonA.m_normals;
        for (var i = 0; i < vertexCount; ++i) {
            var s = dotVec2(normals[i], cLocal) - dotVec2(normals[i], vertices[i]);
            if (s > radius) {
                // Early out.
                return;
            }
            if (s > separation) {
                separation = s;
                normalIndex = i;
            }
        }
        // Vertices that subtend the incident face.
        var vertIndex1 = normalIndex;
        var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
        var v1 = vertices[vertIndex1];
        var v2 = vertices[vertIndex2];
        // If the center is inside the polygon ...
        if (separation < EPSILON) {
            manifold.pointCount = 1;
            manifold.type = exports.ManifoldType.e_faceA;
            copyVec2(manifold.localNormal, normals[normalIndex]);
            combineVec2(manifold.localPoint, 0.5, v1, 0.5, v2);
            copyVec2(manifold.points[0].localPoint, circleB.m_p);
            // manifold.points[0].id.key = 0;
            manifold.points[0].id.setFeatures(0, exports.ContactFeatureType.e_vertex, 0, exports.ContactFeatureType.e_vertex);
            return;
        }
        // Compute barycentric coordinates
        // u1 = (cLocal - v1) dot (v2 - v1))
        var u1 = dotVec2(cLocal, v2) - dotVec2(cLocal, v1) - dotVec2(v1, v2) + dotVec2(v1, v1);
        // u2 = (cLocal - v2) dot (v1 - v2)
        var u2 = dotVec2(cLocal, v1) - dotVec2(cLocal, v2) - dotVec2(v2, v1) + dotVec2(v2, v2);
        if (u1 <= 0.0) {
            if (distSqrVec2(cLocal, v1) > radius * radius) {
                return;
            }
            manifold.pointCount = 1;
            manifold.type = exports.ManifoldType.e_faceA;
            diffVec2(manifold.localNormal, cLocal, v1);
            normalizeVec2(manifold.localNormal);
            copyVec2(manifold.localPoint, v1);
            copyVec2(manifold.points[0].localPoint, circleB.m_p);
            // manifold.points[0].id.key = 0;
            manifold.points[0].id.setFeatures(0, exports.ContactFeatureType.e_vertex, 0, exports.ContactFeatureType.e_vertex);
        }
        else if (u2 <= 0.0) {
            if (distSqrVec2(cLocal, v2) > radius * radius) {
                return;
            }
            manifold.pointCount = 1;
            manifold.type = exports.ManifoldType.e_faceA;
            diffVec2(manifold.localNormal, cLocal, v2);
            normalizeVec2(manifold.localNormal);
            copyVec2(manifold.localPoint, v2);
            copyVec2(manifold.points[0].localPoint, circleB.m_p);
            // manifold.points[0].id.key = 0;
            manifold.points[0].id.setFeatures(0, exports.ContactFeatureType.e_vertex, 0, exports.ContactFeatureType.e_vertex);
        }
        else {
            combineVec2(faceCenter, 0.5, v1, 0.5, v2);
            var separation_1 = dotVec2(cLocal, normals[vertIndex1]) - dotVec2(faceCenter, normals[vertIndex1]);
            if (separation_1 > radius) {
                return;
            }
            manifold.pointCount = 1;
            manifold.type = exports.ManifoldType.e_faceA;
            copyVec2(manifold.localNormal, normals[vertIndex1]);
            copyVec2(manifold.localPoint, faceCenter);
            copyVec2(manifold.points[0].localPoint, circleB.m_p);
            // manifold.points[0].id.key = 0;
            manifold.points[0].id.setFeatures(0, exports.ContactFeatureType.e_vertex, 0, exports.ContactFeatureType.e_vertex);
        }
    };

    /*
     * Planck.js
     * The MIT License
     * Copyright (c) 2021 Erin Catto, Ali Shakiba
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /** @internal */ var math_min = Math.min;
    Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);
    Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);
    /** @internal */ function EdgePolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
        CollideEdgePolygon(manifold, fA.getShape(), xfA, fB.getShape(), xfB);
    }
    // reused
    /** @internal */ var edge_reuse = new EdgeShape();
    /** @internal */ function ChainPolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
        var chain = fA.getShape();
        chain.getChildEdge(edge_reuse, indexA);
        CollideEdgePolygon(manifold, edge_reuse, xfA, fB.getShape(), xfB);
    }
    /** @internal */ var EPAxisType;
    (function (EPAxisType) {
        EPAxisType[EPAxisType["e_unknown"] = -1] = "e_unknown";
        EPAxisType[EPAxisType["e_edgeA"] = 1] = "e_edgeA";
        EPAxisType[EPAxisType["e_edgeB"] = 2] = "e_edgeB";
    })(EPAxisType || (EPAxisType = {}));
    // unused?
    /** @internal */ var VertexType;
    (function (VertexType) {
        VertexType[VertexType["e_isolated"] = 0] = "e_isolated";
        VertexType[VertexType["e_concave"] = 1] = "e_concave";
        VertexType[VertexType["e_convex"] = 2] = "e_convex";
    })(VertexType || (VertexType = {}));
    /**
     * This structure is used to keep track of the best separating axis.
     */
    /** @internal */ var EPAxis = /** @class */ (function () {
        function EPAxis() {
        }
        return EPAxis;
    }());
    /**
     * This holds polygon B expressed in frame A.
     */
    /** @internal */ var TempPolygon = /** @class */ (function () {
        function TempPolygon() {
            this.vertices = []; // [Settings.maxPolygonVertices]
            this.normals = []; // [Settings.maxPolygonVertices];
            this.count = 0;
            for (var i = 0; i < SettingsInternal.maxPolygonVertices; i++) {
                this.vertices.push(vec2(0, 0));
                this.normals.push(vec2(0, 0));
            }
        }
        return TempPolygon;
    }());
    /**
     * Reference face used for clipping
     */
    /** @internal */ var ReferenceFace = /** @class */ (function () {
        function ReferenceFace() {
            this.v1 = vec2(0, 0);
            this.v2 = vec2(0, 0);
            this.normal = vec2(0, 0);
            this.sideNormal1 = vec2(0, 0);
            this.sideNormal2 = vec2(0, 0);
        }
        ReferenceFace.prototype.recycle = function () {
            zeroVec2(this.v1);
            zeroVec2(this.v2);
            zeroVec2(this.normal);
            zeroVec2(this.sideNormal1);
            zeroVec2(this.sideNormal2);
        };
        return ReferenceFace;
    }());
    // reused
    /** @internal */ var clipPoints1 = [new ClipVertex(), new ClipVertex()];
    /** @internal */ var clipPoints2 = [new ClipVertex(), new ClipVertex()];
    /** @internal */ var ie = [new ClipVertex(), new ClipVertex()];
    /** @internal */ var edgeAxis = new EPAxis();
    /** @internal */ var polygonAxis = new EPAxis();
    /** @internal */ var polygonBA = new TempPolygon();
    /** @internal */ var rf = new ReferenceFace();
    /** @internal */ var centroidB = vec2(0, 0);
    /** @internal */ var edge0 = vec2(0, 0);
    /** @internal */ var edge1 = vec2(0, 0);
    /** @internal */ var edge2 = vec2(0, 0);
    /** @internal */ var xf = transform(0, 0, 0);
    /** @internal */ var normal = vec2(0, 0);
    /** @internal */ var normal0 = vec2(0, 0);
    /** @internal */ var normal1 = vec2(0, 0);
    /** @internal */ var normal2 = vec2(0, 0);
    /** @internal */ var lowerLimit = vec2(0, 0);
    /** @internal */ var upperLimit = vec2(0, 0);
    /** @internal */ var perp = vec2(0, 0);
    /** @internal */ var n = vec2(0, 0);
    /**
     * This function collides and edge and a polygon, taking into account edge
     * adjacency.
     */
    var CollideEdgePolygon = function (manifold, edgeA, xfA, polygonB, xfB) {
        // Algorithm:
        // 1. Classify v1 and v2
        // 2. Classify polygon centroid as front or back
        // 3. Flip normal if necessary
        // 4. Initialize normal range to [-pi, pi] about face normal
        // 5. Adjust normal range according to adjacent edges
        // 6. Visit each separating axes, only accept axes within the range
        // 7. Return if _any_ axis indicates separation
        // 8. Clip
        // let m_type1: VertexType;
        // let m_type2: VertexType;
        invTransformTransform(xf, xfA, xfB);
        transformVec2(centroidB, xf, polygonB.m_centroid);
        var v0 = edgeA.m_vertex0;
        var v1 = edgeA.m_vertex1;
        var v2 = edgeA.m_vertex2;
        var v3 = edgeA.m_vertex3;
        var hasVertex0 = edgeA.m_hasVertex0;
        var hasVertex3 = edgeA.m_hasVertex3;
        diffVec2(edge1, v2, v1);
        normalizeVec2(edge1);
        setVec2(normal1, edge1.y, -edge1.x);
        var offset1 = dotVec2(normal1, centroidB) - dotVec2(normal1, v1);
        var offset0 = 0.0;
        var offset2 = 0.0;
        var convex1 = false;
        var convex2 = false;
        zeroVec2(normal0);
        zeroVec2(normal2);
        // Is there a preceding edge?
        if (hasVertex0) {
            diffVec2(edge0, v1, v0);
            normalizeVec2(edge0);
            setVec2(normal0, edge0.y, -edge0.x);
            convex1 = crossVec2Vec2(edge0, edge1) >= 0.0;
            offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);
        }
        // Is there a following edge?
        if (hasVertex3) {
            diffVec2(edge2, v3, v2);
            normalizeVec2(edge2);
            setVec2(normal2, edge2.y, -edge2.x);
            convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;
            offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);
        }
        var front;
        zeroVec2(normal);
        zeroVec2(lowerLimit);
        zeroVec2(upperLimit);
        // Determine front or back collision. Determine collision normal limits.
        if (hasVertex0 && hasVertex3) {
            if (convex1 && convex2) {
                front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;
                if (front) {
                    copyVec2(normal, normal1);
                    copyVec2(lowerLimit, normal0);
                    copyVec2(upperLimit, normal2);
                }
                else {
                    setMulVec2(normal, -1, normal1);
                    setMulVec2(lowerLimit, -1, normal1);
                    setMulVec2(upperLimit, -1, normal1);
                }
            }
            else if (convex1) {
                front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);
                if (front) {
                    copyVec2(normal, normal1);
                    copyVec2(lowerLimit, normal0);
                    copyVec2(upperLimit, normal1);
                }
                else {
                    setMulVec2(normal, -1, normal1);
                    setMulVec2(lowerLimit, -1, normal2);
                    setMulVec2(upperLimit, -1, normal1);
                }
            }
            else if (convex2) {
                front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);
                if (front) {
                    copyVec2(normal, normal1);
                    copyVec2(lowerLimit, normal1);
                    copyVec2(upperLimit, normal2);
                }
                else {
                    setMulVec2(normal, -1, normal1);
                    setMulVec2(lowerLimit, -1, normal1);
                    setMulVec2(upperLimit, -1, normal0);
                }
            }
            else {
                front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;
                if (front) {
                    copyVec2(normal, normal1);
                    copyVec2(lowerLimit, normal1);
                    copyVec2(upperLimit, normal1);
                }
                else {
                    setMulVec2(normal, -1, normal1);
                    setMulVec2(lowerLimit, -1, normal2);
                    setMulVec2(upperLimit, -1, normal0);
                }
            }
        }
        else if (hasVertex0) {
            if (convex1) {
                front = offset0 >= 0.0 || offset1 >= 0.0;
                if (front) {
                    copyVec2(normal, normal1);
                    copyVec2(lowerLimit, normal0);
                    setMulVec2(upperLimit, -1, normal1);
                }
                else {
                    setMulVec2(normal, -1, normal1);
                    copyVec2(lowerLimit, normal1);
                    setMulVec2(upperLimit, -1, normal1);
                }
            }
            else {
                front = offset0 >= 0.0 && offset1 >= 0.0;
                if (front) {
                    copyVec2(normal, normal1);
                    copyVec2(lowerLimit, normal1);
                    setMulVec2(upperLimit, -1, normal1);
                }
                else {
                    setMulVec2(normal, -1, normal1);
                    copyVec2(lowerLimit, normal1);
                    setMulVec2(upperLimit, -1, normal0);
                }
            }
        }
        else if (hasVertex3) {
            if (convex2) {
                front = offset1 >= 0.0 || offset2 >= 0.0;
                if (front) {
                    copyVec2(normal, normal1);
                    setMulVec2(lowerLimit, -1, normal1);
                    copyVec2(upperLimit, normal2);
                }
                else {
                    setMulVec2(normal, -1, normal1);
                    setMulVec2(lowerLimit, -1, normal1);
                    copyVec2(upperLimit, normal1);
                }
            }
            else {
                front = offset1 >= 0.0 && offset2 >= 0.0;
                if (front) {
                    copyVec2(normal, normal1);
                    setMulVec2(lowerLimit, -1, normal1);
                    copyVec2(upperLimit, normal1);
                }
                else {
                    setMulVec2(normal, -1, normal1);
                    setMulVec2(lowerLimit, -1, normal2);
                    copyVec2(upperLimit, normal1);
                }
            }
        }
        else {
            front = offset1 >= 0.0;
            if (front) {
                copyVec2(normal, normal1);
                setMulVec2(lowerLimit, -1, normal1);
                setMulVec2(upperLimit, -1, normal1);
            }
            else {
                setMulVec2(normal, -1, normal1);
                copyVec2(lowerLimit, normal1);
                copyVec2(upperLimit, normal1);
            }
        }
        // Get polygonB in frameA
        polygonBA.count = polygonB.m_count;
        for (var i = 0; i < polygonB.m_count; ++i) {
            transformVec2(polygonBA.vertices[i], xf, polygonB.m_vertices[i]);
            rotVec2(polygonBA.normals[i], xf.q, polygonB.m_normals[i]);
        }
        var radius = polygonB.m_radius + edgeA.m_radius;
        manifold.pointCount = 0;
        { // ComputeEdgeSeparation
            edgeAxis.type = EPAxisType.e_edgeA;
            edgeAxis.index = front ? 0 : 1;
            edgeAxis.separation = Infinity;
            for (var i = 0; i < polygonBA.count; ++i) {
                var v = polygonBA.vertices[i];
                var s = dotVec2(normal, v) - dotVec2(normal, v1);
                if (s < edgeAxis.separation) {
                    edgeAxis.separation = s;
                }
            }
        }
        // If no valid normal can be found than this edge should not collide.
        // @ts-ignore todo: why we need this if here?
        if (edgeAxis.type == EPAxisType.e_unknown) {
            return;
        }
        if (edgeAxis.separation > radius) {
            return;
        }
        { // ComputePolygonSeparation
            polygonAxis.type = EPAxisType.e_unknown;
            polygonAxis.index = -1;
            polygonAxis.separation = -Infinity;
            setVec2(perp, -normal.y, normal.x);
            for (var i = 0; i < polygonBA.count; ++i) {
                setMulVec2(n, -1, polygonBA.normals[i]);
                var s1 = dotVec2(n, polygonBA.vertices[i]) - dotVec2(n, v1);
                var s2 = dotVec2(n, polygonBA.vertices[i]) - dotVec2(n, v2);
                var s = math_min(s1, s2);
                if (s > radius) {
                    // No collision
                    polygonAxis.type = EPAxisType.e_edgeB;
                    polygonAxis.index = i;
                    polygonAxis.separation = s;
                    break;
                }
                // Adjacency
                if (dotVec2(n, perp) >= 0.0) {
                    if (dotVec2(n, normal) - dotVec2(upperLimit, normal) < -SettingsInternal.angularSlop) {
                        continue;
                    }
                }
                else {
                    if (dotVec2(n, normal) - dotVec2(lowerLimit, normal) < -SettingsInternal.angularSlop) {
                        continue;
                    }
                }
                if (s > polygonAxis.separation) {
                    polygonAxis.type = EPAxisType.e_edgeB;
                    polygonAxis.index = i;
                    polygonAxis.separation = s;
                }
            }
        }
        if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {
            return;
        }
        // Use hysteresis for jitter reduction.
        var k_relativeTol = 0.98;
        var k_absoluteTol = 0.001;
        var primaryAxis;
        if (polygonAxis.type == EPAxisType.e_unknown) {
            primaryAxis = edgeAxis;
        }
        else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {
            primaryAxis = polygonAxis;
        }
        else {
            primaryAxis = edgeAxis;
        }
        ie[0].recycle(), ie[1].recycle();
        if (primaryAxis.type == EPAxisType.e_edgeA) {
            manifold.type = exports.ManifoldType.e_faceA;
            // Search for the polygon normal that is most anti-parallel to the edge
            // normal.
            var bestIndex = 0;
            var bestValue = dotVec2(normal, polygonBA.normals[0]);
            for (var i = 1; i < polygonBA.count; ++i) {
                var value = dotVec2(normal, polygonBA.normals[i]);
                if (value < bestValue) {
                    bestValue = value;
                    bestIndex = i;
                }
            }
            var i1 = bestIndex;
            var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;
            copyVec2(ie[0].v, polygonBA.vertices[i1]);
            ie[0].id.setFeatures(0, exports.ContactFeatureType.e_face, i1, exports.ContactFeatureType.e_vertex);
            copyVec2(ie[1].v, polygonBA.vertices[i2]);
            ie[1].id.setFeatures(0, exports.ContactFeatureType.e_face, i2, exports.ContactFeatureType.e_vertex);
            if (front) {
                rf.i1 = 0;
                rf.i2 = 1;
                copyVec2(rf.v1, v1);
                copyVec2(rf.v2, v2);
                copyVec2(rf.normal, normal1);
            }
            else {
                rf.i1 = 1;
                rf.i2 = 0;
                copyVec2(rf.v1, v2);
                copyVec2(rf.v2, v1);
                setMulVec2(rf.normal, -1, normal1);
            }
        }
        else {
            manifold.type = exports.ManifoldType.e_faceB;
            copyVec2(ie[0].v, v1);
            ie[0].id.setFeatures(0, exports.ContactFeatureType.e_vertex, primaryAxis.index, exports.ContactFeatureType.e_face);
            copyVec2(ie[1].v, v2);
            ie[1].id.setFeatures(0, exports.ContactFeatureType.e_vertex, primaryAxis.index, exports.ContactFeatureType.e_face);
            rf.i1 = primaryAxis.index;
            rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;
            copyVec2(rf.v1, polygonBA.vertices[rf.i1]);
            copyVec2(rf.v2, polygonBA.vertices[rf.i2]);
            copyVec2(rf.normal, polygonBA.normals[rf.i1]);
        }
        setVec2(rf.sideNormal1, rf.normal.y, -rf.normal.x);
        setVec2(rf.sideNormal2, -rf.sideNormal1.x, -rf.sideNormal1.y);
        rf.sideOffset1 = dotVec2(rf.sideNormal1, rf.v1);
        rf.sideOffset2 = dotVec2(rf.sideNormal2, rf.v2);
        // Clip incident edge against extruded edge1 side edges.
        clipPoints1[0].recycle(), clipPoints1[1].recycle();
        clipPoints2[0].recycle(), clipPoints2[1].recycle();
        // Clip to box side 1
        var np1 = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);
        if (np1 < SettingsInternal.maxManifoldPoints) {
            return;
        }
        // Clip to negative box side 1
        var np2 = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);
        if (np2 < SettingsInternal.maxManifoldPoints) {
            return;
        }
        // Now clipPoints2 contains the clipped points.
        if (primaryAxis.type == EPAxisType.e_edgeA) {
            copyVec2(manifold.localNormal, rf.normal);
            copyVec2(manifold.localPoint, rf.v1);
        }
        else {
            copyVec2(manifold.localNormal, polygonB.m_normals[rf.i1]);
            copyVec2(manifold.localPoint, polygonB.m_vertices[rf.i1]);
        }
        var pointCount = 0;
        for (var i = 0; i < SettingsInternal.maxManifoldPoints; ++i) {
            var separation = dotVec2(rf.normal, clipPoints2[i].v) - dotVec2(rf.normal, rf.v1);
            if (separation <= radius) {
                var cp = manifold.points[pointCount]; // ManifoldPoint
                if (primaryAxis.type == EPAxisType.e_edgeA) {
                    invTransformVec2(cp.localPoint, xf, clipPoints2[i].v);
                    cp.id.set(clipPoints2[i].id);
                }
                else {
                    copyVec2(cp.localPoint, clipPoints2[i].v);
                    cp.id.set(clipPoints2[i].id);
                    cp.id.swapFeatures();
                }
                ++pointCount;
            }
        }
        manifold.pointCount = pointCount;
    };

    /** @deprecated Merged with main namespace */
    var internal = {
        CollidePolygons: CollidePolygons,
        Settings: SettingsInternal,
        Sweep: Sweep,
        Manifold: Manifold,
        Distance: Distance,
        TimeOfImpact: TimeOfImpact,
        DynamicTree: DynamicTree,
        stats: stats
    };

    var planck = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Math: math,
        Serializer: Serializer,
        Testbed: Testbed,
        testbed: testbed,
        Vec2: Vec2,
        Vec3: Vec3,
        Mat22: Mat22,
        Mat33: Mat33,
        Transform: Transform,
        Rot: Rot,
        AABB: AABB,
        Shape: Shape,
        FixtureProxy: FixtureProxy,
        Fixture: Fixture,
        Body: Body,
        ContactEdge: ContactEdge,
        mixFriction: mixFriction,
        mixRestitution: mixRestitution,
        VelocityConstraintPoint: VelocityConstraintPoint,
        Contact: Contact,
        JointEdge: JointEdge,
        Joint: Joint,
        World: World,
        CircleShape: CircleShape,
        Circle: Circle,
        EdgeShape: EdgeShape,
        Edge: Edge,
        PolygonShape: PolygonShape,
        Polygon: Polygon,
        ChainShape: ChainShape,
        Chain: Chain,
        BoxShape: BoxShape,
        Box: Box,
        CollideCircles: CollideCircles,
        CollideEdgeCircle: CollideEdgeCircle,
        CollidePolygons: CollidePolygons,
        CollidePolygonCircle: CollidePolygonCircle,
        CollideEdgePolygon: CollideEdgePolygon,
        DistanceJoint: DistanceJoint,
        FrictionJoint: FrictionJoint,
        GearJoint: GearJoint,
        MotorJoint: MotorJoint,
        MouseJoint: MouseJoint,
        PrismaticJoint: PrismaticJoint,
        PulleyJoint: PulleyJoint,
        RevoluteJoint: RevoluteJoint,
        RopeJoint: RopeJoint,
        WeldJoint: WeldJoint,
        WheelJoint: WheelJoint,
        Settings: Settings,
        SettingsInternal: SettingsInternal,
        Sweep: Sweep,
        get ManifoldType () { return exports.ManifoldType; },
        get ContactFeatureType () { return exports.ContactFeatureType; },
        get PointState () { return exports.PointState; },
        ClipVertex: ClipVertex,
        Manifold: Manifold,
        ManifoldPoint: ManifoldPoint,
        ContactID: ContactID,
        WorldManifold: WorldManifold,
        getPointStates: getPointStates,
        clipSegmentToLine: clipSegmentToLine,
        DistanceInput: DistanceInput,
        DistanceOutput: DistanceOutput,
        SimplexCache: SimplexCache,
        Distance: Distance,
        DistanceProxy: DistanceProxy,
        testOverlap: testOverlap,
        ShapeCastInput: ShapeCastInput,
        ShapeCastOutput: ShapeCastOutput,
        ShapeCast: ShapeCast,
        TOIInput: TOIInput,
        get TOIOutputState () { return exports.TOIOutputState; },
        TOIOutput: TOIOutput,
        TimeOfImpact: TimeOfImpact,
        TreeNode: TreeNode,
        DynamicTree: DynamicTree,
        stats: stats,
        internal: internal
    });

    exports.AABB = AABB;
    exports.Body = Body;
    exports.Box = Box;
    exports.BoxShape = BoxShape;
    exports.Chain = Chain;
    exports.ChainShape = ChainShape;
    exports.Circle = Circle;
    exports.CircleShape = CircleShape;
    exports.ClipVertex = ClipVertex;
    exports.CollideCircles = CollideCircles;
    exports.CollideEdgeCircle = CollideEdgeCircle;
    exports.CollideEdgePolygon = CollideEdgePolygon;
    exports.CollidePolygonCircle = CollidePolygonCircle;
    exports.CollidePolygons = CollidePolygons;
    exports.Contact = Contact;
    exports.ContactEdge = ContactEdge;
    exports.ContactID = ContactID;
    exports.Distance = Distance;
    exports.DistanceInput = DistanceInput;
    exports.DistanceJoint = DistanceJoint;
    exports.DistanceOutput = DistanceOutput;
    exports.DistanceProxy = DistanceProxy;
    exports.DynamicTree = DynamicTree;
    exports.Edge = Edge;
    exports.EdgeShape = EdgeShape;
    exports.Fixture = Fixture;
    exports.FixtureProxy = FixtureProxy;
    exports.FrictionJoint = FrictionJoint;
    exports.GearJoint = GearJoint;
    exports.Joint = Joint;
    exports.JointEdge = JointEdge;
    exports.Manifold = Manifold;
    exports.ManifoldPoint = ManifoldPoint;
    exports.Mat22 = Mat22;
    exports.Mat33 = Mat33;
    exports.Math = math;
    exports.MotorJoint = MotorJoint;
    exports.MouseJoint = MouseJoint;
    exports.Polygon = Polygon;
    exports.PolygonShape = PolygonShape;
    exports.PrismaticJoint = PrismaticJoint;
    exports.PulleyJoint = PulleyJoint;
    exports.RevoluteJoint = RevoluteJoint;
    exports.RopeJoint = RopeJoint;
    exports.Rot = Rot;
    exports.Serializer = Serializer;
    exports.Settings = Settings;
    exports.SettingsInternal = SettingsInternal;
    exports.Shape = Shape;
    exports.ShapeCast = ShapeCast;
    exports.ShapeCastInput = ShapeCastInput;
    exports.ShapeCastOutput = ShapeCastOutput;
    exports.SimplexCache = SimplexCache;
    exports.Sweep = Sweep;
    exports.TOIInput = TOIInput;
    exports.TOIOutput = TOIOutput;
    exports.Testbed = Testbed;
    exports.TimeOfImpact = TimeOfImpact;
    exports.Transform = Transform;
    exports.TreeNode = TreeNode;
    exports.Vec2 = Vec2;
    exports.Vec3 = Vec3;
    exports.VelocityConstraintPoint = VelocityConstraintPoint;
    exports.WeldJoint = WeldJoint;
    exports.WheelJoint = WheelJoint;
    exports.World = World;
    exports.WorldManifold = WorldManifold;
    exports.clipSegmentToLine = clipSegmentToLine;
    exports["default"] = planck;
    exports.getPointStates = getPointStates;
    exports.internal = internal;
    exports.mixFriction = mixFriction;
    exports.mixRestitution = mixRestitution;
    exports.stats = stats;
    exports.testOverlap = testOverlap;
    exports.testbed = testbed;

    Object.defineProperty(exports, '__esModule', { value: true });

}));


},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21waWxlZFRTL2luZGV4LmpzIiwiY29tcGlsZWRUUy9vYmplY3RzL2JveC5qcyIsImNvbXBpbGVkVFMvb2JqZWN0cy9jaXJjbGUuanMiLCJub2RlX21vZHVsZXMvcGxhbmNrL2Rpc3QvcGxhbmNrLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFjY29yZGluZyA9IHZvaWQgMDtcbmV4cG9ydHMuYWNjb3JkaW5nID0gMjA7XG5jb25zdCBwbGFuY2tfMSA9IHJlcXVpcmUoXCJwbGFuY2tcIik7XG5jb25zdCBib3hfMSA9IHJlcXVpcmUoXCIuL29iamVjdHMvYm94XCIpO1xuY29uc3QgY2lyY2xlXzEgPSByZXF1aXJlKFwiLi9vYmplY3RzL2NpcmNsZVwiKTtcbi8vIENyZWF0ZSBhbmQgc2V0IGNhbnZhc1xuY29uc3QgY2FudmFzID0gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XG5jYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbmNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5jb25zdCBjID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5jb25zdCB3b3JsZCA9IG5ldyBwbGFuY2tfMS5Xb3JsZCgoMCwgcGxhbmNrXzEuVmVjMikoMCwgMzApKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ29uc3RhbnRzXG5jb25zdCB0b0ogPSA0MDtcbmNvbnN0IGRlbGF5ID0gMSAvIDYwO1xuY29uc3Qgc3BlZWQgPSAxMDtcbmNvbnN0IGp1bXBTcGVlZCA9IDEwMDAwO1xuY29uc3QgcmFkaXVzID0gMzA7XG5jb25zdCBrZXlzID0ge1xuICAgIHc6IGZhbHNlLFxuICAgIHM6IGZhbHNlLFxuICAgIGE6IGZhbHNlLFxuICAgIGQ6IGZhbHNlXG59O1xubGV0IF90b0pDID0gMDsgLy8gVG8ganVtcCBjb3VudGVyXG4vLyAtLS0tLS0tLS1cbi8vIE9iamVjdHNcbmNvbnN0IG9iamVjdHMgPSBuZXcgU2V0KCk7XG4vLyBBcmVhXG5jb25zdCBib3R0b21IID0gNDU7XG5jb25zdCB0MlcgPSAoY2FudmFzLndpZHRoIC8gMikgLyA4O1xub2JqZWN0cy5hZGQobmV3IGJveF8xLkJveCgwLCBjYW52YXMuaGVpZ2h0IC0gYm90dG9tSCwgY2FudmFzLndpZHRoIC8gMiwgYm90dG9tSCwgJ3JnYigxMjYsIDUsIDUpJywgd29ybGQsIGMsIHsgdHlwZTogJ3N0YXRpYycgfSkpO1xuZm9yIChsZXQgeCA9IGNhbnZhcy53aWR0aCAvIDIgKyB0Mlc7IHggPCBjYW52YXMud2lkdGg7IHggKz0gdDJXICogMikge1xuICAgIG9iamVjdHMuYWRkKG5ldyBib3hfMS5Cb3goeCArIHQyVyAvIDIgLSBib3R0b21IIC8gNCwgY2FudmFzLmhlaWdodCAtIGJvdHRvbUggKiA1LCBib3R0b21IIC8gMiwgYm90dG9tSCAqIDQsICdyZ2IoMTA1LCA0MiwgMCknLCB3b3JsZCwgYywgeyB0eXBlOiAnZHluYW1pYycgfSwgeyBkZW5zaXR5OiA4LCB1c2VyRGF0YTogeyBjY2FwOiB0cnVlIH0gfSkpO1xuICAgIG9iamVjdHMuYWRkKG5ldyBib3hfMS5Cb3goeCwgY2FudmFzLmhlaWdodCAtIGJvdHRvbUgsIHQyVywgYm90dG9tSCwgJ3JnYigxMjYsIDUsIDUpJywgd29ybGQsIGMsIHsgdHlwZTogJ3N0YXRpYycsIGZpeGVkUm90YXRpb246IGZhbHNlIH0pKTtcbn1cbm9iamVjdHMuYWRkKG5ldyBib3hfMS5Cb3goMCwgY2FudmFzLmhlaWdodCAtIGJvdHRvbUggKiA0LCBib3R0b21ILCBib3R0b21IIC8gMiwgJ3JnYigxMjYsIDUsIDUpJywgd29ybGQsIGMsIHsgdHlwZTogJ3N0YXRpYycgfSkpO1xub2JqZWN0cy5hZGQobmV3IGNpcmNsZV8xLkNpcmNsZShjYW52YXMud2lkdGggLyA0ICsgYm90dG9tSCAqIDQsIGNhbnZhcy5oZWlnaHQgLSBib3R0b21IICogMywgYm90dG9tSCAvIDMsICdyZ2IoMTI2LCA1LCA1KScsIHdvcmxkLCBjLCB7IHR5cGU6ICdzdGF0aWMnIH0pKTtcbm9iamVjdHMuYWRkKG5ldyBjaXJjbGVfMS5DaXJjbGUoY2FudmFzLndpZHRoIC8gNCwgY2FudmFzLmhlaWdodCAtIGJvdHRvbUggKiA1LjUsIGJvdHRvbUgsICdyZ2IoMTI2LCA1LCA1KScsIHdvcmxkLCBjLCB7IHR5cGU6ICdzdGF0aWMnIH0pKTtcbm9iamVjdHMuYWRkKG5ldyBib3hfMS5Cb3goMCwgY2FudmFzLmhlaWdodCAtIGJvdHRvbUggKiA4LCBib3R0b21ILCBib3R0b21IIC8gMiwgJ3JnYigxMjYsIDUsIDUpJywgd29ybGQsIGMsIHsgdHlwZTogJ3N0YXRpYycgfSkpO1xub2JqZWN0cy5hZGQobmV3IGJveF8xLkJveChib3R0b21IICogMiwgY2FudmFzLmhlaWdodCAtIGJvdHRvbUggKiAxMi41LCBjYW52YXMud2lkdGggLyAyICogMC44LCBib3R0b21ILCAncmdiKDEyNiwgNSwgNSknLCB3b3JsZCwgYywgeyB0eXBlOiAnc3RhdGljJyB9KSk7XG5vYmplY3RzLmFkZChuZXcgYm94XzEuQm94KDAsIGNhbnZhcy5oZWlnaHQgLSBib3R0b21IICogMTYsIGJvdHRvbUgsIGJvdHRvbUggLyAyLCAncmdiKDEyNiwgNSwgNSknLCB3b3JsZCwgYywgeyB0eXBlOiAnc3RhdGljJyB9KSk7XG5vYmplY3RzLmFkZChuZXcgYm94XzEuQm94KDAsIHJhZGl1cyAqIDIsIGJvdHRvbUgsIGJvdHRvbUggLyAyLCAncmdiKDEyNiwgNSwgNSknLCB3b3JsZCwgYywgeyB0eXBlOiAnc3RhdGljJyB9KSk7XG5vYmplY3RzLmFkZChuZXcgYm94XzEuQm94KGNhbnZhcy53aWR0aCAtIGNhbnZhcy53aWR0aCAvIDIgKiAwLjgsIHJhZGl1cyAqIDUsIGNhbnZhcy53aWR0aCAvIDIgKiAwLjgsIGJvdHRvbUggLyAyLCAncmdiKDEyNiwgNSwgNSknLCB3b3JsZCwgYywgeyB0eXBlOiAnc3RhdGljJyB9KSk7XG5vYmplY3RzLmFkZChuZXcgYm94XzEuQm94KGNhbnZhcy53aWR0aCAvIDIgKyBib3R0b21IIC8gMiwgY2FudmFzLmhlaWdodCAtIGJvdHRvbUggKiAxNS42NSwgYm90dG9tSCAvIDIsIGJvdHRvbUggLyAyLCAncmdiKDEyNiwgNSwgNSknLCB3b3JsZCwgYywgeyB0eXBlOiAnc3RhdGljJyB9KSk7XG5vYmplY3RzLmFkZChuZXcgYm94XzEuQm94KGNhbnZhcy53aWR0aCAtIGNhbnZhcy53aWR0aCAvIDIgKiAwLjgsIGNhbnZhcy5oZWlnaHQgKiAoMS41IC8gMyksIGNhbnZhcy53aWR0aCAvIDIgKiAwLjgsIGJvdHRvbUggKiA0LCAncmdiKDEyNiwgNSwgNSknLCB3b3JsZCwgYywgeyB0eXBlOiAnc3RhdGljJyB9KSk7XG4vLyAtLS0tLS1cbi8vIER5bmFtaWMgYm9kaWVzXG5sZXQgcGxheWVyID0gbmV3IGNpcmNsZV8xLkNpcmNsZShyYWRpdXMsIGNhbnZhcy5oZWlnaHQgLSBib3R0b21IIC0gcmFkaXVzLCByYWRpdXMsICdyZ2IoMjQxLCAxODAsIDkpJywgd29ybGQsIGMsIHsgdHlwZTogJ2R5bmFtaWMnIH0sIHsgcmVzdGl0dXRpb246IDAsIGRlbnNpdHk6IDEsIHVzZXJEYXRhOiB7IGNjYXA6IHRydWUgfSB9KTtcbm9iamVjdHMuYWRkKG5ldyBjaXJjbGVfMS5DaXJjbGUoMjAwLCAxMDAsIHJhZGl1cywgJ2dyZWVuJywgd29ybGQsIGMsIHsgdHlwZTogJ2R5bmFtaWMnLCBsaW5lYXJEYW1waW5nOiAyIH0sIHsgcmVzdGl0dXRpb246IDAuNywgZGVuc2l0eTogMSwgdXNlckRhdGE6IHsgY2NhcDogdHJ1ZSB9IH0pKTtcbm9iamVjdHMuYWRkKG5ldyBjaXJjbGVfMS5DaXJjbGUoY2FudmFzLndpZHRoIC0gY2FudmFzLndpZHRoIC8gMiAqIDAuOCArIHJhZGl1cyAqIDEuNSwgcmFkaXVzICogMiwgcmFkaXVzLCAncmdiKDIxMiwgMTYsIDE5NiknLCB3b3JsZCwgYywgeyB0eXBlOiAnZHluYW1pYycsIGxpbmVhckRhbXBpbmc6IDIgfSwgeyByZXN0aXR1dGlvbjogMC43LCBkZW5zaXR5OiAxLCB1c2VyRGF0YTogeyBjY2FwOiB0cnVlIH0gfSkpO1xub2JqZWN0cy5hZGQocGxheWVyKTtcbmNvbnN0IGJhbGxSID0gcmFkaXVzIC8gMywgYmFsbHNDID0gMTA7XG5mb3IgKGxldCB4ID0gY2FudmFzLndpZHRoIC0gY2FudmFzLndpZHRoIC8gMiAqIDAuNCwgeSA9IGNhbnZhcy5oZWlnaHQgKiAoMS41IC8gMykgLSBiYWxsUjsgeSA+IGNhbnZhcy5oZWlnaHQgKiAoMS41IC8gMykgLSBiYWxsUiAqIDIgKiBiYWxsc0M7IHkgLT0gYmFsbFIgKiAyKVxuICAgIG9iamVjdHMuYWRkKG5ldyBjaXJjbGVfMS5DaXJjbGUoeCwgeSwgYmFsbFIsICdncmVlbicsIHdvcmxkLCBjLCB7IHR5cGU6ICdkeW5hbWljJywgbGluZWFyRGFtcGluZzogMSB9LCB7IHJlc3RpdHV0aW9uOiAwLjg1LCBkZW5zaXR5OiAxLCB1c2VyRGF0YTogeyBjY2FwOiB0cnVlIH0gfSkpO1xuLy8gLS0tLS0tLVxuLy8gSW5wdXQgbGlzdGVuZXJzXG5kb2N1bWVudC5vbmtleWRvd24gPSAoaykgPT4ge1xuICAgIGlmIChrLmNvZGUgPT0gJ0tleVcnKVxuICAgICAgICBrZXlzLncgPSB0cnVlO1xuICAgIGlmIChrLmNvZGUgPT0gJ0tleVMnKVxuICAgICAgICBrZXlzLnMgPSB0cnVlO1xuICAgIGlmIChrLmNvZGUgPT0gJ0tleUEnKVxuICAgICAgICBrZXlzLmEgPSB0cnVlO1xuICAgIGlmIChrLmNvZGUgPT0gJ0tleUQnKVxuICAgICAgICBrZXlzLmQgPSB0cnVlO1xufTtcbmRvY3VtZW50Lm9ua2V5dXAgPSAoaykgPT4ge1xuICAgIGlmIChrLmNvZGUgPT0gJ0tleVcnKVxuICAgICAgICBrZXlzLncgPSBmYWxzZTtcbiAgICBpZiAoay5jb2RlID09ICdLZXlTJylcbiAgICAgICAga2V5cy5zID0gZmFsc2U7XG4gICAgaWYgKGsuY29kZSA9PSAnS2V5QScpXG4gICAgICAgIGtleXMuYSA9IGZhbHNlO1xuICAgIGlmIChrLmNvZGUgPT0gJ0tleUQnKVxuICAgICAgICBrZXlzLmQgPSBmYWxzZTtcbn07XG5jYW52YXMub25tb3VzZWRvd24gPSAobWQpID0+IHtcbiAgICBjb25zdCBjbGlja09uID0gd29ybGQucXVlcnlBQUJCKCgwLCBwbGFuY2tfMS5BQUJCKSgoMCwgcGxhbmNrXzEuVmVjMikoKG1kLnggLSAxKSAvIGV4cG9ydHMuYWNjb3JkaW5nLCAobWQueSAtIDEpIC8gZXhwb3J0cy5hY2NvcmRpbmcpLCAoMCwgcGxhbmNrXzEuVmVjMikoKG1kLnggKyAxKSAvIGV4cG9ydHMuYWNjb3JkaW5nLCAobWQueSArIDEpIC8gZXhwb3J0cy5hY2NvcmRpbmcpKSwgZiA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGYuZ2V0VXNlckRhdGEoKTtcbiAgICAgICAgaWYgKG9iaiAmJiBvYmouZGF0YSAmJiBvYmouZGF0YS5jY2FwKSB7XG4gICAgICAgICAgICBwbGF5ZXIgPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tXG4vLyBDbGVhciBjb250ZXh0XG5jb25zdCBjbGVhciA9IChjKSA9PiB7XG4gICAgYy5maWxsU3R5bGUgPSAnJztcbiAgICBjLnNoYWRvd0JsdXIgPSAwO1xuICAgIGMuc2hhZG93Q29sb3IgPSAnJztcbiAgICBjLnN0cm9rZVN0eWxlID0gJyc7XG4gICAgYy5maWxsU3R5bGUgPSAnJztcbiAgICBjLmZpbHRlciA9ICcnO1xuICAgIGMubGluZVdpZHRoID0gMDtcbn07XG4vLyA6KVxuY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIGNsZWFyKGMpO1xuICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4wNSknO1xuICAgIGMuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAvLyBVcGRhdGUgUGh5c2ljXG4gICAgd29ybGQuc3RlcChkZWxheSk7XG4gICAgLy8gS2V5cyBQcm9jZXNzXG4gICAgY29uc3QgdmVsTm93ID0gcGxheWVyLmJvZHkuZ2V0TGluZWFyVmVsb2NpdHkoKTsgLy8gVmVsb2NpdHkgdlxuICAgIC8vIEp1bXBcbiAgICBfdG9KQyAmJiBfdG9KQy0tO1xuICAgIGlmICghX3RvSkMgJiYga2V5cy53ICYmIE1hdGguYWJzKHZlbE5vdy55KSA8IDAuMDUpIHtcbiAgICAgICAgX3RvSkMgPSB0b0o7XG4gICAgICAgIHBsYXllci5ib2R5LmFwcGx5Rm9yY2UoKDAsIHBsYW5ja18xLlZlYzIpKDAsIC1qdW1wU3BlZWQgKiAoKChfYSA9IHBsYXllci5ib2R5LmdldEZpeHR1cmVMaXN0KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXREZW5zaXR5KCkpIHx8IDEpKSwgcGxheWVyLmJvZHkuZ2V0V29ybGRDZW50ZXIoKSk7XG4gICAgfVxuICAgIC8vIEtleSBcInNcIiB4RFxuICAgIGlmIChrZXlzLnMpXG4gICAgICAgIHBsYXllci5ib2R5LnNldEdyYXZpdHlTY2FsZSg1KTtcbiAgICBlbHNlXG4gICAgICAgIHBsYXllci5ib2R5LnNldEdyYXZpdHlTY2FsZSgxKTtcbiAgICAvLyBNb3ZlbWVudFxuICAgIGlmIChrZXlzLmEpXG4gICAgICAgIHZlbE5vdy54ID0gLXNwZWVkO1xuICAgIGlmIChrZXlzLmQpXG4gICAgICAgIHZlbE5vdy54ID0gc3BlZWQ7XG4gICAgaWYgKCFrZXlzLmEgJiYgIWtleXMuZClcbiAgICAgICAgdmVsTm93LnggPSAwO1xuICAgIHBsYXllci5ib2R5LnNldExpbmVhclZlbG9jaXR5KHZlbE5vdyk7XG4gICAgLy8gLS0tLS0tLS0tLS0tXG4gICAgLy8gRHJhdyBQcm9jZXNzXG4gICAgb2JqZWN0cy5mb3JFYWNoKHAgPT4gcC5kcmF3KCkpO1xuICAgIC8vIC0tLS0tLS0tLS0tLVxufTtcbmFuaW1hdGUoKTsgLy8gU3RhcnRcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Cb3ggPSB2b2lkIDA7XG5jb25zdCBwbGFuY2tfMSA9IHJlcXVpcmUoXCJwbGFuY2tcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG5jbGFzcyBCb3gge1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yLCB3b3JsZCwgYywgYm9keURlZiA9IHt9LCBmaXh0RGVmID0ge30pIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZml4dERlZi51c2VyRGF0YTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgICAgIHRoaXMuYyA9IGM7XG4gICAgICAgIHRoaXMuX2JvZHkgPSB3b3JsZC5jcmVhdGVCb2R5KE9iamVjdC5hc3NpZ24oeyBwb3NpdGlvbjogKDAsIHBsYW5ja18xLlZlYzIpKHgsIHkpLm11bCgxIC8gX18xLmFjY29yZGluZykgfSwgYm9keURlZikpO1xuICAgICAgICBjb25zdCB3ID0gd2lkdGggLyBfXzEuYWNjb3JkaW5nIC8gMiwgaCA9IGhlaWdodCAvIF9fMS5hY2NvcmRpbmcgLyAyO1xuICAgICAgICB0aGlzLl9ib2R5LmNyZWF0ZUZpeHR1cmUoKDAsIHBsYW5ja18xLkJveCkodywgaCwgKDAsIHBsYW5ja18xLlZlYzIpKHcsIGgpKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaXh0RGVmKSwgeyB1c2VyRGF0YTogdGhpcyB9KSk7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmMsIHBvcyA9IHRoaXMuX2JvZHkuZ2V0UG9zaXRpb24oKS5jbG9uZSgpLm11bChfXzEuYWNjb3JkaW5nKTtcbiAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgYy5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgICBjLnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgICAgICBjLnJvdGF0ZSh0aGlzLl9ib2R5LmdldEFuZ2xlKCkpO1xuICAgICAgICBjLmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgYy5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfVxuICAgIGdldCBib2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9keTtcbiAgICB9XG59XG5leHBvcnRzLkJveCA9IEJveDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaXJjbGUgPSB2b2lkIDA7XG5jb25zdCBwbGFuY2tfMSA9IHJlcXVpcmUoXCJwbGFuY2tcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG5jbGFzcyBDaXJjbGUge1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHJhZGl1cywgY29sb3IsIHdvcmxkLCBjLCBib2R5RGVmID0ge30sIGZpeHREZWYgPSB7fSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBmaXh0RGVmLnVzZXJEYXRhO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgICAgIHRoaXMuYyA9IGM7XG4gICAgICAgIHRoaXMuX2JvZHkgPSB3b3JsZC5jcmVhdGVCb2R5KE9iamVjdC5hc3NpZ24oeyBwb3NpdGlvbjogKDAsIHBsYW5ja18xLlZlYzIpKHgsIHkpLm11bCgxIC8gX18xLmFjY29yZGluZyksIGZpeGVkUm90YXRpb246IHRydWUgfSwgYm9keURlZikpO1xuICAgICAgICB0aGlzLl9ib2R5LmNyZWF0ZUZpeHR1cmUoKDAsIHBsYW5ja18xLkNpcmNsZSkodGhpcy5yYWRpdXMgLyBfXzEuYWNjb3JkaW5nKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaXh0RGVmKSwgeyB1c2VyRGF0YTogdGhpcyB9KSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGZpeHREZWYpO1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5jLCBwb3MgPSB0aGlzLl9ib2R5LmdldFBvc2l0aW9uKCkuY2xvbmUoKS5tdWwoX18xLmFjY29yZGluZyk7XG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgICAgIGMuZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgICAgYy5hcmMocG9zLngsIHBvcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgICAgYy5maWxsKCk7XG4gICAgfVxuICAgIGdldCBib2R5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9keTtcbiAgICB9XG59XG5leHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbiIsIi8qKlxuICogUGxhbmNrLmpzIHYxLjAuMC1iZXRhLjE2XG4gKiBAbGljZW5zZSBUaGUgTUlUIGxpY2Vuc2VcbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnBsYW5jayA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG4gICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbiAgICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH1cblxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICAvKiogQGludGVybmFsICovXG4gICAgdmFyIG9wdGlvbnMgPSBmdW5jdGlvbiAoaW5wdXQsIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tb2JqZWN0LWxpdGVyYWwtdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICAgIGlucHV0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IF9fYXNzaWduKHt9LCBpbnB1dCk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3ItaW5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgaW5wdXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZGVmYXVsdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN5bWJvbCkgJiYgdHlwZW9mIGlucHV0W3N5bWJvbF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtzeW1ib2xdID0gZGVmYXVsdHNbc3ltYm9sXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfcmFuZG9tID0gTWF0aC5yYW5kb207XG4gICAgdmFyIEVQU0lMT04gPSAxZS05O1xuICAgIC8qKiBAaW50ZXJuYWwgQGRlcHJlY2F0ZWQgKi9cbiAgICB2YXIgaXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGU7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBOZXh0IExhcmdlc3QgUG93ZXIgb2YgMiBHaXZlbiBhIGJpbmFyeSBpbnRlZ2VyIHZhbHVlIHgsIHRoZSBuZXh0IGxhcmdlc3RcbiAgICAgKiBwb3dlciBvZiAyIGNhbiBiZSBjb21wdXRlZCBieSBhIFNXQVIgYWxnb3JpdGhtIHRoYXQgcmVjdXJzaXZlbHkgXCJmb2xkc1wiIHRoZVxuICAgICAqIHVwcGVyIGJpdHMgaW50byB0aGUgbG93ZXIgYml0cy4gVGhpcyBwcm9jZXNzIHlpZWxkcyBhIGJpdCB2ZWN0b3Igd2l0aCB0aGVcbiAgICAgKiBzYW1lIG1vc3Qgc2lnbmlmaWNhbnQgMSBhcyB4LCBidXQgYWxsIDEncyBiZWxvdyBpdC4gQWRkaW5nIDEgdG8gdGhhdCB2YWx1ZVxuICAgICAqIHlpZWxkcyB0aGUgbmV4dCBsYXJnZXN0IHBvd2VyIG9mIDIuIEZvciBhIDMyLWJpdCB2YWx1ZTpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZXh0UG93ZXJPZlR3byh4KSB7XG4gICAgICAgIHggfD0gKHggPj4gMSk7XG4gICAgICAgIHggfD0gKHggPj4gMik7XG4gICAgICAgIHggfD0gKHggPj4gNCk7XG4gICAgICAgIHggfD0gKHggPj4gOCk7XG4gICAgICAgIHggfD0gKHggPj4gMTYpO1xuICAgICAgICByZXR1cm4geCArIDE7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGZ1bmN0aW9uIGlzUG93ZXJPZlR3byh4KSB7XG4gICAgICAgIHJldHVybiB4ID4gMCAmJiAoeCAmICh4IC0gMSkpID09PSAwO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBmdW5jdGlvbiBtb2QobnVtLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1heCA9IDE7XG4gICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggPiBtaW4pIHtcbiAgICAgICAgICAgIG51bSA9IChudW0gLSBtaW4pICUgKG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXR1cm4gbnVtICsgKG51bSA8IDAgPyBtYXggOiBtaW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbnVtID0gKG51bSAtIG1heCkgJSAobWluIC0gbWF4KTtcbiAgICAgICAgICAgIHJldHVybiBudW0gKyAobnVtIDw9IDAgPyBtaW4gOiBtYXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJucyBhIG1pbiBpZiBudW0gaXMgbGVzcyB0aGFuIG1pbiwgYW5kIG1heCBpZiBtb3JlIHRoYW4gbWF4LCBvdGhlcndpc2UgcmV0dXJucyBudW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAobnVtIDwgbWluKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bSA+IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IHdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAgICogSWYgb25lIGFyZyBpcyBwcm92aWRlZCBiZXR3ZWVuIDAgdG8gbWF4LlxuICAgICAqIElmIG9uZSBhcmcgaXMgcGFzc2VkIGJldHdlZW4gMCB0byAxLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1heCA9IDE7XG4gICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gPT09IG1heCA/IG1pbiA6IG1hdGhfcmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICB2YXIgbWF0aCA9IE9iamVjdC5jcmVhdGUoTWF0aCk7XG4gICAgbWF0aC5FUFNJTE9OID0gRVBTSUxPTjtcbiAgICBtYXRoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbWF0aC5uZXh0UG93ZXJPZlR3byA9IG5leHRQb3dlck9mVHdvO1xuICAgIG1hdGguaXNQb3dlck9mVHdvID0gaXNQb3dlck9mVHdvO1xuICAgIG1hdGgubW9kID0gbW9kO1xuICAgIG1hdGguY2xhbXAgPSBjbGFtcDtcbiAgICBtYXRoLnJhbmRvbSA9IHJhbmRvbTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX2FicyQ5ID0gTWF0aC5hYnM7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9zcXJ0JDUgPSBNYXRoLnNxcnQ7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9tYXgkOCA9IE1hdGgubWF4O1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfbWluJDggPSBNYXRoLm1pbjtcbiAgICB2YXIgVmVjMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgZnVuY3Rpb24gVmVjMih4LCB5KSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVmVjMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0geC54O1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHgueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVmVjMi5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVmVjMi5wcm90b3R5cGUpO1xuICAgICAgICAgICAgb2JqLnggPSBkYXRhLng7XG4gICAgICAgICAgICBvYmoueSA9IGRhdGEueTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIuemVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKFZlYzIucHJvdG90eXBlKTtcbiAgICAgICAgICAgIG9iai54ID0gMDtcbiAgICAgICAgICAgIG9iai55ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVmVjMi5uZW8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVmVjMi5wcm90b3R5cGUpO1xuICAgICAgICAgICAgb2JqLnggPSB4O1xuICAgICAgICAgICAgb2JqLnkgPSB5O1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5jbG9uZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8odi54LCB2LnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRG9lcyB0aGlzIHZlY3RvciBjb250YWluIGZpbml0ZSBjb29yZGluYXRlcz9cbiAgICAgICAgICovXG4gICAgICAgIFZlYzIuaXNWYWxpZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG9iai54KSAmJiBOdW1iZXIuaXNGaW5pdGUob2JqLnkpO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIuY2xvbmUodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB2ZWN0b3IgdG8gYWxsIHplcm9zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy54ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy55ID0gMC4wO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB2ZWN0b3IgdG8gc29tZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIFZlYzIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0geC54O1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHgueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdmVjdG9yIHRvIHNvbWUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5zZXROdW0gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHZlY3RvciB0byBzb21lIHNwZWNpZmllZCBjb29yZGluYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUuc2V0VmVjMiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy54ID0gdmFsdWUueDtcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlLnk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBAZGVwcmVjYXRlZCBVc2Ugc2V0Q29tYmluZSBvciBzZXRNdWwgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUud1NldCA9IGZ1bmN0aW9uIChhLCB2LCBiLCB3KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldENvbWJpbmUoYSwgdiwgYiwgdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNdWwoYSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgbGluZWFyIGNvbWJpbmF0aW9uIG9mIHYgYW5kIHc6IGBhICogdiArIGIgKiB3YFxuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUuc2V0Q29tYmluZSA9IGZ1bmN0aW9uIChhLCB2LCBiLCB3KSB7XG4gICAgICAgICAgICB2YXIgeCA9IGEgKiB2LnggKyBiICogdy54O1xuICAgICAgICAgICAgdmFyIHkgPSBhICogdi55ICsgYiAqIHcueTtcbiAgICAgICAgICAgIC8vIGB0aGlzYCBtYXkgYmUgYHdgXG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5zZXRNdWwgPSBmdW5jdGlvbiAoYSwgdikge1xuICAgICAgICAgICAgdmFyIHggPSBhICogdi54O1xuICAgICAgICAgICAgdmFyIHkgPSBhICogdi55O1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIHZlY3RvciB0byB0aGlzIHZlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgVmVjMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIHRoaXMueCArPSB3Lng7XG4gICAgICAgICAgICB0aGlzLnkgKz0gdy55O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgQGRlcHJlY2F0ZWQgVXNlIGFkZENvbWJpbmUgb3IgYWRkTXVsICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLndBZGQgPSBmdW5jdGlvbiAoYSwgdiwgYiwgdykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDb21iaW5lKGEsIHYsIGIsIHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTXVsKGEsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGxpbmVhciBjb21iaW5hdGlvbiBvZiB2IGFuZCB3OiBgYSAqIHYgKyBiICogd2BcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLmFkZENvbWJpbmUgPSBmdW5jdGlvbiAoYSwgdiwgYiwgdykge1xuICAgICAgICAgICAgdmFyIHggPSBhICogdi54ICsgYiAqIHcueDtcbiAgICAgICAgICAgIHZhciB5ID0gYSAqIHYueSArIGIgKiB3Lnk7XG4gICAgICAgICAgICAvLyBgdGhpc2AgbWF5IGJlIGB3YFxuICAgICAgICAgICAgdGhpcy54ICs9IHg7XG4gICAgICAgICAgICB0aGlzLnkgKz0geTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5hZGRNdWwgPSBmdW5jdGlvbiAoYSwgdikge1xuICAgICAgICAgICAgdmFyIHggPSBhICogdi54O1xuICAgICAgICAgICAgdmFyIHkgPSBhICogdi55O1xuICAgICAgICAgICAgdGhpcy54ICs9IHg7XG4gICAgICAgICAgICB0aGlzLnkgKz0geTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIHN1YkNvbWJpbmUgb3Igc3ViTXVsXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnByb3RvdHlwZS53U3ViID0gZnVuY3Rpb24gKGEsIHYsIGIsIHcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViQ29tYmluZShhLCB2LCBiLCB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Yk11bChhLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnRyYWN0IGxpbmVhciBjb21iaW5hdGlvbiBvZiB2IGFuZCB3OiBgYSAqIHYgKyBiICogd2BcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLnN1YkNvbWJpbmUgPSBmdW5jdGlvbiAoYSwgdiwgYiwgdykge1xuICAgICAgICAgICAgdmFyIHggPSBhICogdi54ICsgYiAqIHcueDtcbiAgICAgICAgICAgIHZhciB5ID0gYSAqIHYueSArIGIgKiB3Lnk7XG4gICAgICAgICAgICAvLyBgdGhpc2AgbWF5IGJlIGB3YFxuICAgICAgICAgICAgdGhpcy54IC09IHg7XG4gICAgICAgICAgICB0aGlzLnkgLT0geTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5zdWJNdWwgPSBmdW5jdGlvbiAoYSwgdikge1xuICAgICAgICAgICAgdmFyIHggPSBhICogdi54O1xuICAgICAgICAgICAgdmFyIHkgPSBhICogdi55O1xuICAgICAgICAgICAgdGhpcy54IC09IHg7XG4gICAgICAgICAgICB0aGlzLnkgLT0geTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VidHJhY3QgYSB2ZWN0b3IgZnJvbSB0aGlzIHZlY3RvclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgdGhpcy54IC09IHcueDtcbiAgICAgICAgICAgIHRoaXMueSAtPSB3Lnk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11bHRpcGx5IHRoaXMgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgdGhpcy54ICo9IG07XG4gICAgICAgICAgICB0aGlzLnkgKj0gbTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsZW5ndGggb2YgdGhpcyB2ZWN0b3IgKHRoZSBub3JtKS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHBlcmZvcm1hbmNlLCB1c2UgdGhpcyBpbnN0ZWFkIG9mIGxlbmd0aFNxdWFyZWQgKGlmIHBvc3NpYmxlKS5cbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLmxlbmd0aE9mKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsZW5ndGggc3F1YXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLmxlbmd0aFNxdWFyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5sZW5ndGhTcXVhcmVkKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHZlY3RvciBpbnRvIGEgdW5pdCB2ZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIG9sZCBsZW5ndGhcbiAgICAgICAgICovXG4gICAgICAgIFZlYzIucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGludkxlbmd0aCA9IDEuMCAvIGxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMueCAqPSBpbnZMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnkgKj0gaW52TGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yICh0aGUgbm9ybSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBwZXJmb3JtYW5jZSwgdXNlIHRoaXMgaW5zdGVhZCBvZiBsZW5ndGhTcXVhcmVkIChpZiBwb3NzaWJsZSkuXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLmxlbmd0aE9mID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoX3NxcnQkNSh2LnggKiB2LnggKyB2LnkgKiB2LnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsZW5ndGggc3F1YXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIFZlYzIubGVuZ3RoU3F1YXJlZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdi54ICogdi54ICsgdi55ICogdi55O1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHYueCAtIHcueDtcbiAgICAgICAgICAgIHZhciBkeSA9IHYueSAtIHcueTtcbiAgICAgICAgICAgIHJldHVybiBtYXRoX3NxcnQkNShkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIuZGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHYueCAtIHcueDtcbiAgICAgICAgICAgIHZhciBkeSA9IHYueSAtIHcueTtcbiAgICAgICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5hcmVFcXVhbCA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gdiA9PT0gdyB8fCB0eXBlb2YgdyA9PT0gJ29iamVjdCcgJiYgdyAhPT0gbnVsbCAmJiB2LnggPT09IHcueCAmJiB2LnkgPT09IHcueTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc2tldyB2ZWN0b3Igc3VjaCB0aGF0IGRvdChza2V3X3ZlYywgb3RoZXIpID09IGNyb3NzKHZlYywgb3RoZXIpXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLnNrZXcgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKC12LnksIHYueCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBEb3QgcHJvZHVjdCBvbiB0d28gdmVjdG9ycyAqL1xuICAgICAgICBWZWMyLmRvdCA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gdi54ICogdy54ICsgdi55ICogdy55O1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLmNyb3NzID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8odyAqIHYueSwgLXcgKiB2LngpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKC12ICogdy55LCB2ICogdy54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LnggKiB3LnkgLSB2LnkgKiB3Lng7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBDcm9zcyBwcm9kdWN0IG9uIHR3byB2ZWN0b3JzICovXG4gICAgICAgIFZlYzIuY3Jvc3NWZWMyVmVjMiA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gdi54ICogdy55IC0gdi55ICogdy54O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQ3Jvc3MgcHJvZHVjdCBvbiBhIHZlY3RvciBhbmQgYSBzY2FsYXIgKi9cbiAgICAgICAgVmVjMi5jcm9zc1ZlYzJOdW0gPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHcgKiB2LnksIC13ICogdi54KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIENyb3NzIHByb2R1Y3Qgb24gYSB2ZWN0b3IgYW5kIGEgc2NhbGFyICovXG4gICAgICAgIFZlYzIuY3Jvc3NOdW1WZWMyID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbygtdiAqIHcueSwgdiAqIHcueCk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIuYWRkQ3Jvc3MgPSBmdW5jdGlvbiAoYSwgdiwgdykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh3ICogdi55ICsgYS54LCAtdyAqIHYueCArIGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oLXYgKiB3LnkgKyBhLngsIHYgKiB3LnggKyBhLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBgYSArICh2IHggdylgXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLmFkZENyb3NzVmVjMk51bSA9IGZ1bmN0aW9uIChhLCB2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8odyAqIHYueSArIGEueCwgLXcgKiB2LnggKyBhLnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBgYSArICh2IHggdylgXG4gICAgICAgICAqL1xuICAgICAgICBWZWMyLmFkZENyb3NzTnVtVmVjMiA9IGZ1bmN0aW9uIChhLCB2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oLXYgKiB3LnkgKyBhLngsIHYgKiB3LnggKyBhLnkpO1xuICAgICAgICB9O1xuICAgICAgICBWZWMyLmFkZCA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8odi54ICsgdy54LCB2LnkgKyB3LnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsIEBkZXByZWNhdGVkICovXG4gICAgICAgIFZlYzIud0FkZCA9IGZ1bmN0aW9uIChhLCB2LCBiLCB3KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLmNvbWJpbmUoYSwgdiwgYiwgdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5tdWxOdW1WZWMyKGEsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBWZWMyLmNvbWJpbmUgPSBmdW5jdGlvbiAoYSwgdiwgYiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIuemVybygpLnNldENvbWJpbmUoYSwgdiwgYiwgdyk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIuc3ViID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh2LnggLSB3LngsIHYueSAtIHcueSk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIubXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oYS54ICogYiwgYS55ICogYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oYSAqIGIueCwgYSAqIGIueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIubXVsVmVjMk51bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oYS54ICogYiwgYS55ICogYik7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIubXVsTnVtVmVjMiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oYSAqIGIueCwgYSAqIGIueSk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIubmVnID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbygtdi54LCAtdi55KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5hYnMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKG1hdGhfYWJzJDkodi54KSwgbWF0aF9hYnMkOSh2LnkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5taWQgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKCh2LnggKyB3LngpICogMC41LCAodi55ICsgdy55KSAqIDAuNSk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIudXBwZXIgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKG1hdGhfbWF4JDgodi54LCB3LngpLCBtYXRoX21heCQ4KHYueSwgdy55KSk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIubG93ZXIgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKG1hdGhfbWluJDgodi54LCB3LngpLCBtYXRoX21pbiQ4KHYueSwgdy55KSk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzIucHJvdG90eXBlLmNsYW1wID0gZnVuY3Rpb24gKG1heCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aFNxciA9IHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcbiAgICAgICAgICAgIGlmIChsZW5ndGhTcXIgPiBtYXggKiBtYXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBtYXggLyBtYXRoX3NxcnQkNShsZW5ndGhTcXIpO1xuICAgICAgICAgICAgICAgIHRoaXMueCAqPSBzY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgKj0gc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMi5jbGFtcCA9IGZ1bmN0aW9uICh2LCBtYXgpIHtcbiAgICAgICAgICAgIHZhciByID0gVmVjMi5uZW8odi54LCB2LnkpO1xuICAgICAgICAgICAgci5jbGFtcChtYXgpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiAgQGludGVybmFsIEBkZXByZWNhdGVkICovXG4gICAgICAgIFZlYzIuc2NhbGVGbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAvLyB0b2RvOiB0aGlzIHdhcyB1c2VkIGluIGV4YW1wbGVzLCByZW1vdmUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHYueCAqIHgsIHYueSAqIHkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqICBAaW50ZXJuYWwgQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgVmVjMi50cmFuc2xhdGVGbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAvLyB0b2RvOiB0aGlzIHdhcyB1c2VkIGluIGV4YW1wbGVzLCByZW1vdmUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHYueCArIHgsIHYueSArIHkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZlYzI7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX21heCQ3ID0gTWF0aC5tYXg7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9taW4kNyA9IE1hdGgubWluO1xuICAgIHZhciBBQUJCID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBQUJCKGxvd2VyLCB1cHBlcikge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFBQkIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBQUJCKGxvd2VyLCB1cHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvd2VyQm91bmQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb3dlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvd2VyQm91bmQuc2V0VmVjMihsb3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZC5zZXRWZWMyKHVwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQuc2V0VmVjMihsb3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmeSB0aGF0IHRoZSBib3VuZHMgYXJlIHNvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIEFBQkIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQUFCQi5pc1ZhbGlkKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLmlzVmFsaWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFZlYzIuaXNWYWxpZChvYmoubG93ZXJCb3VuZCkgJiYgVmVjMi5pc1ZhbGlkKG9iai51cHBlckJvdW5kKSAmJiBWZWMyLnN1YihvYmoudXBwZXJCb3VuZCwgb2JqLmxvd2VyQm91bmQpLmxlbmd0aFNxdWFyZWQoKSA+PSAwO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgQUFCQi5cbiAgICAgICAgICovXG4gICAgICAgIEFBQkIucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbygodGhpcy5sb3dlckJvdW5kLnggKyB0aGlzLnVwcGVyQm91bmQueCkgKiAwLjUsICh0aGlzLmxvd2VyQm91bmQueSArIHRoaXMudXBwZXJCb3VuZC55KSAqIDAuNSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGV4dGVudHMgb2YgdGhlIEFBQkIgKGhhbGYtd2lkdGhzKS5cbiAgICAgICAgICovXG4gICAgICAgIEFBQkIucHJvdG90eXBlLmdldEV4dGVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oKHRoaXMudXBwZXJCb3VuZC54IC0gdGhpcy5sb3dlckJvdW5kLngpICogMC41LCAodGhpcy51cHBlckJvdW5kLnkgLSB0aGlzLmxvd2VyQm91bmQueSkgKiAwLjUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBwZXJpbWV0ZXIgbGVuZ3RoLlxuICAgICAgICAgKi9cbiAgICAgICAgQUFCQi5wcm90b3R5cGUuZ2V0UGVyaW1ldGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDIuMCAqICh0aGlzLnVwcGVyQm91bmQueCAtIHRoaXMubG93ZXJCb3VuZC54ICsgdGhpcy51cHBlckJvdW5kLnkgLSB0aGlzLmxvd2VyQm91bmQueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21iaW5lIG9uZSBvciB0d28gQUFCQiBpbnRvIHRoaXMgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgQUFCQi5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBiID0gYiB8fCB0aGlzO1xuICAgICAgICAgICAgdmFyIGxvd2VyQSA9IGEubG93ZXJCb3VuZDtcbiAgICAgICAgICAgIHZhciB1cHBlckEgPSBhLnVwcGVyQm91bmQ7XG4gICAgICAgICAgICB2YXIgbG93ZXJCID0gYi5sb3dlckJvdW5kO1xuICAgICAgICAgICAgdmFyIHVwcGVyQiA9IGIudXBwZXJCb3VuZDtcbiAgICAgICAgICAgIHZhciBsb3dlclggPSBtYXRoX21pbiQ3KGxvd2VyQS54LCBsb3dlckIueCk7XG4gICAgICAgICAgICB2YXIgbG93ZXJZID0gbWF0aF9taW4kNyhsb3dlckEueSwgbG93ZXJCLnkpO1xuICAgICAgICAgICAgdmFyIHVwcGVyWCA9IG1hdGhfbWF4JDcodXBwZXJCLngsIHVwcGVyQS54KTtcbiAgICAgICAgICAgIHZhciB1cHBlclkgPSBtYXRoX21heCQ3KHVwcGVyQi55LCB1cHBlckEueSk7XG4gICAgICAgICAgICB0aGlzLmxvd2VyQm91bmQuc2V0TnVtKGxvd2VyWCwgbG93ZXJZKTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZC5zZXROdW0odXBwZXJYLCB1cHBlclkpO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLnByb3RvdHlwZS5jb21iaW5lUG9pbnRzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZC5zZXROdW0obWF0aF9taW4kNyhhLngsIGIueCksIG1hdGhfbWluJDcoYS55LCBiLnkpKTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZC5zZXROdW0obWF0aF9tYXgkNyhhLngsIGIueCksIG1hdGhfbWF4JDcoYS55LCBiLnkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQUFCQi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGFhYmIpIHtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZC5zZXROdW0oYWFiYi5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC55KTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZC5zZXROdW0oYWFiYi51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55KTtcbiAgICAgICAgfTtcbiAgICAgICAgQUFCQi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoYWFiYikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdGhpcy5sb3dlckJvdW5kLnggPD0gYWFiYi5sb3dlckJvdW5kLng7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdGhpcy5sb3dlckJvdW5kLnkgPD0gYWFiYi5sb3dlckJvdW5kLnk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgYWFiYi51cHBlckJvdW5kLnggPD0gdGhpcy51cHBlckJvdW5kLng7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgYWFiYi51cHBlckJvdW5kLnkgPD0gdGhpcy51cHBlckJvdW5kLnk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIEFBQkIuZXh0ZW5kKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLmV4dGVuZCA9IGZ1bmN0aW9uIChvdXQsIHZhbHVlKSB7XG4gICAgICAgICAgICBvdXQubG93ZXJCb3VuZC54IC09IHZhbHVlO1xuICAgICAgICAgICAgb3V0Lmxvd2VyQm91bmQueSAtPSB2YWx1ZTtcbiAgICAgICAgICAgIG91dC51cHBlckJvdW5kLnggKz0gdmFsdWU7XG4gICAgICAgICAgICBvdXQudXBwZXJCb3VuZC55ICs9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgQUFCQi50ZXN0T3ZlcmxhcCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZDF4ID0gYi5sb3dlckJvdW5kLnggLSBhLnVwcGVyQm91bmQueDtcbiAgICAgICAgICAgIHZhciBkMnggPSBhLmxvd2VyQm91bmQueCAtIGIudXBwZXJCb3VuZC54O1xuICAgICAgICAgICAgdmFyIGQxeSA9IGIubG93ZXJCb3VuZC55IC0gYS51cHBlckJvdW5kLnk7XG4gICAgICAgICAgICB2YXIgZDJ5ID0gYS5sb3dlckJvdW5kLnkgLSBiLnVwcGVyQm91bmQueTtcbiAgICAgICAgICAgIGlmIChkMXggPiAwIHx8IGQxeSA+IDAgfHwgZDJ4ID4gMCB8fCBkMnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIEFBQkIuYXJlRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIuYXJlRXF1YWwoYS5sb3dlckJvdW5kLCBiLmxvd2VyQm91bmQpICYmIFZlYzIuYXJlRXF1YWwoYS51cHBlckJvdW5kLCBiLnVwcGVyQm91bmQpO1xuICAgICAgICB9O1xuICAgICAgICBBQUJCLmRpZmYgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIHdEID0gbWF0aF9tYXgkNygwLCBtYXRoX21pbiQ3KGEudXBwZXJCb3VuZC54LCBiLnVwcGVyQm91bmQueCkgLSBtYXRoX21heCQ3KGIubG93ZXJCb3VuZC54LCBhLmxvd2VyQm91bmQueCkpO1xuICAgICAgICAgICAgdmFyIGhEID0gbWF0aF9tYXgkNygwLCBtYXRoX21pbiQ3KGEudXBwZXJCb3VuZC55LCBiLnVwcGVyQm91bmQueSkgLSBtYXRoX21heCQ3KGIubG93ZXJCb3VuZC55LCBhLmxvd2VyQm91bmQueSkpO1xuICAgICAgICAgICAgdmFyIHdBID0gYS51cHBlckJvdW5kLnggLSBhLmxvd2VyQm91bmQueDtcbiAgICAgICAgICAgIHZhciBoQSA9IGEudXBwZXJCb3VuZC55IC0gYS5sb3dlckJvdW5kLnk7XG4gICAgICAgICAgICB2YXIgd0IgPSBiLnVwcGVyQm91bmQueCAtIGIubG93ZXJCb3VuZC54O1xuICAgICAgICAgICAgdmFyIGhCID0gYi51cHBlckJvdW5kLnkgLSBiLmxvd2VyQm91bmQueTtcbiAgICAgICAgICAgIHJldHVybiB3QSAqIGhBICsgd0IgKiBoQiAtIHdEICogaEQ7XG4gICAgICAgIH07XG4gICAgICAgIEFBQkIucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCkge1xuICAgICAgICAgICAgLy8gRnJvbSBSZWFsLXRpbWUgQ29sbGlzaW9uIERldGVjdGlvbiwgcDE3OS5cbiAgICAgICAgICAgIHZhciB0bWluID0gLUluZmluaXR5O1xuICAgICAgICAgICAgdmFyIHRtYXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBwID0gaW5wdXQucDE7XG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKGlucHV0LnAyLCBpbnB1dC5wMSk7XG4gICAgICAgICAgICB2YXIgYWJzRCA9IFZlYzIuYWJzKGQpO1xuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgZm9yICh2YXIgZiA9ICd4JzsgZiAhPT0gbnVsbDsgZiA9IChmID09PSAneCcgPyAneScgOiBudWxsKSkge1xuICAgICAgICAgICAgICAgIGlmIChhYnNELnggPCBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcmFsbGVsLlxuICAgICAgICAgICAgICAgICAgICBpZiAocFtmXSA8IHRoaXMubG93ZXJCb3VuZFtmXSB8fCB0aGlzLnVwcGVyQm91bmRbZl0gPCBwW2ZdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnZfZCA9IDEuMCAvIGRbZl07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0MSA9ICh0aGlzLmxvd2VyQm91bmRbZl0gLSBwW2ZdKSAqIGludl9kO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDIgPSAodGhpcy51cHBlckJvdW5kW2ZdIC0gcFtmXSkgKiBpbnZfZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lnbiBvZiB0aGUgbm9ybWFsIHZlY3Rvci5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAtMS4wO1xuICAgICAgICAgICAgICAgICAgICBpZiAodDEgPiB0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0MiA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggdGhlIG1pbiB1cFxuICAgICAgICAgICAgICAgICAgICBpZiAodDEgPiB0bWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsW2ZdID0gcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtaW4gPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBtYXggZG93blxuICAgICAgICAgICAgICAgICAgICB0bWF4ID0gbWF0aF9taW4kNyh0bWF4LCB0Mik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0bWluID4gdG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9lcyB0aGUgcmF5IHN0YXJ0IGluc2lkZSB0aGUgYm94P1xuICAgICAgICAgICAgLy8gRG9lcyB0aGUgcmF5IGludGVyc2VjdCBiZXlvbmQgdGhlIG1heCBmcmFjdGlvbj9cbiAgICAgICAgICAgIGlmICh0bWluIDwgMC4wIHx8IGlucHV0Lm1heEZyYWN0aW9uIDwgdG1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEludGVyc2VjdGlvbi5cbiAgICAgICAgICAgIG91dHB1dC5mcmFjdGlvbiA9IHRtaW47XG4gICAgICAgICAgICBvdXRwdXQubm9ybWFsID0gbm9ybWFsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gQUFCQi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIEFBQkIuY29tYmluZVBvaW50cyA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICAgICAgICAgIG91dC5sb3dlckJvdW5kLnggPSBtYXRoX21pbiQ3KGEueCwgYi54KTtcbiAgICAgICAgICAgIG91dC5sb3dlckJvdW5kLnkgPSBtYXRoX21pbiQ3KGEueSwgYi55KTtcbiAgICAgICAgICAgIG91dC51cHBlckJvdW5kLnggPSBtYXRoX21heCQ3KGEueCwgYi54KTtcbiAgICAgICAgICAgIG91dC51cHBlckJvdW5kLnkgPSBtYXRoX21heCQ3KGEueSwgYi55KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIEFBQkIuY29tYmluZWRQZXJpbWV0ZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIGx4ID0gbWF0aF9taW4kNyhhLmxvd2VyQm91bmQueCwgYi5sb3dlckJvdW5kLngpO1xuICAgICAgICAgICAgdmFyIGx5ID0gbWF0aF9taW4kNyhhLmxvd2VyQm91bmQueSwgYi5sb3dlckJvdW5kLnkpO1xuICAgICAgICAgICAgdmFyIHV4ID0gbWF0aF9tYXgkNyhhLnVwcGVyQm91bmQueCwgYi51cHBlckJvdW5kLngpO1xuICAgICAgICAgICAgdmFyIHV5ID0gbWF0aF9tYXgkNyhhLnVwcGVyQm91bmQueSwgYi51cHBlckJvdW5kLnkpO1xuICAgICAgICAgICAgcmV0dXJuIDIuMCAqICh1eCAtIGx4ICsgdXkgLSBseSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBQUJCO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9QSSQ2ID0gTWF0aC5QSTtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgY29uc3RhbnRzIGJhc2VkIG9uIG1ldGVycy1raWxvZ3JhbXMtc2Vjb25kcyAoTUtTKSB1bml0cy5cbiAgICAgKlxuICAgICAqIFNvbWUgdG9sZXJhbmNlcyBhcmUgYWJzb2x1dGUgYW5kIHNvbWUgYXJlIHJlbGF0aXZlLiBBYnNvbHV0ZSB0b2xlcmFuY2VzIHVzZSBNS1MgdW5pdHMuXG4gICAgICovXG4gICAgdmFyIFNldHRpbmdzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3MsIFwicG9seWdvblJhZGl1c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24vZWRnZSBzaGFwZSBza2luLiBUaGlzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG4gICAgICAgICAgICAgKiBNYWtpbmcgdGhpcyBzbWFsbGVyIG1lYW5zIHBvbHlnb25zIHdpbGwgaGF2ZSBhbiBpbnN1ZmZpY2llbnQgYnVmZmVyIGZvclxuICAgICAgICAgICAgICogY29udGludW91cyBjb2xsaXNpb24uIE1ha2luZyBpdCBsYXJnZXIgbWF5IGNyZWF0ZSBhcnRpZmFjdHMgZm9yIHZlcnRleFxuICAgICAgICAgICAgICogY29sbGlzaW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIuMCAqIFNldHRpbmdzLmxpbmVhclNsb3A7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gdXNlIHRoaXMgdG8gY2hhbmdlIHRoZSBsZW5ndGggc2NhbGUgdXNlZCBieSB5b3VyIGdhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlIGZvciBpbmNoZXMgeW91IGNvdWxkIHVzZSAzOS40LlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubGVuZ3RoVW5pdHNQZXJNZXRlciA9IDEuMDtcbiAgICAgICAgLy8gQ29sbGlzaW9uXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29udGFjdCBwb2ludHMgYmV0d2VlbiB0d28gY29udmV4IHNoYXBlcy4gRG8gbm90IGNoYW5nZVxuICAgICAgICAgKiB0aGlzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubWF4TWFuaWZvbGRQb2ludHMgPSAyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzIG9uIGEgY29udmV4IHBvbHlnb24uIFlvdSBjYW5ub3QgaW5jcmVhc2UgdGhpc1xuICAgICAgICAgKiB0b28gbXVjaCBiZWNhdXNlIEJsb2NrQWxsb2NhdG9yIGhhcyBhIG1heGltdW0gb2JqZWN0IHNpemUuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXMgPSAxMjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBmYXR0ZW4gQUFCQnMgaW4gdGhlIGR5bmFtaWMgdHJlZS4gVGhpcyBhbGxvd3MgcHJveGllcyB0byBtb3ZlXG4gICAgICAgICAqIGJ5IGEgc21hbGwgYW1vdW50IHdpdGhvdXQgdHJpZ2dlcmluZyBhIHRyZWUgYWRqdXN0bWVudC4gVGhpcyBpcyBpbiBtZXRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5hYWJiRXh0ZW5zaW9uID0gMC4xO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHRvIGZhdHRlbiBBQUJCcyBpbiB0aGUgZHluYW1pYyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gcHJlZGljdCB0aGVcbiAgICAgICAgICogZnV0dXJlIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRpc3BsYWNlbWVudC4gVGhpcyBpcyBhIGRpbWVuc2lvbmxlc3NcbiAgICAgICAgICogbXVsdGlwbGllci5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmFhYmJNdWx0aXBsaWVyID0gMi4wO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzbWFsbCBsZW5ndGggdXNlZCBhcyBhIGNvbGxpc2lvbiBhbmQgY29uc3RyYWludCB0b2xlcmFuY2UuIFVzdWFsbHkgaXQgaXNcbiAgICAgICAgICogY2hvc2VuIHRvIGJlIG51bWVyaWNhbGx5IHNpZ25pZmljYW50LCBidXQgdmlzdWFsbHkgaW5zaWduaWZpY2FudC5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmxpbmVhclNsb3AgPSAwLjAwNTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc21hbGwgYW5nbGUgdXNlZCBhcyBhIGNvbGxpc2lvbiBhbmQgY29uc3RyYWludCB0b2xlcmFuY2UuIFVzdWFsbHkgaXQgaXNcbiAgICAgICAgICogY2hvc2VuIHRvIGJlIG51bWVyaWNhbGx5IHNpZ25pZmljYW50LCBidXQgdmlzdWFsbHkgaW5zaWduaWZpY2FudC5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmFuZ3VsYXJTbG9wID0gKDIuMCAvIDE4MC4wICogbWF0aF9QSSQ2KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1heGltdW0gbnVtYmVyIG9mIHN1Yi1zdGVwcyBwZXIgY29udGFjdCBpbiBjb250aW51b3VzIHBoeXNpY3Mgc2ltdWxhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLm1heFN1YlN0ZXBzID0gODtcbiAgICAgICAgLy8gRHluYW1pY3NcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGNvbnRhY3RzIHRvIGJlIGhhbmRsZWQgdG8gc29sdmUgYSBUT0kgaW1wYWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubWF4VE9JQ29udGFjdHMgPSAzMjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1heGltdW0gaXRlcmF0aW9ucyB0byBzb2x2ZSBhIFRPSS5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLm1heFRPSUl0ZXJhdGlvbnMgPSAyMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1heGltdW0gaXRlcmF0aW9ucyB0byBmaW5kIERpc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubWF4RGlzdGFuY2VJdGVyYXRpb25zID0gMjA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHZlbG9jaXR5IHRocmVzaG9sZCBmb3IgZWxhc3RpYyBjb2xsaXNpb25zLiBBbnkgY29sbGlzaW9uIHdpdGggYSByZWxhdGl2ZVxuICAgICAgICAgKiBsaW5lYXIgdmVsb2NpdHkgYmVsb3cgdGhpcyB0aHJlc2hvbGQgd2lsbCBiZSB0cmVhdGVkIGFzIGluZWxhc3RpYy5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLnZlbG9jaXR5VGhyZXNob2xkID0gMS4wO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbGluZWFyIHBvc2l0aW9uIGNvcnJlY3Rpb24gdXNlZCB3aGVuIHNvbHZpbmcgY29uc3RyYWludHMuIFRoaXNcbiAgICAgICAgICogaGVscHMgdG8gcHJldmVudCBvdmVyc2hvb3QuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5tYXhMaW5lYXJDb3JyZWN0aW9uID0gMC4yO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gYW5ndWxhciBwb3NpdGlvbiBjb3JyZWN0aW9uIHVzZWQgd2hlbiBzb2x2aW5nIGNvbnN0cmFpbnRzLiBUaGlzXG4gICAgICAgICAqIGhlbHBzIHRvIHByZXZlbnQgb3ZlcnNob290LlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubWF4QW5ndWxhckNvcnJlY3Rpb24gPSAoOC4wIC8gMTgwLjAgKiBtYXRoX1BJJDYpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbGluZWFyIHZlbG9jaXR5IG9mIGEgYm9keS4gVGhpcyBsaW1pdCBpcyB2ZXJ5IGxhcmdlIGFuZCBpcyB1c2VkXG4gICAgICAgICAqIHRvIHByZXZlbnQgbnVtZXJpY2FsIHByb2JsZW1zLiBZb3Ugc2hvdWxkbid0IG5lZWQgdG8gYWRqdXN0IFNldHRpbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubWF4VHJhbnNsYXRpb24gPSAyLjA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBhbmd1bGFyIHZlbG9jaXR5IG9mIGEgYm9keS4gVGhpcyBsaW1pdCBpcyB2ZXJ5IGxhcmdlIGFuZCBpcyB1c2VkXG4gICAgICAgICAqIHRvIHByZXZlbnQgbnVtZXJpY2FsIHByb2JsZW1zLiBZb3Ugc2hvdWxkbid0IG5lZWQgdG8gYWRqdXN0IFNldHRpbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgU2V0dGluZ3MubWF4Um90YXRpb24gPSAoMC41ICogbWF0aF9QSSQ2KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgc2NhbGUgZmFjdG9yIGNvbnRyb2xzIGhvdyBmYXN0IG92ZXJsYXAgaXMgcmVzb2x2ZWQuIElkZWFsbHkgdGhpcyB3b3VsZFxuICAgICAgICAgKiBiZSAxIHNvIHRoYXQgb3ZlcmxhcCBpcyByZW1vdmVkIGluIG9uZSB0aW1lIHN0ZXAuIEhvd2V2ZXIgdXNpbmcgdmFsdWVzIGNsb3NlXG4gICAgICAgICAqIHRvIDEgb2Z0ZW4gbGVhZCB0byBvdmVyc2hvb3QuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5iYXVtZ2FydGUgPSAwLjI7XG4gICAgICAgIFNldHRpbmdzLnRvaUJhdWdhcnRlID0gMC43NTtcbiAgICAgICAgLy8gU2xlZXBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRoYXQgYSBib2R5IG11c3QgYmUgc3RpbGwgYmVmb3JlIGl0IHdpbGwgZ28gdG8gc2xlZXAuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy50aW1lVG9TbGVlcCA9IDAuNTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9keSBjYW5ub3Qgc2xlZXAgaWYgaXRzIGxpbmVhciB2ZWxvY2l0eSBpcyBhYm92ZSB0aGlzIHRvbGVyYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIFNldHRpbmdzLmxpbmVhclNsZWVwVG9sZXJhbmNlID0gMC4wMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9keSBjYW5ub3Qgc2xlZXAgaWYgaXRzIGFuZ3VsYXIgdmVsb2NpdHkgaXMgYWJvdmUgdGhpcyB0b2xlcmFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBTZXR0aW5ncy5hbmd1bGFyU2xlZXBUb2xlcmFuY2UgPSAoMi4wIC8gMTgwLjAgKiBtYXRoX1BJJDYpO1xuICAgICAgICByZXR1cm4gU2V0dGluZ3M7XG4gICAgfSgpKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdmFyIFNldHRpbmdzSW50ZXJuYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNldHRpbmdzSW50ZXJuYWwoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwibWF4TWFuaWZvbGRQb2ludHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLm1heE1hbmlmb2xkUG9pbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3NJbnRlcm5hbCwgXCJtYXhQb2x5Z29uVmVydGljZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLm1heFBvbHlnb25WZXJ0aWNlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwiYWFiYkV4dGVuc2lvblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0dGluZ3MuYWFiYkV4dGVuc2lvbiAqIFNldHRpbmdzLmxlbmd0aFVuaXRzUGVyTWV0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcImFhYmJNdWx0aXBsaWVyXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5hYWJiTXVsdGlwbGllcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwibGluZWFyU2xvcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0dGluZ3MubGluZWFyU2xvcCAqIFNldHRpbmdzLmxlbmd0aFVuaXRzUGVyTWV0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcImxpbmVhclNsb3BTcXVhcmVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5saW5lYXJTbG9wICogU2V0dGluZ3MubGVuZ3RoVW5pdHNQZXJNZXRlciAqIFNldHRpbmdzLmxpbmVhclNsb3AgKiBTZXR0aW5ncy5sZW5ndGhVbml0c1Blck1ldGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3NJbnRlcm5hbCwgXCJhbmd1bGFyU2xvcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0dGluZ3MuYW5ndWxhclNsb3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcInBvbHlnb25SYWRpdXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIuMCAqIFNldHRpbmdzLmxpbmVhclNsb3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcIm1heFN1YlN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5tYXhTdWJTdGVwcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwibWF4VE9JQ29udGFjdHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLm1heFRPSUNvbnRhY3RzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3NJbnRlcm5hbCwgXCJtYXhUT0lJdGVyYXRpb25zXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5tYXhUT0lJdGVyYXRpb25zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3NJbnRlcm5hbCwgXCJtYXhEaXN0YW5jZUl0ZXJhdGlvbnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLm1heERpc3RhbmNlSXRlcmF0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwidmVsb2NpdHlUaHJlc2hvbGRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLnZlbG9jaXR5VGhyZXNob2xkICogU2V0dGluZ3MubGVuZ3RoVW5pdHNQZXJNZXRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwibWF4TGluZWFyQ29ycmVjdGlvblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0dGluZ3MubWF4TGluZWFyQ29ycmVjdGlvbiAqIFNldHRpbmdzLmxlbmd0aFVuaXRzUGVyTWV0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcIm1heEFuZ3VsYXJDb3JyZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5tYXhBbmd1bGFyQ29ycmVjdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwibWF4VHJhbnNsYXRpb25cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLm1heFRyYW5zbGF0aW9uICogU2V0dGluZ3MubGVuZ3RoVW5pdHNQZXJNZXRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwibWF4VHJhbnNsYXRpb25TcXVhcmVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5tYXhUcmFuc2xhdGlvbiAqIFNldHRpbmdzLmxlbmd0aFVuaXRzUGVyTWV0ZXIgKiBTZXR0aW5ncy5tYXhUcmFuc2xhdGlvbiAqIFNldHRpbmdzLmxlbmd0aFVuaXRzUGVyTWV0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcIm1heFJvdGF0aW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5tYXhSb3RhdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwibWF4Um90YXRpb25TcXVhcmVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5tYXhSb3RhdGlvbiAqIFNldHRpbmdzLm1heFJvdGF0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3NJbnRlcm5hbCwgXCJiYXVtZ2FydGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLmJhdW1nYXJ0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldHRpbmdzSW50ZXJuYWwsIFwidG9pQmF1Z2FydGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLnRvaUJhdWdhcnRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3NJbnRlcm5hbCwgXCJ0aW1lVG9TbGVlcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0dGluZ3MudGltZVRvU2xlZXA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcImxpbmVhclNsZWVwVG9sZXJhbmNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5saW5lYXJTbGVlcFRvbGVyYW5jZSAqIFNldHRpbmdzLmxlbmd0aFVuaXRzUGVyTWV0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcImxpbmVhclNsZWVwVG9sZXJhbmNlU3FyXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXR0aW5ncy5saW5lYXJTbGVlcFRvbGVyYW5jZSAqIFNldHRpbmdzLmxlbmd0aFVuaXRzUGVyTWV0ZXIgKiBTZXR0aW5ncy5saW5lYXJTbGVlcFRvbGVyYW5jZSAqIFNldHRpbmdzLmxlbmd0aFVuaXRzUGVyTWV0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXR0aW5nc0ludGVybmFsLCBcImFuZ3VsYXJTbGVlcFRvbGVyYW5jZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0dGluZ3MuYW5ndWxhclNsZWVwVG9sZXJhbmNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0dGluZ3NJbnRlcm5hbCwgXCJhbmd1bGFyU2xlZXBUb2xlcmFuY2VTcXJcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLmFuZ3VsYXJTbGVlcFRvbGVyYW5jZSAqIFNldHRpbmdzLmFuZ3VsYXJTbGVlcFRvbGVyYW5jZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFNldHRpbmdzSW50ZXJuYWw7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggQWxpIFNoYWtpYmEgaHR0cDovL3NoYWtpYmEubWUvcGxhbmNrLmpzXG4gICAgICpcbiAgICAgKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuICAgICAqIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbiAgICAgKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuICAgICAqIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuICAgICAqIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbiAgICAgKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4gICAgICogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3RcbiAgICAgKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuICAgICAqIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuICAgICAqIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4gICAgICogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbiAgICAgKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4gICAgICogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovXG4gICAgdmFyIFBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBvb2wob3B0cykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWF4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLl9oYXNDcmVhdGVGbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5faGFzQWxsb2NhdGVGbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fYWxsb2NhdGVDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9oYXNSZWxlYXNlRm4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9oYXNEaXNwb3NlRm4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgICAgICAgICB0aGlzLl9tYXggPSBvcHRzLm1heCB8fCB0aGlzLl9tYXg7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVGbiA9IG9wdHMuY3JlYXRlO1xuICAgICAgICAgICAgdGhpcy5faGFzQ3JlYXRlRm4gPSB0eXBlb2YgdGhpcy5fY3JlYXRlRm4gPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICB0aGlzLl9hbGxvY2F0ZUZuID0gb3B0cy5hbGxvY2F0ZTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0FsbG9jYXRlRm4gPSB0eXBlb2YgdGhpcy5fYWxsb2NhdGVGbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VGbiA9IG9wdHMucmVsZWFzZTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1JlbGVhc2VGbiA9IHR5cGVvZiB0aGlzLl9yZWxlYXNlRm4gPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlRm4gPSBvcHRzLmRpc3Bvc2U7XG4gICAgICAgICAgICB0aGlzLl9oYXNEaXNwb3NlRm4gPSB0eXBlb2YgdGhpcy5fZGlzcG9zZUZuID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgICAgIFBvb2wucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4ID0gbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgICAgIH07XG4gICAgICAgIFBvb2wucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdC5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIFBvb2wucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuX2xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc0NyZWF0ZUZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9jcmVhdGVGbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW9iamVjdC1saXRlcmFsLXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hbGxvY2F0ZUNvdW50Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzQWxsb2NhdGVGbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbG9jYXRlRm4oaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9vbC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdC5sZW5ndGggPCB0aGlzLl9tYXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxlYXNlQ291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFzUmVsZWFzZUZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VGbihpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc0Rpc3Bvc2VGbikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5fZGlzcG9zZUZuKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUG9vbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIgK1wiICsgdGhpcy5fY3JlYXRlQ291bnQgKyBcIiA+XCIgKyB0aGlzLl9hbGxvY2F0ZUNvdW50ICsgXCIgPFwiICsgdGhpcy5fcmVsZWFzZUNvdW50ICsgXCIgLVwiXG4gICAgICAgICAgICAgICAgKyB0aGlzLl9kaXNwb3NlQ291bnQgKyBcIiA9XCIgKyB0aGlzLl9saXN0Lmxlbmd0aCArIFwiL1wiICsgdGhpcy5fbWF4O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUG9vbDtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfYWJzJDggPSBNYXRoLmFicztcbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX21heCQ2ID0gTWF0aC5tYXg7XG4gICAgLyoqXG4gICAgICogQSBub2RlIGluIHRoZSBkeW5hbWljIHRyZWUuIFRoZSBjbGllbnQgZG9lcyBub3QgaW50ZXJhY3Qgd2l0aCB0aGlzIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHZhciBUcmVlTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJlZU5vZGUoaWQpIHtcbiAgICAgICAgICAgIC8qKiBFbmxhcmdlZCBBQUJCICovXG4gICAgICAgICAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuICAgICAgICAgICAgdGhpcy51c2VyRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkMiA9IG51bGw7XG4gICAgICAgICAgICAvKiogMDogbGVhZiwgLTE6IGZyZWUgbm9kZSAqL1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkICsgXCI6IFwiICsgdGhpcy51c2VyRGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkMSA9PSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJlZU5vZGU7XG4gICAgfSgpKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBwb29sVHJlZU5vZGUgPSBuZXcgUG9vbCh7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSgpO1xuICAgICAgICB9LFxuICAgICAgICByZWxlYXNlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS51c2VyRGF0YSA9IG51bGw7XG4gICAgICAgICAgICBub2RlLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBub2RlLmNoaWxkMSA9IG51bGw7XG4gICAgICAgICAgICBub2RlLmNoaWxkMiA9IG51bGw7XG4gICAgICAgICAgICBub2RlLmhlaWdodCA9IC0xO1xuICAgICAgICAgICAgbm9kZS5pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEEgZHluYW1pYyBBQUJCIHRyZWUgYnJvYWQtcGhhc2UsIGluc3BpcmVkIGJ5IE5hdGhhbmFlbCBQcmVzc29uJ3MgYnREYnZ0LiBBXG4gICAgICogZHluYW1pYyB0cmVlIGFycmFuZ2VzIGRhdGEgaW4gYSBiaW5hcnkgdHJlZSB0byBhY2NlbGVyYXRlIHF1ZXJpZXMgc3VjaCBhc1xuICAgICAqIHZvbHVtZSBxdWVyaWVzIGFuZCByYXkgY2FzdHMuIExlYWZzIGFyZSBwcm94aWVzIHdpdGggYW4gQUFCQi4gSW4gdGhlIHRyZWUgd2VcbiAgICAgKiBleHBhbmQgdGhlIHByb3h5IEFBQkIgYnkgYGFhYmJFeHRlbnNpb25gIHNvIHRoYXQgdGhlIHByb3h5IEFBQkIgaXMgYmlnZ2VyXG4gICAgICogdGhhbiB0aGUgY2xpZW50IG9iamVjdC4gVGhpcyBhbGxvd3MgdGhlIGNsaWVudCBvYmplY3QgdG8gbW92ZSBieSBzbWFsbFxuICAgICAqIGFtb3VudHMgd2l0aG91dCB0cmlnZ2VyaW5nIGEgdHJlZSB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBOb2RlcyBhcmUgcG9vbGVkIGFuZCByZWxvY2F0YWJsZSwgc28gd2UgdXNlIG5vZGUgaW5kaWNlcyByYXRoZXIgdGhhblxuICAgICAqIHBvaW50ZXJzLlxuICAgICAqL1xuICAgIHZhciBEeW5hbWljVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRHluYW1pY1RyZWUoKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0UG9vbCA9IG5ldyBQb29sKHtcbiAgICAgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW9iamVjdC1saXRlcmFsLXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zdGFja1Bvb2wgPSBuZXcgUG9vbCh7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pdGVyYXRvclBvb2wgPSBuZXcgUG9vbCh7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX25vZGVzID0ge307XG4gICAgICAgICAgICB0aGlzLm1fbGFzdFByb3h5SWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcHJveHkgdXNlciBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBwcm94eSB1c2VyIGRhdGEgb3IgMCBpZiB0aGUgaWQgaXMgaW52YWxpZC5cbiAgICAgICAgICovXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRVc2VyRGF0YSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fbm9kZXNbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudXNlckRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZhdCBBQUJCIGZvciBhIG5vZGUgaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIHByb3h5IHVzZXIgZGF0YSBvciAwIGlmIHRoZSBpZCBpcyBpbnZhbGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmdldEZhdEFBQkIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5tX25vZGVzW2lkXTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmFhYmI7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5hbGxvY2F0ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHBvb2xUcmVlTm9kZS5hbGxvY2F0ZSgpO1xuICAgICAgICAgICAgbm9kZS5pZCA9ICsrdGhpcy5tX2xhc3RQcm94eUlkO1xuICAgICAgICAgICAgdGhpcy5tX25vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZnJlZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tX25vZGVzW25vZGUuaWRdO1xuICAgICAgICAgICAgcG9vbFRyZWVOb2RlLnJlbGVhc2Uobm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBwcm94eSBpbiB0aGUgdHJlZSBhcyBhIGxlYWYgbm9kZS4gV2UgcmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbm9kZVxuICAgICAgICAgKiBpbnN0ZWFkIG9mIGEgcG9pbnRlciBzbyB0aGF0IHdlIGNhbiBncm93IHRoZSBub2RlIHBvb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIENyZWF0ZSBhIHByb3h5LiBQcm92aWRlIGEgdGlnaHQgZml0dGluZyBBQUJCIGFuZCBhIHVzZXJEYXRhIHBvaW50ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuY3JlYXRlUHJveHkgPSBmdW5jdGlvbiAoYWFiYiwgdXNlckRhdGEpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5hbGxvY2F0ZU5vZGUoKTtcbiAgICAgICAgICAgIG5vZGUuYWFiYi5zZXQoYWFiYik7XG4gICAgICAgICAgICAvLyBGYXR0ZW4gdGhlIGFhYmIuXG4gICAgICAgICAgICBBQUJCLmV4dGVuZChub2RlLmFhYmIsIFNldHRpbmdzSW50ZXJuYWwuYWFiYkV4dGVuc2lvbik7XG4gICAgICAgICAgICBub2RlLnVzZXJEYXRhID0gdXNlckRhdGE7XG4gICAgICAgICAgICBub2RlLmhlaWdodCA9IDA7XG4gICAgICAgICAgICB0aGlzLmluc2VydExlYWYobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5pZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgYSBwcm94eS4gVGhpcyBhc3NlcnRzIGlmIHRoZSBpZCBpcyBpbnZhbGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmRlc3Ryb3lQcm94eSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fbm9kZXNbaWRdO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMZWFmKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mcmVlTm9kZShub2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdmUgYSBwcm94eSB3aXRoIGEgc3dlcHRlZCBBQUJCLiBJZiB0aGUgcHJveHkgaGFzIG1vdmVkIG91dHNpZGUgb2YgaXRzXG4gICAgICAgICAqIGZhdHRlbmVkIEFBQkIsIHRoZW4gdGhlIHByb3h5IGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZSBhbmQgcmUtaW5zZXJ0ZWQuXG4gICAgICAgICAqIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBpbW1lZGlhdGVseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGQgRGlzcGxhY2VtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgcHJveHkgd2FzIHJlLWluc2VydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLm1vdmVQcm94eSA9IGZ1bmN0aW9uIChpZCwgYWFiYiwgZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fbm9kZXNbaWRdO1xuICAgICAgICAgICAgaWYgKG5vZGUuYWFiYi5jb250YWlucyhhYWJiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGVhZihub2RlKTtcbiAgICAgICAgICAgIG5vZGUuYWFiYi5zZXQoYWFiYik7XG4gICAgICAgICAgICAvLyBFeHRlbmQgQUFCQi5cbiAgICAgICAgICAgIGFhYmIgPSBub2RlLmFhYmI7XG4gICAgICAgICAgICBBQUJCLmV4dGVuZChhYWJiLCBTZXR0aW5nc0ludGVybmFsLmFhYmJFeHRlbnNpb24pO1xuICAgICAgICAgICAgLy8gUHJlZGljdCBBQUJCIGRpc3BsYWNlbWVudC5cbiAgICAgICAgICAgIC8vIGNvbnN0IGQgPSBWZWMyLm11bChTZXR0aW5ncy5hYWJiTXVsdGlwbGllciwgZGlzcGxhY2VtZW50KTtcbiAgICAgICAgICAgIGlmIChkLnggPCAwLjApIHtcbiAgICAgICAgICAgICAgICBhYWJiLmxvd2VyQm91bmQueCArPSBkLnggKiBTZXR0aW5nc0ludGVybmFsLmFhYmJNdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWFiYi51cHBlckJvdW5kLnggKz0gZC54ICogU2V0dGluZ3NJbnRlcm5hbC5hYWJiTXVsdGlwbGllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkLnkgPCAwLjApIHtcbiAgICAgICAgICAgICAgICBhYWJiLmxvd2VyQm91bmQueSArPSBkLnkgKiBTZXR0aW5nc0ludGVybmFsLmFhYmJNdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWFiYi51cHBlckJvdW5kLnkgKz0gZC55ICogU2V0dGluZ3NJbnRlcm5hbC5hYWJiTXVsdGlwbGllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0TGVhZihub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuaW5zZXJ0TGVhZiA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX3Jvb3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9yb290ID0gbGVhZjtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcm9vdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGJlc3Qgc2libGluZyBmb3IgdGhpcyBub2RlXG4gICAgICAgICAgICB2YXIgbGVhZkFBQkIgPSBsZWFmLmFhYmI7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm1fcm9vdDtcbiAgICAgICAgICAgIHdoaWxlICghaW5kZXguaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQxID0gaW5kZXguY2hpbGQxO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZDIgPSBpbmRleC5jaGlsZDI7XG4gICAgICAgICAgICAgICAgdmFyIGFyZWEgPSBpbmRleC5hYWJiLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZEFyZWEgPSBBQUJCLmNvbWJpbmVkUGVyaW1ldGVyKGluZGV4LmFhYmIsIGxlYWZBQUJCKTtcbiAgICAgICAgICAgICAgICAvLyBDb3N0IG9mIGNyZWF0aW5nIGEgbmV3IHBhcmVudCBmb3IgdGhpcyBub2RlIGFuZCB0aGUgbmV3IGxlYWZcbiAgICAgICAgICAgICAgICB2YXIgY29zdCA9IDIuMCAqIGNvbWJpbmVkQXJlYTtcbiAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIGNvc3Qgb2YgcHVzaGluZyB0aGUgbGVhZiBmdXJ0aGVyIGRvd24gdGhlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGFuY2VDb3N0ID0gMi4wICogKGNvbWJpbmVkQXJlYSAtIGFyZWEpO1xuICAgICAgICAgICAgICAgIC8vIENvc3Qgb2YgZGVzY2VuZGluZyBpbnRvIGNoaWxkMVxuICAgICAgICAgICAgICAgIHZhciBuZXdBcmVhMSA9IEFBQkIuY29tYmluZWRQZXJpbWV0ZXIobGVhZkFBQkIsIGNoaWxkMS5hYWJiKTtcbiAgICAgICAgICAgICAgICB2YXIgY29zdDEgPSBuZXdBcmVhMSArIGluaGVyaXRhbmNlQ29zdDtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkMS5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQXJlYSA9IGNoaWxkMS5hYWJiLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb3N0MSAtPSBvbGRBcmVhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb3N0IG9mIGRlc2NlbmRpbmcgaW50byBjaGlsZDJcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJlYTIgPSBBQUJCLmNvbWJpbmVkUGVyaW1ldGVyKGxlYWZBQUJCLCBjaGlsZDIuYWFiYik7XG4gICAgICAgICAgICAgICAgdmFyIGNvc3QyID0gbmV3QXJlYTIgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZDIuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZEFyZWEgPSBjaGlsZDIuYWFiYi5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29zdDIgLT0gb2xkQXJlYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGVzY2VuZCBhY2NvcmRpbmcgdG8gdGhlIG1pbmltdW0gY29zdC5cbiAgICAgICAgICAgICAgICBpZiAoY29zdCA8IGNvc3QxICYmIGNvc3QgPCBjb3N0Mikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGVzY2VuZFxuICAgICAgICAgICAgICAgIGlmIChjb3N0MSA8IGNvc3QyKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY2hpbGQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjaGlsZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBpbmRleDtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICB2YXIgb2xkUGFyZW50ID0gc2libGluZy5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gdGhpcy5hbGxvY2F0ZU5vZGUoKTtcbiAgICAgICAgICAgIG5ld1BhcmVudC5wYXJlbnQgPSBvbGRQYXJlbnQ7XG4gICAgICAgICAgICBuZXdQYXJlbnQudXNlckRhdGEgPSBudWxsO1xuICAgICAgICAgICAgbmV3UGFyZW50LmFhYmIuY29tYmluZShsZWFmQUFCQiwgc2libGluZy5hYWJiKTtcbiAgICAgICAgICAgIG5ld1BhcmVudC5oZWlnaHQgPSBzaWJsaW5nLmhlaWdodCArIDE7XG4gICAgICAgICAgICBpZiAob2xkUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyB3YXMgbm90IHRoZSByb290LlxuICAgICAgICAgICAgICAgIGlmIChvbGRQYXJlbnQuY2hpbGQxID09PSBzaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFBhcmVudC5jaGlsZDEgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQuY2hpbGQyID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuY2hpbGQxID0gc2libGluZztcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuY2hpbGQyID0gbGVhZjtcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIHdhcyB0aGUgcm9vdC5cbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuY2hpbGQxID0gc2libGluZztcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuY2hpbGQyID0gbGVhZjtcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcm9vdCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdhbGsgYmFjayB1cCB0aGUgdHJlZSBmaXhpbmcgaGVpZ2h0cyBhbmQgQUFCQnNcbiAgICAgICAgICAgIGluZGV4ID0gbGVhZi5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5iYWxhbmNlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQxID0gaW5kZXguY2hpbGQxO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZDIgPSBpbmRleC5jaGlsZDI7XG4gICAgICAgICAgICAgICAgaW5kZXguaGVpZ2h0ID0gMSArIG1hdGhfbWF4JDYoY2hpbGQxLmhlaWdodCwgY2hpbGQyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaW5kZXguYWFiYi5jb21iaW5lKGNoaWxkMS5hYWJiLCBjaGlsZDIuYWFiYik7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUucmVtb3ZlTGVhZiA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgICAgICBpZiAobGVhZiA9PT0gdGhpcy5tX3Jvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcm9vdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGxlYWYucGFyZW50O1xuICAgICAgICAgICAgdmFyIGdyYW5kUGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZDEgPT09IGxlYWYpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LmNoaWxkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuY2hpbGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXN0cm95IHBhcmVudCBhbmQgY29ubmVjdCBzaWJsaW5nIHRvIGdyYW5kUGFyZW50LlxuICAgICAgICAgICAgICAgIGlmIChncmFuZFBhcmVudC5jaGlsZDEgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5jaGlsZDEgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQuY2hpbGQyID0gc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBncmFuZFBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmZyZWVOb2RlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IGFuY2VzdG9yIGJvdW5kcy5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBncmFuZFBhcmVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuYmFsYW5jZShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDEgPSBpbmRleC5jaGlsZDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDIgPSBpbmRleC5jaGlsZDI7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmFhYmIuY29tYmluZShjaGlsZDEuYWFiYiwgY2hpbGQyLmFhYmIpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5oZWlnaHQgPSAxICsgbWF0aF9tYXgkNihjaGlsZDEuaGVpZ2h0LCBjaGlsZDIuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZyZWVOb2RlKHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhIGxlZnQgb3IgcmlnaHQgcm90YXRpb24gaWYgbm9kZSBBIGlzIGltYmFsYW5jZWQuIFJldHVybnMgdGhlIG5ld1xuICAgICAgICAgKiByb290IGluZGV4LlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmJhbGFuY2UgPSBmdW5jdGlvbiAoaUEpIHtcbiAgICAgICAgICAgIHZhciBBID0gaUE7XG4gICAgICAgICAgICBpZiAoQS5pc0xlYWYoKSB8fCBBLmhlaWdodCA8IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaUE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgQiA9IEEuY2hpbGQxO1xuICAgICAgICAgICAgdmFyIEMgPSBBLmNoaWxkMjtcbiAgICAgICAgICAgIHZhciBiYWxhbmNlID0gQy5oZWlnaHQgLSBCLmhlaWdodDtcbiAgICAgICAgICAgIC8vIFJvdGF0ZSBDIHVwXG4gICAgICAgICAgICBpZiAoYmFsYW5jZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgRiA9IEMuY2hpbGQxO1xuICAgICAgICAgICAgICAgIHZhciBHID0gQy5jaGlsZDI7XG4gICAgICAgICAgICAgICAgLy8gU3dhcCBBIGFuZCBDXG4gICAgICAgICAgICAgICAgQy5jaGlsZDEgPSBBO1xuICAgICAgICAgICAgICAgIEMucGFyZW50ID0gQS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgQS5wYXJlbnQgPSBDO1xuICAgICAgICAgICAgICAgIC8vIEEncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byBDXG4gICAgICAgICAgICAgICAgaWYgKEMucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEMucGFyZW50LmNoaWxkMSA9PT0gaUEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEMucGFyZW50LmNoaWxkMSA9IEM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDLnBhcmVudC5jaGlsZDIgPSBDO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fcm9vdCA9IEM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJvdGF0ZVxuICAgICAgICAgICAgICAgIGlmIChGLmhlaWdodCA+IEcuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIEMuY2hpbGQyID0gRjtcbiAgICAgICAgICAgICAgICAgICAgQS5jaGlsZDIgPSBHO1xuICAgICAgICAgICAgICAgICAgICBHLnBhcmVudCA9IEE7XG4gICAgICAgICAgICAgICAgICAgIEEuYWFiYi5jb21iaW5lKEIuYWFiYiwgRy5hYWJiKTtcbiAgICAgICAgICAgICAgICAgICAgQy5hYWJiLmNvbWJpbmUoQS5hYWJiLCBGLmFhYmIpO1xuICAgICAgICAgICAgICAgICAgICBBLmhlaWdodCA9IDEgKyBtYXRoX21heCQ2KEIuaGVpZ2h0LCBHLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIEMuaGVpZ2h0ID0gMSArIG1hdGhfbWF4JDYoQS5oZWlnaHQsIEYuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEMuY2hpbGQyID0gRztcbiAgICAgICAgICAgICAgICAgICAgQS5jaGlsZDIgPSBGO1xuICAgICAgICAgICAgICAgICAgICBGLnBhcmVudCA9IEE7XG4gICAgICAgICAgICAgICAgICAgIEEuYWFiYi5jb21iaW5lKEIuYWFiYiwgRi5hYWJiKTtcbiAgICAgICAgICAgICAgICAgICAgQy5hYWJiLmNvbWJpbmUoQS5hYWJiLCBHLmFhYmIpO1xuICAgICAgICAgICAgICAgICAgICBBLmhlaWdodCA9IDEgKyBtYXRoX21heCQ2KEIuaGVpZ2h0LCBGLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIEMuaGVpZ2h0ID0gMSArIG1hdGhfbWF4JDYoQS5oZWlnaHQsIEcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSb3RhdGUgQiB1cFxuICAgICAgICAgICAgaWYgKGJhbGFuY2UgPCAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBEID0gQi5jaGlsZDE7XG4gICAgICAgICAgICAgICAgdmFyIEUgPSBCLmNoaWxkMjtcbiAgICAgICAgICAgICAgICAvLyBTd2FwIEEgYW5kIEJcbiAgICAgICAgICAgICAgICBCLmNoaWxkMSA9IEE7XG4gICAgICAgICAgICAgICAgQi5wYXJlbnQgPSBBLnBhcmVudDtcbiAgICAgICAgICAgICAgICBBLnBhcmVudCA9IEI7XG4gICAgICAgICAgICAgICAgLy8gQSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIEJcbiAgICAgICAgICAgICAgICBpZiAoQi5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQi5wYXJlbnQuY2hpbGQxID09PSBBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBCLnBhcmVudC5jaGlsZDEgPSBCO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQi5wYXJlbnQuY2hpbGQyID0gQjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBCO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSb3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoRC5oZWlnaHQgPiBFLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBCLmNoaWxkMiA9IEQ7XG4gICAgICAgICAgICAgICAgICAgIEEuY2hpbGQxID0gRTtcbiAgICAgICAgICAgICAgICAgICAgRS5wYXJlbnQgPSBBO1xuICAgICAgICAgICAgICAgICAgICBBLmFhYmIuY29tYmluZShDLmFhYmIsIEUuYWFiYik7XG4gICAgICAgICAgICAgICAgICAgIEIuYWFiYi5jb21iaW5lKEEuYWFiYiwgRC5hYWJiKTtcbiAgICAgICAgICAgICAgICAgICAgQS5oZWlnaHQgPSAxICsgbWF0aF9tYXgkNihDLmhlaWdodCwgRS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBCLmhlaWdodCA9IDEgKyBtYXRoX21heCQ2KEEuaGVpZ2h0LCBELmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBCLmNoaWxkMiA9IEU7XG4gICAgICAgICAgICAgICAgICAgIEEuY2hpbGQxID0gRDtcbiAgICAgICAgICAgICAgICAgICAgRC5wYXJlbnQgPSBBO1xuICAgICAgICAgICAgICAgICAgICBBLmFhYmIuY29tYmluZShDLmFhYmIsIEQuYWFiYik7XG4gICAgICAgICAgICAgICAgICAgIEIuYWFiYi5jb21iaW5lKEEuYWFiYiwgRS5hYWJiKTtcbiAgICAgICAgICAgICAgICAgICAgQS5oZWlnaHQgPSAxICsgbWF0aF9tYXgkNihDLmhlaWdodCwgRC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBCLmhlaWdodCA9IDEgKyBtYXRoX21heCQ2KEEuaGVpZ2h0LCBFLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlIHRoZSBoZWlnaHQgb2YgdGhlIGJpbmFyeSB0cmVlIGluIE8oTikgdGltZS4gU2hvdWxkIG5vdCBiZSBjYWxsZWRcbiAgICAgICAgICogb2Z0ZW4uXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9yb290ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fcm9vdC5oZWlnaHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJhdGlvIG9mIHRoZSBzdW0gb2YgdGhlIG5vZGUgYXJlYXMgdG8gdGhlIHJvb3QgYXJlYS5cbiAgICAgICAgICovXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRBcmVhUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX3Jvb3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMubV9yb290O1xuICAgICAgICAgICAgdmFyIHJvb3RBcmVhID0gcm9vdC5hYWJiLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgdmFyIHRvdGFsQXJlYSA9IDAuMDtcbiAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvclBvb2wuYWxsb2NhdGUoKS5wcmVvcmRlcih0aGlzLm1fcm9vdCk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSA9IGl0Lm5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRnJlZSBub2RlIGluIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdGFsQXJlYSArPSBub2RlLmFhYmIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLml0ZXJhdG9yUG9vbC5yZWxlYXNlKGl0KTtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbEFyZWEgLyByb290QXJlYTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXB1dGUgdGhlIGhlaWdodCBvZiBhIHN1Yi10cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmNvbXB1dGVIZWlnaHQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5tX25vZGVzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm1fcm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbHNlICYmIGNvbnNvbGUuYXNzZXJ0KDAgPD0gaWQgJiYgaWQgPCB0aGlzLm1fbm9kZUNhcGFjaXR5KTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGVpZ2h0MSA9IHRoaXMuY29tcHV0ZUhlaWdodChub2RlLmNoaWxkMS5pZCk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0MiA9IHRoaXMuY29tcHV0ZUhlaWdodChub2RlLmNoaWxkMi5pZCk7XG4gICAgICAgICAgICByZXR1cm4gMSArIG1hdGhfbWF4JDYoaGVpZ2h0MSwgaGVpZ2h0Mik7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS52YWxpZGF0ZVN0cnVjdHVyZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubV9yb290KSA7XG4gICAgICAgICAgICB2YXIgY2hpbGQxID0gbm9kZS5jaGlsZDE7XG4gICAgICAgICAgICB2YXIgY2hpbGQyID0gbm9kZS5jaGlsZDI7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTdHJ1Y3R1cmUoY2hpbGQxKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTdHJ1Y3R1cmUoY2hpbGQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnZhbGlkYXRlTWV0cmljcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkMSA9IG5vZGUuY2hpbGQxO1xuICAgICAgICAgICAgdmFyIGNoaWxkMiA9IG5vZGUuY2hpbGQyO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxzZSAmJiBjb25zb2xlLmFzc2VydCgwIDw9IGNoaWxkMSAmJiBjaGlsZDEgPCB0aGlzLm1fbm9kZUNhcGFjaXR5KTtcbiAgICAgICAgICAgIC8vIGZhbHNlICYmIGNvbnNvbGUuYXNzZXJ0KDAgPD0gY2hpbGQyICYmIGNoaWxkMiA8IHRoaXMubV9ub2RlQ2FwYWNpdHkpO1xuICAgICAgICAgICAgY2hpbGQxLmhlaWdodDtcbiAgICAgICAgICAgIGNoaWxkMi5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICBhYWJiLmNvbWJpbmUoY2hpbGQxLmFhYmIsIGNoaWxkMi5hYWJiKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVNZXRyaWNzKGNoaWxkMSk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlTWV0cmljcyhjaGlsZDIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgdGhpcyB0cmVlLiBGb3IgdGVzdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbWF4aW11bSBiYWxhbmNlIG9mIGFuIG5vZGUgaW4gdGhlIHRyZWUuIFRoZSBiYWxhbmNlIGlzIHRoZSBkaWZmZXJlbmNlXG4gICAgICAgICAqIGluIGhlaWdodCBvZiB0aGUgdHdvIGNoaWxkcmVuIG9mIGEgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRNYXhCYWxhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1heEJhbGFuY2UgPSAwO1xuICAgICAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgICAgICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yUG9vbC5hbGxvY2F0ZSgpLnByZW9yZGVyKHRoaXMubV9yb290KTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlID0gaXQubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVpZ2h0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiYWxhbmNlID0gbWF0aF9hYnMkOChub2RlLmNoaWxkMi5oZWlnaHQgLSBub2RlLmNoaWxkMS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIG1heEJhbGFuY2UgPSBtYXRoX21heCQ2KG1heEJhbGFuY2UsIGJhbGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVyYXRvclBvb2wucmVsZWFzZShpdCk7XG4gICAgICAgICAgICByZXR1cm4gbWF4QmFsYW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkIGFuIG9wdGltYWwgdHJlZS4gVmVyeSBleHBlbnNpdmUuIEZvciB0ZXN0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJlYnVpbGRCb3R0b21VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIEJ1aWxkIGFycmF5IG9mIGxlYXZlcy4gRnJlZSB0aGUgcmVzdC5cbiAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvclBvb2wuYWxsb2NhdGUoKS5wcmVvcmRlcih0aGlzLm1fcm9vdCk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSA9IGl0Lm5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJlZSBub2RlIGluIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbY291bnRdID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlZU5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVyYXRvclBvb2wucmVsZWFzZShpdCk7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkNvc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB2YXIgaU1pbiA9IC0xO1xuICAgICAgICAgICAgICAgIHZhciBqTWluID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhYWJiaSA9IG5vZGVzW2ldLmFhYmI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGNvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYWJiaiA9IG5vZGVzW2pdLmFhYmI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29zdCA9IEFBQkIuY29tYmluZWRQZXJpbWV0ZXIoYWFiYmksIGFhYmJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3N0IDwgbWluQ29zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlNaW4gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpNaW4gPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvc3QgPSBjb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGlsZDEgPSBub2Rlc1tpTWluXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQyID0gbm9kZXNbak1pbl07XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5hbGxvY2F0ZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRfMS5jaGlsZDEgPSBjaGlsZDE7XG4gICAgICAgICAgICAgICAgcGFyZW50XzEuY2hpbGQyID0gY2hpbGQyO1xuICAgICAgICAgICAgICAgIHBhcmVudF8xLmhlaWdodCA9IDEgKyBtYXRoX21heCQ2KGNoaWxkMS5oZWlnaHQsIGNoaWxkMi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHBhcmVudF8xLmFhYmIuY29tYmluZShjaGlsZDEuYWFiYiwgY2hpbGQyLmFhYmIpO1xuICAgICAgICAgICAgICAgIHBhcmVudF8xLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2hpbGQxLnBhcmVudCA9IHBhcmVudF8xO1xuICAgICAgICAgICAgICAgIGNoaWxkMi5wYXJlbnQgPSBwYXJlbnRfMTtcbiAgICAgICAgICAgICAgICBub2Rlc1tqTWluXSA9IG5vZGVzW2NvdW50IC0gMV07XG4gICAgICAgICAgICAgICAgbm9kZXNbaU1pbl0gPSBwYXJlbnRfMTtcbiAgICAgICAgICAgICAgICAtLWNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX3Jvb3QgPSBub2Rlc1swXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNoaWZ0IHRoZSB3b3JsZCBvcmlnaW4uIFVzZWZ1bCBmb3IgbGFyZ2Ugd29ybGRzLiBUaGUgc2hpZnQgZm9ybXVsYSBpczpcbiAgICAgICAgICogcG9zaXRpb24gLT0gbmV3T3JpZ2luXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXdPcmlnaW4gVGhlIG5ldyBvcmlnaW4gd2l0aCByZXNwZWN0IHRvIHRoZSBvbGQgb3JpZ2luXG4gICAgICAgICAqL1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbiAobmV3T3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBCdWlsZCBhcnJheSBvZiBsZWF2ZXMuIEZyZWUgdGhlIHJlc3QuXG4gICAgICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgICAgIHZhciBpdCA9IHRoaXMuaXRlcmF0b3JQb29sLmFsbG9jYXRlKCkucHJlb3JkZXIodGhpcy5tX3Jvb3QpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSBpdC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWFiYiA9IG5vZGUuYWFiYjtcbiAgICAgICAgICAgICAgICBhYWJiLmxvd2VyQm91bmQueCAtPSBuZXdPcmlnaW4ueDtcbiAgICAgICAgICAgICAgICBhYWJiLmxvd2VyQm91bmQueSAtPSBuZXdPcmlnaW4ueTtcbiAgICAgICAgICAgICAgICBhYWJiLnVwcGVyQm91bmQueCAtPSBuZXdPcmlnaW4ueDtcbiAgICAgICAgICAgICAgICBhYWJiLnVwcGVyQm91bmQueSAtPSBuZXdPcmlnaW4ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXRlcmF0b3JQb29sLnJlbGVhc2UoaXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUXVlcnkgYW4gQUFCQiBmb3Igb3ZlcmxhcHBpbmcgcHJveGllcy4gVGhlIGNhbGxiYWNrIGNsYXNzIGlzIGNhbGxlZCBmb3IgZWFjaFxuICAgICAgICAgKiBwcm94eSB0aGF0IG92ZXJsYXBzIHRoZSBzdXBwbGllZCBBQUJCLlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGFhYmIsIHF1ZXJ5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2tQb29sLmFsbG9jYXRlKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMubV9yb290KTtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQUFCQi50ZXN0T3ZlcmxhcChub2RlLmFhYmIsIGFhYmIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2VlZCA9IHF1ZXJ5Q2FsbGJhY2sobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2VlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUuY2hpbGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZS5jaGlsZDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFja1Bvb2wucmVsZWFzZShzdGFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYXktY2FzdCBhZ2FpbnN0IHRoZSBwcm94aWVzIGluIHRoZSB0cmVlLiBUaGlzIHJlbGllcyBvbiB0aGUgY2FsbGJhY2sgdG9cbiAgICAgICAgICogcGVyZm9ybSBhIGV4YWN0IHJheS1jYXN0IGluIHRoZSBjYXNlIHdlcmUgdGhlIHByb3h5IGNvbnRhaW5zIGEgc2hhcGUuIFRoZVxuICAgICAgICAgKiBjYWxsYmFjayBhbHNvIHBlcmZvcm1zIHRoZSBhbnkgY29sbGlzaW9uIGZpbHRlcmluZy4gVGhpcyBoYXMgcGVyZm9ybWFuY2VcbiAgICAgICAgICogcm91Z2hseSBlcXVhbCB0byBrICogbG9nKG4pLCB3aGVyZSBrIGlzIHRoZSBudW1iZXIgb2YgY29sbGlzaW9ucyBhbmQgbiBpcyB0aGVcbiAgICAgICAgICogbnVtYmVyIG9mIHByb3hpZXMgaW4gdGhlIHRyZWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgcmF5LWNhc3QgaW5wdXQgZGF0YS4gVGhlIHJheSBleHRlbmRzIGZyb20gYHAxYCB0byBgcDEgKyBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKWAuXG4gICAgICAgICAqIEBwYXJhbSByYXlDYXN0Q2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCBwcm94eSB0aGF0IGlzIGhpdCBieSB0aGUgcmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAoaW5wdXQsIHJheUNhc3RDYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHAxID0gaW5wdXQucDE7XG4gICAgICAgICAgICB2YXIgcDIgPSBpbnB1dC5wMjtcbiAgICAgICAgICAgIHZhciByID0gVmVjMi5zdWIocDIsIHAxKTtcbiAgICAgICAgICAgIHIubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAvLyB2IGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHNlZ21lbnQuXG4gICAgICAgICAgICB2YXIgdiA9IFZlYzIuY3Jvc3NOdW1WZWMyKDEuMCwgcik7XG4gICAgICAgICAgICB2YXIgYWJzX3YgPSBWZWMyLmFicyh2KTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRpbmcgYXhpcyBmb3Igc2VnbWVudCAoR2lubywgcDgwKS5cbiAgICAgICAgICAgIC8vIHxkb3QodiwgcDEgLSBjKXwgPiBkb3QofHZ8LCBoKVxuICAgICAgICAgICAgdmFyIG1heEZyYWN0aW9uID0gaW5wdXQubWF4RnJhY3Rpb247XG4gICAgICAgICAgICAvLyBCdWlsZCBhIGJvdW5kaW5nIGJveCBmb3IgdGhlIHNlZ21lbnQuXG4gICAgICAgICAgICB2YXIgc2VnbWVudEFBQkIgPSBuZXcgQUFCQigpO1xuICAgICAgICAgICAgdmFyIHQgPSBWZWMyLmNvbWJpbmUoKDEgLSBtYXhGcmFjdGlvbiksIHAxLCBtYXhGcmFjdGlvbiwgcDIpO1xuICAgICAgICAgICAgc2VnbWVudEFBQkIuY29tYmluZVBvaW50cyhwMSwgdCk7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrUG9vbC5hbGxvY2F0ZSgpO1xuICAgICAgICAgICAgdmFyIHN1YklucHV0ID0gdGhpcy5pbnB1dFBvb2wuYWxsb2NhdGUoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5tX3Jvb3QpO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBQUJCLnRlc3RPdmVybGFwKG5vZGUuYWFiYiwgc2VnbWVudEFBQkIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VwYXJhdGluZyBheGlzIGZvciBzZWdtZW50IChHaW5vLCBwODApLlxuICAgICAgICAgICAgICAgIC8vIHxkb3QodiwgcDEgLSBjKXwgPiBkb3QofHZ8LCBoKVxuICAgICAgICAgICAgICAgIHZhciBjID0gbm9kZS5hYWJiLmdldENlbnRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBoID0gbm9kZS5hYWJiLmdldEV4dGVudHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IG1hdGhfYWJzJDgoVmVjMi5kb3QodiwgVmVjMi5zdWIocDEsIGMpKSkgLSBWZWMyLmRvdChhYnNfdiwgaCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YklucHV0LnAxID0gVmVjMi5jbG9uZShpbnB1dC5wMSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YklucHV0LnAyID0gVmVjMi5jbG9uZShpbnB1dC5wMik7XG4gICAgICAgICAgICAgICAgICAgIHN1YklucHV0Lm1heEZyYWN0aW9uID0gbWF4RnJhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJheUNhc3RDYWxsYmFjayhzdWJJbnB1dCwgbm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2xpZW50IGhhcyB0ZXJtaW5hdGVkIHRoZSByYXkgY2FzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBzZWdtZW50IGJvdW5kaW5nIGJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZyYWN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gVmVjMi5jb21iaW5lKCgxIC0gbWF4RnJhY3Rpb24pLCBwMSwgbWF4RnJhY3Rpb24sIHAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLmNvbWJpbmVQb2ludHMocDEsIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUuY2hpbGQxKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlLmNoaWxkMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFja1Bvb2wucmVsZWFzZShzdGFjayk7XG4gICAgICAgICAgICB0aGlzLmlucHV0UG9vbC5yZWxlYXNlKHN1YklucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIER5bmFtaWNUcmVlO1xuICAgIH0oKSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHZhciBJdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSXRlcmF0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgSXRlcmF0b3IucHJvdG90eXBlLnByZW9yZGVyID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRzLnB1c2gocm9vdCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5wYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhcmVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVzW2ldID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzW2ldID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlc1tpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlc1tpXSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRzLnB1c2gobm9kZS5jaGlsZDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXNbaV0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXNbaV0gPSAzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50cy5wdXNoKG5vZGUuY2hpbGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBJdGVyYXRvci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEl0ZXJhdG9yO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9tYXgkNSA9IE1hdGgubWF4O1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfbWluJDYgPSBNYXRoLm1pbjtcbiAgICAvKipcbiAgICAgKiBUaGUgYnJvYWQtcGhhc2Ugd3JhcHMgYW5kIGV4dGVuZHMgYSBkeW5hbWljLXRyZWUgdG8ga2VlcCB0cmFjayBvZiBtb3ZlZFxuICAgICAqIG9iamVjdHMgYW5kIHF1ZXJ5IHRoZW0gb24gdXBkYXRlLlxuICAgICAqL1xuICAgIHZhciBCcm9hZFBoYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCcm9hZFBoYXNlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubV90cmVlID0gbmV3IER5bmFtaWNUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLm1fbW92ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBRdWVyeSBhbiBBQUJCIGZvciBvdmVybGFwcGluZyBwcm94aWVzLiBUaGUgY2FsbGJhY2sgY2xhc3MgaXMgY2FsbGVkIGZvciBlYWNoXG4gICAgICAgICAgICAgKiBwcm94eSB0aGF0IG92ZXJsYXBzIHRoZSBzdXBwbGllZCBBQUJCLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gZnVuY3Rpb24gKGFhYmIsIHF1ZXJ5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3RyZWUucXVlcnkoYWFiYiwgcXVlcnlDYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5xdWVyeUNhbGxiYWNrID0gZnVuY3Rpb24gKHByb3h5SWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHByb3h5IGNhbm5vdCBmb3JtIGEgcGFpciB3aXRoIGl0c2VsZi5cbiAgICAgICAgICAgICAgICBpZiAocHJveHlJZCA9PT0gX3RoaXMubV9xdWVyeVByb3h5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcm94eUlkQSA9IG1hdGhfbWluJDYocHJveHlJZCwgX3RoaXMubV9xdWVyeVByb3h5SWQpO1xuICAgICAgICAgICAgICAgIHZhciBwcm94eUlkQiA9IG1hdGhfbWF4JDUocHJveHlJZCwgX3RoaXMubV9xdWVyeVByb3h5SWQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFNraXAgYW55IGR1cGxpY2F0ZSBwYWlycy5cbiAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFBID0gX3RoaXMubV90cmVlLmdldFVzZXJEYXRhKHByb3h5SWRBKTtcbiAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFCID0gX3RoaXMubV90cmVlLmdldFVzZXJEYXRhKHByb3h5SWRCKTtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBwYWlycyBiYWNrIHRvIHRoZSBjbGllbnQuXG4gICAgICAgICAgICAgICAgX3RoaXMubV9jYWxsYmFjayh1c2VyRGF0YUEsIHVzZXJEYXRhQik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdXNlciBkYXRhIGZyb20gYSBwcm94eS4gUmV0dXJucyBudWxsIGlmIHRoZSBpZCBpcyBpbnZhbGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUuZ2V0VXNlckRhdGEgPSBmdW5jdGlvbiAocHJveHlJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV90cmVlLmdldFVzZXJEYXRhKHByb3h5SWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBvdmVybGFwIG9mIGZhdCBBQUJCcy5cbiAgICAgICAgICovXG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLnRlc3RPdmVybGFwID0gZnVuY3Rpb24gKHByb3h5SWRBLCBwcm94eUlkQikge1xuICAgICAgICAgICAgdmFyIGFhYmJBID0gdGhpcy5tX3RyZWUuZ2V0RmF0QUFCQihwcm94eUlkQSk7XG4gICAgICAgICAgICB2YXIgYWFiYkIgPSB0aGlzLm1fdHJlZS5nZXRGYXRBQUJCKHByb3h5SWRCKTtcbiAgICAgICAgICAgIHJldHVybiBBQUJCLnRlc3RPdmVybGFwKGFhYmJBLCBhYWJiQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZhdCBBQUJCIGZvciBhIHByb3h5LlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUuZ2V0RmF0QUFCQiA9IGZ1bmN0aW9uIChwcm94eUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3RyZWUuZ2V0RmF0QUFCQihwcm94eUlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHByb3hpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5nZXRQcm94eUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tb3ZlQnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBlbWJlZGRlZCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUuZ2V0VHJlZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHJlZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYmFsYW5jZSAoaW50ZWdlcikgb2YgdGhlIGVtYmVkZGVkIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5nZXRUcmVlQmFsYW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHJlZS5nZXRNYXhCYWxhbmNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHF1YWxpdHkgbWV0cmljIG9mIHRoZSBlbWJlZGRlZCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUuZ2V0VHJlZVF1YWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3RyZWUuZ2V0QXJlYVJhdGlvKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYXktY2FzdCBhZ2FpbnN0IHRoZSBwcm94aWVzIGluIHRoZSB0cmVlLiBUaGlzIHJlbGllcyBvbiB0aGUgY2FsbGJhY2sgdG9cbiAgICAgICAgICogcGVyZm9ybSBhIGV4YWN0IHJheS1jYXN0IGluIHRoZSBjYXNlIHdlcmUgdGhlIHByb3h5IGNvbnRhaW5zIGEgc2hhcGUuIFRoZVxuICAgICAgICAgKiBjYWxsYmFjayBhbHNvIHBlcmZvcm1zIHRoZSBhbnkgY29sbGlzaW9uIGZpbHRlcmluZy4gVGhpcyBoYXMgcGVyZm9ybWFuY2VcbiAgICAgICAgICogcm91Z2hseSBlcXVhbCB0byBrICogbG9nKG4pLCB3aGVyZSBrIGlzIHRoZSBudW1iZXIgb2YgY29sbGlzaW9ucyBhbmQgbiBpcyB0aGVcbiAgICAgICAgICogbnVtYmVyIG9mIHByb3hpZXMgaW4gdGhlIHRyZWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgcmF5LWNhc3QgaW5wdXQgZGF0YS4gVGhlIHJheSBleHRlbmRzIGZyb20gYHAxYCB0byBgcDEgKyBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKWAuXG4gICAgICAgICAqIEBwYXJhbSByYXlDYXN0Q2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCBwcm94eSB0aGF0IGlzIGhpdCBieSB0aGUgcmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChpbnB1dCwgcmF5Q2FzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm1fdHJlZS5yYXlDYXN0KGlucHV0LCByYXlDYXN0Q2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hpZnQgdGhlIHdvcmxkIG9yaWdpbi4gVXNlZnVsIGZvciBsYXJnZSB3b3JsZHMuIFRoZSBzaGlmdCBmb3JtdWxhIGlzOlxuICAgICAgICAgKiBwb3NpdGlvbiAtPSBuZXdPcmlnaW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5ld09yaWdpbiBUaGUgbmV3IG9yaWdpbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG9sZCBvcmlnaW5cbiAgICAgICAgICovXG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLnNoaWZ0T3JpZ2luID0gZnVuY3Rpb24gKG5ld09yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5tX3RyZWUuc2hpZnRPcmlnaW4obmV3T3JpZ2luKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHByb3h5IHdpdGggYW4gaW5pdGlhbCBBQUJCLiBQYWlycyBhcmUgbm90IHJlcG9ydGVkIHVudGlsIFVwZGF0ZVBhaXJzXG4gICAgICAgICAqIGlzIGNhbGxlZC5cbiAgICAgICAgICovXG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLmNyZWF0ZVByb3h5ID0gZnVuY3Rpb24gKGFhYmIsIHVzZXJEYXRhKSB7XG4gICAgICAgICAgICB2YXIgcHJveHlJZCA9IHRoaXMubV90cmVlLmNyZWF0ZVByb3h5KGFhYmIsIHVzZXJEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTW92ZShwcm94eUlkKTtcbiAgICAgICAgICAgIHJldHVybiBwcm94eUlkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveSBhIHByb3h5LiBJdCBpcyB1cCB0byB0aGUgY2xpZW50IHRvIHJlbW92ZSBhbnkgcGFpcnMuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS5kZXN0cm95UHJveHkgPSBmdW5jdGlvbiAocHJveHlJZCkge1xuICAgICAgICAgICAgdGhpcy51bmJ1ZmZlck1vdmUocHJveHlJZCk7XG4gICAgICAgICAgICB0aGlzLm1fdHJlZS5kZXN0cm95UHJveHkocHJveHlJZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIG1vdmVQcm94eSBhcyBtYW55IHRpbWVzIGFzIHlvdSBsaWtlLCB0aGVuIHdoZW4geW91IGFyZSBkb25lIGNhbGxcbiAgICAgICAgICogVXBkYXRlUGFpcnMgdG8gZmluYWxpemVkIHRoZSBwcm94eSBwYWlycyAoZm9yIHlvdXIgdGltZSBzdGVwKS5cbiAgICAgICAgICovXG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLm1vdmVQcm94eSA9IGZ1bmN0aW9uIChwcm94eUlkLCBhYWJiLCBkaXNwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5tX3RyZWUubW92ZVByb3h5KHByb3h5SWQsIGFhYmIsIGRpc3BsYWNlbWVudCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTW92ZShwcm94eUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGwgdG8gdHJpZ2dlciBhIHJlLXByb2Nlc3Npbmcgb2YgaXQncyBwYWlycyBvbiB0aGUgbmV4dCBjYWxsIHRvXG4gICAgICAgICAqIFVwZGF0ZVBhaXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUudG91Y2hQcm94eSA9IGZ1bmN0aW9uIChwcm94eUlkKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck1vdmUocHJveHlJZCk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb2FkUGhhc2UucHJvdG90eXBlLmJ1ZmZlck1vdmUgPSBmdW5jdGlvbiAocHJveHlJZCkge1xuICAgICAgICAgICAgdGhpcy5tX21vdmVCdWZmZXIucHVzaChwcm94eUlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvYWRQaGFzZS5wcm90b3R5cGUudW5idWZmZXJNb3ZlID0gZnVuY3Rpb24gKHByb3h5SWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX21vdmVCdWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX21vdmVCdWZmZXJbaV0gPT09IHByb3h5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX21vdmVCdWZmZXJbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgcGFpcnMuIFRoaXMgcmVzdWx0cyBpbiBwYWlyIGNhbGxiYWNrcy4gVGhpcyBjYW4gb25seSBhZGQgcGFpcnMuXG4gICAgICAgICAqL1xuICAgICAgICBCcm9hZFBoYXNlLnByb3RvdHlwZS51cGRhdGVQYWlycyA9IGZ1bmN0aW9uIChhZGRQYWlyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubV9jYWxsYmFjayA9IGFkZFBhaXJDYWxsYmFjaztcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gdHJlZSBxdWVyaWVzIGZvciBhbGwgbW92aW5nIHByb3hpZXMuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5tX21vdmVCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9xdWVyeVByb3h5SWQgPSB0aGlzLm1fbW92ZUJ1ZmZlci5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX3F1ZXJ5UHJveHlJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBxdWVyeSB0aGUgdHJlZSB3aXRoIHRoZSBmYXQgQUFCQiBzbyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgZmFpbCB0byBjcmVhdGUgYSBwYWlyIHRoYXQgbWF5IHRvdWNoIGxhdGVyLlxuICAgICAgICAgICAgICAgIHZhciBmYXRBQUJCID0gdGhpcy5tX3RyZWUuZ2V0RmF0QUFCQih0aGlzLm1fcXVlcnlQcm94eUlkKTtcbiAgICAgICAgICAgICAgICAvLyBRdWVyeSB0cmVlLCBjcmVhdGUgcGFpcnMgYW5kIGFkZCB0aGVtIHBhaXIgYnVmZmVyLlxuICAgICAgICAgICAgICAgIHRoaXMubV90cmVlLnF1ZXJ5KGZhdEFBQkIsIHRoaXMucXVlcnlDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcnkgdG8ga2VlcCB0aGUgdHJlZSBiYWxhbmNlZC5cbiAgICAgICAgICAgIC8vIHRoaXMubV90cmVlLnJlYmFsYW5jZSg0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJyb2FkUGhhc2U7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIzIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX3NpbiQyID0gTWF0aC5zaW47XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9jb3MkMiA9IE1hdGguY29zO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfc3FydCQ0ID0gTWF0aC5zcXJ0O1xuICAgIGZ1bmN0aW9uIHZlYzIoeCwgeSkge1xuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdGF0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB7IHM6IG1hdGhfc2luJDIoYW5nbGUpLCBjOiBtYXRoX2NvcyQyKGFuZ2xlKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRWZWMyKG91dCwgeCwgeSkge1xuICAgICAgICBvdXQueCA9IHg7XG4gICAgICAgIG91dC55ID0geTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVZlYzIob3V0LCB3KSB7XG4gICAgICAgIG91dC54ID0gdy54O1xuICAgICAgICBvdXQueSA9IHcueTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gemVyb1ZlYzIob3V0KSB7XG4gICAgICAgIG91dC54ID0gMDtcbiAgICAgICAgb3V0LnkgPSAwO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZWdWZWMyKG91dCkge1xuICAgICAgICBvdXQueCA9IC1vdXQueDtcbiAgICAgICAgb3V0LnkgPSAtb3V0Lnk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFZlYzIob3V0LCB3KSB7XG4gICAgICAgIG91dC54ICs9IHcueDtcbiAgICAgICAgb3V0LnkgKz0gdy55O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdW1WZWMyKG91dCwgdiwgdykge1xuICAgICAgICBvdXQueCA9IHYueCArIHcueDtcbiAgICAgICAgb3V0LnkgPSB2LnggKyB3Lnk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1YlZlYzIob3V0LCB3KSB7XG4gICAgICAgIG91dC54IC09IHcueDtcbiAgICAgICAgb3V0LnkgLT0gdy55O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmVmVjMihvdXQsIHYsIHcpIHtcbiAgICAgICAgb3V0LnggPSB2LnggLSB3Lng7XG4gICAgICAgIG91dC55ID0gdi55IC0gdy55O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZVZlYzIob3V0LCBtKSB7XG4gICAgICAgIG91dC54ICo9IG07XG4gICAgICAgIG91dC55ICo9IG07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldE11bFZlYzIob3V0LCBtLCB3KSB7XG4gICAgICAgIG91dC54ID0gbSAqIHcueDtcbiAgICAgICAgb3V0LnkgPSBtICogdy55O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRNdWxWZWMyKG91dCwgbSwgdykge1xuICAgICAgICBvdXQueCArPSBtICogdy54O1xuICAgICAgICBvdXQueSArPSBtICogdy55O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJNdWxWZWMyKG91dCwgbSwgdykge1xuICAgICAgICBvdXQueCAtPSBtICogdy54O1xuICAgICAgICBvdXQueSAtPSBtICogdy55O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21iaW5lVmVjMihvdXQsIGFtLCBhLCBibSwgYikge1xuICAgICAgICBvdXQueCA9IGFtICogYS54ICsgYm0gKiBiLng7XG4gICAgICAgIG91dC55ID0gYW0gKiBhLnkgKyBibSAqIGIueTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVmVjMkxlbmd0aChvdXQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG1hdGhfc3FydCQ0KG91dC54ICogb3V0LnggKyBvdXQueSAqIG91dC55KTtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGludkxlbmd0aCA9IDEgLyBsZW5ndGg7XG4gICAgICAgICAgICBvdXQueCAqPSBpbnZMZW5ndGg7XG4gICAgICAgICAgICBvdXQueSAqPSBpbnZMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVmVjMihvdXQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG1hdGhfc3FydCQ0KG91dC54ICogb3V0LnggKyBvdXQueSAqIG91dC55KTtcbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpbnZMZW5ndGggPSAxIC8gbGVuZ3RoO1xuICAgICAgICAgICAgb3V0LnggKj0gaW52TGVuZ3RoO1xuICAgICAgICAgICAgb3V0LnkgKj0gaW52TGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyb3NzVmVjMk51bShvdXQsIHYsIHcpIHtcbiAgICAgICAgdmFyIHggPSB3ICogdi55O1xuICAgICAgICB2YXIgeSA9IC13ICogdi54O1xuICAgICAgICBvdXQueCA9IHg7XG4gICAgICAgIG91dC55ID0geTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3Jvc3NOdW1WZWMyKG91dCwgdywgdikge1xuICAgICAgICB2YXIgeCA9IC13ICogdi55O1xuICAgICAgICB2YXIgeSA9IHcgKiB2Lng7XG4gICAgICAgIG91dC54ID0geDtcbiAgICAgICAgb3V0LnkgPSB5O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcm9zc1ZlYzJWZWMyKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG90VmVjMihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlbmd0aFNxclZlYzIoYSkge1xuICAgICAgICByZXR1cm4gYS54ICogYS54ICsgYS55ICogYS55O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXN0VmVjMihhLCBiKSB7XG4gICAgICAgIHZhciBkeCA9IGEueCAtIGIueDtcbiAgICAgICAgdmFyIGR5ID0gYS55IC0gYi55O1xuICAgICAgICByZXR1cm4gbWF0aF9zcXJ0JDQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXN0U3FyVmVjMihhLCBiKSB7XG4gICAgICAgIHZhciBkeCA9IGEueCAtIGIueDtcbiAgICAgICAgdmFyIGR5ID0gYS55IC0gYi55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFJvdEFuZ2xlKG91dCwgYSkge1xuICAgICAgICBvdXQuYyA9IG1hdGhfY29zJDIoYSk7XG4gICAgICAgIG91dC5zID0gbWF0aF9zaW4kMihhKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90VmVjMihvdXQsIHEsIHYpIHtcbiAgICAgICAgb3V0LnggPSBxLmMgKiB2LnggLSBxLnMgKiB2Lnk7XG4gICAgICAgIG91dC55ID0gcS5zICogdi54ICsgcS5jICogdi55O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZSb3RWZWMyKG91dCwgcSwgdikge1xuICAgICAgICB2YXIgeCA9IHEuYyAqIHYueCArIHEucyAqIHYueTtcbiAgICAgICAgdmFyIHkgPSAtcS5zICogdi54ICsgcS5jICogdi55O1xuICAgICAgICBvdXQueCA9IHg7XG4gICAgICAgIG91dC55ID0geTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyb3RWZWMyKG91dCwgYmVmb3JlLCBhZnRlciwgdikge1xuICAgICAgICB2YXIgeDAgPSBiZWZvcmUuYyAqIHYueCArIGJlZm9yZS5zICogdi55O1xuICAgICAgICB2YXIgeTAgPSAtYmVmb3JlLnMgKiB2LnggKyBiZWZvcmUuYyAqIHYueTtcbiAgICAgICAgdmFyIHggPSBhZnRlci5jICogeDAgLSBhZnRlci5zICogeTA7XG4gICAgICAgIHZhciB5ID0gYWZ0ZXIucyAqIHgwICsgYWZ0ZXIuYyAqIHkwO1xuICAgICAgICBvdXQueCA9IHg7XG4gICAgICAgIG91dC55ID0geTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHksIGEpIHtcbiAgICAgICAgcmV0dXJuIHsgcDogdmVjMih4LCB5KSwgcTogcm90YXRpb24oYSkgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRyYW5zZm9ybShvdXQsIHRyYW5zZm9ybSkge1xuICAgICAgICBvdXQucC54ID0gdHJhbnNmb3JtLnAueDtcbiAgICAgICAgb3V0LnAueSA9IHRyYW5zZm9ybS5wLnk7XG4gICAgICAgIG91dC5xLnMgPSB0cmFuc2Zvcm0ucS5zO1xuICAgICAgICBvdXQucS5jID0gdHJhbnNmb3JtLnEuYztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtVmVjMihvdXQsIHhmLCB2KSB7XG4gICAgICAgIHZhciB4ID0geGYucS5jICogdi54IC0geGYucS5zICogdi55ICsgeGYucC54O1xuICAgICAgICB2YXIgeSA9IHhmLnEucyAqIHYueCArIHhmLnEuYyAqIHYueSArIHhmLnAueTtcbiAgICAgICAgb3V0LnggPSB4O1xuICAgICAgICBvdXQueSA9IHk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludlRyYW5zZm9ybVZlYzIob3V0LCB4Ziwgdikge1xuICAgICAgICB2YXIgcHggPSB2LnggLSB4Zi5wLng7XG4gICAgICAgIHZhciBweSA9IHYueSAtIHhmLnAueTtcbiAgICAgICAgdmFyIHggPSAoeGYucS5jICogcHggKyB4Zi5xLnMgKiBweSk7XG4gICAgICAgIHZhciB5ID0gKC14Zi5xLnMgKiBweCArIHhmLnEuYyAqIHB5KTtcbiAgICAgICAgb3V0LnggPSB4O1xuICAgICAgICBvdXQueSA9IHk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJhbnNmb3JtVmVjMihvdXQsIGZyb20sIHRvLCB2KSB7XG4gICAgICAgIHZhciB4MCA9IGZyb20ucS5jICogdi54IC0gZnJvbS5xLnMgKiB2LnkgKyBmcm9tLnAueDtcbiAgICAgICAgdmFyIHkwID0gZnJvbS5xLnMgKiB2LnggKyBmcm9tLnEuYyAqIHYueSArIGZyb20ucC55O1xuICAgICAgICB2YXIgcHggPSB4MCAtIHRvLnAueDtcbiAgICAgICAgdmFyIHB5ID0geTAgLSB0by5wLnk7XG4gICAgICAgIHZhciB4ID0gdG8ucS5jICogcHggKyB0by5xLnMgKiBweTtcbiAgICAgICAgdmFyIHkgPSAtdG8ucS5zICogcHggKyB0by5xLmMgKiBweTtcbiAgICAgICAgb3V0LnggPSB4O1xuICAgICAgICBvdXQueSA9IHk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludlRyYW5zZm9ybVRyYW5zZm9ybShvdXQsIGEsIGIpIHtcbiAgICAgICAgdmFyIGMgPSBhLnEuYyAqIGIucS5jICsgYS5xLnMgKiBiLnEucztcbiAgICAgICAgdmFyIHMgPSBhLnEuYyAqIGIucS5zIC0gYS5xLnMgKiBiLnEuYztcbiAgICAgICAgdmFyIHggPSBhLnEuYyAqIChiLnAueCAtIGEucC54KSArIGEucS5zICogKGIucC55IC0gYS5wLnkpO1xuICAgICAgICB2YXIgeSA9IC1hLnEucyAqIChiLnAueCAtIGEucC54KSArIGEucS5jICogKGIucC55IC0gYS5wLnkpO1xuICAgICAgICBvdXQucS5jID0gYztcbiAgICAgICAgb3V0LnEucyA9IHM7XG4gICAgICAgIG91dC5wLnggPSB4O1xuICAgICAgICBvdXQucC55ID0geTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9zaW4kMSA9IE1hdGguc2luO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfY29zJDEgPSBNYXRoLmNvcztcbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX2F0YW4yJDEgPSBNYXRoLmF0YW4yO1xuICAgIHZhciBSb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBJbml0aWFsaXplIGZyb20gYW4gYW5nbGUgaW4gcmFkaWFucy4gKi9cbiAgICAgICAgZnVuY3Rpb24gUm90KGFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUm90KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUm90KGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5nbGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmdsZShhbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5nbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb3QoYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJZGVudGl0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUm90Lm5lbyA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoUm90LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmouc2V0QW5nbGUoYW5nbGUpO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgUm90LmNsb25lID0gZnVuY3Rpb24gKHJvdCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoUm90LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmoucyA9IHJvdC5zO1xuICAgICAgICAgICAgb2JqLmMgPSByb3QuYztcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIFJvdC5pZGVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKFJvdC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgb2JqLnMgPSAwLjA7XG4gICAgICAgICAgICBvYmouYyA9IDEuMDtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIFJvdC5pc1ZhbGlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUob2JqLnMpICYmIE51bWJlci5pc0Zpbml0ZShvYmouYyk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdC5hc3NlcnQgPSBmdW5jdGlvbiAobykge1xuICAgICAgICB9O1xuICAgICAgICAvKiogU2V0IHRvIHRoZSBpZGVudGl0eSByb3RhdGlvbi4gKi9cbiAgICAgICAgUm90LnByb3RvdHlwZS5zZXRJZGVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucyA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMuYyA9IDEuMDtcbiAgICAgICAgfTtcbiAgICAgICAgUm90LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5nbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zID0gYW5nbGUucztcbiAgICAgICAgICAgICAgICB0aGlzLmMgPSBhbmdsZS5jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ET19FUklOIG9wdGltaXplXG4gICAgICAgICAgICAgICAgdGhpcy5zID0gbWF0aF9zaW4kMShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jID0gbWF0aF9jb3MkMShhbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJvdC5wcm90b3R5cGUuc2V0Um90ID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSBhbmdsZS5zO1xuICAgICAgICAgICAgdGhpcy5jID0gYW5nbGUuYztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFNldCB1c2luZyBhbiBhbmdsZSBpbiByYWRpYW5zLiAqL1xuICAgICAgICBSb3QucHJvdG90eXBlLnNldEFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICAgICAgICAvLyBUT0RPX0VSSU4gb3B0aW1pemVcbiAgICAgICAgICAgIHRoaXMucyA9IG1hdGhfc2luJDEoYW5nbGUpO1xuICAgICAgICAgICAgdGhpcy5jID0gbWF0aF9jb3MkMShhbmdsZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBHZXQgdGhlIGFuZ2xlIGluIHJhZGlhbnMuICovXG4gICAgICAgIFJvdC5wcm90b3R5cGUuZ2V0QW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aF9hdGFuMiQxKHRoaXMucywgdGhpcy5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEdldCB0aGUgeC1heGlzLiAqL1xuICAgICAgICBSb3QucHJvdG90eXBlLmdldFhBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHRoaXMuYywgdGhpcy5zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEdldCB0aGUgeS1heGlzLiAqL1xuICAgICAgICBSb3QucHJvdG90eXBlLmdldFlBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKC10aGlzLnMsIHRoaXMuYyk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdC5tdWwgPSBmdW5jdGlvbiAocm90LCBtKSB7XG4gICAgICAgICAgICBpZiAoJ2MnIGluIG0gJiYgJ3MnIGluIG0pIHtcbiAgICAgICAgICAgICAgICAvLyBbcWMgLXFzXSAqIFtyYyAtcnNdID0gW3FjKnJjLXFzKnJzIC1xYypycy1xcypyY11cbiAgICAgICAgICAgICAgICAvLyBbcXMgcWNdIFtycyByY10gW3FzKnJjK3FjKnJzIC1xcypycytxYypyY11cbiAgICAgICAgICAgICAgICAvLyBzID0gcXMgKiByYyArIHFjICogcnNcbiAgICAgICAgICAgICAgICAvLyBjID0gcWMgKiByYyAtIHFzICogcnNcbiAgICAgICAgICAgICAgICB2YXIgcXIgPSBSb3QuaWRlbnRpdHkoKTtcbiAgICAgICAgICAgICAgICBxci5zID0gcm90LnMgKiBtLmMgKyByb3QuYyAqIG0ucztcbiAgICAgICAgICAgICAgICBxci5jID0gcm90LmMgKiBtLmMgLSByb3QucyAqIG0ucztcbiAgICAgICAgICAgICAgICByZXR1cm4gcXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgneCcgaW4gbSAmJiAneScgaW4gbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhyb3QuYyAqIG0ueCAtIHJvdC5zICogbS55LCByb3QucyAqIG0ueCArIHJvdC5jICogbS55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIE11bHRpcGx5IHR3byByb3RhdGlvbnM6IHEgKiByICovXG4gICAgICAgIFJvdC5tdWxSb3QgPSBmdW5jdGlvbiAocm90LCBtKSB7XG4gICAgICAgICAgICAvLyBbcWMgLXFzXSAqIFtyYyAtcnNdID0gW3FjKnJjLXFzKnJzIC1xYypycy1xcypyY11cbiAgICAgICAgICAgIC8vIFtxcyBxY10gW3JzIHJjXSBbcXMqcmMrcWMqcnMgLXFzKnJzK3FjKnJjXVxuICAgICAgICAgICAgLy8gcyA9IHFzICogcmMgKyBxYyAqIHJzXG4gICAgICAgICAgICAvLyBjID0gcWMgKiByYyAtIHFzICogcnNcbiAgICAgICAgICAgIHZhciBxciA9IFJvdC5pZGVudGl0eSgpO1xuICAgICAgICAgICAgcXIucyA9IHJvdC5zICogbS5jICsgcm90LmMgKiBtLnM7XG4gICAgICAgICAgICBxci5jID0gcm90LmMgKiBtLmMgLSByb3QucyAqIG0ucztcbiAgICAgICAgICAgIHJldHVybiBxcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFJvdGF0ZSBhIHZlY3RvciAqL1xuICAgICAgICBSb3QubXVsVmVjMiA9IGZ1bmN0aW9uIChyb3QsIG0pIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhyb3QuYyAqIG0ueCAtIHJvdC5zICogbS55LCByb3QucyAqIG0ueCArIHJvdC5jICogbS55KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm90Lm11bFN1YiA9IGZ1bmN0aW9uIChyb3QsIHYsIHcpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcm90LmMgKiAodi54IC0gdy54KSAtIHJvdC5zICogKHYueSAtIHcueSk7XG4gICAgICAgICAgICB2YXIgeSA9IHJvdC5zICogKHYueCAtIHcueCkgKyByb3QuYyAqICh2LnkgLSB3LnkpO1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICBSb3QubXVsVCA9IGZ1bmN0aW9uIChyb3QsIG0pIHtcbiAgICAgICAgICAgIGlmICgnYycgaW4gbSAmJiAncycgaW4gbSkge1xuICAgICAgICAgICAgICAgIC8vIFsgcWMgcXNdICogW3JjIC1yc10gPSBbcWMqcmMrcXMqcnMgLXFjKnJzK3FzKnJjXVxuICAgICAgICAgICAgICAgIC8vIFstcXMgcWNdIFtycyByY10gWy1xcypyYytxYypycyBxcypycytxYypyY11cbiAgICAgICAgICAgICAgICAvLyBzID0gcWMgKiBycyAtIHFzICogcmNcbiAgICAgICAgICAgICAgICAvLyBjID0gcWMgKiByYyArIHFzICogcnNcbiAgICAgICAgICAgICAgICB2YXIgcXIgPSBSb3QuaWRlbnRpdHkoKTtcbiAgICAgICAgICAgICAgICBxci5zID0gcm90LmMgKiBtLnMgLSByb3QucyAqIG0uYztcbiAgICAgICAgICAgICAgICBxci5jID0gcm90LmMgKiBtLmMgKyByb3QucyAqIG0ucztcbiAgICAgICAgICAgICAgICByZXR1cm4gcXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgneCcgaW4gbSAmJiAneScgaW4gbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhyb3QuYyAqIG0ueCArIHJvdC5zICogbS55LCAtcm90LnMgKiBtLnggKyByb3QuYyAqIG0ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBUcmFuc3Bvc2UgbXVsdGlwbHkgdHdvIHJvdGF0aW9uczogcVQgKiByICovXG4gICAgICAgIFJvdC5tdWxUUm90ID0gZnVuY3Rpb24gKHJvdCwgbSkge1xuICAgICAgICAgICAgLy8gWyBxYyBxc10gKiBbcmMgLXJzXSA9IFtxYypyYytxcypycyAtcWMqcnMrcXMqcmNdXG4gICAgICAgICAgICAvLyBbLXFzIHFjXSBbcnMgcmNdIFstcXMqcmMrcWMqcnMgcXMqcnMrcWMqcmNdXG4gICAgICAgICAgICAvLyBzID0gcWMgKiBycyAtIHFzICogcmNcbiAgICAgICAgICAgIC8vIGMgPSBxYyAqIHJjICsgcXMgKiByc1xuICAgICAgICAgICAgdmFyIHFyID0gUm90LmlkZW50aXR5KCk7XG4gICAgICAgICAgICBxci5zID0gcm90LmMgKiBtLnMgLSByb3QucyAqIG0uYztcbiAgICAgICAgICAgIHFyLmMgPSByb3QuYyAqIG0uYyArIHJvdC5zICogbS5zO1xuICAgICAgICAgICAgcmV0dXJuIHFyO1xuICAgICAgICB9O1xuICAgICAgICAvKiogSW52ZXJzZSByb3RhdGUgYSB2ZWN0b3IgKi9cbiAgICAgICAgUm90Lm11bFRWZWMyID0gZnVuY3Rpb24gKHJvdCwgbSkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHJvdC5jICogbS54ICsgcm90LnMgKiBtLnksIC1yb3QucyAqIG0ueCArIHJvdC5jICogbS55KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJvdDtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfYXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfUEkkNSA9IE1hdGguUEk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdGVtcCQ3ID0gdmVjMigwLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGRlc2NyaWJlcyB0aGUgbW90aW9uIG9mIGEgYm9keS9zaGFwZSBmb3IgVE9JIGNvbXB1dGF0aW9uLiBTaGFwZXMgYXJlXG4gICAgICogZGVmaW5lZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGJvZHkgb3JpZ2luLCB3aGljaCBtYXkgbm90IGNvaW5jaWRlIHdpdGggdGhlXG4gICAgICogY2VudGVyIG9mIG1hc3MuIEhvd2V2ZXIsIHRvIHN1cHBvcnQgZHluYW1pY3Mgd2UgbXVzdCBpbnRlcnBvbGF0ZSB0aGUgY2VudGVyXG4gICAgICogb2YgbWFzcyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgU3dlZXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN3ZWVwKCkge1xuICAgICAgICAgICAgLyoqIExvY2FsIGNlbnRlciBvZiBtYXNzIHBvc2l0aW9uICovXG4gICAgICAgICAgICB0aGlzLmxvY2FsQ2VudGVyID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAvKiogV29ybGQgY2VudGVyIHBvc2l0aW9uICovXG4gICAgICAgICAgICB0aGlzLmMgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIC8qKiBXb3JsZCBhbmdsZSAqL1xuICAgICAgICAgICAgdGhpcy5hID0gMDtcbiAgICAgICAgICAgIC8qKiBGcmFjdGlvbiBvZiB0aGUgY3VycmVudCB0aW1lIHN0ZXAgaW4gdGhlIHJhbmdlIFswLDFdLCBjMCBhbmQgYTAgYXJlIGMgYW5kIGEgYXQgYWxwaGEwLiAqL1xuICAgICAgICAgICAgdGhpcy5hbHBoYTAgPSAwO1xuICAgICAgICAgICAgdGhpcy5jMCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdGhpcy5hMCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTd2VlcC5wcm90b3R5cGUucmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMubG9jYWxDZW50ZXIpO1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy5jKTtcbiAgICAgICAgICAgIHRoaXMuYSA9IDA7XG4gICAgICAgICAgICB0aGlzLmFscGhhMCA9IDA7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLmMwKTtcbiAgICAgICAgICAgIHRoaXMuYTAgPSAwO1xuICAgICAgICB9O1xuICAgICAgICBTd2VlcC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHRlbXAkNywgeGYsIHRoaXMubG9jYWxDZW50ZXIpO1xuICAgICAgICAgICAgY29weVZlYzIodGhpcy5jLCB0ZW1wJDcpO1xuICAgICAgICAgICAgY29weVZlYzIodGhpcy5jMCwgdGVtcCQ3KTtcbiAgICAgICAgICAgIHRoaXMuYSA9IHRoaXMuYTAgPSBtYXRoX2F0YW4yKHhmLnEucywgeGYucS5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3dlZXAucHJvdG90eXBlLnNldExvY2FsQ2VudGVyID0gZnVuY3Rpb24gKGxvY2FsQ2VudGVyLCB4Zikge1xuICAgICAgICAgICAgY29weVZlYzIodGhpcy5sb2NhbENlbnRlciwgbG9jYWxDZW50ZXIpO1xuICAgICAgICAgICAgdHJhbnNmb3JtVmVjMih0ZW1wJDcsIHhmLCB0aGlzLmxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMuYywgdGVtcCQ3KTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMuYzAsIHRlbXAkNyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGludGVycG9sYXRlZCB0cmFuc2Zvcm0gYXQgYSBzcGVjaWZpYyB0aW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geGZcbiAgICAgICAgICogQHBhcmFtIGJldGEgQSBmYWN0b3IgaW4gWzAsMV0sIHdoZXJlIDAgaW5kaWNhdGVzIGFscGhhMFxuICAgICAgICAgKi9cbiAgICAgICAgU3dlZXAucHJvdG90eXBlLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4ZiwgYmV0YSkge1xuICAgICAgICAgICAgaWYgKGJldGEgPT09IHZvaWQgMCkgeyBiZXRhID0gMDsgfVxuICAgICAgICAgICAgc2V0Um90QW5nbGUoeGYucSwgKDEuMCAtIGJldGEpICogdGhpcy5hMCArIGJldGEgKiB0aGlzLmEpO1xuICAgICAgICAgICAgY29tYmluZVZlYzIoeGYucCwgKDEuMCAtIGJldGEpLCB0aGlzLmMwLCBiZXRhLCB0aGlzLmMpO1xuICAgICAgICAgICAgLy8gc2hpZnQgdG8gb3JpZ2luXG4gICAgICAgICAgICBzdWJWZWMyKHhmLnAsIHJvdFZlYzIodGVtcCQ3LCB4Zi5xLCB0aGlzLmxvY2FsQ2VudGVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZHZhbmNlIHRoZSBzd2VlcCBmb3J3YXJkLCB5aWVsZGluZyBhIG5ldyBpbml0aWFsIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWxwaGEgVGhlIG5ldyBpbml0aWFsIHRpbWVcbiAgICAgICAgICovXG4gICAgICAgIFN3ZWVwLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgICAgICB2YXIgYmV0YSA9IChhbHBoYSAtIHRoaXMuYWxwaGEwKSAvICgxLjAgLSB0aGlzLmFscGhhMCk7XG4gICAgICAgICAgICBjb21iaW5lVmVjMih0aGlzLmMwLCBiZXRhLCB0aGlzLmMsIDEgLSBiZXRhLCB0aGlzLmMwKTtcbiAgICAgICAgICAgIHRoaXMuYTAgPSBiZXRhICogdGhpcy5hICsgKDEgLSBiZXRhKSAqIHRoaXMuYTA7XG4gICAgICAgICAgICB0aGlzLmFscGhhMCA9IGFscGhhO1xuICAgICAgICB9O1xuICAgICAgICBTd2VlcC5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYTAgPSB0aGlzLmE7XG4gICAgICAgICAgICBjb3B5VmVjMih0aGlzLmMwLCB0aGlzLmMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogbm9ybWFsaXplIHRoZSBhbmdsZXMgaW4gcmFkaWFucyB0byBiZSBiZXR3ZWVuIC1waSBhbmQgcGkuXG4gICAgICAgICAqL1xuICAgICAgICBTd2VlcC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGEwID0gbW9kKHRoaXMuYTAsIC1tYXRoX1BJJDUsICttYXRoX1BJJDUpO1xuICAgICAgICAgICAgdGhpcy5hIC09IHRoaXMuYTAgLSBhMDtcbiAgICAgICAgICAgIHRoaXMuYTAgPSBhMDtcbiAgICAgICAgfTtcbiAgICAgICAgU3dlZXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgICAgICBjb3B5VmVjMih0aGlzLmxvY2FsQ2VudGVyLCB0aGF0LmxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMuYywgdGhhdC5jKTtcbiAgICAgICAgICAgIHRoaXMuYSA9IHRoYXQuYTtcbiAgICAgICAgICAgIHRoaXMuYWxwaGEwID0gdGhhdC5hbHBoYTA7XG4gICAgICAgICAgICBjb3B5VmVjMih0aGlzLmMwLCB0aGF0LmMwKTtcbiAgICAgICAgICAgIHRoaXMuYTAgPSB0aGF0LmEwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3dlZXA7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIHRyYW5zZm9ybSBjb250YWlucyB0cmFuc2xhdGlvbiBhbmQgcm90YXRpb24uIEl0IGlzIHVzZWQgdG8gcmVwcmVzZW50IHRoZVxuICAgICAqIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiByaWdpZCBmcmFtZXMuIEluaXRpYWxpemUgdXNpbmcgYSBwb3NpdGlvbiB2ZWN0b3JcbiAgICAgKiBhbmQgYSByb3RhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgVHJhbnNmb3JtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm0ocG9zaXRpb24sIHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHBvc2l0aW9uLCByb3RhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnAgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMucSA9IFJvdC5pZGVudGl0eSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuc2V0VmVjMihwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvdGF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMucS5zZXRBbmdsZShyb3RhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVHJhbnNmb3JtLmNsb25lID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKTtcbiAgICAgICAgICAgIG9iai5wID0gVmVjMi5jbG9uZSh4Zi5wKTtcbiAgICAgICAgICAgIG9iai5xID0gUm90LmNsb25lKHhmLnEpO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBUcmFuc2Zvcm0ubmVvID0gZnVuY3Rpb24gKHBvc2l0aW9uLCByb3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmoucCA9IFZlYzIuY2xvbmUocG9zaXRpb24pO1xuICAgICAgICAgICAgb2JqLnEgPSBSb3QuY2xvbmUocm90YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNmb3JtLmlkZW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmoucCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgb2JqLnEgPSBSb3QuaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBTZXQgdGhpcyB0byB0aGUgaWRlbnRpdHkgdHJhbnNmb3JtICovXG4gICAgICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuc2V0SWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnAuc2V0WmVybygpO1xuICAgICAgICAgICAgdGhpcy5xLnNldElkZW50aXR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuc2V0KGEucCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xLnNldChhLnEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLnNldChhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnEuc2V0KGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogU2V0IHBvc2l0aW9uIGFuZCBhbmdsZSAqL1xuICAgICAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLnNldE51bSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgcm90YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucC5zZXRWZWMyKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucS5zZXRBbmdsZShyb3RhdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICAgICAgICB0aGlzLnAuc2V0VmVjMih4Zi5wKTtcbiAgICAgICAgICAgIHRoaXMucS5zZXRSb3QoeGYucSk7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybS5pc1ZhbGlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBWZWMyLmlzVmFsaWQob2JqLnApICYmIFJvdC5pc1ZhbGlkKG9iai5xKTtcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNmb3JtLmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHN0YXRpYyBtdWwoYTogVHJhbnNmb3JtLCBiOiBWZWMyVmFsdWVbXSk6IFZlYzJbXTtcbiAgICAgICAgLy8gc3RhdGljIG11bChhOiBUcmFuc2Zvcm0sIGI6IFRyYW5zZm9ybVtdKTogVHJhbnNmb3JtW107XG4gICAgICAgIFRyYW5zZm9ybS5tdWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycltpXSA9IFRyYW5zZm9ybS5tdWwoYSwgYltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgneCcgaW4gYiAmJiAneScgaW4gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm0ubXVsVmVjMihhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdwJyBpbiBiICYmICdxJyBpbiBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5tdWxYZihhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNmb3JtLm11bEFsbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBUcmFuc2Zvcm0ubXVsKGEsIGJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBUcmFuc2Zvcm0ubXVsRm4gPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5tdWwoYSwgYik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm0ubXVsVmVjMiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgeCA9IChhLnEuYyAqIGIueCAtIGEucS5zICogYi55KSArIGEucC54O1xuICAgICAgICAgICAgdmFyIHkgPSAoYS5xLnMgKiBiLnggKyBhLnEuYyAqIGIueSkgKyBhLnAueTtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh4LCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNmb3JtLm11bFhmID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIHYyID0gQS5xLlJvdChCLnEuUm90KHYxKSArIEIucCkgKyBBLnBcbiAgICAgICAgICAgIC8vID0gKEEucSAqIEIucSkuUm90KHYxKSArIEEucS5Sb3QoQi5wKSArIEEucFxuICAgICAgICAgICAgdmFyIHhmID0gVHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgICAgICAgICB4Zi5xID0gUm90Lm11bFJvdChhLnEsIGIucSk7XG4gICAgICAgICAgICB4Zi5wID0gVmVjMi5hZGQoUm90Lm11bFZlYzIoYS5xLCBiLnApLCBhLnApO1xuICAgICAgICAgICAgcmV0dXJuIHhmO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm0ubXVsVCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoJ3gnIGluIGIgJiYgJ3knIGluIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLm11bFRWZWMyKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3AnIGluIGIgJiYgJ3EnIGluIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLm11bFRYZihhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNmb3JtLm11bFRWZWMyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBweCA9IGIueCAtIGEucC54O1xuICAgICAgICAgICAgdmFyIHB5ID0gYi55IC0gYS5wLnk7XG4gICAgICAgICAgICB2YXIgeCA9IChhLnEuYyAqIHB4ICsgYS5xLnMgKiBweSk7XG4gICAgICAgICAgICB2YXIgeSA9ICgtYS5xLnMgKiBweCArIGEucS5jICogcHkpO1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm0ubXVsVFhmID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIHYyID0gQS5xJyAqIChCLnEgKiB2MSArIEIucCAtIEEucClcbiAgICAgICAgICAgIC8vID0gQS5xJyAqIEIucSAqIHYxICsgQS5xJyAqIChCLnAgLSBBLnApXG4gICAgICAgICAgICB2YXIgeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHhmLnEuc2V0Um90KFJvdC5tdWxUUm90KGEucSwgYi5xKSk7XG4gICAgICAgICAgICB4Zi5wLnNldFZlYzIoUm90Lm11bFRWZWMyKGEucSwgVmVjMi5zdWIoYi5wLCBhLnApKSk7XG4gICAgICAgICAgICByZXR1cm4geGY7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm07XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICB2YXIgVmVsb2NpdHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZlbG9jaXR5KCkge1xuICAgICAgICAgICAgLyoqIGxpbmVhciAqL1xuICAgICAgICAgICAgdGhpcy52ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAvKiogYW5ndWxhciAqL1xuICAgICAgICAgICAgdGhpcy53ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmVsb2NpdHk7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX3NpbiA9IE1hdGguc2luO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfY29zID0gTWF0aC5jb3M7XG4gICAgdmFyIFBvc2l0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgICAgICAgICAgIC8qKiBsb2NhdGlvbiAqL1xuICAgICAgICAgICAgdGhpcy5jID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAvKiogYW5nbGUgKi9cbiAgICAgICAgICAgIHRoaXMuYSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbzogY2FjaGUgc2luL2Nvc1xuICAgICAgICBQb3NpdGlvbi5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHhmLCBwKSB7XG4gICAgICAgICAgICAvLyB4Zi5xID0gcm90YXRpb24odGhpcy5hKTtcbiAgICAgICAgICAgIC8vIHhmLnAgPSB0aGlzLmMgLSB4Zi5xICogcFxuICAgICAgICAgICAgeGYucS5jID0gbWF0aF9jb3ModGhpcy5hKTtcbiAgICAgICAgICAgIHhmLnEucyA9IG1hdGhfc2luKHRoaXMuYSk7XG4gICAgICAgICAgICB4Zi5wLnggPSB0aGlzLmMueCAtICh4Zi5xLmMgKiBwLnggLSB4Zi5xLnMgKiBwLnkpO1xuICAgICAgICAgICAgeGYucC55ID0gdGhpcy5jLnkgLSAoeGYucS5zICogcC54ICsgeGYucS5jICogcC55KTtcbiAgICAgICAgICAgIHJldHVybiB4ZjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHhmLCBwLCBjLCBhKSB7XG4gICAgICAgIC8vIHhmLnEgPSByb3RhdGlvbihhKTtcbiAgICAgICAgLy8geGYucCA9IHRoaXMuYyAtIHhmLnEgKiBwXG4gICAgICAgIHhmLnEuYyA9IG1hdGhfY29zKGEpO1xuICAgICAgICB4Zi5xLnMgPSBtYXRoX3NpbihhKTtcbiAgICAgICAgeGYucC54ID0gYy54IC0gKHhmLnEuYyAqIHAueCAtIHhmLnEucyAqIHAueSk7XG4gICAgICAgIHhmLnAueSA9IGMueSAtICh4Zi5xLnMgKiBwLnggKyB4Zi5xLmMgKiBwLnkpO1xuICAgICAgICByZXR1cm4geGY7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8vIHRvZG8gbWFrZSBzaGFwZSBhbiBpbnRlcmZhY2VcbiAgICAvKipcbiAgICAgKiBBIHNoYXBlIGlzIHVzZWQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24uIFlvdSBjYW4gY3JlYXRlIGEgc2hhcGUgaG93ZXZlciB5b3VcbiAgICAgKiBsaWtlLiBTaGFwZXMgdXNlZCBmb3Igc2ltdWxhdGlvbiBpbiBXb3JsZCBhcmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYVxuICAgICAqIEZpeHR1cmUgaXMgY3JlYXRlZC4gU2hhcGVzIG1heSBlbmNhcHN1bGF0ZSBvbmUgb3IgbW9yZSBjaGlsZCBzaGFwZXMuXG4gICAgICovXG4gICAgdmFyIFNoYXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBTaGFwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqLm1fdHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIG9iai5tX3JhZGl1cyA9PT0gJ251bWJlcic7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTaGFwZTtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHN5bmNocm9uaXplX2FhYmIxID0gbmV3IEFBQkIoKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBzeW5jaHJvbml6ZV9hYWJiMiA9IG5ldyBBQUJCKCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZGlzcGxhY2VtZW50ID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBGaXh0dXJlRGVmRGVmYXVsdCA9IHtcbiAgICAgICAgdXNlckRhdGE6IG51bGwsXG4gICAgICAgIGZyaWN0aW9uOiAwLjIsXG4gICAgICAgIHJlc3RpdHV0aW9uOiAwLjAsXG4gICAgICAgIGRlbnNpdHk6IDAuMCxcbiAgICAgICAgaXNTZW5zb3I6IGZhbHNlLFxuICAgICAgICBmaWx0ZXJHcm91cEluZGV4OiAwLFxuICAgICAgICBmaWx0ZXJDYXRlZ29yeUJpdHM6IDB4MDAwMSxcbiAgICAgICAgZmlsdGVyTWFza0JpdHM6IDB4RkZGRlxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBwcm94eSBpcyB1c2VkIGludGVybmFsbHkgdG8gY29ubmVjdCBzaGFwZSBjaGlsZHJlbiB0byB0aGUgYnJvYWQtcGhhc2UuXG4gICAgICovXG4gICAgdmFyIEZpeHR1cmVQcm94eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRml4dHVyZVByb3h5KGZpeHR1cmUsIGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICB0aGlzLmZpeHR1cmUgPSBmaXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5jaGlsZEluZGV4ID0gY2hpbGRJbmRleDtcbiAgICAgICAgICAgIHRoaXMucHJveHlJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRml4dHVyZVByb3h5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQSBmaXh0dXJlIGlzIHVzZWQgdG8gYXR0YWNoIGEgc2hhcGUgdG8gYSBib2R5IGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLiBBXG4gICAgICogZml4dHVyZSBpbmhlcml0cyBpdHMgdHJhbnNmb3JtIGZyb20gaXRzIHBhcmVudC4gRml4dHVyZXMgaG9sZCBhZGRpdGlvbmFsXG4gICAgICogbm9uLWdlb21ldHJpYyBkYXRhIHN1Y2ggYXMgZnJpY3Rpb24sIGNvbGxpc2lvbiBmaWx0ZXJzLCBldGMuXG4gICAgICpcbiAgICAgKiBUbyBjcmVhdGUgYSBuZXcgRml4dHVyZSB1c2Uge0BsaW5rIEJvZHkuY3JlYXRlRml4dHVyZX0uXG4gICAgICovXG4gICAgdmFyIEZpeHR1cmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgZnVuY3Rpb24gRml4dHVyZShib2R5LCBzaGFwZSwgZGVmKSB7XG4gICAgICAgICAgICBpZiAoc2hhcGUuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBkZWYgPSBzaGFwZTtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHNoYXBlLnNoYXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBkZWYgPSB7IGRlbnNpdHk6IGRlZiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmID0gb3B0aW9ucyhkZWYsIEZpeHR1cmVEZWZEZWZhdWx0KTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMubV9mcmljdGlvbiA9IGRlZi5mcmljdGlvbjtcbiAgICAgICAgICAgIHRoaXMubV9yZXN0aXR1dGlvbiA9IGRlZi5yZXN0aXR1dGlvbjtcbiAgICAgICAgICAgIHRoaXMubV9kZW5zaXR5ID0gZGVmLmRlbnNpdHk7XG4gICAgICAgICAgICB0aGlzLm1faXNTZW5zb3IgPSBkZWYuaXNTZW5zb3I7XG4gICAgICAgICAgICB0aGlzLm1fZmlsdGVyR3JvdXBJbmRleCA9IGRlZi5maWx0ZXJHcm91cEluZGV4O1xuICAgICAgICAgICAgdGhpcy5tX2ZpbHRlckNhdGVnb3J5Qml0cyA9IGRlZi5maWx0ZXJDYXRlZ29yeUJpdHM7XG4gICAgICAgICAgICB0aGlzLm1fZmlsdGVyTWFza0JpdHMgPSBkZWYuZmlsdGVyTWFza0JpdHM7XG4gICAgICAgICAgICAvLyBUT0RPIHZhbGlkYXRlIHNoYXBlXG4gICAgICAgICAgICB0aGlzLm1fc2hhcGUgPSBzaGFwZTsgLy8gLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fcHJveGllcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tX3Byb3h5Q291bnQgPSAwO1xuICAgICAgICAgICAgLy8gZml4dHVyZSBwcm94aWVzIGFyZSBjcmVhdGVkIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSBhcmUgYWN0aXZhdGUgaW4gd2hlbiBhIGZpeHR1cmUgaXMgYWRkZWQgdG8gYm9keVxuICAgICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSB0aGlzLm1fc2hhcGUuZ2V0Q2hpbGRDb3VudCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcHJveGllc1tpXSA9IG5ldyBGaXh0dXJlUHJveHkodGhpcywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fdXNlckRhdGEgPSBkZWYudXNlckRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCBSZS1zZXR1cCBmaXh0dXJlLiAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSBib2R5Lm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UHJveGllcyhicm9hZFBoYXNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fc2hhcGUuX3Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NoYXBlLl9yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSB0aGlzLm1fc2hhcGUuZ2V0Q2hpbGRDb3VudCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcHJveGllc1tpXSA9IG5ldyBGaXh0dXJlUHJveHkodGhpcywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVByb3hpZXMoYnJvYWRQaGFzZSwgYm9keS5tX3hmKTtcbiAgICAgICAgICAgIGJvZHkucmVzZXRNYXNzRGF0YSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyaWN0aW9uOiB0aGlzLm1fZnJpY3Rpb24sXG4gICAgICAgICAgICAgICAgcmVzdGl0dXRpb246IHRoaXMubV9yZXN0aXR1dGlvbixcbiAgICAgICAgICAgICAgICBkZW5zaXR5OiB0aGlzLm1fZGVuc2l0eSxcbiAgICAgICAgICAgICAgICBpc1NlbnNvcjogdGhpcy5tX2lzU2Vuc29yLFxuICAgICAgICAgICAgICAgIGZpbHRlckdyb3VwSW5kZXg6IHRoaXMubV9maWx0ZXJHcm91cEluZGV4LFxuICAgICAgICAgICAgICAgIGZpbHRlckNhdGVnb3J5Qml0czogdGhpcy5tX2ZpbHRlckNhdGVnb3J5Qml0cyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJNYXNrQml0czogdGhpcy5tX2ZpbHRlck1hc2tCaXRzLFxuICAgICAgICAgICAgICAgIHNoYXBlOiB0aGlzLm1fc2hhcGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZpeHR1cmUuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIGJvZHksIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHJlc3RvcmUoU2hhcGUsIGRhdGEuc2hhcGUpO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmUgPSBzaGFwZSAmJiBuZXcgRml4dHVyZShib2R5LCBzaGFwZSwgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZml4dHVyZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGUgY2hpbGQgc2hhcGUuIFlvdSBjYW4gdXNlIHRoaXMgdG8gZG93biBjYXN0IHRvIHRoZVxuICAgICAgICAgKiBjb25jcmV0ZSBzaGFwZS5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLm1fdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2hpbGQgc2hhcGUuIFlvdSBjYW4gbW9kaWZ5IHRoZSBjaGlsZCBzaGFwZSwgaG93ZXZlciB5b3Ugc2hvdWxkIG5vdFxuICAgICAgICAgKiBjaGFuZ2UgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBiZWNhdXNlIHRoaXMgd2lsbCBjcmFzaCBzb21lIGNvbGxpc2lvbiBjYWNoaW5nXG4gICAgICAgICAqIG1lY2hhbmlzbXMuIE1hbmlwdWxhdGluZyB0aGUgc2hhcGUgbWF5IGxlYWQgdG8gbm9uLXBoeXNpY2FsIGJlaGF2aW9yLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3NoYXBlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZW5zb3Igc2hhcGUgY29sbGVjdHMgY29udGFjdCBpbmZvcm1hdGlvbiBidXQgbmV2ZXIgZ2VuZXJhdGVzIGEgY29sbGlzaW9uXG4gICAgICAgICAqIHJlc3BvbnNlLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuaXNTZW5zb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2lzU2Vuc29yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGlmIHRoaXMgZml4dHVyZSBpcyBhIHNlbnNvci5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLnNldFNlbnNvciA9IGZ1bmN0aW9uIChzZW5zb3IpIHtcbiAgICAgICAgICAgIGlmIChzZW5zb3IgIT0gdGhpcy5tX2lzU2Vuc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHkuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2lzU2Vuc29yID0gc2Vuc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyAvKipcbiAgICAgICAgLy8gICogR2V0IHRoZSBjb250YWN0IGZpbHRlcmluZyBkYXRhLlxuICAgICAgICAvLyAgKi9cbiAgICAgICAgLy8gZ2V0RmlsdGVyRGF0YSgpIHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5tX2ZpbHRlcjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB1c2VyIGRhdGEgdGhhdCB3YXMgYXNzaWduZWQgaW4gdGhlIGZpeHR1cmUgZGVmaW5pdGlvbi4gVXNlIHRoaXMgdG9cbiAgICAgICAgICogc3RvcmUgeW91ciBhcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0VXNlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3VzZXJEYXRhO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB1c2VyIGRhdGEuIFVzZSB0aGlzIHRvIHN0b3JlIHlvdXIgYXBwbGljYXRpb24gc3BlY2lmaWMgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLnNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHBhcmVudCBib2R5IG9mIHRoaXMgZml4dHVyZS4gVGhpcyBpcyBudWxsIGlmIHRoZSBmaXh0dXJlIGlzIG5vdFxuICAgICAgICAgKiBhdHRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5leHQgZml4dHVyZSBpbiB0aGUgcGFyZW50IGJvZHkncyBmaXh0dXJlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9uZXh0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBkZW5zaXR5IG9mIHRoaXMgZml4dHVyZS5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldERlbnNpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2RlbnNpdHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRlbnNpdHkgb2YgdGhpcyBmaXh0dXJlLiBUaGlzIHdpbGwgX25vdF8gYXV0b21hdGljYWxseSBhZGp1c3QgdGhlXG4gICAgICAgICAqIG1hc3Mgb2YgdGhlIGJvZHkuIFlvdSBtdXN0IGNhbGwgQm9keS5yZXNldE1hc3NEYXRhIHRvIHVwZGF0ZSB0aGUgYm9keSdzIG1hc3MuXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5zZXREZW5zaXR5ID0gZnVuY3Rpb24gKGRlbnNpdHkpIHtcbiAgICAgICAgICAgIHRoaXMubV9kZW5zaXR5ID0gZGVuc2l0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24sIHVzdWFsbHkgaW4gdGhlIHJhbmdlIFswLDFdLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2ZyaWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbi4gVGhpcyB3aWxsIG5vdCBjaGFuZ2UgdGhlIGZyaWN0aW9uIG9mXG4gICAgICAgICAqIGV4aXN0aW5nIGNvbnRhY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuc2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubV9mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9yZXN0aXR1dGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY29lZmZpY2llbnQgb2YgcmVzdGl0dXRpb24uIFRoaXMgd2lsbCBub3QgY2hhbmdlIHRoZSByZXN0aXR1dGlvbiBvZlxuICAgICAgICAgKiBleGlzdGluZyBjb250YWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLnNldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24gKHJlc3RpdHV0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSByZXN0aXR1dGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3QgYSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcyBmb3IgY29udGFpbm1lbnQgaW4gdGhpcyBmaXh0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUudGVzdFBvaW50ID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fc2hhcGUudGVzdFBvaW50KHRoaXMubV9ib2R5LmdldFRyYW5zZm9ybSgpLCBwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhc3QgYSByYXkgYWdhaW5zdCB0aGlzIHNoYXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLnJheUNhc3Qob3V0cHV0LCBpbnB1dCwgdGhpcy5tX2JvZHkuZ2V0VHJhbnNmb3JtKCksIGNoaWxkSW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXNzIGRhdGEgZm9yIHRoaXMgZml4dHVyZS4gVGhlIG1hc3MgZGF0YSBpcyBiYXNlZCBvbiB0aGUgZGVuc2l0eSBhbmRcbiAgICAgICAgICogdGhlIHNoYXBlLiBUaGUgcm90YXRpb25hbCBpbmVydGlhIGlzIGFib3V0IHRoZSBzaGFwZSdzIG9yaWdpbi4gVGhpcyBvcGVyYXRpb25cbiAgICAgICAgICogbWF5IGJlIGV4cGVuc2l2ZS5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldE1hc3NEYXRhID0gZnVuY3Rpb24gKG1hc3NEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm1fc2hhcGUuY29tcHV0ZU1hc3MobWFzc0RhdGEsIHRoaXMubV9kZW5zaXR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZml4dHVyZSdzIEFBQkIuIFRoaXMgQUFCQiBtYXkgYmUgZW5sYXJnZSBhbmQvb3Igc3RhbGUuIElmIHlvdSBuZWVkIGFcbiAgICAgICAgICogbW9yZSBhY2N1cmF0ZSBBQUJCLCBjb21wdXRlIGl0IHVzaW5nIHRoZSBzaGFwZSBhbmQgdGhlIGJvZHkgdHJhbnNmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uIChjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3Byb3hpZXNbY2hpbGRJbmRleF0uYWFiYjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZXNlIHN1cHBvcnQgYm9keSBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmNyZWF0ZVByb3hpZXMgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSwgeGYpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm94aWVzIGluIHRoZSBicm9hZC1waGFzZS5cbiAgICAgICAgICAgIHRoaXMubV9wcm94eUNvdW50ID0gdGhpcy5tX3NoYXBlLmdldENoaWxkQ291bnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3Byb3h5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMubV9wcm94aWVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zaGFwZS5jb21wdXRlQUFCQihwcm94eS5hYWJiLCB4ZiwgaSk7XG4gICAgICAgICAgICAgICAgcHJveHkucHJveHlJZCA9IGJyb2FkUGhhc2UuY3JlYXRlUHJveHkocHJveHkuYWFiYiwgcHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5kZXN0cm95UHJveGllcyA9IGZ1bmN0aW9uIChicm9hZFBoYXNlKSB7XG4gICAgICAgICAgICAvLyBEZXN0cm95IHByb3hpZXMgaW4gdGhlIGJyb2FkLXBoYXNlLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fcHJveHlDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5tX3Byb3hpZXNbaV07XG4gICAgICAgICAgICAgICAgYnJvYWRQaGFzZS5kZXN0cm95UHJveHkocHJveHkucHJveHlJZCk7XG4gICAgICAgICAgICAgICAgcHJveHkucHJveHlJZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlDb3VudCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoaXMgZml4dHVyZSBwcm94eSBpbiBicm9hZC1waGFzZSAod2l0aCBjb21iaW5lZCBBQUJCIG9mIGN1cnJlbnQgYW5kXG4gICAgICAgICAqIG5leHQgdHJhbnNmb3JtYXRpb24pLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuc3luY2hyb25pemUgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSwgeGYxLCB4ZjIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3Byb3h5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMubV9wcm94aWVzW2ldO1xuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYW4gQUFCQiB0aGF0IGNvdmVycyB0aGUgc3dlcHQgc2hhcGUgKG1heSBtaXNzIHNvbWUgcm90YXRpb25cbiAgICAgICAgICAgICAgICAvLyBlZmZlY3QpLlxuICAgICAgICAgICAgICAgIHRoaXMubV9zaGFwZS5jb21wdXRlQUFCQihzeW5jaHJvbml6ZV9hYWJiMSwgeGYxLCBwcm94eS5jaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc2hhcGUuY29tcHV0ZUFBQkIoc3luY2hyb25pemVfYWFiYjIsIHhmMiwgcHJveHkuY2hpbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgcHJveHkuYWFiYi5jb21iaW5lKHN5bmNocm9uaXplX2FhYmIxLCBzeW5jaHJvbml6ZV9hYWJiMik7XG4gICAgICAgICAgICAgICAgZGlmZlZlYzIoZGlzcGxhY2VtZW50LCB4ZjIucCwgeGYxLnApO1xuICAgICAgICAgICAgICAgIGJyb2FkUGhhc2UubW92ZVByb3h5KHByb3h5LnByb3h5SWQsIHByb3h5LmFhYmIsIGRpc3BsYWNlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNvbnRhY3QgZmlsdGVyaW5nIGRhdGEuIFRoaXMgd2lsbCBub3QgdXBkYXRlIGNvbnRhY3RzIHVudGlsIHRoZSBuZXh0XG4gICAgICAgICAqIHRpbWUgc3RlcCB3aGVuIGVpdGhlciBwYXJlbnQgYm9keSBpcyBhY3RpdmUgYW5kIGF3YWtlLiBUaGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICogY2FsbHMgcmVmaWx0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5zZXRGaWx0ZXJEYXRhID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5tX2ZpbHRlckdyb3VwSW5kZXggPSBmaWx0ZXIuZ3JvdXBJbmRleDtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHMgPSBmaWx0ZXIuY2F0ZWdvcnlCaXRzO1xuICAgICAgICAgICAgdGhpcy5tX2ZpbHRlck1hc2tCaXRzID0gZmlsdGVyLm1hc2tCaXRzO1xuICAgICAgICAgICAgdGhpcy5yZWZpbHRlcigpO1xuICAgICAgICB9O1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5nZXRGaWx0ZXJHcm91cEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maWx0ZXJHcm91cEluZGV4O1xuICAgICAgICB9O1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5zZXRGaWx0ZXJHcm91cEluZGV4ID0gZnVuY3Rpb24gKGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJHcm91cEluZGV4ID0gZ3JvdXBJbmRleDtcbiAgICAgICAgICAgIHRoaXMucmVmaWx0ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuZ2V0RmlsdGVyQ2F0ZWdvcnlCaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHM7XG4gICAgICAgIH07XG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLnNldEZpbHRlckNhdGVnb3J5Qml0cyA9IGZ1bmN0aW9uIChjYXRlZ29yeUJpdHMpIHtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHMgPSBjYXRlZ29yeUJpdHM7XG4gICAgICAgICAgICB0aGlzLnJlZmlsdGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIEZpeHR1cmUucHJvdG90eXBlLmdldEZpbHRlck1hc2tCaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maWx0ZXJNYXNrQml0cztcbiAgICAgICAgfTtcbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUuc2V0RmlsdGVyTWFza0JpdHMgPSBmdW5jdGlvbiAobWFza0JpdHMpIHtcbiAgICAgICAgICAgIHRoaXMubV9maWx0ZXJNYXNrQml0cyA9IG1hc2tCaXRzO1xuICAgICAgICAgICAgdGhpcy5yZWZpbHRlcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbCB0aGlzIGlmIHlvdSB3YW50IHRvIGVzdGFibGlzaCBjb2xsaXNpb24gdGhhdCB3YXMgcHJldmlvdXNseSBkaXNhYmxlZCBieVxuICAgICAgICAgKiBDb250YWN0RmlsdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgRml4dHVyZS5wcm90b3R5cGUucmVmaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZsYWcgYXNzb2NpYXRlZCBjb250YWN0cyBmb3IgZmlsdGVyaW5nLlxuICAgICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLm1fYm9keS5nZXRDb250YWN0TGlzdCgpO1xuICAgICAgICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGVkZ2UuY29udGFjdDtcbiAgICAgICAgICAgICAgICB2YXIgZml4dHVyZUEgPSBjb250YWN0LmdldEZpeHR1cmVBKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gY29udGFjdC5nZXRGaXh0dXJlQigpO1xuICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlQSA9PSB0aGlzIHx8IGZpeHR1cmVCID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5mbGFnRm9yRmlsdGVyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd29ybGQgPSB0aGlzLm1fYm9keS5nZXRXb3JsZCgpO1xuICAgICAgICAgICAgaWYgKHdvcmxkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb3VjaCBlYWNoIHByb3h5IHNvIHRoYXQgbmV3IHBhaXJzIG1heSBiZSBjcmVhdGVkXG4gICAgICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHdvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3Byb3h5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGJyb2FkUGhhc2UudG91Y2hQcm94eSh0aGlzLm1fcHJveGllc1tpXS5wcm94eUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGNvbGxpc2lvbiBmaWx0ZXJpbmcsIGlmIHlvdSB3YW50IGZpbmVyXG4gICAgICAgICAqIGNvbnRyb2wgb3ZlciBjb250YWN0IGNyZWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBjb250YWN0IGNhbGN1bGF0aW9ucyBzaG91bGQgYmUgcGVyZm9ybWVkIGJldHdlZW4gdGhlc2UgdHdvXG4gICAgICAgICAqIGZpeHR1cmVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXYXJuaW5nOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyB0aGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIEFBQkJzIGJlZ2luIHRvXG4gICAgICAgICAqIG92ZXJsYXAuXG4gICAgICAgICAqL1xuICAgICAgICBGaXh0dXJlLnByb3RvdHlwZS5zaG91bGRDb2xsaWRlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgICAgIGlmICh0aGF0Lm1fZmlsdGVyR3JvdXBJbmRleCA9PT0gdGhpcy5tX2ZpbHRlckdyb3VwSW5kZXggJiYgdGhhdC5tX2ZpbHRlckdyb3VwSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5tX2ZpbHRlckdyb3VwSW5kZXggPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbGxpZGVBID0gKHRoYXQubV9maWx0ZXJNYXNrQml0cyAmIHRoaXMubV9maWx0ZXJDYXRlZ29yeUJpdHMpICE9PSAwO1xuICAgICAgICAgICAgdmFyIGNvbGxpZGVCID0gKHRoYXQubV9maWx0ZXJDYXRlZ29yeUJpdHMgJiB0aGlzLm1fZmlsdGVyTWFza0JpdHMpICE9PSAwO1xuICAgICAgICAgICAgdmFyIGNvbGxpZGUgPSBjb2xsaWRlQSAmJiBjb2xsaWRlQjtcbiAgICAgICAgICAgIHJldHVybiBjb2xsaWRlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRml4dHVyZTtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIFNUQVRJQyA9ICdzdGF0aWMnO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIEtJTkVNQVRJQyA9ICdraW5lbWF0aWMnO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIERZTkFNSUMgPSAnZHluYW1pYyc7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgb2xkQ2VudGVyID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBsb2NhbENlbnRlciA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgc2hpZnQgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHRlbXAkNiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgeGYkMiA9IHRyYW5zZm9ybSgwLCAwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBCb2R5RGVmRGVmYXVsdCA9IHtcbiAgICAgICAgdHlwZTogU1RBVElDLFxuICAgICAgICBwb3NpdGlvbjogVmVjMi56ZXJvKCksXG4gICAgICAgIGFuZ2xlOiAwLjAsXG4gICAgICAgIGxpbmVhclZlbG9jaXR5OiBWZWMyLnplcm8oKSxcbiAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAwLjAsXG4gICAgICAgIGxpbmVhckRhbXBpbmc6IDAuMCxcbiAgICAgICAgYW5ndWxhckRhbXBpbmc6IDAuMCxcbiAgICAgICAgZml4ZWRSb3RhdGlvbjogZmFsc2UsXG4gICAgICAgIGJ1bGxldDogZmFsc2UsXG4gICAgICAgIGdyYXZpdHlTY2FsZTogMS4wLFxuICAgICAgICBhbGxvd1NsZWVwOiB0cnVlLFxuICAgICAgICBhd2FrZTogdHJ1ZSxcbiAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICB1c2VyRGF0YTogbnVsbFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSByaWdpZCBib2R5IGNvbXBvc2VkIG9mIG9uZSBvciBtb3JlIGZpeHR1cmVzLlxuICAgICAqXG4gICAgICogVG8gY3JlYXRlIGEgbmV3IEJvZHkgdXNlIHtAbGluayBXb3JsZC5jcmVhdGVCb2R5fS5cbiAgICAgKi9cbiAgICB2YXIgQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBmdW5jdGlvbiBCb2R5KHdvcmxkLCBkZWYpIHtcbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBCb2R5RGVmRGVmYXVsdCk7XG4gICAgICAgICAgICB0aGlzLm1fd29ybGQgPSB3b3JsZDtcbiAgICAgICAgICAgIHRoaXMubV9hd2FrZUZsYWcgPSBkZWYuYXdha2U7XG4gICAgICAgICAgICB0aGlzLm1fYXV0b1NsZWVwRmxhZyA9IGRlZi5hbGxvd1NsZWVwO1xuICAgICAgICAgICAgdGhpcy5tX2J1bGxldEZsYWcgPSBkZWYuYnVsbGV0O1xuICAgICAgICAgICAgdGhpcy5tX2ZpeGVkUm90YXRpb25GbGFnID0gZGVmLmZpeGVkUm90YXRpb247XG4gICAgICAgICAgICB0aGlzLm1fYWN0aXZlRmxhZyA9IGRlZi5hY3RpdmU7XG4gICAgICAgICAgICB0aGlzLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX3RvaUZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRlZi51c2VyRGF0YTtcbiAgICAgICAgICAgIHRoaXMubV90eXBlID0gZGVmLnR5cGU7XG4gICAgICAgICAgICBpZiAodGhpcy5tX3R5cGUgPT0gRFlOQU1JQykge1xuICAgICAgICAgICAgICAgIHRoaXMubV9tYXNzID0gMS4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSb3RhdGlvbmFsIGluZXJ0aWEgYWJvdXQgdGhlIGNlbnRlciBvZiBtYXNzLlxuICAgICAgICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1faW52SSA9IDAuMDtcbiAgICAgICAgICAgIC8vIHRoZSBib2R5IG9yaWdpbiB0cmFuc2Zvcm1cbiAgICAgICAgICAgIHRoaXMubV94ZiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5tX3hmLnAuc2V0VmVjMihkZWYucG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5tX3hmLnEuc2V0QW5nbGUoZGVmLmFuZ2xlKTtcbiAgICAgICAgICAgIC8vIHRoZSBzd2VwdCBtb3Rpb24gZm9yIENDRFxuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwID0gbmV3IFN3ZWVwKCk7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXAuc2V0VHJhbnNmb3JtKHRoaXMubV94Zik7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgY29ycmVjdGlvblxuICAgICAgICAgICAgdGhpcy5jX3ZlbG9jaXR5ID0gbmV3IFZlbG9jaXR5KCk7XG4gICAgICAgICAgICB0aGlzLmNfcG9zaXRpb24gPSBuZXcgUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubV9mb3JjZSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdGhpcy5tX3RvcnF1ZSA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eSA9IFZlYzIuY2xvbmUoZGVmLmxpbmVhclZlbG9jaXR5KTtcbiAgICAgICAgICAgIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgPSBkZWYuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgdGhpcy5tX2xpbmVhckRhbXBpbmcgPSBkZWYubGluZWFyRGFtcGluZztcbiAgICAgICAgICAgIHRoaXMubV9hbmd1bGFyRGFtcGluZyA9IGRlZi5hbmd1bGFyRGFtcGluZztcbiAgICAgICAgICAgIHRoaXMubV9ncmF2aXR5U2NhbGUgPSBkZWYuZ3Jhdml0eVNjYWxlO1xuICAgICAgICAgICAgdGhpcy5tX3NsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMubV9qb2ludExpc3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9maXh0dXJlTGlzdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fcHJldiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBmID0gdGhpcy5tX2ZpeHR1cmVMaXN0OyBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgICAgICAgICBmaXh0dXJlcy5wdXNoKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICBidWxsZXQ6IHRoaXMubV9idWxsZXRGbGFnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLm1feGYucCxcbiAgICAgICAgICAgICAgICBhbmdsZTogdGhpcy5tX3hmLnEuZ2V0QW5nbGUoKSxcbiAgICAgICAgICAgICAgICBsaW5lYXJWZWxvY2l0eTogdGhpcy5tX2xpbmVhclZlbG9jaXR5LFxuICAgICAgICAgICAgICAgIGFuZ3VsYXJWZWxvY2l0eTogdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgICAgICAgICBmaXh0dXJlczogZml4dHVyZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEJvZHkuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIHdvcmxkLCByZXN0b3JlKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHdvcmxkLCBkYXRhKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmZpeHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEuZml4dHVyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpeHR1cmUgPSByZXN0b3JlKEZpeHR1cmUsIGRhdGEuZml4dHVyZXNbaV0sIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBib2R5Ll9hZGRGaXh0dXJlKGZpeHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5pc1dvcmxkTG9ja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV93b3JsZCAmJiB0aGlzLm1fd29ybGQuaXNMb2NrZWQoKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0V29ybGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3dvcmxkO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9uZXh0O1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRVc2VyRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm1fdXNlckRhdGEgPSBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldEZpeHR1cmVMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maXh0dXJlTGlzdDtcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0Sm9pbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9qb2ludExpc3Q7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYXJuaW5nOiB0aGlzIGxpc3QgY2hhbmdlcyBkdXJpbmcgdGhlIHRpbWUgc3RlcCBhbmQgeW91IG1heSBtaXNzIHNvbWVcbiAgICAgICAgICogY29sbGlzaW9ucyBpZiB5b3UgZG9uJ3QgdXNlIENvbnRhY3RMaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldENvbnRhY3RMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuaXNTdGF0aWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3R5cGUgPT0gU1RBVElDO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5pc0R5bmFtaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3R5cGUgPT0gRFlOQU1JQztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuaXNLaW5lbWF0aWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3R5cGUgPT0gS0lORU1BVElDO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB3aWxsIGFsdGVyIHRoZSBtYXNzIGFuZCB2ZWxvY2l0eS5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldFN0YXRpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VHlwZShTVEFUSUMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldER5bmFtaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldFR5cGUoRFlOQU1JQyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0S2luZW1hdGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRUeXBlKEtJTkVNQVRJQyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGUgYm9keS5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHR5cGUgb2YgdGhlIGJvZHkgdG8gXCJzdGF0aWNcIiwgXCJraW5lbWF0aWNcIiBvciBcImR5bmFtaWNcIi5cbiAgICAgICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIGJvZHkuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzV29ybGRMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlID09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fdHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0aGlzLnJlc2V0TWFzc0RhdGEoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSA9PSBTVEFUSUMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLmZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNocm9uaXplRml4dHVyZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fZm9yY2Uuc2V0WmVybygpO1xuICAgICAgICAgICAgdGhpcy5tX3RvcnF1ZSA9IDAuMDtcbiAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgYXR0YWNoZWQgY29udGFjdHMuXG4gICAgICAgICAgICB2YXIgY2UgPSB0aGlzLm1fY29udGFjdExpc3Q7XG4gICAgICAgICAgICB3aGlsZSAoY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2UwID0gY2U7XG4gICAgICAgICAgICAgICAgY2UgPSBjZS5uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMubV93b3JsZC5kZXN0cm95Q29udGFjdChjZTAuY29udGFjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fY29udGFjdExpc3QgPSBudWxsO1xuICAgICAgICAgICAgLy8gVG91Y2ggdGhlIHByb3hpZXMgc28gdGhhdCBuZXcgY29udGFjdHMgd2lsbCBiZSBjcmVhdGVkICh3aGVuIGFwcHJvcHJpYXRlKVxuICAgICAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgICAgICAgICAgZm9yICh2YXIgZiA9IHRoaXMubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmLm1fcHJveHlDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyb2FkUGhhc2UudG91Y2hQcm94eShmLm1fcHJveGllc1tpXS5wcm94eUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmlzQnVsbGV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9idWxsZXRGbGFnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoaXMgYm9keSBiZSB0cmVhdGVkIGxpa2UgYSBidWxsZXQgZm9yIGNvbnRpbnVvdXMgY29sbGlzaW9uIGRldGVjdGlvbj9cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldEJ1bGxldCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1fYnVsbGV0RmxhZyA9ICEhZmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuaXNTbGVlcGluZ0FsbG93ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2F1dG9TbGVlcEZsYWc7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldFNsZWVwaW5nQWxsb3dlZCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICB0aGlzLm1fYXV0b1NsZWVwRmxhZyA9ICEhZmxhZztcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYXV0b1NsZWVwRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmlzQXdha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2F3YWtlRmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgc2xlZXAgc3RhdGUgb2YgdGhlIGJvZHkuIEEgc2xlZXBpbmcgYm9keSBoYXMgdmVyeSBsb3cgQ1BVIGNvc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBmbGFnIFNldCB0byB0cnVlIHRvIHdha2UgdGhlIGJvZHksIGZhbHNlIHRvIHB1dCBpdCB0byBzbGVlcC5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldEF3YWtlID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2F3YWtlRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9hd2FrZUZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc2xlZXBUaW1lID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZm9yY2Uuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV90b3JxdWUgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9hY3RpdmVGbGFnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGJvZHkuIEFuIGluYWN0aXZlIGJvZHkgaXMgbm90IHNpbXVsYXRlZCBhbmRcbiAgICAgICAgICogY2Fubm90IGJlIGNvbGxpZGVkIHdpdGggb3Igd29rZW4gdXAuIElmIHlvdSBwYXNzIGEgZmxhZyBvZiB0cnVlLCBhbGwgZml4dHVyZXNcbiAgICAgICAgICogd2lsbCBiZSBhZGRlZCB0byB0aGUgYnJvYWQtcGhhc2UuIElmIHlvdSBwYXNzIGEgZmxhZyBvZiBmYWxzZSwgYWxsIGZpeHR1cmVzXG4gICAgICAgICAqIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBicm9hZC1waGFzZSBhbmQgYWxsIGNvbnRhY3RzIHdpbGwgYmUgZGVzdHJveWVkLlxuICAgICAgICAgKiBGaXh0dXJlcyBhbmQgam9pbnRzIGFyZSBvdGhlcndpc2UgdW5hZmZlY3RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IG1heSBjb250aW51ZSB0byBjcmVhdGUvZGVzdHJveSBmaXh0dXJlcyBhbmQgam9pbnRzIG9uIGluYWN0aXZlIGJvZGllcy5cbiAgICAgICAgICogRml4dHVyZXMgb24gYW4gaW5hY3RpdmUgYm9keSBhcmUgaW1wbGljaXRseSBpbmFjdGl2ZSBhbmQgd2lsbCBub3QgcGFydGljaXBhdGVcbiAgICAgICAgICogaW4gY29sbGlzaW9ucywgcmF5LWNhc3RzLCBvciBxdWVyaWVzLiBKb2ludHMgY29ubmVjdGVkIHRvIGFuIGluYWN0aXZlIGJvZHlcbiAgICAgICAgICogYXJlIGltcGxpY2l0bHkgaW5hY3RpdmUuIEFuIGluYWN0aXZlIGJvZHkgaXMgc3RpbGwgb3duZWQgYnkgYSBXb3JsZCBvYmplY3RcbiAgICAgICAgICogYW5kIHJlbWFpbnNcbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICBpZiAoZmxhZyA9PSB0aGlzLm1fYWN0aXZlRmxhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9hY3RpdmVGbGFnID0gISFmbGFnO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9hY3RpdmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFsbCBwcm94aWVzLlxuICAgICAgICAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmID0gdGhpcy5tX2ZpeHR1cmVMaXN0OyBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZi5jcmVhdGVQcm94aWVzKGJyb2FkUGhhc2UsIHRoaXMubV94Zik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENvbnRhY3RzIGFyZSBjcmVhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHRcbiAgICAgICAgICAgICAgICB0aGlzLm1fd29ybGQubV9uZXdGaXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgYWxsIHByb3hpZXMuXG4gICAgICAgICAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9icm9hZFBoYXNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBmLmRlc3Ryb3lQcm94aWVzKGJyb2FkUGhhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEZXN0cm95IHRoZSBhdHRhY2hlZCBjb250YWN0cy5cbiAgICAgICAgICAgICAgICB2YXIgY2UgPSB0aGlzLm1fY29udGFjdExpc3Q7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZTAgPSBjZTtcbiAgICAgICAgICAgICAgICAgICAgY2UgPSBjZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fd29ybGQuZGVzdHJveUNvbnRhY3QoY2UwLmNvbnRhY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1fY29udGFjdExpc3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5pc0ZpeGVkUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2ZpeGVkUm90YXRpb25GbGFnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgYm9keSB0byBoYXZlIGZpeGVkIHJvdGF0aW9uLiBUaGlzIGNhdXNlcyB0aGUgbWFzcyB0byBiZSByZXNldC5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldEZpeGVkUm90YXRpb24gPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9maXhlZFJvdGF0aW9uRmxhZyA9PSBmbGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2ZpeGVkUm90YXRpb25GbGFnID0gISFmbGFnO1xuICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMucmVzZXRNYXNzRGF0YSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3b3JsZCB0cmFuc2Zvcm0gZm9yIHRoZSBib2R5J3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV94ZjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkncyBvcmlnaW4gYW5kIHJvdGF0aW9uLiBNYW5pcHVsYXRpbmcgYSBib2R5J3NcbiAgICAgICAgICogdHJhbnNmb3JtIG1heSBjYXVzZSBub24tcGh5c2ljYWwgYmVoYXZpb3IuIE5vdGU6IGNvbnRhY3RzIGFyZSB1cGRhdGVkIG9uIHRoZVxuICAgICAgICAgKiBuZXh0IGNhbGwgdG8gV29ybGQuc3RlcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgYm9keSdzIGxvY2FsIG9yaWdpbi5cbiAgICAgICAgICogQHBhcmFtIGFuZ2xlIFRoZSB3b3JsZCByb3RhdGlvbiBpbiByYWRpYW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBhbmdsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXb3JsZExvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1feGYuc2V0TnVtKHBvc2l0aW9uLCBhbmdsZSk7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXAuc2V0VHJhbnNmb3JtKHRoaXMubV94Zik7XG4gICAgICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBmID0gdGhpcy5tX2ZpeHR1cmVMaXN0OyBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgICAgICAgICBmLnN5bmNocm9uaXplKGJyb2FkUGhhc2UsIHRoaXMubV94ZiwgdGhpcy5tX3hmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLnN5bmNocm9uaXplVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLmdldFRyYW5zZm9ybSh0aGlzLm1feGYsIDEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGZpeHR1cmVzIGluIGJyb2FkLXBoYXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuc3luY2hyb25pemVGaXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcC5nZXRUcmFuc2Zvcm0oeGYkMiwgMCk7XG4gICAgICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBmID0gdGhpcy5tX2ZpeHR1cmVMaXN0OyBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgICAgICAgICBmLnN5bmNocm9uaXplKGJyb2FkUGhhc2UsIHhmJDIsIHRoaXMubV94Zik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGluIFRPSS5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5ldyBzYWZlIHRpbWUuIFRoaXMgZG9lc24ndCBzeW5jIHRoZSBicm9hZC1waGFzZS5cbiAgICAgICAgICAgIHRoaXMubV9zd2VlcC5hZHZhbmNlKGFscGhhKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMubV9zd2VlcC5jLCB0aGlzLm1fc3dlZXAuYzApO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwLmEgPSB0aGlzLm1fc3dlZXAuYTA7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXAuZ2V0VHJhbnNmb3JtKHRoaXMubV94ZiwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHdvcmxkIHBvc2l0aW9uIGZvciB0aGUgYm9keSdzIG9yaWdpbi5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV94Zi5wO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShwLCB0aGlzLm1fc3dlZXAuYSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgd29ybGQgcm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9zd2VlcC5hO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRBbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0odGhpcy5tX3hmLnAsIGFuZ2xlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiBtYXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0V29ybGRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3N3ZWVwLmM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxvY2FsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldExvY2FsQ2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd29ybGQgbGluZWFyIHZlbG9jaXR5IG9mIGEgd29ybGQgcG9pbnQgYXR0YWNoZWQgdG8gdGhpcyBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gd29ybGRQb2ludCBBIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50KSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxDZW50ZXIgPSBWZWMyLnN1Yih3b3JsZFBvaW50LCB0aGlzLm1fc3dlZXAuYyk7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5hZGQodGhpcy5tX2xpbmVhclZlbG9jaXR5LCBWZWMyLmNyb3NzTnVtVmVjMih0aGlzLm1fYW5ndWxhclZlbG9jaXR5LCBsb2NhbENlbnRlcikpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3b3JsZCB2ZWxvY2l0eSBvZiBhIGxvY2FsIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbG9jYWxQb2ludCBBIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TGluZWFyVmVsb2NpdHlGcm9tTG9jYWxQb2ludCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lYXJWZWxvY2l0eUZyb21Xb3JsZFBvaW50KHRoaXMuZ2V0V29ybGRQb2ludChsb2NhbFBvaW50KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2IFRoZSBuZXcgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSA9PSBTVEFUSUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVmVjMi5kb3QodiwgdikgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LnNldFZlYzIodik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHRoZSBhbmd1bGFyIHZlbG9jaXR5IGluIHJhZGlhbnMvc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9hbmd1bGFyVmVsb2NpdHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvbWVnYSBUaGUgbmV3IGFuZ3VsYXIgdmVsb2NpdHkgaW4gcmFkaWFucy9zZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5zZXRBbmd1bGFyVmVsb2NpdHkgPSBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlID09IFNUQVRJQykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3ICogdyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gdztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbGluZWFyRGFtcGluZztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uIChsaW5lYXJEYW1waW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFyRGFtcGluZyA9IGxpbmVhckRhbXBpbmc7XG4gICAgICAgIH07XG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldEFuZ3VsYXJEYW1waW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9hbmd1bGFyRGFtcGluZztcbiAgICAgICAgfTtcbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0QW5ndWxhckRhbXBpbmcgPSBmdW5jdGlvbiAoYW5ndWxhckRhbXBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubV9hbmd1bGFyRGFtcGluZyA9IGFuZ3VsYXJEYW1waW5nO1xuICAgICAgICB9O1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRHcmF2aXR5U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2dyYXZpdHlTY2FsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIHRoZSBncmF2aXR5IGFwcGxpZWQgdG8gdGhpcyBib2R5LlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2V0R3Jhdml0eVNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLm1fZ3Jhdml0eVNjYWxlID0gc2NhbGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHRvdGFsIG1hc3Mgb2YgdGhlIGJvZHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtYXNzLCB1c3VhbGx5IGluIGtpbG9ncmFtcyAoa2cpLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TWFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWFzcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcm90YXRpb25hbCBpbmVydGlhIG9mIHRoZSBib2R5IGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIHJvdGF0aW9uYWwgaW5lcnRpYSwgdXN1YWxseSBpbiBrZy1tXjIuXG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRJbmVydGlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9JICsgdGhpcy5tX21hc3NcbiAgICAgICAgICAgICAgICAqIFZlYzIuZG90KHRoaXMubV9zd2VlcC5sb2NhbENlbnRlciwgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvcHkgdGhlIG1hc3MgZGF0YSBvZiB0aGUgYm9keSB0byBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgZGF0YS5tYXNzID0gdGhpcy5tX21hc3M7XG4gICAgICAgICAgICBkYXRhLkkgPSB0aGlzLmdldEluZXJ0aWEoKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKGRhdGEuY2VudGVyLCB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXNldHMgdGhlIG1hc3MgcHJvcGVydGllcyB0byB0aGUgc3VtIG9mIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhlXG4gICAgICAgICAqIGZpeHR1cmVzLiBUaGlzIG5vcm1hbGx5IGRvZXMgbm90IG5lZWQgdG8gYmUgY2FsbGVkIHVubGVzcyB5b3UgY2FsbGVkXG4gICAgICAgICAqIFNldE1hc3NEYXRhIHRvIG92ZXJyaWRlIHRoZSBtYXNzIGFuZCB5b3UgbGF0ZXIgd2FudCB0byByZXNldCB0aGUgbWFzcy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnJlc2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIG1hc3MgZGF0YSBmcm9tIHNoYXBlcy4gRWFjaCBzaGFwZSBoYXMgaXRzIG93biBkZW5zaXR5LlxuICAgICAgICAgICAgdGhpcy5tX21hc3MgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzcyA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMubV9JID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5tX2ludkkgPSAwLjA7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIpO1xuICAgICAgICAgICAgLy8gU3RhdGljIGFuZCBraW5lbWF0aWMgYm9kaWVzIGhhdmUgemVybyBtYXNzLlxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMoKSB8fCB0aGlzLmlzS2luZW1hdGljKCkpIHtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMih0aGlzLm1fc3dlZXAuYzAsIHRoaXMubV94Zi5wKTtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMih0aGlzLm1fc3dlZXAuYywgdGhpcy5tX3hmLnApO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zd2VlcC5hMCA9IHRoaXMubV9zd2VlcC5hO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgbWFzcyBvdmVyIGFsbCBmaXh0dXJlcy5cbiAgICAgICAgICAgIHplcm9WZWMyKGxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChmLm1fZGVuc2l0eSA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXNzRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWFzczogMCxcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyOiB2ZWMyKDAsIDApLFxuICAgICAgICAgICAgICAgICAgICBJOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmLmdldE1hc3NEYXRhKG1hc3NEYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcyArPSBtYXNzRGF0YS5tYXNzO1xuICAgICAgICAgICAgICAgIGFkZE11bFZlYzIobG9jYWxDZW50ZXIsIG1hc3NEYXRhLm1hc3MsIG1hc3NEYXRhLmNlbnRlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0kgKz0gbWFzc0RhdGEuSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgICAgICBpZiAodGhpcy5tX21hc3MgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW52TWFzcyA9IDEuMCAvIHRoaXMubV9tYXNzO1xuICAgICAgICAgICAgICAgIHNldE11bFZlYzIobG9jYWxDZW50ZXIsIHRoaXMubV9pbnZNYXNzLCBsb2NhbENlbnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBhbGwgZHluYW1pYyBib2RpZXMgdG8gaGF2ZSBhIHBvc2l0aXZlIG1hc3MuXG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX0kgPiAwLjAgJiYgdGhpcy5tX2ZpeGVkUm90YXRpb25GbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2VudGVyIHRoZSBpbmVydGlhIGFib3V0IHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgICAgICAgICAgICAgICB0aGlzLm1fSSAtPSB0aGlzLm1fbWFzcyAqIGRvdFZlYzIobG9jYWxDZW50ZXIsIGxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW52SSA9IDEuMCAvIHRoaXMubV9JO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ludkkgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNb3ZlIGNlbnRlciBvZiBtYXNzLlxuICAgICAgICAgICAgY29weVZlYzIob2xkQ2VudGVyLCB0aGlzLm1fc3dlZXAuYyk7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXAuc2V0TG9jYWxDZW50ZXIobG9jYWxDZW50ZXIsIHRoaXMubV94Zik7XG4gICAgICAgICAgICAvLyBVcGRhdGUgY2VudGVyIG9mIG1hc3MgdmVsb2NpdHkuXG4gICAgICAgICAgICBkaWZmVmVjMihzaGlmdCwgdGhpcy5tX3N3ZWVwLmMsIG9sZENlbnRlcik7XG4gICAgICAgICAgICBjcm9zc051bVZlYzIodGVtcCQ2LCB0aGlzLm1fYW5ndWxhclZlbG9jaXR5LCBzaGlmdCk7XG4gICAgICAgICAgICBhZGRWZWMyKHRoaXMubV9saW5lYXJWZWxvY2l0eSwgdGVtcCQ2KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWFzcyBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhlIGZpeHR1cmVzLiBOb3RlXG4gICAgICAgICAqIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSBjZW50ZXIgb2YgbWFzcyBwb3NpdGlvbi4gTm90ZSB0aGF0IGNyZWF0aW5nIG9yXG4gICAgICAgICAqIGRlc3Ryb3lpbmcgZml4dHVyZXMgY2FuIGFsc28gYWx0ZXIgdGhlIG1hc3MuIFRoaXMgZnVuY3Rpb24gaGFzIG5vIGVmZmVjdCBpZlxuICAgICAgICAgKiB0aGUgYm9keSBpc24ndCBkeW5hbWljLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWFzc0RhdGEgVGhlIG1hc3MgcHJvcGVydGllcy5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnNldE1hc3NEYXRhID0gZnVuY3Rpb24gKG1hc3NEYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dvcmxkTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBEWU5BTUlDKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1fSSA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMubV9pbnZJID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5tX21hc3MgPSBtYXNzRGF0YS5tYXNzO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9tYXNzIDw9IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9tYXNzID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjAgLyB0aGlzLm1fbWFzcztcbiAgICAgICAgICAgIGlmIChtYXNzRGF0YS5JID4gMC4wICYmIHRoaXMubV9maXhlZFJvdGF0aW9uRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9JID0gbWFzc0RhdGEuSSAtIHRoaXMubV9tYXNzICogZG90VmVjMihtYXNzRGF0YS5jZW50ZXIsIG1hc3NEYXRhLmNlbnRlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ludkkgPSAxLjAgLyB0aGlzLm1fSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1vdmUgY2VudGVyIG9mIG1hc3MuXG4gICAgICAgICAgICBjb3B5VmVjMihvbGRDZW50ZXIsIHRoaXMubV9zd2VlcC5jKTtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcC5zZXRMb2NhbENlbnRlcihtYXNzRGF0YS5jZW50ZXIsIHRoaXMubV94Zik7XG4gICAgICAgICAgICAvLyBVcGRhdGUgY2VudGVyIG9mIG1hc3MgdmVsb2NpdHkuXG4gICAgICAgICAgICBkaWZmVmVjMihzaGlmdCwgdGhpcy5tX3N3ZWVwLmMsIG9sZENlbnRlcik7XG4gICAgICAgICAgICBjcm9zc051bVZlYzIodGVtcCQ2LCB0aGlzLm1fYW5ndWxhclZlbG9jaXR5LCBzaGlmdCk7XG4gICAgICAgICAgICBhZGRWZWMyKHRoaXMubV9saW5lYXJWZWxvY2l0eSwgdGVtcCQ2KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IGEgZm9yY2UgYXQgYSB3b3JsZCBwb2ludC4gSWYgdGhlIGZvcmNlIGlzIG5vdCBhcHBsaWVkIGF0IHRoZSBjZW50ZXIgb2ZcbiAgICAgICAgICogbWFzcywgaXQgd2lsbCBnZW5lcmF0ZSBhIHRvcnF1ZSBhbmQgYWZmZWN0IHRoZSBhbmd1bGFyIHZlbG9jaXR5LiBUaGlzIHdha2VzXG4gICAgICAgICAqIHVwIHRoZSBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZm9yY2UgVGhlIHdvcmxkIGZvcmNlIHZlY3RvciwgdXN1YWxseSBpbiBOZXd0b25zIChOKS5cbiAgICAgICAgICogQHBhcmFtIHBvaW50IFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB3YWtlIEFsc28gd2FrZSB1cCB0aGUgYm9keVxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uIChmb3JjZSwgcG9pbnQsIHdha2UpIHtcbiAgICAgICAgICAgIGlmICh3YWtlID09PSB2b2lkIDApIHsgd2FrZSA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBEWU5BTUlDKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdha2UgJiYgdGhpcy5tX2F3YWtlRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBhY2N1bXVsYXRlIGEgZm9yY2UgaWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcuXG4gICAgICAgICAgICBpZiAodGhpcy5tX2F3YWtlRmxhZykge1xuICAgICAgICAgICAgICAgIHRoaXMubV9mb3JjZS5hZGQoZm9yY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMubV90b3JxdWUgKz0gVmVjMi5jcm9zc1ZlYzJWZWMyKFZlYzIuc3ViKHBvaW50LCB0aGlzLm1fc3dlZXAuYyksIGZvcmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IGEgZm9yY2UgdG8gdGhlIGNlbnRlciBvZiBtYXNzLiBUaGlzIHdha2VzIHVwIHRoZSBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZm9yY2UgVGhlIHdvcmxkIGZvcmNlIHZlY3RvciwgdXN1YWxseSBpbiBOZXd0b25zIChOKS5cbiAgICAgICAgICogQHBhcmFtIHdha2UgQWxzbyB3YWtlIHVwIHRoZSBib2R5XG4gICAgICAgICAqL1xuICAgICAgICBCb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlVG9DZW50ZXIgPSBmdW5jdGlvbiAoZm9yY2UsIHdha2UpIHtcbiAgICAgICAgICAgIGlmICh3YWtlID09PSB2b2lkIDApIHsgd2FrZSA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBEWU5BTUlDKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdha2UgJiYgdGhpcy5tX2F3YWtlRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBhY2N1bXVsYXRlIGEgZm9yY2UgaWYgdGhlIGJvZHkgaXMgc2xlZXBpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYXdha2VGbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ZvcmNlLmFkZChmb3JjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBhIHRvcnF1ZS4gVGhpcyBhZmZlY3RzIHRoZSBhbmd1bGFyIHZlbG9jaXR5IHdpdGhvdXQgYWZmZWN0aW5nIHRoZVxuICAgICAgICAgKiBsaW5lYXIgdmVsb2NpdHkgb2YgdGhlIGNlbnRlciBvZiBtYXNzLiBUaGlzIHdha2VzIHVwIHRoZSBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdG9ycXVlIEFib3V0IHRoZSB6LWF4aXMgKG91dCBvZiB0aGUgc2NyZWVuKSwgdXN1YWxseSBpbiBOLW0uXG4gICAgICAgICAqIEBwYXJhbSB3YWtlIEFsc28gd2FrZSB1cCB0aGUgYm9keVxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuYXBwbHlUb3JxdWUgPSBmdW5jdGlvbiAodG9ycXVlLCB3YWtlKSB7XG4gICAgICAgICAgICBpZiAod2FrZSA9PT0gdm9pZCAwKSB7IHdha2UgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX3R5cGUgIT0gRFlOQU1JQykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YWtlICYmIHRoaXMubV9hd2FrZUZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9uJ3QgYWNjdW11bGF0ZSBhIGZvcmNlIGlmIHRoZSBib2R5IGlzIHNsZWVwaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5tX2F3YWtlRmxhZykge1xuICAgICAgICAgICAgICAgIHRoaXMubV90b3JxdWUgKz0gdG9ycXVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgYW4gaW1wdWxzZSBhdCBhIHBvaW50LiBUaGlzIGltbWVkaWF0ZWx5IG1vZGlmaWVzIHRoZSB2ZWxvY2l0eS4gSXQgYWxzb1xuICAgICAgICAgKiBtb2RpZmllcyB0aGUgYW5ndWxhciB2ZWxvY2l0eSBpZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb24gaXMgbm90IGF0IHRoZVxuICAgICAgICAgKiBjZW50ZXIgb2YgbWFzcy4gVGhpcyB3YWtlcyB1cCB0aGUgYm9keS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltcHVsc2UgVGhlIHdvcmxkIGltcHVsc2UgdmVjdG9yLCB1c3VhbGx5IGluIE4tc2Vjb25kcyBvciBrZy1tL3MuXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHBvaW50IG9mIGFwcGxpY2F0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gd2FrZSBBbHNvIHdha2UgdXAgdGhlIGJvZHlcbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmFwcGx5TGluZWFySW1wdWxzZSA9IGZ1bmN0aW9uIChpbXB1bHNlLCBwb2ludCwgd2FrZSkge1xuICAgICAgICAgICAgaWYgKHdha2UgPT09IHZvaWQgMCkgeyB3YWtlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlICE9IERZTkFNSUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FrZSAmJiB0aGlzLm1fYXdha2VGbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IGFjY3VtdWxhdGUgdmVsb2NpdHkgaWYgdGhlIGJvZHkgaXMgc2xlZXBpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYXdha2VGbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LmFkZE11bCh0aGlzLm1faW52TWFzcywgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLm1faW52SSAqIFZlYzIuY3Jvc3NWZWMyVmVjMihWZWMyLnN1Yihwb2ludCwgdGhpcy5tX3N3ZWVwLmMpLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IGFuIGFuZ3VsYXIgaW1wdWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltcHVsc2UgVGhlIGFuZ3VsYXIgaW1wdWxzZSBpbiB1bml0cyBvZiBrZyptKm0vc1xuICAgICAgICAgKiBAcGFyYW0gd2FrZSBBbHNvIHdha2UgdXAgdGhlIGJvZHlcbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmFwcGx5QW5ndWxhckltcHVsc2UgPSBmdW5jdGlvbiAoaW1wdWxzZSwgd2FrZSkge1xuICAgICAgICAgICAgaWYgKHdha2UgPT09IHZvaWQgMCkgeyB3YWtlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlICE9IERZTkFNSUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FrZSAmJiB0aGlzLm1fYXdha2VGbGFnID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IGFjY3VtdWxhdGUgdmVsb2NpdHkgaWYgdGhlIGJvZHkgaXMgc2xlZXBpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYXdha2VGbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLm1faW52SSAqIGltcHVsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgdG8gdGVzdCBpZiB0d28gYm9kaWVzIHNob3VsZCBjb2xsaWRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCb2RpZXMgZG8gbm90IGNvbGxpZGUgd2hlbjpcbiAgICAgICAgICogLSBOZWl0aGVyIG9mIHRoZW0gaXMgZHluYW1pY1xuICAgICAgICAgKiAtIFRoZXkgYXJlIGNvbm5lY3RlZCBieSBhIGpvaW50IHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuc2hvdWxkQ29sbGlkZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICAgICAgICAvLyBBdCBsZWFzdCBvbmUgYm9keSBzaG91bGQgYmUgZHluYW1pYy5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBEWU5BTUlDICYmIHRoYXQubV90eXBlICE9IERZTkFNSUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb2VzIGEgam9pbnQgcHJldmVudCBjb2xsaXNpb24/XG4gICAgICAgICAgICBmb3IgKHZhciBqbiA9IHRoaXMubV9qb2ludExpc3Q7IGpuOyBqbiA9IGpuLm5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoam4ub3RoZXIgPT0gdGhhdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoam4uam9pbnQubV9jb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBVc2VkIGZvciBkZXNlcmlhbGl6ZS4gKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuX2FkZEZpeHR1cmUgPSBmdW5jdGlvbiAoZml4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXb3JsZExvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fYWN0aXZlRmxhZykge1xuICAgICAgICAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgICAgICAgICBmaXh0dXJlLmNyZWF0ZVByb3hpZXMoYnJvYWRQaGFzZSwgdGhpcy5tX3hmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpeHR1cmUubV9uZXh0ID0gdGhpcy5tX2ZpeHR1cmVMaXN0O1xuICAgICAgICAgICAgdGhpcy5tX2ZpeHR1cmVMaXN0ID0gZml4dHVyZTtcbiAgICAgICAgICAgIC8vIEFkanVzdCBtYXNzIHByb3BlcnRpZXMgaWYgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKGZpeHR1cmUubV9kZW5zaXR5ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldE1hc3NEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMZXQgdGhlIHdvcmxkIGtub3cgd2UgaGF2ZSBhIG5ldyBmaXh0dXJlLiBUaGlzIHdpbGwgY2F1c2UgbmV3IGNvbnRhY3RzXG4gICAgICAgICAgICAvLyB0byBiZSBjcmVhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgdGltZSBzdGVwLlxuICAgICAgICAgICAgdGhpcy5tX3dvcmxkLm1fbmV3Rml4dHVyZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZml4dHVyZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgQm9keS5wcm90b3R5cGUuY3JlYXRlRml4dHVyZSA9IGZ1bmN0aW9uIChzaGFwZSwgZml4ZGVmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dvcmxkTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpeHR1cmUgPSBuZXcgRml4dHVyZSh0aGlzLCBzaGFwZSwgZml4ZGVmKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEZpeHR1cmUoZml4dHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gZml4dHVyZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgYSBmaXh0dXJlLiBUaGlzIHJlbW92ZXMgdGhlIGZpeHR1cmUgZnJvbSB0aGUgYnJvYWQtcGhhc2UgYW5kIGRlc3Ryb3lzXG4gICAgICAgICAqIGFsbCBjb250YWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaXh0dXJlLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBhZGp1c3QgdGhlXG4gICAgICAgICAqIG1hc3Mgb2YgdGhlIGJvZHkgaWYgdGhlIGJvZHkgaXMgZHluYW1pYyBhbmQgdGhlIGZpeHR1cmUgaGFzIHBvc2l0aXZlIGRlbnNpdHkuXG4gICAgICAgICAqIEFsbCBmaXh0dXJlcyBhdHRhY2hlZCB0byBhIGJvZHkgYXJlIGltcGxpY2l0bHkgZGVzdHJveWVkIHdoZW4gdGhlIGJvZHkgaXNcbiAgICAgICAgICogZGVzdHJveWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZml4dHVyZSBUaGUgZml4dHVyZSB0byBiZSByZW1vdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZGVzdHJveUZpeHR1cmUgPSBmdW5jdGlvbiAoZml4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXb3JsZExvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZpeHR1cmVMaXN0ID09PSBmaXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ZpeHR1cmVMaXN0ID0gZml4dHVyZS5tX25leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubV9maXh0dXJlTGlzdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm1fbmV4dCA9PT0gZml4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tX25leHQgPSBmaXh0dXJlLm1fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm1fbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZXN0cm95IGFueSBjb250YWN0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGZpeHR1cmUuXG4gICAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBlZGdlLmNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgICAgICAgICB2YXIgZml4dHVyZUEgPSBjLmdldEZpeHR1cmVBKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gYy5nZXRGaXh0dXJlQigpO1xuICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlID09IGZpeHR1cmVBIHx8IGZpeHR1cmUgPT0gZml4dHVyZUIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBkZXN0cm95cyB0aGUgY29udGFjdCBhbmQgcmVtb3ZlcyBpdCBmcm9tXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYm9keSdzIGNvbnRhY3QgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3dvcmxkLmRlc3Ryb3lDb250YWN0KGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fYWN0aXZlRmxhZykge1xuICAgICAgICAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgICAgICAgICBmaXh0dXJlLmRlc3Ryb3lQcm94aWVzKGJyb2FkUGhhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZml4dHVyZS5tX2JvZHkgPSBudWxsO1xuICAgICAgICAgICAgZml4dHVyZS5tX25leHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX3dvcmxkLnB1Ymxpc2goJ3JlbW92ZS1maXh0dXJlJywgZml4dHVyZSk7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgbWFzcyBkYXRhLlxuICAgICAgICAgICAgdGhpcy5yZXNldE1hc3NEYXRhKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvcnJlc3BvbmRpbmcgd29ybGQgcG9pbnQgb2YgYSBsb2NhbCBwb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFdvcmxkUG9pbnQgPSBmdW5jdGlvbiAobG9jYWxQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5tdWxWZWMyKHRoaXMubV94ZiwgbG9jYWxQb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvcnJlc3BvbmRpbmcgd29ybGQgdmVjdG9yIG9mIGEgbG9jYWwgdmVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0V29ybGRWZWN0b3IgPSBmdW5jdGlvbiAobG9jYWxWZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSb3QubXVsVmVjMih0aGlzLm1feGYucSwgbG9jYWxWZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyBsb2NhbCBwb2ludCBvZiBhIHdvcmxkIHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0TG9jYWxQb2ludCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLm11bFRWZWMyKHRoaXMubV94Ziwgd29ybGRQb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHZlY3RvciBvZiBhIHdvcmxkIHZlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldExvY2FsVmVjdG9yID0gZnVuY3Rpb24gKHdvcmxkVmVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUm90Lm11bFRWZWMyKHRoaXMubV94Zi5xLCB3b3JsZFZlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0YXRpYyBib2R5IGRvZXMgbm90IG1vdmUgdW5kZXIgc2ltdWxhdGlvbiBhbmQgYmVoYXZlcyBhcyBpZiBpdCBoYXMgaW5maW5pdGUgbWFzcy5cbiAgICAgICAgICogSW50ZXJuYWxseSwgemVybyBpcyBzdG9yZWQgZm9yIHRoZSBtYXNzIGFuZCB0aGUgaW52ZXJzZSBtYXNzLlxuICAgICAgICAgKiBTdGF0aWMgYm9kaWVzIGNhbiBiZSBtb3ZlZCBtYW51YWxseSBieSB0aGUgdXNlci5cbiAgICAgICAgICogQSBzdGF0aWMgYm9keSBoYXMgemVybyB2ZWxvY2l0eS5cbiAgICAgICAgICogU3RhdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIHN0YXRpYyBvciBraW5lbWF0aWMgYm9kaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5TVEFUSUMgPSAnc3RhdGljJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEga2luZW1hdGljIGJvZHkgbW92ZXMgdW5kZXIgc2ltdWxhdGlvbiBhY2NvcmRpbmcgdG8gaXRzIHZlbG9jaXR5LlxuICAgICAgICAgKiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCByZXNwb25kIHRvIGZvcmNlcy5cbiAgICAgICAgICogVGhleSBjYW4gYmUgbW92ZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIsIGJ1dCBub3JtYWxseSBhIGtpbmVtYXRpYyBib2R5IGlzIG1vdmVkIGJ5IHNldHRpbmcgaXRzIHZlbG9jaXR5LlxuICAgICAgICAgKiBBIGtpbmVtYXRpYyBib2R5IGJlaGF2ZXMgYXMgaWYgaXQgaGFzIGluZmluaXRlIG1hc3MsIGhvd2V2ZXIsIHplcm8gaXMgc3RvcmVkIGZvciB0aGUgbWFzcyBhbmQgdGhlIGludmVyc2UgbWFzcy5cbiAgICAgICAgICogS2luZW1hdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIGtpbmVtYXRpYyBvciBzdGF0aWMgYm9kaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5LSU5FTUFUSUMgPSAna2luZW1hdGljJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC5cbiAgICAgICAgICogVGhleSBjYW4gYmUgbW92ZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIsIGJ1dCBub3JtYWxseSB0aGV5IG1vdmUgYWNjb3JkaW5nIHRvIGZvcmNlcy5cbiAgICAgICAgICogQSBkeW5hbWljIGJvZHkgY2FuIGNvbGxpZGUgd2l0aCBhbGwgYm9keSB0eXBlcy5cbiAgICAgICAgICogQSBkeW5hbWljIGJvZHkgYWx3YXlzIGhhcyBmaW5pdGUsIG5vbi16ZXJvIG1hc3MuXG4gICAgICAgICAqIElmIHlvdSB0cnkgdG8gc2V0IHRoZSBtYXNzIG9mIGEgZHluYW1pYyBib2R5IHRvIHplcm8sIGl0IHdpbGwgYXV0b21hdGljYWxseSBhY3F1aXJlIGEgbWFzcyBvZiBvbmUga2lsb2dyYW0gYW5kIGl0IHdvbid0IHJvdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkuRFlOQU1JQyA9ICdkeW5hbWljJztcbiAgICAgICAgcmV0dXJuIEJvZHk7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIGpvaW50IGVkZ2UgaXMgdXNlZCB0byBjb25uZWN0IGJvZGllcyBhbmQgam9pbnRzIHRvZ2V0aGVyIGluIGEgam9pbnQgZ3JhcGhcbiAgICAgKiB3aGVyZSBlYWNoIGJvZHkgaXMgYSBub2RlIGFuZCBlYWNoIGpvaW50IGlzIGFuIGVkZ2UuIEEgam9pbnQgZWRnZSBiZWxvbmdzIHRvXG4gICAgICogYSBkb3VibHkgbGlua2VkIGxpc3QgbWFpbnRhaW5lZCBpbiBlYWNoIGF0dGFjaGVkIGJvZHkuIEVhY2ggam9pbnQgaGFzIHR3b1xuICAgICAqIGpvaW50IG5vZGVzLCBvbmUgZm9yIGVhY2ggYXR0YWNoZWQgYm9keS5cbiAgICAgKi9cbiAgICB2YXIgSm9pbnRFZGdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBKb2ludEVkZ2UoKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHByb3ZpZGVzIHF1aWNrIGFjY2VzcyB0byB0aGUgb3RoZXIgYm9keSBhdHRhY2hlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vdGhlciA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHRoZSBqb2ludFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmpvaW50ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcHJldiB0aGUgcHJldmlvdXMgam9pbnQgZWRnZSBpbiB0aGUgYm9keSdzIGpvaW50IGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdGhlIG5leHQgam9pbnQgZWRnZSBpbiB0aGUgYm9keSdzIGpvaW50IGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSm9pbnRFZGdlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVGhlIGJhc2Ugam9pbnQgY2xhc3MuIEpvaW50cyBhcmUgdXNlZCB0byBjb25zdHJhaW50IHR3byBib2RpZXMgdG9nZXRoZXIgaW5cbiAgICAgKiB2YXJpb3VzIGZhc2hpb25zLiBTb21lIGpvaW50cyBhbHNvIGZlYXR1cmUgbGltaXRzIGFuZCBtb3RvcnMuXG4gICAgICovXG4gICAgdmFyIEpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBKb2ludChkZWYsIGJvZHlBLCBib2R5Qikge1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLm1fdHlwZSA9ICd1bmtub3duLWpvaW50JztcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy5tX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMubV9lZGdlQSA9IG5ldyBKb2ludEVkZ2UoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy5tX2VkZ2VCID0gbmV3IEpvaW50RWRnZSgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgYm9keUEgPSAnYm9keUEnIGluIGRlZiA/IGRlZi5ib2R5QSA6IGJvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSAnYm9keUInIGluIGRlZiA/IGRlZi5ib2R5QiA6IGJvZHlCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBID0gYm9keUE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIgPSBib2R5QjtcbiAgICAgICAgICAgIHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkID0gISFkZWYuY29sbGlkZUNvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRlZi51c2VyRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnQtY3V0IGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBlaXRoZXIgYm9keSBpcyBpbmFjdGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIEpvaW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuaXNBY3RpdmUoKSAmJiB0aGlzLm1fYm9keUIuaXNBY3RpdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGUgY29uY3JldGUgam9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBKb2ludC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlyc3QgYm9keSBhdHRhY2hlZCB0byB0aGlzIGpvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgSm9pbnQucHJvdG90eXBlLmdldEJvZHlBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc2Vjb25kIGJvZHkgYXR0YWNoZWQgdG8gdGhpcyBqb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIEpvaW50LnByb3RvdHlwZS5nZXRCb2R5QiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5leHQgam9pbnQgdGhlIHdvcmxkIGpvaW50IGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBKb2ludC5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbmV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgSm9pbnQucHJvdG90eXBlLmdldFVzZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV91c2VyRGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgSm9pbnQucHJvdG90eXBlLnNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29sbGlkZSBjb25uZWN0ZWQuIE5vdGU6IG1vZGlmeWluZyB0aGUgY29sbGlkZSBjb25uZWN0IGZsYWcgd29uJ3Qgd29ya1xuICAgICAgICAgKiBjb3JyZWN0bHkgYmVjYXVzZSB0aGUgZmxhZyBpcyBvbmx5IGNoZWNrZWQgd2hlbiBmaXh0dXJlIEFBQkJzIGJlZ2luIHRvXG4gICAgICAgICAqIG92ZXJsYXAuXG4gICAgICAgICAqL1xuICAgICAgICBKb2ludC5wcm90b3R5cGUuZ2V0Q29sbGlkZUNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNoaWZ0IHRoZSBvcmlnaW4gZm9yIGFueSBwb2ludHMgc3RvcmVkIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgSm9pbnQucHJvdG90eXBlLnNoaWZ0T3JpZ2luID0gZnVuY3Rpb24gKG5ld09yaWdpbikgeyB9O1xuICAgICAgICByZXR1cm4gSm9pbnQ7XG4gICAgfSgpKTtcblxuICAgIHZhciBzdGF0cyA9IHtcbiAgICAgICAgZ2prQ2FsbHM6IDAsXG4gICAgICAgIGdqa0l0ZXJzOiAwLFxuICAgICAgICBnamtNYXhJdGVyczogMCxcbiAgICAgICAgdG9pVGltZTogMCxcbiAgICAgICAgdG9pTWF4VGltZTogMCxcbiAgICAgICAgdG9pQ2FsbHM6IDAsXG4gICAgICAgIHRvaUl0ZXJzOiAwLFxuICAgICAgICB0b2lNYXhJdGVyczogMCxcbiAgICAgICAgdG9pUm9vdEl0ZXJzOiAwLFxuICAgICAgICB0b2lNYXhSb290SXRlcnM6IDAsXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAobmV3bGluZSkge1xuICAgICAgICAgICAgbmV3bGluZSA9IHR5cGVvZiBuZXdsaW5lID09PSAnc3RyaW5nJyA/IG5ld2xpbmUgOiAnXFxuJztcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvci1pblxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbbmFtZV8xXSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdGhpc1tuYW1lXzFdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gbmFtZV8xICsgJzogJyArIHRoaXNbbmFtZV8xXSArIG5ld2xpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKiogQGludGVybmFsICovXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdmFyIGRpZmYgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRpbWU7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdmFyIFRpbWVyID0ge1xuICAgICAgICBub3c6IG5vdyxcbiAgICAgICAgZGlmZjogZGlmZixcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfbWF4JDQgPSBNYXRoLm1heDtcbiAgICAvKiogQGludGVybmFsICovIHZhciB0ZW1wJDUgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG5vcm1hbCQ0ID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBlMTIgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGUxMyA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZTIzID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciB0ZW1wMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdGVtcDIgPSB2ZWMyKDAsIDApO1xuICAgIC8qKlxuICAgICAqIEdKSyB1c2luZyBWb3Jvbm9pIHJlZ2lvbnMgKENocmlzdGVyIEVyaWNzb24pIGFuZCBCYXJ5Y2VudHJpYyBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBzdGF0cy5namtDYWxscyA9IDA7XG4gICAgc3RhdHMuZ2prSXRlcnMgPSAwO1xuICAgIHN0YXRzLmdqa01heEl0ZXJzID0gMDtcbiAgICAvKipcbiAgICAgKiBJbnB1dCBmb3IgRGlzdGFuY2UuIFlvdSBoYXZlIHRvIG9wdGlvbiB0byB1c2UgdGhlIHNoYXBlIHJhZGlpIGluIHRoZVxuICAgICAqIGNvbXB1dGF0aW9uLiBFdmVuXG4gICAgICovXG4gICAgdmFyIERpc3RhbmNlSW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERpc3RhbmNlSW5wdXQoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5QSA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgICAgICAgICB0aGlzLnByb3h5QiA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUEgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICAgICAgdGhpcy51c2VSYWRpaSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIERpc3RhbmNlSW5wdXQucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5QS5yZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLnByb3h5Qi5yZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUEuc2V0SWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQi5zZXRJZGVudGl0eSgpO1xuICAgICAgICAgICAgdGhpcy51c2VSYWRpaSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGlzdGFuY2VJbnB1dDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE91dHB1dCBmb3IgRGlzdGFuY2UuXG4gICAgICovXG4gICAgdmFyIERpc3RhbmNlT3V0cHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEaXN0YW5jZU91dHB1dCgpIHtcbiAgICAgICAgICAgIC8qKiBjbG9zZXN0IHBvaW50IG9uIHNoYXBlQSAqL1xuICAgICAgICAgICAgdGhpcy5wb2ludEEgPSB2ZWMyKDAsIDApO1xuICAgICAgICAgICAgLyoqIGNsb3Nlc3QgcG9pbnQgb24gc2hhcGVCICovXG4gICAgICAgICAgICB0aGlzLnBvaW50QiA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gMDtcbiAgICAgICAgICAgIC8qKiBpdGVyYXRpb25zIG51bWJlciBvZiBHSksgaXRlcmF0aW9ucyB1c2VkICovXG4gICAgICAgICAgICB0aGlzLml0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIERpc3RhbmNlT3V0cHV0LnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy5wb2ludEEpO1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy5wb2ludEIpO1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICB0aGlzLml0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGlzdGFuY2VPdXRwdXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHdhcm0gc3RhcnQgRGlzdGFuY2UuIFNldCBjb3VudCB0byB6ZXJvIG9uIGZpcnN0IGNhbGwuXG4gICAgICovXG4gICAgdmFyIFNpbXBsZXhDYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2ltcGxleENhY2hlKCkge1xuICAgICAgICAgICAgLyoqIGxlbmd0aCBvciBhcmVhICovXG4gICAgICAgICAgICB0aGlzLm1ldHJpYyA9IDA7XG4gICAgICAgICAgICAvKiogdmVydGljZXMgb24gc2hhcGUgQSAqL1xuICAgICAgICAgICAgdGhpcy5pbmRleEEgPSBbXTtcbiAgICAgICAgICAgIC8qKiB2ZXJ0aWNlcyBvbiBzaGFwZSBCICovXG4gICAgICAgICAgICB0aGlzLmluZGV4QiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgU2ltcGxleENhY2hlLnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tZXRyaWMgPSAwO1xuICAgICAgICAgICAgdGhpcy5pbmRleEEubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNpbXBsZXhDYWNoZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGNsb3Nlc3QgcG9pbnRzIGJldHdlZW4gdHdvIHNoYXBlcy4gU3VwcG9ydHMgYW55IGNvbWJpbmF0aW9uIG9mOlxuICAgICAqIENpcmNsZVNoYXBlLCBQb2x5Z29uU2hhcGUsIEVkZ2VTaGFwZS4gVGhlIHNpbXBsZXggY2FjaGUgaXMgaW5wdXQvb3V0cHV0LiBPblxuICAgICAqIHRoZSBmaXJzdCBjYWxsIHNldCBTaW1wbGV4Q2FjaGUuY291bnQgdG8gemVyby5cbiAgICAgKi9cbiAgICB2YXIgRGlzdGFuY2UgPSBmdW5jdGlvbiAob3V0cHV0LCBjYWNoZSwgaW5wdXQpIHtcbiAgICAgICAgKytzdGF0cy5namtDYWxscztcbiAgICAgICAgdmFyIHByb3h5QSA9IGlucHV0LnByb3h5QTtcbiAgICAgICAgdmFyIHByb3h5QiA9IGlucHV0LnByb3h5QjtcbiAgICAgICAgdmFyIHhmQSA9IGlucHV0LnRyYW5zZm9ybUE7XG4gICAgICAgIHZhciB4ZkIgPSBpbnB1dC50cmFuc2Zvcm1CO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBzaW1wbGV4LlxuICAgICAgICAvLyBjb25zdCBzaW1wbGV4ID0gbmV3IFNpbXBsZXgoKTtcbiAgICAgICAgc2ltcGxleC5yZWN5Y2xlKCk7XG4gICAgICAgIHNpbXBsZXgucmVhZENhY2hlKGNhY2hlLCBwcm94eUEsIHhmQSwgcHJveHlCLCB4ZkIpO1xuICAgICAgICAvLyBHZXQgc2ltcGxleCB2ZXJ0aWNlcyBhcyBhbiBhcnJheS5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gc2ltcGxleC5tX3Y7XG4gICAgICAgIHZhciBrX21heEl0ZXJzID0gU2V0dGluZ3NJbnRlcm5hbC5tYXhEaXN0YW5jZUl0ZXJhdGlvbnM7XG4gICAgICAgIC8vIFRoZXNlIHN0b3JlIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgbGFzdCBzaW1wbGV4IHNvIHRoYXQgd2VcbiAgICAgICAgLy8gY2FuIGNoZWNrIGZvciBkdXBsaWNhdGVzIGFuZCBwcmV2ZW50IGN5Y2xpbmcuXG4gICAgICAgIHZhciBzYXZlQSA9IFtdO1xuICAgICAgICB2YXIgc2F2ZUIgPSBbXTsgLy8gaW50WzNdXG4gICAgICAgIHZhciBzYXZlQ291bnQgPSAwO1xuICAgICAgICAvLyBNYWluIGl0ZXJhdGlvbiBsb29wLlxuICAgICAgICB2YXIgaXRlciA9IDA7XG4gICAgICAgIHdoaWxlIChpdGVyIDwga19tYXhJdGVycykge1xuICAgICAgICAgICAgLy8gQ29weSBzaW1wbGV4IHNvIHdlIGNhbiBpZGVudGlmeSBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgc2F2ZUNvdW50ID0gc2ltcGxleC5tX2NvdW50O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYXZlQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHNhdmVBW2ldID0gdmVydGljZXNbaV0uaW5kZXhBO1xuICAgICAgICAgICAgICAgIHNhdmVCW2ldID0gdmVydGljZXNbaV0uaW5kZXhCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2ltcGxleC5zb2x2ZSgpO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSAzIHBvaW50cywgdGhlbiB0aGUgb3JpZ2luIGlzIGluIHRoZSBjb3JyZXNwb25kaW5nIHRyaWFuZ2xlLlxuICAgICAgICAgICAgaWYgKHNpbXBsZXgubV9jb3VudCA9PT0gMykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHNlYXJjaCBkaXJlY3Rpb24uXG4gICAgICAgICAgICB2YXIgZCA9IHNpbXBsZXguZ2V0U2VhcmNoRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHNlYXJjaCBkaXJlY3Rpb24gaXMgbnVtZXJpY2FsbHkgZml0LlxuICAgICAgICAgICAgaWYgKGxlbmd0aFNxclZlYzIoZCkgPCBFUFNJTE9OICogRVBTSUxPTikge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW4gaXMgcHJvYmFibHkgY29udGFpbmVkIGJ5IGEgbGluZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgLy8gb3IgdHJpYW5nbGUuIFRodXMgdGhlIHNoYXBlcyBhcmUgb3ZlcmxhcHBlZC5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCByZXR1cm4gemVybyBoZXJlIGV2ZW4gdGhvdWdoIHRoZXJlIG1heSBiZSBvdmVybGFwLlxuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIHNpbXBsZXggaXMgYSBwb2ludCwgc2VnbWVudCwgb3IgdHJpYW5nbGUgaXQgaXMgZGlmZmljdWx0XG4gICAgICAgICAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIGlmIHRoZSBvcmlnaW4gaXMgY29udGFpbmVkIGluIHRoZSBDU08gb3IgdmVyeSBjbG9zZSB0byBpdC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgYSB0ZW50YXRpdmUgbmV3IHNpbXBsZXggdmVydGV4IHVzaW5nIHN1cHBvcnQgcG9pbnRzLlxuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW3NpbXBsZXgubV9jb3VudF07IC8vIFNpbXBsZXhWZXJ0ZXhcbiAgICAgICAgICAgIHZlcnRleC5pbmRleEEgPSBwcm94eUEuZ2V0U3VwcG9ydChpbnZSb3RWZWMyKHRlbXAkNSwgeGZBLnEsIHNldE11bFZlYzIodGVtcCQ1LCAtMSwgZCkpKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybVZlYzIodmVydGV4LndBLCB4ZkEsIHByb3h5QS5nZXRWZXJ0ZXgodmVydGV4LmluZGV4QSkpO1xuICAgICAgICAgICAgdmVydGV4LmluZGV4QiA9IHByb3h5Qi5nZXRTdXBwb3J0KGludlJvdFZlYzIodGVtcCQ1LCB4ZkIucSwgZCkpO1xuICAgICAgICAgICAgdHJhbnNmb3JtVmVjMih2ZXJ0ZXgud0IsIHhmQiwgcHJveHlCLmdldFZlcnRleCh2ZXJ0ZXguaW5kZXhCKSk7XG4gICAgICAgICAgICBkaWZmVmVjMih2ZXJ0ZXgudywgdmVydGV4LndCLCB2ZXJ0ZXgud0EpO1xuICAgICAgICAgICAgLy8gSXRlcmF0aW9uIGNvdW50IGlzIGVxdWF0ZWQgdG8gdGhlIG51bWJlciBvZiBzdXBwb3J0IHBvaW50IGNhbGxzLlxuICAgICAgICAgICAgKytpdGVyO1xuICAgICAgICAgICAgKytzdGF0cy5namtJdGVycztcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgc3VwcG9ydCBwb2ludHMuIFRoaXMgaXMgdGhlIG1haW4gdGVybWluYXRpb25cbiAgICAgICAgICAgIC8vIGNyaXRlcmlhLlxuICAgICAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYXZlQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXguaW5kZXhBID09PSBzYXZlQVtpXSAmJiB2ZXJ0ZXguaW5kZXhCID09PSBzYXZlQltpXSkge1xuICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGR1cGxpY2F0ZSBzdXBwb3J0IHBvaW50IHdlIG11c3QgZXhpdCB0byBhdm9pZCBjeWNsaW5nLlxuICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmV3IHZlcnRleCBpcyBvayBhbmQgbmVlZGVkLlxuICAgICAgICAgICAgKytzaW1wbGV4Lm1fY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHMuZ2prTWF4SXRlcnMgPSBtYXRoX21heCQ0KHN0YXRzLmdqa01heEl0ZXJzLCBpdGVyKTtcbiAgICAgICAgLy8gUHJlcGFyZSBvdXRwdXQuXG4gICAgICAgIHNpbXBsZXguZ2V0V2l0bmVzc1BvaW50cyhvdXRwdXQucG9pbnRBLCBvdXRwdXQucG9pbnRCKTtcbiAgICAgICAgb3V0cHV0LmRpc3RhbmNlID0gZGlzdFZlYzIob3V0cHV0LnBvaW50QSwgb3V0cHV0LnBvaW50Qik7XG4gICAgICAgIG91dHB1dC5pdGVyYXRpb25zID0gaXRlcjtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIHNpbXBsZXguXG4gICAgICAgIHNpbXBsZXgud3JpdGVDYWNoZShjYWNoZSk7XG4gICAgICAgIC8vIEFwcGx5IHJhZGlpIGlmIHJlcXVlc3RlZC5cbiAgICAgICAgaWYgKGlucHV0LnVzZVJhZGlpKSB7XG4gICAgICAgICAgICB2YXIgckEgPSBwcm94eUEubV9yYWRpdXM7XG4gICAgICAgICAgICB2YXIgckIgPSBwcm94eUIubV9yYWRpdXM7XG4gICAgICAgICAgICBpZiAob3V0cHV0LmRpc3RhbmNlID4gckEgKyByQiAmJiBvdXRwdXQuZGlzdGFuY2UgPiBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hhcGVzIGFyZSBzdGlsbCBubyBvdmVybGFwcGVkLlxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHdpdG5lc3MgcG9pbnRzIHRvIHRoZSBvdXRlciBzdXJmYWNlLlxuICAgICAgICAgICAgICAgIG91dHB1dC5kaXN0YW5jZSAtPSByQSArIHJCO1xuICAgICAgICAgICAgICAgIGRpZmZWZWMyKG5vcm1hbCQ0LCBvdXRwdXQucG9pbnRCLCBvdXRwdXQucG9pbnRBKTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVWZWMyKG5vcm1hbCQ0KTtcbiAgICAgICAgICAgICAgICBhZGRNdWxWZWMyKG91dHB1dC5wb2ludEEsIHJBLCBub3JtYWwkNCk7XG4gICAgICAgICAgICAgICAgc3ViTXVsVmVjMihvdXRwdXQucG9pbnRCLCByQiwgbm9ybWFsJDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2hhcGVzIGFyZSBvdmVybGFwcGVkIHdoZW4gcmFkaWkgYXJlIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgd2l0bmVzcyBwb2ludHMgdG8gdGhlIG1pZGRsZS5cbiAgICAgICAgICAgICAgICB2YXIgcCA9IGRpZmZWZWMyKHRlbXAkNSwgb3V0cHV0LnBvaW50QSwgb3V0cHV0LnBvaW50Qik7XG4gICAgICAgICAgICAgICAgY29weVZlYzIob3V0cHV0LnBvaW50QSwgcCk7XG4gICAgICAgICAgICAgICAgY29weVZlYzIob3V0cHV0LnBvaW50QiwgcCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmRpc3RhbmNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpc3RhbmNlIHByb3h5IGlzIHVzZWQgYnkgdGhlIEdKSyBhbGdvcml0aG0uIEl0IGVuY2Fwc3VsYXRlcyBhbnkgc2hhcGUuXG4gICAgICovXG4gICAgdmFyIERpc3RhbmNlUHJveHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERpc3RhbmNlUHJveHkoKSB7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMubV92ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoaXM/XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMubV9jb3VudCA9IDA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMubV9yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIERpc3RhbmNlUHJveHkucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1fdmVydGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLm1fcmFkaXVzID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdmVydGV4IGNvdW50LlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuZ2V0VmVydGV4Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2NvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdmVydGV4IGJ5IGluZGV4LiBVc2VkIGJ5IERpc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuZ2V0VmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3ZlcnRpY2VzW2luZGV4XTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3VwcG9ydGluZyB2ZXJ0ZXggaW5kZXggaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlUHJveHkucHJvdG90eXBlLmdldFN1cHBvcnQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGJlc3RJbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkb3RWZWMyKHRoaXMubV92ZXJ0aWNlc1tpXSwgZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZXN0SW5kZXg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHN1cHBvcnRpbmcgdmVydGV4IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBEaXN0YW5jZVByb3h5LnByb3RvdHlwZS5nZXRTdXBwb3J0VmVydGV4ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbdGhpcy5nZXRTdXBwb3J0KGQpXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIHByb3h5IHVzaW5nIHRoZSBnaXZlbiBzaGFwZS4gVGhlIHNoYXBlIG11c3QgcmVtYWluIGluIHNjb3BlXG4gICAgICAgICAqIHdoaWxlIHRoZSBwcm94eSBpcyBpbiB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICBEaXN0YW5jZVByb3h5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoc2hhcGUsIGluZGV4KSB7XG4gICAgICAgICAgICBzaGFwZS5jb21wdXRlRGlzdGFuY2VQcm94eSh0aGlzLCBpbmRleCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBwcm94eSB1c2luZyBhIHZlcnRleCBjbG91ZCBhbmQgcmFkaXVzLiBUaGUgdmVydGljZXNcbiAgICAgICAgICogbXVzdCByZW1haW4gaW4gc2NvcGUgd2hpbGUgdGhlIHByb3h5IGlzIGluIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlUHJveHkucHJvdG90eXBlLnNldFZlcnRpY2VzID0gZnVuY3Rpb24gKHZlcnRpY2VzLCBjb3VudCwgcmFkaXVzKSB7XG4gICAgICAgICAgICB0aGlzLm1fdmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IGNvdW50O1xuICAgICAgICAgICAgdGhpcy5tX3JhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERpc3RhbmNlUHJveHk7XG4gICAgfSgpKTtcbiAgICB2YXIgU2ltcGxleFZlcnRleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2ltcGxleFZlcnRleCgpIHtcbiAgICAgICAgICAgIC8qKiBzdXBwb3J0IHBvaW50IGluIHByb3h5QSAqL1xuICAgICAgICAgICAgdGhpcy53QSA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICAvKiogd0EgaW5kZXggKi9cbiAgICAgICAgICAgIHRoaXMuaW5kZXhBID0gMDtcbiAgICAgICAgICAgIC8qKiBzdXBwb3J0IHBvaW50IGluIHByb3h5QiAqL1xuICAgICAgICAgICAgdGhpcy53QiA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICAvKiogd0IgaW5kZXggKi9cbiAgICAgICAgICAgIHRoaXMuaW5kZXhCID0gMDtcbiAgICAgICAgICAgIC8qKiB3QiAtIHdBOyAqL1xuICAgICAgICAgICAgdGhpcy53ID0gdmVjMigwLCAwKTtcbiAgICAgICAgICAgIC8qKiBiYXJ5Y2VudHJpYyBjb29yZGluYXRlIGZvciBjbG9zZXN0IHBvaW50ICovXG4gICAgICAgICAgICB0aGlzLmEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFNpbXBsZXhWZXJ0ZXgucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4QSA9IDA7XG4gICAgICAgICAgICB0aGlzLmluZGV4QiA9IDA7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLndBKTtcbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMud0IpO1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy53KTtcbiAgICAgICAgICAgIHRoaXMuYSA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIFNpbXBsZXhWZXJ0ZXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4QSA9IHYuaW5kZXhBO1xuICAgICAgICAgICAgdGhpcy5pbmRleEIgPSB2LmluZGV4QjtcbiAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMud0EsIHYud0EpO1xuICAgICAgICAgICAgY29weVZlYzIodGhpcy53Qiwgdi53Qik7XG4gICAgICAgICAgICBjb3B5VmVjMih0aGlzLncsIHYudyk7XG4gICAgICAgICAgICB0aGlzLmEgPSB2LmE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTaW1wbGV4VmVydGV4O1xuICAgIH0oKSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgc2VhcmNoRGlyZWN0aW9uX3JldXNlID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBjbG9zZXN0UG9pbnRfcmV1c2UgPSB2ZWMyKDAsIDApO1xuICAgIHZhciBTaW1wbGV4ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTaW1wbGV4KCkge1xuICAgICAgICAgICAgdGhpcy5tX3YxID0gbmV3IFNpbXBsZXhWZXJ0ZXgoKTtcbiAgICAgICAgICAgIHRoaXMubV92MiA9IG5ldyBTaW1wbGV4VmVydGV4KCk7XG4gICAgICAgICAgICB0aGlzLm1fdjMgPSBuZXcgU2ltcGxleFZlcnRleCgpO1xuICAgICAgICAgICAgdGhpcy5tX3YgPSBbdGhpcy5tX3YxLCB0aGlzLm1fdjIsIHRoaXMubV92M107XG4gICAgICAgIH1cbiAgICAgICAgU2ltcGxleC5wcm90b3R5cGUucmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubV92MS5yZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLm1fdjIucmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5tX3YzLnJlY3ljbGUoKTtcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gU2ltcGxleC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2NvdW50ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIitcIiArIHRoaXMubV9jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3YxLmEsIHRoaXMubV92MS53QS54LCB0aGlzLm1fdjEud0EueSwgdGhpcy5tX3YxLndCLngsIHRoaXMubV92MS53Qi55LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fdjIuYSwgdGhpcy5tX3YyLndBLngsIHRoaXMubV92Mi53QS55LCB0aGlzLm1fdjIud0IueCwgdGhpcy5tX3YyLndCLnksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV92My5hLCB0aGlzLm1fdjMud0EueCwgdGhpcy5tX3YzLndBLnksIHRoaXMubV92My53Qi54LCB0aGlzLm1fdjMud0IueVxuICAgICAgICAgICAgICAgIF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9jb3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCIrXCIgKyB0aGlzLm1fY291bnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV92MS5hLCB0aGlzLm1fdjEud0EueCwgdGhpcy5tX3YxLndBLnksIHRoaXMubV92MS53Qi54LCB0aGlzLm1fdjEud0IueSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3YyLmEsIHRoaXMubV92Mi53QS54LCB0aGlzLm1fdjIud0EueSwgdGhpcy5tX3YyLndCLngsIHRoaXMubV92Mi53Qi55XG4gICAgICAgICAgICAgICAgXS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIitcIiArIHRoaXMubV9jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3YxLmEsIHRoaXMubV92MS53QS54LCB0aGlzLm1fdjEud0EueSwgdGhpcy5tX3YxLndCLngsIHRoaXMubV92MS53Qi55XG4gICAgICAgICAgICAgICAgXS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiK1wiICsgdGhpcy5tX2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTaW1wbGV4LnByb3RvdHlwZS5yZWFkQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUsIHByb3h5QSwgdHJhbnNmb3JtQSwgcHJveHlCLCB0cmFuc2Zvcm1CKSB7XG4gICAgICAgICAgICAvLyBDb3B5IGRhdGEgZnJvbSBjYWNoZS5cbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IGNhY2hlLmNvdW50O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5tX3ZbaV07XG4gICAgICAgICAgICAgICAgdi5pbmRleEEgPSBjYWNoZS5pbmRleEFbaV07XG4gICAgICAgICAgICAgICAgdi5pbmRleEIgPSBjYWNoZS5pbmRleEJbaV07XG4gICAgICAgICAgICAgICAgdmFyIHdBTG9jYWwgPSBwcm94eUEuZ2V0VmVydGV4KHYuaW5kZXhBKTtcbiAgICAgICAgICAgICAgICB2YXIgd0JMb2NhbCA9IHByb3h5Qi5nZXRWZXJ0ZXgodi5pbmRleEIpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZlYzIodi53QSwgdHJhbnNmb3JtQSwgd0FMb2NhbCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMih2LndCLCB0cmFuc2Zvcm1CLCB3QkxvY2FsKTtcbiAgICAgICAgICAgICAgICBkaWZmVmVjMih2LncsIHYud0IsIHYud0EpO1xuICAgICAgICAgICAgICAgIHYuYSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG5ldyBzaW1wbGV4IG1ldHJpYywgaWYgaXQgaXMgc3Vic3RhbnRpYWxseSBkaWZmZXJlbnQgdGhhblxuICAgICAgICAgICAgLy8gb2xkIG1ldHJpYyB0aGVuIGZsdXNoIHRoZSBzaW1wbGV4LlxuICAgICAgICAgICAgaWYgKHRoaXMubV9jb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0cmljMSA9IGNhY2hlLm1ldHJpYztcbiAgICAgICAgICAgICAgICB2YXIgbWV0cmljMiA9IHRoaXMuZ2V0TWV0cmljKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldHJpYzIgPCAwLjUgKiBtZXRyaWMxIHx8IDIuMCAqIG1ldHJpYzEgPCBtZXRyaWMyIHx8IG1ldHJpYzIgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBzaW1wbGV4LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjYWNoZSBpcyBlbXB0eSBvciBpbnZhbGlkLi4uXG4gICAgICAgICAgICBpZiAodGhpcy5tX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLm1fdlswXTtcbiAgICAgICAgICAgICAgICB2LmluZGV4QSA9IDA7XG4gICAgICAgICAgICAgICAgdi5pbmRleEIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB3QUxvY2FsID0gcHJveHlBLmdldFZlcnRleCgwKTtcbiAgICAgICAgICAgICAgICB2YXIgd0JMb2NhbCA9IHByb3h5Qi5nZXRWZXJ0ZXgoMCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMih2LndBLCB0cmFuc2Zvcm1BLCB3QUxvY2FsKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHYud0IsIHRyYW5zZm9ybUIsIHdCTG9jYWwpO1xuICAgICAgICAgICAgICAgIGRpZmZWZWMyKHYudywgdi53Qiwgdi53QSk7XG4gICAgICAgICAgICAgICAgdi5hID0gMS4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNpbXBsZXgucHJvdG90eXBlLndyaXRlQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgIGNhY2hlLm1ldHJpYyA9IHRoaXMuZ2V0TWV0cmljKCk7XG4gICAgICAgICAgICBjYWNoZS5jb3VudCA9IHRoaXMubV9jb3VudDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5pbmRleEFbaV0gPSB0aGlzLm1fdltpXS5pbmRleEE7XG4gICAgICAgICAgICAgICAgY2FjaGUuaW5kZXhCW2ldID0gdGhpcy5tX3ZbaV0uaW5kZXhCO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTaW1wbGV4LnByb3RvdHlwZS5nZXRTZWFyY2hEaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdjEgPSB0aGlzLm1fdjE7XG4gICAgICAgICAgICB2YXIgdjIgPSB0aGlzLm1fdjI7XG4gICAgICAgICAgICB0aGlzLm1fdjM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFZlYzIoc2VhcmNoRGlyZWN0aW9uX3JldXNlLCAtdjEudy54LCAtdjEudy55KTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZlZlYzIoZTEyLCB2Mi53LCB2MS53KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNnbiA9IC1jcm9zc1ZlYzJWZWMyKGUxMiwgdjEudyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZ24gPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbiBpcyBsZWZ0IG9mIGUxMi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRWZWMyKHNlYXJjaERpcmVjdGlvbl9yZXVzZSwgLWUxMi55LCBlMTIueCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW4gaXMgcmlnaHQgb2YgZTEyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFZlYzIoc2VhcmNoRGlyZWN0aW9uX3JldXNlLCBlMTIueSwgLWUxMi54KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gemVyb1ZlYzIoc2VhcmNoRGlyZWN0aW9uX3JldXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2ltcGxleC5wcm90b3R5cGUuZ2V0Q2xvc2VzdFBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHYxID0gdGhpcy5tX3YxO1xuICAgICAgICAgICAgdmFyIHYyID0gdGhpcy5tX3YyO1xuICAgICAgICAgICAgdGhpcy5tX3YzO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1fY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvVmVjMihjbG9zZXN0UG9pbnRfcmV1c2UpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcHlWZWMyKGNsb3Nlc3RQb2ludF9yZXVzZSwgdjEudyk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluZVZlYzIoY2xvc2VzdFBvaW50X3JldXNlLCB2MS5hLCB2MS53LCB2Mi5hLCB2Mi53KTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvVmVjMihjbG9zZXN0UG9pbnRfcmV1c2UpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvVmVjMihjbG9zZXN0UG9pbnRfcmV1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTaW1wbGV4LnByb3RvdHlwZS5nZXRXaXRuZXNzUG9pbnRzID0gZnVuY3Rpb24gKHBBLCBwQikge1xuICAgICAgICAgICAgdmFyIHYxID0gdGhpcy5tX3YxO1xuICAgICAgICAgICAgdmFyIHYyID0gdGhpcy5tX3YyO1xuICAgICAgICAgICAgdmFyIHYzID0gdGhpcy5tX3YzO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1fY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIocEEsIHYxLndBKTtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIocEIsIHYxLndCKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjb21iaW5lVmVjMihwQSwgdjEuYSwgdjEud0EsIHYyLmEsIHYyLndBKTtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZVZlYzIocEIsIHYxLmEsIHYxLndCLCB2Mi5hLCB2Mi53Qik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcEIueCA9IHBBLnggPSB2MS5hICogdjEud0EueCArIHYyLmEgKiB2Mi53QS54ICsgdjMuYSAqIHYzLndBLng7XG4gICAgICAgICAgICAgICAgICAgIHBCLnkgPSBwQS55ID0gdjEuYSAqIHYxLndBLnkgKyB2Mi5hICogdjIud0EueSArIHYzLmEgKiB2My53QS55O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2ltcGxleC5wcm90b3R5cGUuZ2V0TWV0cmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1fY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpc3RWZWMyKHRoaXMubV92MS53LCB0aGlzLm1fdjIudyk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NWZWMyVmVjMihkaWZmVmVjMih0ZW1wMSwgdGhpcy5tX3YyLncsIHRoaXMubV92MS53KSwgZGlmZlZlYzIodGVtcDIsIHRoaXMubV92My53LCB0aGlzLm1fdjEudykpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNpbXBsZXgucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1fY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2x2ZTIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvbHZlMygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gU29sdmUgYSBsaW5lIHNlZ21lbnQgdXNpbmcgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHAgPSBhMSAqIHcxICsgYTIgKiB3MlxuICAgICAgICAvLyBhMSArIGEyID0gMVxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgdmVjdG9yIGZyb20gdGhlIG9yaWdpbiB0byB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgbGluZSBpc1xuICAgICAgICAvLyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBsaW5lLlxuICAgICAgICAvLyBlMTIgPSB3MiAtIHcxXG4gICAgICAgIC8vIGRvdChwLCBlKSA9IDBcbiAgICAgICAgLy8gYTEgKiBkb3QodzEsIGUpICsgYTIgKiBkb3QodzIsIGUpID0gMFxuICAgICAgICAvL1xuICAgICAgICAvLyAyLWJ5LTIgbGluZWFyIHN5c3RlbVxuICAgICAgICAvLyBbMSAxIF1bYTFdID0gWzFdXG4gICAgICAgIC8vIFt3MS5lMTIgdzIuZTEyXVthMl0gPSBbMF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVmaW5lXG4gICAgICAgIC8vIGQxMl8xID0gZG90KHcyLCBlMTIpXG4gICAgICAgIC8vIGQxMl8yID0gLWRvdCh3MSwgZTEyKVxuICAgICAgICAvLyBkMTIgPSBkMTJfMSArIGQxMl8yXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNvbHV0aW9uXG4gICAgICAgIC8vIGExID0gZDEyXzEgLyBkMTJcbiAgICAgICAgLy8gYTIgPSBkMTJfMiAvIGQxMlxuICAgICAgICBTaW1wbGV4LnByb3RvdHlwZS5zb2x2ZTIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdzEgPSB0aGlzLm1fdjEudztcbiAgICAgICAgICAgIHZhciB3MiA9IHRoaXMubV92Mi53O1xuICAgICAgICAgICAgZGlmZlZlYzIoZTEyLCB3MiwgdzEpO1xuICAgICAgICAgICAgLy8gdzEgcmVnaW9uXG4gICAgICAgICAgICB2YXIgZDEyXzIgPSAtZG90VmVjMih3MSwgZTEyKTtcbiAgICAgICAgICAgIGlmIChkMTJfMiA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICAvLyBhMiA8PSAwLCBzbyB3ZSBjbGFtcCBpdCB0byAwXG4gICAgICAgICAgICAgICAgdGhpcy5tX3YxLmEgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3MiByZWdpb25cbiAgICAgICAgICAgIHZhciBkMTJfMSA9IGRvdFZlYzIodzIsIGUxMik7XG4gICAgICAgICAgICBpZiAoZDEyXzEgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgLy8gYTEgPD0gMCwgc28gd2UgY2xhbXAgaXQgdG8gMFxuICAgICAgICAgICAgICAgIHRoaXMubV92Mi5hID0gMS4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YxLnNldCh0aGlzLm1fdjIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE11c3QgYmUgaW4gZTEyIHJlZ2lvbi5cbiAgICAgICAgICAgIHZhciBpbnZfZDEyID0gMS4wIC8gKGQxMl8xICsgZDEyXzIpO1xuICAgICAgICAgICAgdGhpcy5tX3YxLmEgPSBkMTJfMSAqIGludl9kMTI7XG4gICAgICAgICAgICB0aGlzLm1fdjIuYSA9IGQxMl8yICogaW52X2QxMjtcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFBvc3NpYmxlIHJlZ2lvbnM6XG4gICAgICAgIC8vIC0gcG9pbnRzWzJdXG4gICAgICAgIC8vIC0gZWRnZSBwb2ludHNbMF0tcG9pbnRzWzJdXG4gICAgICAgIC8vIC0gZWRnZSBwb2ludHNbMV0tcG9pbnRzWzJdXG4gICAgICAgIC8vIC0gaW5zaWRlIHRoZSB0cmlhbmdsZVxuICAgICAgICBTaW1wbGV4LnByb3RvdHlwZS5zb2x2ZTMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdzEgPSB0aGlzLm1fdjEudztcbiAgICAgICAgICAgIHZhciB3MiA9IHRoaXMubV92Mi53O1xuICAgICAgICAgICAgdmFyIHczID0gdGhpcy5tX3YzLnc7XG4gICAgICAgICAgICAvLyBFZGdlMTJcbiAgICAgICAgICAgIC8vIFsxIDEgXVthMV0gPSBbMV1cbiAgICAgICAgICAgIC8vIFt3MS5lMTIgdzIuZTEyXVthMl0gPSBbMF1cbiAgICAgICAgICAgIC8vIGEzID0gMFxuICAgICAgICAgICAgZGlmZlZlYzIoZTEyLCB3MiwgdzEpO1xuICAgICAgICAgICAgdmFyIHcxZTEyID0gZG90VmVjMih3MSwgZTEyKTtcbiAgICAgICAgICAgIHZhciB3MmUxMiA9IGRvdFZlYzIodzIsIGUxMik7XG4gICAgICAgICAgICB2YXIgZDEyXzEgPSB3MmUxMjtcbiAgICAgICAgICAgIHZhciBkMTJfMiA9IC13MWUxMjtcbiAgICAgICAgICAgIC8vIEVkZ2UxM1xuICAgICAgICAgICAgLy8gWzEgMSBdW2ExXSA9IFsxXVxuICAgICAgICAgICAgLy8gW3cxLmUxMyB3My5lMTNdW2EzXSA9IFswXVxuICAgICAgICAgICAgLy8gYTIgPSAwXG4gICAgICAgICAgICBkaWZmVmVjMihlMTMsIHczLCB3MSk7XG4gICAgICAgICAgICB2YXIgdzFlMTMgPSBkb3RWZWMyKHcxLCBlMTMpO1xuICAgICAgICAgICAgdmFyIHczZTEzID0gZG90VmVjMih3MywgZTEzKTtcbiAgICAgICAgICAgIHZhciBkMTNfMSA9IHczZTEzO1xuICAgICAgICAgICAgdmFyIGQxM18yID0gLXcxZTEzO1xuICAgICAgICAgICAgLy8gRWRnZTIzXG4gICAgICAgICAgICAvLyBbMSAxIF1bYTJdID0gWzFdXG4gICAgICAgICAgICAvLyBbdzIuZTIzIHczLmUyM11bYTNdID0gWzBdXG4gICAgICAgICAgICAvLyBhMSA9IDBcbiAgICAgICAgICAgIGRpZmZWZWMyKGUyMywgdzMsIHcyKTtcbiAgICAgICAgICAgIHZhciB3MmUyMyA9IGRvdFZlYzIodzIsIGUyMyk7XG4gICAgICAgICAgICB2YXIgdzNlMjMgPSBkb3RWZWMyKHczLCBlMjMpO1xuICAgICAgICAgICAgdmFyIGQyM18xID0gdzNlMjM7XG4gICAgICAgICAgICB2YXIgZDIzXzIgPSAtdzJlMjM7XG4gICAgICAgICAgICAvLyBUcmlhbmdsZTEyM1xuICAgICAgICAgICAgdmFyIG4xMjMgPSBjcm9zc1ZlYzJWZWMyKGUxMiwgZTEzKTtcbiAgICAgICAgICAgIHZhciBkMTIzXzEgPSBuMTIzICogY3Jvc3NWZWMyVmVjMih3MiwgdzMpO1xuICAgICAgICAgICAgdmFyIGQxMjNfMiA9IG4xMjMgKiBjcm9zc1ZlYzJWZWMyKHczLCB3MSk7XG4gICAgICAgICAgICB2YXIgZDEyM18zID0gbjEyMyAqIGNyb3NzVmVjMlZlYzIodzEsIHcyKTtcbiAgICAgICAgICAgIC8vIHcxIHJlZ2lvblxuICAgICAgICAgICAgaWYgKGQxMl8yIDw9IDAuMCAmJiBkMTNfMiA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjEuYSA9IDEuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fY291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGUxMlxuICAgICAgICAgICAgaWYgKGQxMl8xID4gMC4wICYmIGQxMl8yID4gMC4wICYmIGQxMjNfMyA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW52X2QxMiA9IDEuMCAvIChkMTJfMSArIGQxMl8yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjEuYSA9IGQxMl8xICogaW52X2QxMjtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjIuYSA9IGQxMl8yICogaW52X2QxMjtcbiAgICAgICAgICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGUxM1xuICAgICAgICAgICAgaWYgKGQxM18xID4gMC4wICYmIGQxM18yID4gMC4wICYmIGQxMjNfMiA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW52X2QxMyA9IDEuMCAvIChkMTNfMSArIGQxM18yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjEuYSA9IGQxM18xICogaW52X2QxMztcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjMuYSA9IGQxM18yICogaW52X2QxMztcbiAgICAgICAgICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xuICAgICAgICAgICAgICAgIHRoaXMubV92Mi5zZXQodGhpcy5tX3YzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3MiByZWdpb25cbiAgICAgICAgICAgIGlmIChkMTJfMSA8PSAwLjAgJiYgZDIzXzIgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YyLmEgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjEuc2V0KHRoaXMubV92Mik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdzMgcmVnaW9uXG4gICAgICAgICAgICBpZiAoZDEzXzEgPD0gMC4wICYmIGQyM18xIDw9IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV92My5hID0gMS4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3YxLnNldCh0aGlzLm1fdjMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGUyM1xuICAgICAgICAgICAgaWYgKGQyM18xID4gMC4wICYmIGQyM18yID4gMC4wICYmIGQxMjNfMSA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW52X2QyMyA9IDEuMCAvIChkMjNfMSArIGQyM18yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjIuYSA9IGQyM18xICogaW52X2QyMztcbiAgICAgICAgICAgICAgICB0aGlzLm1fdjMuYSA9IGQyM18yICogaW52X2QyMztcbiAgICAgICAgICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xuICAgICAgICAgICAgICAgIHRoaXMubV92MS5zZXQodGhpcy5tX3YzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNdXN0IGJlIGluIHRyaWFuZ2xlMTIzXG4gICAgICAgICAgICB2YXIgaW52X2QxMjMgPSAxLjAgLyAoZDEyM18xICsgZDEyM18yICsgZDEyM18zKTtcbiAgICAgICAgICAgIHRoaXMubV92MS5hID0gZDEyM18xICogaW52X2QxMjM7XG4gICAgICAgICAgICB0aGlzLm1fdjIuYSA9IGQxMjNfMiAqIGludl9kMTIzO1xuICAgICAgICAgICAgdGhpcy5tX3YzLmEgPSBkMTIzXzMgKiBpbnZfZDEyMztcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTaW1wbGV4O1xuICAgIH0oKSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgc2ltcGxleCA9IG5ldyBTaW1wbGV4KCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgaW5wdXQkMSA9IG5ldyBEaXN0YW5jZUlucHV0KCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY2FjaGUkMSA9IG5ldyBTaW1wbGV4Q2FjaGUoKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBvdXRwdXQkMSA9IG5ldyBEaXN0YW5jZU91dHB1dCgpO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0d28gZ2VuZXJpYyBzaGFwZXMgb3ZlcmxhcC5cbiAgICAgKi9cbiAgICB2YXIgdGVzdE92ZXJsYXAgPSBmdW5jdGlvbiAoc2hhcGVBLCBpbmRleEEsIHNoYXBlQiwgaW5kZXhCLCB4ZkEsIHhmQikge1xuICAgICAgICBpbnB1dCQxLnJlY3ljbGUoKTtcbiAgICAgICAgaW5wdXQkMS5wcm94eUEuc2V0KHNoYXBlQSwgaW5kZXhBKTtcbiAgICAgICAgaW5wdXQkMS5wcm94eUIuc2V0KHNoYXBlQiwgaW5kZXhCKTtcbiAgICAgICAgY29weVRyYW5zZm9ybShpbnB1dCQxLnRyYW5zZm9ybUEsIHhmQSk7XG4gICAgICAgIGNvcHlUcmFuc2Zvcm0oaW5wdXQkMS50cmFuc2Zvcm1CLCB4ZkIpO1xuICAgICAgICBpbnB1dCQxLnVzZVJhZGlpID0gdHJ1ZTtcbiAgICAgICAgb3V0cHV0JDEucmVjeWNsZSgpO1xuICAgICAgICBjYWNoZSQxLnJlY3ljbGUoKTtcbiAgICAgICAgRGlzdGFuY2Uob3V0cHV0JDEsIGNhY2hlJDEsIGlucHV0JDEpO1xuICAgICAgICByZXR1cm4gb3V0cHV0JDEuZGlzdGFuY2UgPCAxMC4wICogRVBTSUxPTjtcbiAgICB9O1xuICAgIC8vIGxlZ2FjeSBleHBvcnRzXG4gICAgRGlzdGFuY2UudGVzdE92ZXJsYXAgPSB0ZXN0T3ZlcmxhcDtcbiAgICBEaXN0YW5jZS5JbnB1dCA9IERpc3RhbmNlSW5wdXQ7XG4gICAgRGlzdGFuY2UuT3V0cHV0ID0gRGlzdGFuY2VPdXRwdXQ7XG4gICAgRGlzdGFuY2UuUHJveHkgPSBEaXN0YW5jZVByb3h5O1xuICAgIERpc3RhbmNlLkNhY2hlID0gU2ltcGxleENhY2hlO1xuICAgIC8qKlxuICAgICAqIElucHV0IHBhcmFtZXRlcnMgZm9yIFNoYXBlQ2FzdFxuICAgICAqL1xuICAgIHZhciBTaGFwZUNhc3RJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2hhcGVDYXN0SW5wdXQoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5QSA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgICAgICAgICB0aGlzLnByb3h5QiA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUEgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQiA9IFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvbkIgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgfVxuICAgICAgICBTaGFwZUNhc3RJbnB1dC5wcm90b3R5cGUucmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucHJveHlBLnJlY3ljbGUoKTtcbiAgICAgICAgICAgIHRoaXMucHJveHlCLnJlY3ljbGUoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQS5zZXRJZGVudGl0eSgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1CLnNldElkZW50aXR5KCk7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLnRyYW5zbGF0aW9uQik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTaGFwZUNhc3RJbnB1dDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE91dHB1dCByZXN1bHRzIGZvciBiMlNoYXBlQ2FzdFxuICAgICAqL1xuICAgIHZhciBTaGFwZUNhc3RPdXRwdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNoYXBlQ2FzdE91dHB1dCgpIHtcbiAgICAgICAgICAgIHRoaXMucG9pbnQgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLmxhbWJkYSA9IDEuMDtcbiAgICAgICAgICAgIHRoaXMuaXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNoYXBlQ2FzdE91dHB1dDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBsaW5lYXIgc2hhcGUgY2FzdCBvZiBzaGFwZSBCIG1vdmluZyBhbmQgc2hhcGUgQSBmaXhlZC4gRGV0ZXJtaW5lc1xuICAgICAqIHRoZSBoaXQgcG9pbnQsIG5vcm1hbCwgYW5kIHRyYW5zbGF0aW9uIGZyYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBoaXQsIGZhbHNlIGlmIHRoZXJlIGlzIG5vIGhpdCBvciBhbiBpbml0aWFsIG92ZXJsYXBcbiAgICAgKi9cbiAgICAvL1xuICAgIC8vIEdKSy1yYXljYXN0XG4gICAgLy8gQWxnb3JpdGhtIGJ5IEdpbm8gdmFuIGRlbiBCZXJnZW4uXG4gICAgLy8gXCJTbW9vdGggTWVzaCBDb250YWN0cyB3aXRoIEdKS1wiIGluIEdhbWUgUGh5c2ljcyBQZWFybHMuIDIwMTBcbiAgICB2YXIgU2hhcGVDYXN0ID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQpIHtcbiAgICAgICAgb3V0cHV0Lml0ZXJhdGlvbnMgPSAwO1xuICAgICAgICBvdXRwdXQubGFtYmRhID0gMS4wO1xuICAgICAgICBvdXRwdXQubm9ybWFsLnNldFplcm8oKTtcbiAgICAgICAgb3V0cHV0LnBvaW50LnNldFplcm8oKTtcbiAgICAgICAgdmFyIHByb3h5QSA9IGlucHV0LnByb3h5QTtcbiAgICAgICAgdmFyIHByb3h5QiA9IGlucHV0LnByb3h5QjtcbiAgICAgICAgdmFyIHJhZGl1c0EgPSBtYXRoX21heCQ0KHByb3h5QS5tX3JhZGl1cywgU2V0dGluZ3NJbnRlcm5hbC5wb2x5Z29uUmFkaXVzKTtcbiAgICAgICAgdmFyIHJhZGl1c0IgPSBtYXRoX21heCQ0KHByb3h5Qi5tX3JhZGl1cywgU2V0dGluZ3NJbnRlcm5hbC5wb2x5Z29uUmFkaXVzKTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c0EgKyByYWRpdXNCO1xuICAgICAgICB2YXIgeGZBID0gaW5wdXQudHJhbnNmb3JtQTtcbiAgICAgICAgdmFyIHhmQiA9IGlucHV0LnRyYW5zZm9ybUI7XG4gICAgICAgIHZhciByID0gaW5wdXQudHJhbnNsYXRpb25CO1xuICAgICAgICB2YXIgbiA9IFZlYzIuemVybygpO1xuICAgICAgICB2YXIgbGFtYmRhID0gMC4wO1xuICAgICAgICAvLyBJbml0aWFsIHNpbXBsZXhcbiAgICAgICAgdmFyIHNpbXBsZXggPSBuZXcgU2ltcGxleCgpO1xuICAgICAgICBzaW1wbGV4Lm1fY291bnQgPSAwO1xuICAgICAgICAvLyBHZXQgc2ltcGxleCB2ZXJ0aWNlcyBhcyBhbiBhcnJheS5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gc2ltcGxleC5tX3Y7XG4gICAgICAgIC8vIEdldCBzdXBwb3J0IHBvaW50IGluIC1yIGRpcmVjdGlvblxuICAgICAgICB2YXIgaW5kZXhBID0gcHJveHlBLmdldFN1cHBvcnQoUm90Lm11bFRWZWMyKHhmQS5xLCBWZWMyLm5lZyhyKSkpO1xuICAgICAgICB2YXIgd0EgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIHByb3h5QS5nZXRWZXJ0ZXgoaW5kZXhBKSk7XG4gICAgICAgIHZhciBpbmRleEIgPSBwcm94eUIuZ2V0U3VwcG9ydChSb3QubXVsVFZlYzIoeGZCLnEsIHIpKTtcbiAgICAgICAgdmFyIHdCID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCBwcm94eUIuZ2V0VmVydGV4KGluZGV4QikpO1xuICAgICAgICB2YXIgdiA9IFZlYzIuc3ViKHdBLCB3Qik7XG4gICAgICAgIC8vIFNpZ21hIGlzIHRoZSB0YXJnZXQgZGlzdGFuY2UgYmV0d2VlbiBwb2x5Z29uc1xuICAgICAgICB2YXIgc2lnbWEgPSBtYXRoX21heCQ0KFNldHRpbmdzSW50ZXJuYWwucG9seWdvblJhZGl1cywgcmFkaXVzIC0gU2V0dGluZ3NJbnRlcm5hbC5wb2x5Z29uUmFkaXVzKTtcbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IDAuNSAqIFNldHRpbmdzSW50ZXJuYWwubGluZWFyU2xvcDtcbiAgICAgICAgLy8gTWFpbiBpdGVyYXRpb24gbG9vcC5cbiAgICAgICAgdmFyIGtfbWF4SXRlcnMgPSAyMDtcbiAgICAgICAgdmFyIGl0ZXIgPSAwO1xuICAgICAgICB3aGlsZSAoaXRlciA8IGtfbWF4SXRlcnMgJiYgdi5sZW5ndGgoKSAtIHNpZ21hID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBvdXRwdXQuaXRlcmF0aW9ucyArPSAxO1xuICAgICAgICAgICAgLy8gU3VwcG9ydCBpbiBkaXJlY3Rpb24gLXYgKEEgLSBCKVxuICAgICAgICAgICAgaW5kZXhBID0gcHJveHlBLmdldFN1cHBvcnQoUm90Lm11bFRWZWMyKHhmQS5xLCBWZWMyLm5lZyh2KSkpO1xuICAgICAgICAgICAgd0EgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEsIHByb3h5QS5nZXRWZXJ0ZXgoaW5kZXhBKSk7XG4gICAgICAgICAgICBpbmRleEIgPSBwcm94eUIuZ2V0U3VwcG9ydChSb3QubXVsVFZlYzIoeGZCLnEsIHYpKTtcbiAgICAgICAgICAgIHdCID0gVHJhbnNmb3JtLm11bFZlYzIoeGZCLCBwcm94eUIuZ2V0VmVydGV4KGluZGV4QikpO1xuICAgICAgICAgICAgdmFyIHAgPSBWZWMyLnN1Yih3QSwgd0IpO1xuICAgICAgICAgICAgLy8gLXYgaXMgYSBub3JtYWwgYXQgcFxuICAgICAgICAgICAgdi5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIC8vIEludGVyc2VjdCByYXkgd2l0aCBwbGFuZVxuICAgICAgICAgICAgdmFyIHZwID0gVmVjMi5kb3QodiwgcCk7XG4gICAgICAgICAgICB2YXIgdnIgPSBWZWMyLmRvdCh2LCByKTtcbiAgICAgICAgICAgIGlmICh2cCAtIHNpZ21hID4gbGFtYmRhICogdnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodnIgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFtYmRhID0gKHZwIC0gc2lnbWEpIC8gdnI7XG4gICAgICAgICAgICAgICAgaWYgKGxhbWJkYSA+IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4uc2V0TXVsKC0xLCB2KTtcbiAgICAgICAgICAgICAgICBzaW1wbGV4Lm1fY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV2ZXJzZSBzaW1wbGV4IHNpbmNlIGl0IHdvcmtzIHdpdGggQiAtIEEuXG4gICAgICAgICAgICAvLyBTaGlmdCBieSBsYW1iZGEgKiByIGJlY2F1c2Ugd2Ugd2FudCB0aGUgY2xvc2VzdCBwb2ludCB0byB0aGUgY3VycmVudCBjbGlwIHBvaW50LlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzdXBwb3J0IHBvaW50IHAgaXMgbm90IHNoaWZ0ZWQgYmVjYXVzZSB3ZSB3YW50IHRoZSBwbGFuZSBlcXVhdGlvblxuICAgICAgICAgICAgLy8gdG8gYmUgZm9ybWVkIGluIHVuc2hpZnRlZCBzcGFjZS5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1tzaW1wbGV4Lm1fY291bnRdO1xuICAgICAgICAgICAgdmVydGV4LmluZGV4QSA9IGluZGV4QjtcbiAgICAgICAgICAgIHZlcnRleC53QSA9IFZlYzIuY29tYmluZSgxLCB3QiwgbGFtYmRhLCByKTtcbiAgICAgICAgICAgIHZlcnRleC5pbmRleEIgPSBpbmRleEE7XG4gICAgICAgICAgICB2ZXJ0ZXgud0IgPSB3QTtcbiAgICAgICAgICAgIHZlcnRleC53ID0gVmVjMi5zdWIodmVydGV4LndCLCB2ZXJ0ZXgud0EpO1xuICAgICAgICAgICAgdmVydGV4LmEgPSAxLjA7XG4gICAgICAgICAgICBzaW1wbGV4Lm1fY291bnQgKz0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAoc2ltcGxleC5tX2NvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHNpbXBsZXguc29sdmUyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxleC5zb2x2ZTMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIDMgcG9pbnRzLCB0aGVuIHRoZSBvcmlnaW4gaXMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgdHJpYW5nbGUuXG4gICAgICAgICAgICBpZiAoc2ltcGxleC5tX2NvdW50ID09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBPdmVybGFwXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHNlYXJjaCBkaXJlY3Rpb24uXG4gICAgICAgICAgICB2LnNldFZlYzIoc2ltcGxleC5nZXRDbG9zZXN0UG9pbnQoKSk7XG4gICAgICAgICAgICAvLyBJdGVyYXRpb24gY291bnQgaXMgZXF1YXRlZCB0byB0aGUgbnVtYmVyIG9mIHN1cHBvcnQgcG9pbnQgY2FsbHMuXG4gICAgICAgICAgICArK2l0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZXIgPT0gMCkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbCBvdmVybGFwXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBvdXRwdXQuXG4gICAgICAgIHZhciBwb2ludEEgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgdmFyIHBvaW50QiA9IFZlYzIuemVybygpO1xuICAgICAgICBzaW1wbGV4LmdldFdpdG5lc3NQb2ludHMocG9pbnRCLCBwb2ludEEpO1xuICAgICAgICBpZiAodi5sZW5ndGhTcXVhcmVkKCkgPiAwLjApIHtcbiAgICAgICAgICAgIG4uc2V0TXVsKC0xLCB2KTtcbiAgICAgICAgICAgIG4ubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnBvaW50ID0gVmVjMi5jb21iaW5lKDEsIHBvaW50QSwgcmFkaXVzQSwgbik7XG4gICAgICAgIG91dHB1dC5ub3JtYWwgPSBuO1xuICAgICAgICBvdXRwdXQubGFtYmRhID0gbGFtYmRhO1xuICAgICAgICBvdXRwdXQuaXRlcmF0aW9ucyA9IGl0ZXI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9hYnMkNyA9IE1hdGguYWJzO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfbWF4JDMgPSBNYXRoLm1heDtcbiAgICAvKipcbiAgICAgKiBJbnB1dCBwYXJhbWV0ZXJzIGZvciBUaW1lT2ZJbXBhY3QuXG4gICAgICovXG4gICAgdmFyIFRPSUlucHV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUT0lJbnB1dCgpIHtcbiAgICAgICAgICAgIHRoaXMucHJveHlBID0gbmV3IERpc3RhbmNlUHJveHkoKTtcbiAgICAgICAgICAgIHRoaXMucHJveHlCID0gbmV3IERpc3RhbmNlUHJveHkoKTtcbiAgICAgICAgICAgIHRoaXMuc3dlZXBBID0gbmV3IFN3ZWVwKCk7XG4gICAgICAgICAgICB0aGlzLnN3ZWVwQiA9IG5ldyBTd2VlcCgpO1xuICAgICAgICB9XG4gICAgICAgIFRPSUlucHV0LnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wcm94eUEucmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm94eUIucmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5zd2VlcEEucmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5zd2VlcEIucmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy50TWF4ID0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUT0lJbnB1dDtcbiAgICB9KCkpO1xuICAgIGV4cG9ydHMuVE9JT3V0cHV0U3RhdGUgPSB2b2lkIDA7XG4gICAgKGZ1bmN0aW9uIChUT0lPdXRwdXRTdGF0ZSkge1xuICAgICAgICBUT0lPdXRwdXRTdGF0ZVtUT0lPdXRwdXRTdGF0ZVtcImVfdW5zZXRcIl0gPSAtMV0gPSBcImVfdW5zZXRcIjtcbiAgICAgICAgVE9JT3V0cHV0U3RhdGVbVE9JT3V0cHV0U3RhdGVbXCJlX3Vua25vd25cIl0gPSAwXSA9IFwiZV91bmtub3duXCI7XG4gICAgICAgIFRPSU91dHB1dFN0YXRlW1RPSU91dHB1dFN0YXRlW1wiZV9mYWlsZWRcIl0gPSAxXSA9IFwiZV9mYWlsZWRcIjtcbiAgICAgICAgVE9JT3V0cHV0U3RhdGVbVE9JT3V0cHV0U3RhdGVbXCJlX292ZXJsYXBwZWRcIl0gPSAyXSA9IFwiZV9vdmVybGFwcGVkXCI7XG4gICAgICAgIFRPSU91dHB1dFN0YXRlW1RPSU91dHB1dFN0YXRlW1wiZV90b3VjaGluZ1wiXSA9IDNdID0gXCJlX3RvdWNoaW5nXCI7XG4gICAgICAgIFRPSU91dHB1dFN0YXRlW1RPSU91dHB1dFN0YXRlW1wiZV9zZXBhcmF0ZWRcIl0gPSA0XSA9IFwiZV9zZXBhcmF0ZWRcIjtcbiAgICB9KShleHBvcnRzLlRPSU91dHB1dFN0YXRlIHx8IChleHBvcnRzLlRPSU91dHB1dFN0YXRlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBPdXRwdXQgcGFyYW1ldGVycyBmb3IgVGltZU9mSW1wYWN0LlxuICAgICAqL1xuICAgIHZhciBUT0lPdXRwdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRPSU91dHB1dCgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBleHBvcnRzLlRPSU91dHB1dFN0YXRlLmVfdW5zZXQ7XG4gICAgICAgICAgICB0aGlzLnQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBUT0lPdXRwdXQucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gZXhwb3J0cy5UT0lPdXRwdXRTdGF0ZS5lX3Vuc2V0O1xuICAgICAgICAgICAgdGhpcy50ID0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUT0lPdXRwdXQ7XG4gICAgfSgpKTtcbiAgICBzdGF0cy50b2lUaW1lID0gMDtcbiAgICBzdGF0cy50b2lNYXhUaW1lID0gMDtcbiAgICBzdGF0cy50b2lDYWxscyA9IDA7XG4gICAgc3RhdHMudG9pSXRlcnMgPSAwO1xuICAgIHN0YXRzLnRvaU1heEl0ZXJzID0gMDtcbiAgICBzdGF0cy50b2lSb290SXRlcnMgPSAwO1xuICAgIHN0YXRzLnRvaU1heFJvb3RJdGVycyA9IDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZGlzdGFuY2VJbnB1dCA9IG5ldyBEaXN0YW5jZUlucHV0KCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZGlzdGFuY2VPdXRwdXQgPSBuZXcgRGlzdGFuY2VPdXRwdXQoKTtcbiAgICAvLyB0aGlzIGlzIHBhc3NlZCB0byBEaXN0YW5jZSBhbmQgU2VwYXJhdGlvbkZ1bmN0aW9uXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY2FjaGUgPSBuZXcgU2ltcGxleENhY2hlKCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgeGZBJDEgPSB0cmFuc2Zvcm0oMCwgMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgeGZCJDEgPSB0cmFuc2Zvcm0oMCwgMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdGVtcCQ0ID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBwb2ludEEkMiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcG9pbnRCJDIgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG5vcm1hbCQzID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBheGlzQSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgYXhpc0IgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGxvY2FsUG9pbnRBID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBsb2NhbFBvaW50QiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgdXBwZXIgYm91bmQgb24gdGltZSBiZWZvcmUgdHdvIHNoYXBlcyBwZW5ldHJhdGUuIFRpbWUgaXNcbiAgICAgKiByZXByZXNlbnRlZCBhcyBhIGZyYWN0aW9uIGJldHdlZW4gWzAsdE1heF0uIFRoaXMgdXNlcyBhIHN3ZXB0IHNlcGFyYXRpbmcgYXhpc1xuICAgICAqIGFuZCBtYXkgbWlzcyBzb21lIGludGVybWVkaWF0ZSwgbm9uLXR1bm5lbGluZyBjb2xsaXNpb25zLiBJZiB5b3UgY2hhbmdlIHRoZVxuICAgICAqIHRpbWUgaW50ZXJ2YWwsIHlvdSBzaG91bGQgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluLlxuICAgICAqXG4gICAgICogTm90ZTogdXNlIERpc3RhbmNlIHRvIGNvbXB1dGUgdGhlIGNvbnRhY3QgcG9pbnQgYW5kIG5vcm1hbCBhdCB0aGUgdGltZSBvZlxuICAgICAqIGltcGFjdC5cbiAgICAgKlxuICAgICAqIENDRCB2aWEgdGhlIGxvY2FsIHNlcGFyYXRpbmcgYXhpcyBtZXRob2QuIFRoaXMgc2Vla3MgcHJvZ3Jlc3Npb24gYnkgY29tcHV0aW5nXG4gICAgICogdGhlIGxhcmdlc3QgdGltZSBhdCB3aGljaCBzZXBhcmF0aW9uIGlzIG1haW50YWluZWQuXG4gICAgICovXG4gICAgdmFyIFRpbWVPZkltcGFjdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0KSB7XG4gICAgICAgIHZhciB0aW1lciA9IFRpbWVyLm5vdygpO1xuICAgICAgICArK3N0YXRzLnRvaUNhbGxzO1xuICAgICAgICBvdXRwdXQuc3RhdGUgPSBleHBvcnRzLlRPSU91dHB1dFN0YXRlLmVfdW5rbm93bjtcbiAgICAgICAgb3V0cHV0LnQgPSBpbnB1dC50TWF4O1xuICAgICAgICB2YXIgcHJveHlBID0gaW5wdXQucHJveHlBOyAvLyBEaXN0YW5jZVByb3h5XG4gICAgICAgIHZhciBwcm94eUIgPSBpbnB1dC5wcm94eUI7IC8vIERpc3RhbmNlUHJveHlcbiAgICAgICAgdmFyIHN3ZWVwQSA9IGlucHV0LnN3ZWVwQTsgLy8gU3dlZXBcbiAgICAgICAgdmFyIHN3ZWVwQiA9IGlucHV0LnN3ZWVwQjsgLy8gU3dlZXBcbiAgICAgICAgLy8gTGFyZ2Ugcm90YXRpb25zIGNhbiBtYWtlIHRoZSByb290IGZpbmRlciBmYWlsLCBzbyB3ZSBub3JtYWxpemUgdGhlXG4gICAgICAgIC8vIHN3ZWVwIGFuZ2xlcy5cbiAgICAgICAgc3dlZXBBLm5vcm1hbGl6ZSgpO1xuICAgICAgICBzd2VlcEIubm9ybWFsaXplKCk7XG4gICAgICAgIHZhciB0TWF4ID0gaW5wdXQudE1heDtcbiAgICAgICAgdmFyIHRvdGFsUmFkaXVzID0gcHJveHlBLm1fcmFkaXVzICsgcHJveHlCLm1fcmFkaXVzO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbWF0aF9tYXgkMyhTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3AsIHRvdGFsUmFkaXVzIC0gMy4wICogU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbG9wKTtcbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IDAuMjUgKiBTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3A7XG4gICAgICAgIHZhciB0MSA9IDAuMDtcbiAgICAgICAgdmFyIGtfbWF4SXRlcmF0aW9ucyA9IFNldHRpbmdzSW50ZXJuYWwubWF4VE9JSXRlcmF0aW9ucztcbiAgICAgICAgdmFyIGl0ZXIgPSAwO1xuICAgICAgICAvLyBQcmVwYXJlIGlucHV0IGZvciBkaXN0YW5jZSBxdWVyeS5cbiAgICAgICAgLy8gY29uc3QgY2FjaGUgPSBuZXcgU2ltcGxleENhY2hlKCk7XG4gICAgICAgIGNhY2hlLnJlY3ljbGUoKTtcbiAgICAgICAgZGlzdGFuY2VJbnB1dC5wcm94eUEuc2V0VmVydGljZXMocHJveHlBLm1fdmVydGljZXMsIHByb3h5QS5tX2NvdW50LCBwcm94eUEubV9yYWRpdXMpO1xuICAgICAgICBkaXN0YW5jZUlucHV0LnByb3h5Qi5zZXRWZXJ0aWNlcyhwcm94eUIubV92ZXJ0aWNlcywgcHJveHlCLm1fY291bnQsIHByb3h5Qi5tX3JhZGl1cyk7XG4gICAgICAgIGRpc3RhbmNlSW5wdXQudXNlUmFkaWkgPSBmYWxzZTtcbiAgICAgICAgLy8gVGhlIG91dGVyIGxvb3AgcHJvZ3Jlc3NpdmVseSBhdHRlbXB0cyB0byBjb21wdXRlIG5ldyBzZXBhcmF0aW5nIGF4ZXMuXG4gICAgICAgIC8vIFRoaXMgbG9vcCB0ZXJtaW5hdGVzIHdoZW4gYW4gYXhpcyBpcyByZXBlYXRlZCAobm8gcHJvZ3Jlc3MgaXMgbWFkZSkuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBzd2VlcEEuZ2V0VHJhbnNmb3JtKHhmQSQxLCB0MSk7XG4gICAgICAgICAgICBzd2VlcEIuZ2V0VHJhbnNmb3JtKHhmQiQxLCB0MSk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gc2hhcGVzLiBXZSBjYW4gYWxzbyB1c2UgdGhlIHJlc3VsdHNcbiAgICAgICAgICAgIC8vIHRvIGdldCBhIHNlcGFyYXRpbmcgYXhpcy5cbiAgICAgICAgICAgIGNvcHlUcmFuc2Zvcm0oZGlzdGFuY2VJbnB1dC50cmFuc2Zvcm1BLCB4ZkEkMSk7XG4gICAgICAgICAgICBjb3B5VHJhbnNmb3JtKGRpc3RhbmNlSW5wdXQudHJhbnNmb3JtQiwgeGZCJDEpO1xuICAgICAgICAgICAgRGlzdGFuY2UoZGlzdGFuY2VPdXRwdXQsIGNhY2hlLCBkaXN0YW5jZUlucHV0KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzaGFwZXMgYXJlIG92ZXJsYXBwZWQsIHdlIGdpdmUgdXAgb24gY29udGludW91cyBjb2xsaXNpb24uXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2VPdXRwdXQuZGlzdGFuY2UgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFpbHVyZSFcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RhdGUgPSBleHBvcnRzLlRPSU91dHB1dFN0YXRlLmVfb3ZlcmxhcHBlZDtcbiAgICAgICAgICAgICAgICBvdXRwdXQudCA9IDAuMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZU91dHB1dC5kaXN0YW5jZSA8IHRhcmdldCArIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIFZpY3RvcnkhXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gZXhwb3J0cy5UT0lPdXRwdXRTdGF0ZS5lX3RvdWNoaW5nO1xuICAgICAgICAgICAgICAgIG91dHB1dC50ID0gdDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBzZXBhcmF0aW5nIGF4aXMuXG4gICAgICAgICAgICBzZXBhcmF0aW9uRnVuY3Rpb24uaW5pdGlhbGl6ZShjYWNoZSwgcHJveHlBLCBzd2VlcEEsIHByb3h5Qiwgc3dlZXBCLCB0MSk7XG4gICAgICAgICAgICAvLyBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAgIC8vICAgLy8gRHVtcCB0aGUgY3VydmUgc2VlbiBieSB0aGUgcm9vdCBmaW5kZXJcbiAgICAgICAgICAgIC8vICAgY29uc3QgTiA9IDEwMDtcbiAgICAgICAgICAgIC8vICAgY29uc3QgZHggPSAxLjAgLyBOO1xuICAgICAgICAgICAgLy8gICBjb25zdCB4cyA9IFtdOyAvLyBbIE4gKyAxIF07XG4gICAgICAgICAgICAvLyAgIGNvbnN0IGZzID0gW107IC8vIFsgTiArIDEgXTtcbiAgICAgICAgICAgIC8vICAgY29uc3QgeCA9IDAuMDtcbiAgICAgICAgICAgIC8vICAgZm9yIChjb25zdCBpID0gMDsgaSA8PSBOOyArK2kpIHtcbiAgICAgICAgICAgIC8vICAgICBzd2VlcEEuZ2V0VHJhbnNmb3JtKHhmQSwgeCk7XG4gICAgICAgICAgICAvLyAgICAgc3dlZXBCLmdldFRyYW5zZm9ybSh4ZkIsIHgpO1xuICAgICAgICAgICAgLy8gICAgIGNvbnN0IGYgPSBmY24uZXZhbHVhdGUoeGZBLCB4ZkIpIC0gdGFyZ2V0O1xuICAgICAgICAgICAgLy8gICAgIHByaW50ZihcIiVnICVnXFxuXCIsIHgsIGYpO1xuICAgICAgICAgICAgLy8gICAgIHhzW2ldID0geDtcbiAgICAgICAgICAgIC8vICAgICBmc1tpXSA9IGY7XG4gICAgICAgICAgICAvLyAgICAgeCArPSBkeDtcbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgVE9JIG9uIHRoZSBzZXBhcmF0aW5nIGF4aXMuIFdlIGRvIHRoaXMgYnkgc3VjY2Vzc2l2ZWx5XG4gICAgICAgICAgICAvLyByZXNvbHZpbmcgdGhlIGRlZXBlc3QgcG9pbnQuIFRoaXMgbG9vcCBpcyBib3VuZGVkIGJ5IHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHZlcnRpY2VzLlxuICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB0MiA9IHRNYXg7XG4gICAgICAgICAgICB2YXIgcHVzaEJhY2tJdGVyID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZGVlcGVzdCBwb2ludCBhdCB0Mi4gU3RvcmUgdGhlIHdpdG5lc3MgcG9pbnQgaW5kaWNlcy5cbiAgICAgICAgICAgICAgICB2YXIgczIgPSBzZXBhcmF0aW9uRnVuY3Rpb24uZmluZE1pblNlcGFyYXRpb24odDIpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBmaW5hbCBjb25maWd1cmF0aW9uIHNlcGFyYXRlZD9cbiAgICAgICAgICAgICAgICBpZiAoczIgPiB0YXJnZXQgKyB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmljdG9yeSFcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gZXhwb3J0cy5UT0lPdXRwdXRTdGF0ZS5lX3NlcGFyYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnQgPSB0TWF4O1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhcyB0aGUgc2VwYXJhdGlvbiByZWFjaGVkIHRvbGVyYW5jZT9cbiAgICAgICAgICAgICAgICBpZiAoczIgPiB0YXJnZXQgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgc3dlZXBzXG4gICAgICAgICAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbml0aWFsIHNlcGFyYXRpb24gb2YgdGhlIHdpdG5lc3MgcG9pbnRzLlxuICAgICAgICAgICAgICAgIHZhciBzMSA9IHNlcGFyYXRpb25GdW5jdGlvbi5ldmFsdWF0ZSh0MSk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGluaXRpYWwgb3ZlcmxhcC4gVGhpcyBtaWdodCBoYXBwZW4gaWYgdGhlIHJvb3QgZmluZGVyXG4gICAgICAgICAgICAgICAgLy8gcnVucyBvdXQgb2YgaXRlcmF0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAoczEgPCB0YXJnZXQgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gZXhwb3J0cy5UT0lPdXRwdXRTdGF0ZS5lX2ZhaWxlZDtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnQgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdG91Y2hpbmdcbiAgICAgICAgICAgICAgICBpZiAoczEgPD0gdGFyZ2V0ICsgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZpY3RvcnkhIHQxIHNob3VsZCBob2xkIHRoZSBUT0kgKGNvdWxkIGJlIDAuMCkuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zdGF0ZSA9IGV4cG9ydHMuVE9JT3V0cHV0U3RhdGUuZV90b3VjaGluZztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnQgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIDFEIHJvb3Qgb2Y6IGYoeCkgLSB0YXJnZXQgPSAwXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RJdGVyQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBhMSA9IHQxO1xuICAgICAgICAgICAgICAgIHZhciBhMiA9IHQyO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIG1peCBvZiB0aGUgc2VjYW50IHJ1bGUgYW5kIGJpc2VjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290SXRlckNvdW50ICYgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VjYW50IHJ1bGUgdG8gaW1wcm92ZSBjb252ZXJnZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBhMSArICh0YXJnZXQgLSBzMSkgKiAoYTIgLSBhMSkgLyAoczIgLSBzMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXNlY3Rpb24gdG8gZ3VhcmFudGVlIHByb2dyZXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDAuNSAqIChhMSArIGEyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK3Jvb3RJdGVyQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICsrc3RhdHMudG9pUm9vdEl0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHNlcGFyYXRpb25GdW5jdGlvbi5ldmFsdWF0ZSh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGhfYWJzJDcocyAtIHRhcmdldCkgPCB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHQyIGhvbGRzIGEgdGVudGF0aXZlIHZhbHVlIGZvciB0MVxuICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGNvbnRpbnVlIHRvIGJyYWNrZXQgdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzID4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhMSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhMiA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RJdGVyQ291bnQgPT09IDUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0cy50b2lNYXhSb290SXRlcnMgPSBtYXRoX21heCQzKHN0YXRzLnRvaU1heFJvb3RJdGVycywgcm9vdEl0ZXJDb3VudCk7XG4gICAgICAgICAgICAgICAgKytwdXNoQmFja0l0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHB1c2hCYWNrSXRlciA9PT0gU2V0dGluZ3NJbnRlcm5hbC5tYXhQb2x5Z29uVmVydGljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpdGVyO1xuICAgICAgICAgICAgKytzdGF0cy50b2lJdGVycztcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlciA9PT0ga19tYXhJdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gUm9vdCBmaW5kZXIgZ290IHN0dWNrLiBTZW1pLXZpY3RvcnkuXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0YXRlID0gZXhwb3J0cy5UT0lPdXRwdXRTdGF0ZS5lX2ZhaWxlZDtcbiAgICAgICAgICAgICAgICBvdXRwdXQudCA9IHQxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRzLnRvaU1heEl0ZXJzID0gbWF0aF9tYXgkMyhzdGF0cy50b2lNYXhJdGVycywgaXRlcik7XG4gICAgICAgIHZhciB0aW1lID0gVGltZXIuZGlmZih0aW1lcik7XG4gICAgICAgIHN0YXRzLnRvaU1heFRpbWUgPSBtYXRoX21heCQzKHN0YXRzLnRvaU1heFRpbWUsIHRpbWUpO1xuICAgICAgICBzdGF0cy50b2lUaW1lICs9IHRpbWU7XG4gICAgICAgIHNlcGFyYXRpb25GdW5jdGlvbi5yZWN5Y2xlKCk7XG4gICAgfTtcbiAgICB2YXIgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZTtcbiAgICAoZnVuY3Rpb24gKFNlcGFyYXRpb25GdW5jdGlvblR5cGUpIHtcbiAgICAgICAgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZVtTZXBhcmF0aW9uRnVuY3Rpb25UeXBlW1wiZV91bnNldFwiXSA9IC0xXSA9IFwiZV91bnNldFwiO1xuICAgICAgICBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlW1NlcGFyYXRpb25GdW5jdGlvblR5cGVbXCJlX3BvaW50c1wiXSA9IDFdID0gXCJlX3BvaW50c1wiO1xuICAgICAgICBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlW1NlcGFyYXRpb25GdW5jdGlvblR5cGVbXCJlX2ZhY2VBXCJdID0gMl0gPSBcImVfZmFjZUFcIjtcbiAgICAgICAgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZVtTZXBhcmF0aW9uRnVuY3Rpb25UeXBlW1wiZV9mYWNlQlwiXSA9IDNdID0gXCJlX2ZhY2VCXCI7XG4gICAgfSkoU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZSB8fCAoU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZSA9IHt9KSk7XG4gICAgdmFyIFNlcGFyYXRpb25GdW5jdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2VwYXJhdGlvbkZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gaW5wdXQgY2FjaGVcbiAgICAgICAgICAgIC8vIHRvZG86IG1heWJlIGFzc2lnbiBieSBjb3B5IGluc3RlYWQgb2YgcmVmZXJlbmNlP1xuICAgICAgICAgICAgdGhpcy5tX3Byb3h5QSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlCID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcEEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwQiA9IG51bGw7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGNhY2hlXG4gICAgICAgICAgICB0aGlzLm1fdHlwZSA9IFNlcGFyYXRpb25GdW5jdGlvblR5cGUuZV91bnNldDtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gdmVjMigwLCAwKTtcbiAgICAgICAgICAgIHRoaXMubV9heGlzID0gdmVjMigwLCAwKTtcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgb3V0cHV0XG4gICAgICAgICAgICB0aGlzLmluZGV4QSA9IC0xO1xuICAgICAgICAgICAgdGhpcy5pbmRleEIgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBTZXBhcmF0aW9uRnVuY3Rpb24ucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9wcm94eUIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXBCID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV90eXBlID0gU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5lX3Vuc2V0O1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy5tX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgdGhpcy5pbmRleEEgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCID0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE9fRVJJTiBtaWdodCBub3QgbmVlZCB0byByZXR1cm4gdGhlIHNlcGFyYXRpb25cbiAgICAgICAgU2VwYXJhdGlvbkZ1bmN0aW9uLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGNhY2hlLCBwcm94eUEsIHN3ZWVwQSwgcHJveHlCLCBzd2VlcEIsIHQxKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBjYWNoZS5jb3VudDtcbiAgICAgICAgICAgIHRoaXMubV9wcm94eUEgPSBwcm94eUE7XG4gICAgICAgICAgICB0aGlzLm1fcHJveHlCID0gcHJveHlCO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwQSA9IHN3ZWVwQTtcbiAgICAgICAgICAgIHRoaXMubV9zd2VlcEIgPSBzd2VlcEI7XG4gICAgICAgICAgICB0aGlzLm1fc3dlZXBBLmdldFRyYW5zZm9ybSh4ZkEkMSwgdDEpO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwQi5nZXRUcmFuc2Zvcm0oeGZCJDEsIHQxKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV90eXBlID0gU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5lX3BvaW50cztcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEFfMSA9IHRoaXMubV9wcm94eUEuZ2V0VmVydGV4KGNhY2hlLmluZGV4QVswXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRCXzEgPSB0aGlzLm1fcHJveHlCLmdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZlYzIocG9pbnRBJDIsIHhmQSQxLCBsb2NhbFBvaW50QV8xKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHBvaW50QiQyLCB4ZkIkMSwgbG9jYWxQb2ludEJfMSk7XG4gICAgICAgICAgICAgICAgZGlmZlZlYzIodGhpcy5tX2F4aXMsIHBvaW50QiQyLCBwb2ludEEkMik7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBub3JtYWxpemVWZWMyTGVuZ3RoKHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhY2hlLmluZGV4QVswXSA9PT0gY2FjaGUuaW5kZXhBWzFdKSB7XG4gICAgICAgICAgICAgICAgLy8gVHdvIHBvaW50cyBvbiBCIGFuZCBvbmUgb24gQS5cbiAgICAgICAgICAgICAgICB0aGlzLm1fdHlwZSA9IFNlcGFyYXRpb25GdW5jdGlvblR5cGUuZV9mYWNlQjtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEIxID0gcHJveHlCLmdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBvaW50QjIgPSBwcm94eUIuZ2V0VmVydGV4KGNhY2hlLmluZGV4QlsxXSk7XG4gICAgICAgICAgICAgICAgY3Jvc3NWZWMyTnVtKHRoaXMubV9heGlzLCBkaWZmVmVjMih0ZW1wJDQsIGxvY2FsUG9pbnRCMiwgbG9jYWxQb2ludEIxKSwgMS4wKTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVWZWMyKHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICByb3RWZWMyKG5vcm1hbCQzLCB4ZkIkMS5xLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgY29tYmluZVZlYzIodGhpcy5tX2xvY2FsUG9pbnQsIDAuNSwgbG9jYWxQb2ludEIxLCAwLjUsIGxvY2FsUG9pbnRCMik7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwb2ludEIkMiwgeGZCJDEsIHRoaXMubV9sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEFfMiA9IHByb3h5QS5nZXRWZXJ0ZXgoY2FjaGUuaW5kZXhBWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRBXzEgPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZkEkMSwgbG9jYWxQb2ludEFfMik7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBkb3RWZWMyKHBvaW50QV8xLCBub3JtYWwkMykgLSBkb3RWZWMyKHBvaW50QiQyLCBub3JtYWwkMyk7XG4gICAgICAgICAgICAgICAgaWYgKHMgPCAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgbmVnVmVjMih0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHMgPSAtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUd28gcG9pbnRzIG9uIEEgYW5kIG9uZSBvciB0d28gcG9pbnRzIG9uIEIuXG4gICAgICAgICAgICAgICAgdGhpcy5tX3R5cGUgPSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLmVfZmFjZUE7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRBMSA9IHRoaXMubV9wcm94eUEuZ2V0VmVydGV4KGNhY2hlLmluZGV4QVswXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnRBMiA9IHRoaXMubV9wcm94eUEuZ2V0VmVydGV4KGNhY2hlLmluZGV4QVsxXSk7XG4gICAgICAgICAgICAgICAgY3Jvc3NWZWMyTnVtKHRoaXMubV9heGlzLCBkaWZmVmVjMih0ZW1wJDQsIGxvY2FsUG9pbnRBMiwgbG9jYWxQb2ludEExKSwgMS4wKTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVWZWMyKHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICByb3RWZWMyKG5vcm1hbCQzLCB4ZkEkMS5xLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgY29tYmluZVZlYzIodGhpcy5tX2xvY2FsUG9pbnQsIDAuNSwgbG9jYWxQb2ludEExLCAwLjUsIGxvY2FsUG9pbnRBMik7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwb2ludEEkMiwgeGZBJDEsIHRoaXMubV9sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludEJfMiA9IHRoaXMubV9wcm94eUIuZ2V0VmVydGV4KGNhY2hlLmluZGV4QlswXSk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwb2ludEIkMiwgeGZCJDEsIGxvY2FsUG9pbnRCXzIpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gZG90VmVjMihwb2ludEIkMiwgbm9ybWFsJDMpIC0gZG90VmVjMihwb2ludEEkMiwgbm9ybWFsJDMpO1xuICAgICAgICAgICAgICAgIGlmIChzIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZ1ZlYzIodGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgICAgICBzID0gLXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTZXBhcmF0aW9uRnVuY3Rpb24ucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoZmluZCwgdCkge1xuICAgICAgICAgICAgLy8gSXQgd2FzIGZpbmRNaW5TZXBhcmF0aW9uIGFuZCBldmFsdWF0ZVxuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwQS5nZXRUcmFuc2Zvcm0oeGZBJDEsIHQpO1xuICAgICAgICAgICAgdGhpcy5tX3N3ZWVwQi5nZXRUcmFuc2Zvcm0oeGZCJDEsIHQpO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1fdHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5lX3BvaW50czoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52Um90VmVjMihheGlzQSwgeGZBJDEucSwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52Um90VmVjMihheGlzQiwgeGZCJDEucSwgc2V0TXVsVmVjMih0ZW1wJDQsIC0xLCB0aGlzLm1fYXhpcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEEgPSB0aGlzLm1fcHJveHlBLmdldFN1cHBvcnQoYXhpc0EpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEIgPSB0aGlzLm1fcHJveHlCLmdldFN1cHBvcnQoYXhpc0IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKGxvY2FsUG9pbnRBLCB0aGlzLm1fcHJveHlBLmdldFZlcnRleCh0aGlzLmluZGV4QSkpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihsb2NhbFBvaW50QiwgdGhpcy5tX3Byb3h5Qi5nZXRWZXJ0ZXgodGhpcy5pbmRleEIpKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwb2ludEEkMiwgeGZBJDEsIGxvY2FsUG9pbnRBKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwb2ludEIkMiwgeGZCJDEsIGxvY2FsUG9pbnRCKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcCA9IGRvdFZlYzIocG9pbnRCJDIsIHRoaXMubV9heGlzKSAtIGRvdFZlYzIocG9pbnRBJDIsIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLmVfZmFjZUE6IHtcbiAgICAgICAgICAgICAgICAgICAgcm90VmVjMihub3JtYWwkMywgeGZBJDEucSwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHBvaW50QSQyLCB4ZkEkMSwgdGhpcy5tX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52Um90VmVjMihheGlzQiwgeGZCJDEucSwgc2V0TXVsVmVjMih0ZW1wJDQsIC0xLCBub3JtYWwkMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCID0gdGhpcy5tX3Byb3h5Qi5nZXRTdXBwb3J0KGF4aXNCKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihsb2NhbFBvaW50QiwgdGhpcy5tX3Byb3h5Qi5nZXRWZXJ0ZXgodGhpcy5pbmRleEIpKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwb2ludEIkMiwgeGZCJDEsIGxvY2FsUG9pbnRCKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcCA9IGRvdFZlYzIocG9pbnRCJDIsIG5vcm1hbCQzKSAtIGRvdFZlYzIocG9pbnRBJDIsIG5vcm1hbCQzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLmVfZmFjZUI6IHtcbiAgICAgICAgICAgICAgICAgICAgcm90VmVjMihub3JtYWwkMywgeGZCJDEucSwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHBvaW50QiQyLCB4ZkIkMSwgdGhpcy5tX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52Um90VmVjMihheGlzQSwgeGZBJDEucSwgc2V0TXVsVmVjMih0ZW1wJDQsIC0xLCBub3JtYWwkMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEIgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhBID0gdGhpcy5tX3Byb3h5QS5nZXRTdXBwb3J0KGF4aXNBKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihsb2NhbFBvaW50QSwgdGhpcy5tX3Byb3h5QS5nZXRWZXJ0ZXgodGhpcy5pbmRleEEpKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwb2ludEEkMiwgeGZBJDEsIGxvY2FsUG9pbnRBKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcCA9IGRvdFZlYzIocG9pbnRBJDIsIG5vcm1hbCQzKSAtIGRvdFZlYzIocG9pbnRCJDIsIG5vcm1hbCQzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhBID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4QiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNlcGFyYXRpb25GdW5jdGlvbi5wcm90b3R5cGUuZmluZE1pblNlcGFyYXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZSh0cnVlLCB0KTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VwYXJhdGlvbkZ1bmN0aW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlKGZhbHNlLCB0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNlcGFyYXRpb25GdW5jdGlvbjtcbiAgICB9KCkpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHNlcGFyYXRpb25GdW5jdGlvbiA9IG5ldyBTZXBhcmF0aW9uRnVuY3Rpb24oKTtcbiAgICAvLyBsZWdhY3kgZXhwb3J0c1xuICAgIFRpbWVPZkltcGFjdC5JbnB1dCA9IFRPSUlucHV0O1xuICAgIFRpbWVPZkltcGFjdC5PdXRwdXQgPSBUT0lPdXRwdXQ7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9hYnMkNiA9IE1hdGguYWJzO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfc3FydCQzID0gTWF0aC5zcXJ0O1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfbWluJDUgPSBNYXRoLm1pbjtcbiAgICB2YXIgVGltZVN0ZXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRpbWVTdGVwKCkge1xuICAgICAgICAgICAgLyoqIHRpbWUgc3RlcCAqL1xuICAgICAgICAgICAgdGhpcy5kdCA9IDA7XG4gICAgICAgICAgICAvKiogaW52ZXJzZSB0aW1lIHN0ZXAgKDAgaWYgZHQgPT0gMCkgKi9cbiAgICAgICAgICAgIHRoaXMuaW52X2R0ID0gMDtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHlJdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgIHRoaXMud2FybVN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJsb2NrU29sdmUgPSB0cnVlO1xuICAgICAgICAgICAgLyoqIHRpbWVzdGVwIHJhdGlvIGZvciB2YXJpYWJsZSB0aW1lc3RlcCAqL1xuICAgICAgICAgICAgdGhpcy5pbnZfZHQwID0gMC4wO1xuICAgICAgICAgICAgLyoqIGR0ICogaW52X2R0MCAqL1xuICAgICAgICAgICAgdGhpcy5kdFJhdGlvID0gMTtcbiAgICAgICAgfVxuICAgICAgICBUaW1lU3RlcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR0ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZfZHQwID0gdGhpcy5pbnZfZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICAgICAgICB0aGlzLmludl9kdCA9IGR0ID09IDAgPyAwIDogMSAvIGR0O1xuICAgICAgICAgICAgdGhpcy5kdFJhdGlvID0gZHQgKiB0aGlzLmludl9kdDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUaW1lU3RlcDtcbiAgICB9KCkpO1xuICAgIC8vIHJldXNlXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgc19zdWJTdGVwID0gbmV3IFRpbWVTdGVwKCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgYyA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdHJhbnNsYXRpb24gPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGlucHV0ID0gbmV3IFRPSUlucHV0KCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgb3V0cHV0ID0gbmV3IFRPSU91dHB1dCgpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGJhY2t1cCA9IG5ldyBTd2VlcCgpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGJhY2t1cDEgPSBuZXcgU3dlZXAoKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBiYWNrdXAyID0gbmV3IFN3ZWVwKCk7XG4gICAgLyoqXG4gICAgICogQ29udGFjdCBpbXB1bHNlcyBmb3IgcmVwb3J0aW5nLiBJbXB1bHNlcyBhcmUgdXNlZCBpbnN0ZWFkIG9mIGZvcmNlcyBiZWNhdXNlXG4gICAgICogc3ViLXN0ZXAgZm9yY2VzIG1heSBhcHByb2FjaCBpbmZpbml0eSBmb3IgcmlnaWQgYm9keSBjb2xsaXNpb25zLiBUaGVzZSBtYXRjaFxuICAgICAqIHVwIG9uZS10by1vbmUgd2l0aCB0aGUgY29udGFjdCBwb2ludHMgaW4gTWFuaWZvbGQuXG4gICAgICovXG4gICAgdmFyIENvbnRhY3RJbXB1bHNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb250YWN0SW1wdWxzZShjb250YWN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhY3QgPSBjb250YWN0O1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxzID0gW107XG4gICAgICAgICAgICB0aGlzLnRhbmdlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgQ29udGFjdEltcHVsc2UucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMudGFuZ2VudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhY3RJbXB1bHNlLnByb3RvdHlwZSwgXCJub3JtYWxJbXB1bHNlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMuY29udGFjdDtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFscyA9IHRoaXMubm9ybWFscztcbiAgICAgICAgICAgICAgICBub3JtYWxzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBjb250YWN0LnZfcG9pbnRzLmxlbmd0aDsgKytwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHMucHVzaChjb250YWN0LnZfcG9pbnRzW3BdLm5vcm1hbEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFscztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhY3RJbXB1bHNlLnByb3RvdHlwZSwgXCJ0YW5nZW50SW1wdWxzZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgdmFyIHRhbmdlbnRzID0gdGhpcy50YW5nZW50cztcbiAgICAgICAgICAgICAgICB0YW5nZW50cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgY29udGFjdC52X3BvaW50cy5sZW5ndGg7ICsrcCkge1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50cy5wdXNoKGNvbnRhY3Qudl9wb2ludHNbcF0udGFuZ2VudEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFuZ2VudHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBDb250YWN0SW1wdWxzZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGFuZCBzb2x2ZXMgaXNsYW5kcy4gQW4gaXNsYW5kIGlzIGEgY29ubmVjdGVkIHN1YnNldCBvZiB0aGUgd29ybGQuXG4gICAgICovXG4gICAgdmFyIFNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU29sdmVyKHdvcmxkKSB7XG4gICAgICAgICAgICB0aGlzLm1fd29ybGQgPSB3b3JsZDtcbiAgICAgICAgICAgIHRoaXMubV9zdGFjayA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tX2JvZGllcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRhY3RzID0gW107XG4gICAgICAgICAgICB0aGlzLm1fam9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubV9zdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5tX2JvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLm1fam9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuYWRkQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB0aGlzLm1fYm9kaWVzLnB1c2goYm9keSk7XG4gICAgICAgICAgICAvLyB3aHk/XG4gICAgICAgICAgICAvLyBib2R5LmNfcG9zaXRpb24uYy5zZXRaZXJvKCk7XG4gICAgICAgICAgICAvLyBib2R5LmNfcG9zaXRpb24uYSA9IDA7XG4gICAgICAgICAgICAvLyBib2R5LmNfdmVsb2NpdHkudi5zZXRaZXJvKCk7XG4gICAgICAgICAgICAvLyBib2R5LmNfdmVsb2NpdHkudyA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuYWRkQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0KSB7XG4gICAgICAgICAgICAvLyBmYWxzZSAmJiBjb25zb2xlLmFzc2VydChjb250YWN0IGluc3RhbmNlb2YgQ29udGFjdCwgJ05vdCBhIENvbnRhY3QhJywgY29udGFjdCk7XG4gICAgICAgICAgICB0aGlzLm1fY29udGFjdHMucHVzaChjb250YWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5hZGRKb2ludCA9IGZ1bmN0aW9uIChqb2ludCkge1xuICAgICAgICAgICAgdGhpcy5tX2pvaW50cy5wdXNoKGpvaW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5zb2x2ZVdvcmxkID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB3b3JsZCA9IHRoaXMubV93b3JsZDtcbiAgICAgICAgICAgIC8vIENsZWFyIGFsbCB0aGUgaXNsYW5kIGZsYWdzLlxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IHdvcmxkLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgIGIubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBjXzEgPSB3b3JsZC5tX2NvbnRhY3RMaXN0OyBjXzE7IGNfMSA9IGNfMS5tX25leHQpIHtcbiAgICAgICAgICAgICAgICBjXzEubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gd29ybGQubV9qb2ludExpc3Q7IGo7IGogPSBqLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCBhbmQgc2ltdWxhdGUgYWxsIGF3YWtlIGlzbGFuZHMuXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLm1fc3RhY2s7XG4gICAgICAgICAgICBmb3IgKHZhciBzZWVkID0gd29ybGQubV9ib2R5TGlzdDsgc2VlZDsgc2VlZCA9IHNlZWQubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZWQubV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VlZC5pc0F3YWtlKCkgPT0gZmFsc2UgfHwgc2VlZC5pc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VlZCBjYW4gYmUgZHluYW1pYyBvciBraW5lbWF0aWMuXG4gICAgICAgICAgICAgICAgaWYgKHNlZWQuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgaXNsYW5kIGFuZCBzdGFjay5cbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChzZWVkKTtcbiAgICAgICAgICAgICAgICBzZWVkLm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGRlcHRoIGZpcnN0IHNlYXJjaCAoREZTKSBvbiB0aGUgY29uc3RyYWludCBncmFwaC5cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHcmFiIHRoZSBuZXh0IGJvZHkgb2ZmIHRoZSBzdGFjayBhbmQgYWRkIGl0IHRvIHRoZSBpc2xhbmQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9keShiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBib2R5IGlzIGF3YWtlICh3aXRob3V0IHJlc2V0dGluZyBzbGVlcCB0aW1lcikuXG4gICAgICAgICAgICAgICAgICAgIGIubV9hd2FrZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIGlzbGFuZHMgYXMgc21hbGwgYXMgcG9zc2libGUsIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBpc2xhbmRzIGFjcm9zcyBzdGF0aWMgYm9kaWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggYWxsIGNvbnRhY3RzIGNvbm5lY3RlZCB0byB0aGlzIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNlID0gYi5tX2NvbnRhY3RMaXN0OyBjZTsgY2UgPSBjZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGNlLmNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXMgdGhpcyBjb250YWN0IGFscmVhZHkgYmVlbiBhZGRlZCB0byBhbiBpc2xhbmQ/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5tX2lzbGFuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgY29udGFjdCBzb2xpZCBhbmQgdG91Y2hpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5pc0VuYWJsZWQoKSA9PSBmYWxzZSB8fCBjb250YWN0LmlzVG91Y2hpbmcoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzZW5zb3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbnNvckEgPSBjb250YWN0Lm1fZml4dHVyZUEubV9pc1NlbnNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZW5zb3JCID0gY29udGFjdC5tX2ZpeHR1cmVCLm1faXNTZW5zb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vuc29yQSB8fCBzZW5zb3JCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbnRhY3QoY29udGFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjZS5vdGhlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhcyB0aGUgb3RoZXIgYm9keSBhbHJlYWR5IGFkZGVkIHRvIHRoaXMgaXNsYW5kP1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLm1faXNsYW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsc2UgJiYgY29uc29sZS5hc3NlcnQoc3RhY2subGVuZ3RoIDwgd29ybGQubV9ib2R5Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBhbGwgam9pbnRzIGNvbm5lY3QgdG8gdGhpcyBib2R5LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqZSA9IGIubV9qb2ludExpc3Q7IGplOyBqZSA9IGplLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqZS5qb2ludC5tX2lzbGFuZEZsYWcgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyID0gamUub3RoZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBzaW11bGF0ZSBqb2ludHMgY29ubmVjdGVkIHRvIGluYWN0aXZlIGJvZGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlci5pc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEpvaW50KGplLmpvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGplLmpvaW50Lm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIubV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxzZSAmJiBjb25zb2xlLmFzc2VydChzdGFjay5sZW5ndGggPCB3b3JsZC5tX2JvZHlDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zb2x2ZUlzbGFuZChzdGVwKTtcbiAgICAgICAgICAgICAgICAvLyBQb3N0IHNvbHZlIGNsZWFudXAuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHN0YXRpYyBib2RpZXMgdG8gcGFydGljaXBhdGUgaW4gb3RoZXIgaXNsYW5kcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYXJlIHRoZXkgYWRkZWQgYXQgYWxsP1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChiLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuc29sdmVJc2xhbmQgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgLy8gQjI6IElzbGFuZCBTb2x2ZVxuICAgICAgICAgICAgdmFyIHdvcmxkID0gdGhpcy5tX3dvcmxkO1xuICAgICAgICAgICAgdmFyIGdyYXZpdHkgPSB3b3JsZC5tX2dyYXZpdHk7XG4gICAgICAgICAgICB2YXIgYWxsb3dTbGVlcCA9IHdvcmxkLm1fYWxsb3dTbGVlcDtcbiAgICAgICAgICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICAgICAgICAgIC8vIEludGVncmF0ZSB2ZWxvY2l0aWVzIGFuZCBhcHBseSBkYW1waW5nLiBJbml0aWFsaXplIHRoZSBib2R5IHN0YXRlLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKGMsIGJvZHkubV9zd2VlcC5jKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGJvZHkubV9zd2VlcC5hO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKHYsIGJvZHkubV9saW5lYXJWZWxvY2l0eSk7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBib2R5Lm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHBvc2l0aW9ucyBmb3IgY29udGludW91cyBjb2xsaXNpb24uXG4gICAgICAgICAgICAgICAgY29weVZlYzIoYm9keS5tX3N3ZWVwLmMwLCBib2R5Lm1fc3dlZXAuYyk7XG4gICAgICAgICAgICAgICAgYm9keS5tX3N3ZWVwLmEwID0gYm9keS5tX3N3ZWVwLmE7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkuaXNEeW5hbWljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZWdyYXRlIHZlbG9jaXRpZXMuXG4gICAgICAgICAgICAgICAgICAgIGFkZE11bFZlYzIodiwgaCAqIGJvZHkubV9ncmF2aXR5U2NhbGUsIGdyYXZpdHkpO1xuICAgICAgICAgICAgICAgICAgICBhZGRNdWxWZWMyKHYsIGggKiBib2R5Lm1faW52TWFzcywgYm9keS5tX2ZvcmNlKTtcbiAgICAgICAgICAgICAgICAgICAgdyArPSBoICogYm9keS5tX2ludkkgKiBib2R5Lm1fdG9ycXVlO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogPHByZT5cbiAgICAgICAgICAgICAgICAgICAgICogQXBwbHkgZGFtcGluZy5cbiAgICAgICAgICAgICAgICAgICAgICogT0RFOiBkdi9kdCArIGMgKiB2ID0gMFxuICAgICAgICAgICAgICAgICAgICAgKiBTb2x1dGlvbjogdih0KSA9IHYwICogZXhwKC1jICogdClcbiAgICAgICAgICAgICAgICAgICAgICogVGltZSBzdGVwOiB2KHQgKyBkdCkgPSB2MCAqIGV4cCgtYyAqICh0ICsgZHQpKSA9IHYwICogZXhwKC1jICogdCkgKiBleHAoLWMgKiBkdCkgPSB2ICogZXhwKC1jICogZHQpXG4gICAgICAgICAgICAgICAgICAgICAqIHYyID0gZXhwKC1jICogZHQpICogdjFcbiAgICAgICAgICAgICAgICAgICAgICogUGFkZSBhcHByb3hpbWF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgKiB2MiA9IHYxICogMSAvICgxICsgYyAqIGR0KVxuICAgICAgICAgICAgICAgICAgICAgKiA8L3ByZT5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIodiwgMS4wIC8gKDEuMCArIGggKiBib2R5Lm1fbGluZWFyRGFtcGluZyksIHYpO1xuICAgICAgICAgICAgICAgICAgICB3ICo9IDEuMCAvICgxLjAgKyBoICogYm9keS5tX2FuZ3VsYXJEYW1waW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29weVZlYzIoYm9keS5jX3Bvc2l0aW9uLmMsIGMpO1xuICAgICAgICAgICAgICAgIGJvZHkuY19wb3NpdGlvbi5hID0gYTtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihib2R5LmNfdmVsb2NpdHkudiwgdik7XG4gICAgICAgICAgICAgICAgYm9keS5jX3ZlbG9jaXR5LncgPSB3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgICAgICAgICBjb250YWN0LmluaXRDb25zdHJhaW50KHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgICAgICAgICBjb250YWN0LmluaXRWZWxvY2l0eUNvbnN0cmFpbnQoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBXYXJtIHN0YXJ0LlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5tX2NvbnRhY3RzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0Lndhcm1TdGFydENvbnN0cmFpbnQoc3RlcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fam9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpvaW50ID0gdGhpcy5tX2pvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBqb2ludC5pbml0VmVsb2NpdHlDb25zdHJhaW50cyhzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbHZlIHZlbG9jaXR5IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9qb2ludHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpvaW50ID0gdGhpcy5tX2pvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgam9pbnQuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHN0ZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludChzdGVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9yZSBpbXB1bHNlcyBmb3Igd2FybSBzdGFydGluZ1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgICAgICAgICBjb250YWN0LnN0b3JlQ29uc3RyYWludEltcHVsc2VzKHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW50ZWdyYXRlIHBvc2l0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKGMsIGJvZHkuY19wb3NpdGlvbi5jKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGJvZHkuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKHYsIGJvZHkuY192ZWxvY2l0eS52KTtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IGJvZHkuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBsYXJnZSB2ZWxvY2l0aWVzXG4gICAgICAgICAgICAgICAgc2V0TXVsVmVjMih0cmFuc2xhdGlvbiwgaCwgdik7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTGVuZ3RoU3FyID0gbGVuZ3RoU3FyVmVjMih0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9uTGVuZ3RoU3FyID4gU2V0dGluZ3NJbnRlcm5hbC5tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gU2V0dGluZ3NJbnRlcm5hbC5tYXhUcmFuc2xhdGlvbiAvIG1hdGhfc3FydCQzKHRyYW5zbGF0aW9uTGVuZ3RoU3FyKTtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVWZWMyKHYsIHJhdGlvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gaCAqIHc7XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBTZXR0aW5nc0ludGVybmFsLm1heFJvdGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBTZXR0aW5nc0ludGVybmFsLm1heFJvdGF0aW9uIC8gbWF0aF9hYnMkNihyb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHcgKj0gcmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEludGVncmF0ZVxuICAgICAgICAgICAgICAgIGFkZE11bFZlYzIoYywgaCwgdik7XG4gICAgICAgICAgICAgICAgYSArPSBoICogdztcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihib2R5LmNfcG9zaXRpb24uYywgYyk7XG4gICAgICAgICAgICAgICAgYm9keS5jX3Bvc2l0aW9uLmEgPSBhO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKGJvZHkuY192ZWxvY2l0eS52LCB2KTtcbiAgICAgICAgICAgICAgICBib2R5LmNfdmVsb2NpdHkudyA9IHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb2x2ZSBwb3NpdGlvbiBjb25zdHJhaW50c1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uU29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXAucG9zaXRpb25JdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluU2VwYXJhdGlvbiA9IDAuMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBjb250YWN0LnNvbHZlUG9zaXRpb25Db25zdHJhaW50KHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICBtaW5TZXBhcmF0aW9uID0gbWF0aF9taW4kNShtaW5TZXBhcmF0aW9uLCBzZXBhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZXhwZWN0IG1pblNwZXBhcmF0aW9uID49IC1TZXR0aW5ncy5saW5lYXJTbG9wIGJlY2F1c2Ugd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBwdXNoIHRoZSBzZXBhcmF0aW9uIGFib3ZlIC1TZXR0aW5ncy5saW5lYXJTbG9wLlxuICAgICAgICAgICAgICAgIHZhciBjb250YWN0c09rYXkgPSBtaW5TZXBhcmF0aW9uID49IC0zLjAgKiBTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3A7XG4gICAgICAgICAgICAgICAgdmFyIGpvaW50c09rYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5tX2pvaW50cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgam9pbnQgPSB0aGlzLm1fam9pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgam9pbnRPa2F5ID0gam9pbnQuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICBqb2ludHNPa2F5ID0gam9pbnRzT2theSAmJiBqb2ludE9rYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250YWN0c09rYXkgJiYgam9pbnRzT2theSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBwb3NpdGlvbiBlcnJvcnMgYXJlIHNtYWxsLlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcHkgc3RhdGUgYnVmZmVycyBiYWNrIHRvIHRoZSBib2RpZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2JvZGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gdGhpcy5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihib2R5Lm1fc3dlZXAuYywgYm9keS5jX3Bvc2l0aW9uLmMpO1xuICAgICAgICAgICAgICAgIGJvZHkubV9zd2VlcC5hID0gYm9keS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICAgICAgY29weVZlYzIoYm9keS5tX2xpbmVhclZlbG9jaXR5LCBib2R5LmNfdmVsb2NpdHkudik7XG4gICAgICAgICAgICAgICAgYm9keS5tX2FuZ3VsYXJWZWxvY2l0eSA9IGJvZHkuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgICAgIGJvZHkuc3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9zdFNvbHZlSXNsYW5kKCk7XG4gICAgICAgICAgICBpZiAoYWxsb3dTbGVlcCkge1xuICAgICAgICAgICAgICAgIHZhciBtaW5TbGVlcFRpbWUgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB2YXIgbGluVG9sU3FyID0gU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbGVlcFRvbGVyYW5jZVNxcjtcbiAgICAgICAgICAgICAgICB2YXIgYW5nVG9sU3FyID0gU2V0dGluZ3NJbnRlcm5hbC5hbmd1bGFyU2xlZXBUb2xlcmFuY2VTcXI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gdGhpcy5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChib2R5Lm1fYXV0b1NsZWVwRmxhZyA9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChib2R5Lm1fYW5ndWxhclZlbG9jaXR5ICogYm9keS5tX2FuZ3VsYXJWZWxvY2l0eSA+IGFuZ1RvbFNxcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChsZW5ndGhTcXJWZWMyKGJvZHkubV9saW5lYXJWZWxvY2l0eSkgPiBsaW5Ub2xTcXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Lm1fc2xlZXBUaW1lID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluU2xlZXBUaW1lID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5tX3NsZWVwVGltZSArPSBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluU2xlZXBUaW1lID0gbWF0aF9taW4kNShtaW5TbGVlcFRpbWUsIGJvZHkubV9zbGVlcFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtaW5TbGVlcFRpbWUgPj0gU2V0dGluZ3NJbnRlcm5hbC50aW1lVG9TbGVlcCAmJiBwb3NpdGlvblNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gdGhpcy5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuc2V0QXdha2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCBUT0kgY29udGFjdHMgYW5kIHNvbHZlIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLnNvbHZlV29ybGRUT0kgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHdvcmxkID0gdGhpcy5tX3dvcmxkO1xuICAgICAgICAgICAgaWYgKHdvcmxkLm1fc3RlcENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IHdvcmxkLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBiLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBiLm1fc3dlZXAuYWxwaGEwID0gMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjXzIgPSB3b3JsZC5tX2NvbnRhY3RMaXN0OyBjXzI7IGNfMiA9IGNfMi5tX25leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBUT0lcbiAgICAgICAgICAgICAgICAgICAgY18yLm1fdG9pRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjXzIubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNfMi5tX3RvaUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY18yLm1fdG9pID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgVE9JIGV2ZW50cyBhbmQgc29sdmUgdGhlbS5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgVE9JLlxuICAgICAgICAgICAgICAgIHZhciBtaW5Db250YWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgbWluQWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY18zID0gd29ybGQubV9jb250YWN0TGlzdDsgY18zOyBjXzMgPSBjXzMubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgY29udGFjdCBkaXNhYmxlZD9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNfMy5pc0VuYWJsZWQoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBleGNlc3NpdmUgc3ViLXN0ZXBwaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY18zLm1fdG9pQ291bnQgPiBTZXR0aW5nc0ludGVybmFsLm1heFN1YlN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjXzMubV90b2lGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbnRhY3QgaGFzIGEgdmFsaWQgY2FjaGVkIFRPSS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gY18zLm1fdG9pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZBXzEgPSBjXzMuZ2V0Rml4dHVyZUEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmQl8xID0gY18zLmdldEZpeHR1cmVCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIHNlbnNvcj9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmQV8xLmlzU2Vuc29yKCkgfHwgZkJfMS5pc1NlbnNvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYkFfMSA9IGZBXzEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJCXzEgPSBmQl8xLmdldEJvZHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVBID0gYkFfMS5pc0F3YWtlKCkgJiYgIWJBXzEuaXNTdGF0aWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVCID0gYkJfMS5pc0F3YWtlKCkgJiYgIWJCXzEuaXNTdGF0aWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIGF0IGxlYXN0IG9uZSBib2R5IGFjdGl2ZSAoYXdha2UgYW5kIGR5bmFtaWMgb3Iga2luZW1hdGljKT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVBID09IGZhbHNlICYmIGFjdGl2ZUIgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaWRlQSA9IGJBXzEuaXNCdWxsZXQoKSB8fCAhYkFfMS5pc0R5bmFtaWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaWRlQiA9IGJCXzEuaXNCdWxsZXQoKSB8fCAhYkJfMS5pc0R5bmFtaWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZSB0aGVzZSB0d28gbm9uLWJ1bGxldCBkeW5hbWljIGJvZGllcz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlQSA9PSBmYWxzZSAmJiBjb2xsaWRlQiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgVE9JIGZvciB0aGlzIGNvbnRhY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXQgdGhlIHN3ZWVwcyBvbnRvIHRoZSBzYW1lIHRpbWUgaW50ZXJ2YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGEwID0gYkFfMS5tX3N3ZWVwLmFscGhhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiQV8xLm1fc3dlZXAuYWxwaGEwIDwgYkJfMS5tX3N3ZWVwLmFscGhhMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMCA9IGJCXzEubV9zd2VlcC5hbHBoYTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkFfMS5tX3N3ZWVwLmFkdmFuY2UoYWxwaGEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJCXzEubV9zd2VlcC5hbHBoYTAgPCBiQV8xLm1fc3dlZXAuYWxwaGEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEwID0gYkFfMS5tX3N3ZWVwLmFscGhhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQl8xLm1fc3dlZXAuYWR2YW5jZShhbHBoYTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4QSA9IGNfMy5nZXRDaGlsZEluZGV4QSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4QiA9IGNfMy5nZXRDaGlsZEluZGV4QigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYkFfMS5tX3N3ZWVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYkJfMS5tX3N3ZWVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdGltZSBvZiBpbXBhY3QgaW4gaW50ZXJ2YWwgWzAsIG1pblRPSV1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnByb3h5QS5zZXQoZkFfMS5nZXRTaGFwZSgpLCBpbmRleEEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQucHJveHlCLnNldChmQl8xLmdldFNoYXBlKCksIGluZGV4Qik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zd2VlcEEuc2V0KGJBXzEubV9zd2VlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zd2VlcEIuc2V0KGJCXzEubV9zd2VlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC50TWF4ID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgVGltZU9mSW1wYWN0KG91dHB1dCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmV0YSBpcyB0aGUgZnJhY3Rpb24gb2YgdGhlIHJlbWFpbmluZyBwb3J0aW9uIG9mIHRoZSBbdGltZT9dLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJldGEgPSBvdXRwdXQudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuc3RhdGUgPT0gZXhwb3J0cy5UT0lPdXRwdXRTdGF0ZS5lX3RvdWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBtYXRoX21pbiQ1KGFscGhhMCArICgxLjAgLSBhbHBoYTApICogYmV0YSwgMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY18zLm1fdG9pID0gYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjXzMubV90b2lGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPCBtaW5BbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbWluaW11bSBUT0kgZm91bmQgc28gZmFyLlxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29udGFjdCA9IGNfMztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbkNvbnRhY3QgPT0gbnVsbCB8fCAxLjAgLSAxMC4wICogRVBTSUxPTiA8IG1pbkFscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIG1vcmUgVE9JIGV2ZW50cy4gRG9uZSFcbiAgICAgICAgICAgICAgICAgICAgd29ybGQubV9zdGVwQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgYm9kaWVzIHRvIHRoZSBUT0kuXG4gICAgICAgICAgICAgICAgdmFyIGZBID0gbWluQ29udGFjdC5nZXRGaXh0dXJlQSgpO1xuICAgICAgICAgICAgICAgIHZhciBmQiA9IG1pbkNvbnRhY3QuZ2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgICAgICB2YXIgYkEgPSBmQS5nZXRCb2R5KCk7XG4gICAgICAgICAgICAgICAgdmFyIGJCID0gZkIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICAgIGJhY2t1cDEuc2V0KGJBLm1fc3dlZXApO1xuICAgICAgICAgICAgICAgIGJhY2t1cDIuc2V0KGJCLm1fc3dlZXApO1xuICAgICAgICAgICAgICAgIGJBLmFkdmFuY2UobWluQWxwaGEpO1xuICAgICAgICAgICAgICAgIGJCLmFkdmFuY2UobWluQWxwaGEpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBUT0kgY29udGFjdCBsaWtlbHkgaGFzIHNvbWUgbmV3IGNvbnRhY3QgcG9pbnRzLlxuICAgICAgICAgICAgICAgIG1pbkNvbnRhY3QudXBkYXRlKHdvcmxkKTtcbiAgICAgICAgICAgICAgICBtaW5Db250YWN0Lm1fdG9pRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICsrbWluQ29udGFjdC5tX3RvaUNvdW50O1xuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBjb250YWN0IHNvbGlkP1xuICAgICAgICAgICAgICAgIGlmIChtaW5Db250YWN0LmlzRW5hYmxlZCgpID09IGZhbHNlIHx8IG1pbkNvbnRhY3QuaXNUb3VjaGluZygpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHN3ZWVwcy5cbiAgICAgICAgICAgICAgICAgICAgbWluQ29udGFjdC5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYkEubV9zd2VlcC5zZXQoYmFja3VwMSk7XG4gICAgICAgICAgICAgICAgICAgIGJCLm1fc3dlZXAuc2V0KGJhY2t1cDIpO1xuICAgICAgICAgICAgICAgICAgICBiQS5zeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICBiQi5zeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYkEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYkIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIGlzbGFuZFxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJvZHkoYkEpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9keShiQik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb250YWN0KG1pbkNvbnRhY3QpO1xuICAgICAgICAgICAgICAgIGJBLm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYkIubV9pc2xhbmRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtaW5Db250YWN0Lm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGNvbnRhY3RzIG9uIGJvZHlBIGFuZCBib2R5Qi5cbiAgICAgICAgICAgICAgICB2YXIgYm9kaWVzID0gW2JBLCBiQl07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5LmlzRHluYW1pYygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjZSA9IGJvZHkubV9jb250YWN0TGlzdDsgY2U7IGNlID0gY2UubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLm1fYm9keUNvdW50ID09IHRoaXMubV9ib2R5Q2FwYWNpdHkpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5tX2NvbnRhY3RDb3VudCA9PSB0aGlzLm1fY29udGFjdENhcGFjaXR5KSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBjZS5jb250YWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcyB0aGlzIGNvbnRhY3QgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBpc2xhbmQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QubV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBpZiBlaXRoZXIgaXMgc3RhdGljLCBraW5lbWF0aWMgb3IgYnVsbGV0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNlLm90aGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlci5pc0R5bmFtaWMoKSAmJiAhYm9keS5pc0J1bGxldCgpICYmICFvdGhlci5pc0J1bGxldCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHNlbnNvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbnNvckEgPSBjb250YWN0Lm1fZml4dHVyZUEubV9pc1NlbnNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vuc29yQiA9IGNvbnRhY3QubV9maXh0dXJlQi5tX2lzU2Vuc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZW5zb3JBIHx8IHNlbnNvckIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlbnRhdGl2ZWx5IGFkdmFuY2UgdGhlIGJvZHkgdG8gdGhlIFRPSS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrdXAuc2V0KG90aGVyLm1fc3dlZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlci5tX2lzbGFuZEZsYWcgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuYWR2YW5jZShtaW5BbHBoYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGFjdCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0LnVwZGF0ZSh3b3JsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FzIHRoZSBjb250YWN0IGRpc2FibGVkIGJ5IHRoZSB1c2VyP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZSB0aGVyZSBjb250YWN0IHBvaW50cz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5pc0VuYWJsZWQoKSA9PSBmYWxzZSB8fCBjb250YWN0LmlzVG91Y2hpbmcoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5tX3N3ZWVwLnNldChiYWNrdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5zeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb250YWN0IHRvIHRoZSBpc2xhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm1faXNsYW5kRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDb250YWN0KGNvbnRhY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcyB0aGUgb3RoZXIgYm9keSBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIGlzbGFuZD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIubV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG90aGVyIGJvZHkgdG8gdGhlIGlzbGFuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRCb2R5KG90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzX3N1YlN0ZXAucmVzZXQoKDEuMCAtIG1pbkFscGhhKSAqIHN0ZXAuZHQpO1xuICAgICAgICAgICAgICAgIHNfc3ViU3RlcC5kdFJhdGlvID0gMS4wO1xuICAgICAgICAgICAgICAgIHNfc3ViU3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnMgPSAyMDtcbiAgICAgICAgICAgICAgICBzX3N1YlN0ZXAudmVsb2NpdHlJdGVyYXRpb25zID0gc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgc19zdWJTdGVwLndhcm1TdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc29sdmVJc2xhbmRUT0koc19zdWJTdGVwLCBiQSwgYkIpO1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGlzbGFuZCBmbGFncyBhbmQgc3luY2hyb25pemUgYnJvYWQtcGhhc2UgcHJveGllcy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBib2R5Lm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvZHkuaXNEeW5hbWljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuc3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCBjb250YWN0IFRPSXMgb24gdGhpcyBkaXNwbGFjZWQgYm9keS5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY2UgPSBib2R5Lm1fY29udGFjdExpc3Q7IGNlOyBjZSA9IGNlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlLmNvbnRhY3QubV90b2lGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZS5jb250YWN0Lm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENvbW1pdCBmaXh0dXJlIHByb3h5IG1vdmVtZW50cyB0byB0aGUgYnJvYWQtcGhhc2Ugc28gdGhhdCBuZXcgY29udGFjdHNcbiAgICAgICAgICAgICAgICAvLyBhcmUgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICAvLyBBbHNvLCBzb21lIGNvbnRhY3RzIGNhbiBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAgICAgICAgd29ybGQuZmluZE5ld0NvbnRhY3RzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmxkLm1fc3ViU3RlcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ybGQubV9zdGVwQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLnNvbHZlSXNsYW5kVE9JID0gZnVuY3Rpb24gKHN1YlN0ZXAsIHRvaUEsIHRvaUIpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGJvZHkgc3RhdGUuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ib2RpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgY29weVZlYzIoYm9keS5jX3Bvc2l0aW9uLmMsIGJvZHkubV9zd2VlcC5jKTtcbiAgICAgICAgICAgICAgICBib2R5LmNfcG9zaXRpb24uYSA9IGJvZHkubV9zd2VlcC5hO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKGJvZHkuY192ZWxvY2l0eS52LCBib2R5Lm1fbGluZWFyVmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgIGJvZHkuY192ZWxvY2l0eS53ID0gYm9keS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbaV07XG4gICAgICAgICAgICAgICAgY29udGFjdC5pbml0Q29uc3RyYWludChzdWJTdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbHZlIHBvc2l0aW9uIGNvbnN0cmFpbnRzLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJTdGVwLnBvc2l0aW9uSXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblNlcGFyYXRpb24gPSAwLjA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1fY29udGFjdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gY29udGFjdC5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludFRPSShzdWJTdGVwLCB0b2lBLCB0b2lCKTtcbiAgICAgICAgICAgICAgICAgICAgbWluU2VwYXJhdGlvbiA9IG1hdGhfbWluJDUobWluU2VwYXJhdGlvbiwgc2VwYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGV4cGVjdCBtaW5TcGVwYXJhdGlvbiA+PSAtU2V0dGluZ3MubGluZWFyU2xvcCBiZWNhdXNlIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgc2VwYXJhdGlvbiBhYm92ZSAtU2V0dGluZ3MubGluZWFyU2xvcC5cbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdHNPa2F5ID0gbWluU2VwYXJhdGlvbiA+PSAtMS41ICogU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbG9wO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWN0c09rYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGk7IFxuICAgICAgICAgICAgLy8gTGVhcCBvZiBmYWl0aCB0byBuZXcgc2FmZSBzdGF0ZS5cbiAgICAgICAgICAgIGNvcHlWZWMyKHRvaUEubV9zd2VlcC5jMCwgdG9pQS5jX3Bvc2l0aW9uLmMpO1xuICAgICAgICAgICAgdG9pQS5tX3N3ZWVwLmEwID0gdG9pQS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICBjb3B5VmVjMih0b2lCLm1fc3dlZXAuYzAsIHRvaUIuY19wb3NpdGlvbi5jKTtcbiAgICAgICAgICAgIHRvaUIubV9zd2VlcC5hMCA9IHRvaUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgLy8gTm8gd2FybSBzdGFydGluZyBpcyBuZWVkZWQgZm9yIFRPSSBldmVudHMgYmVjYXVzZSB3YXJtXG4gICAgICAgICAgICAvLyBzdGFydGluZyBpbXB1bHNlcyB3ZXJlIGFwcGxpZWQgaW4gdGhlIGRpc2NyZXRlIHNvbHZlci5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbaV07XG4gICAgICAgICAgICAgICAgY29udGFjdC5pbml0VmVsb2NpdHlDb25zdHJhaW50KHN1YlN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29sdmUgdmVsb2NpdHkgY29uc3RyYWludHMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YlN0ZXAudmVsb2NpdHlJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludChzdWJTdGVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBzdG9yZSB0aGUgVE9JIGNvbnRhY3QgZm9yY2VzIGZvciB3YXJtIHN0YXJ0aW5nXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgY2FuIGJlIHF1aXRlIGxhcmdlLlxuICAgICAgICAgICAgdmFyIGggPSBzdWJTdGVwLmR0O1xuICAgICAgICAgICAgLy8gSW50ZWdyYXRlIHBvc2l0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fYm9kaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKGMsIGJvZHkuY19wb3NpdGlvbi5jKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGJvZHkuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKHYsIGJvZHkuY192ZWxvY2l0eS52KTtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IGJvZHkuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBsYXJnZSB2ZWxvY2l0aWVzXG4gICAgICAgICAgICAgICAgc2V0TXVsVmVjMih0cmFuc2xhdGlvbiwgaCwgdik7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTGVuZ3RoU3FyID0gbGVuZ3RoU3FyVmVjMih0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9uTGVuZ3RoU3FyID4gU2V0dGluZ3NJbnRlcm5hbC5tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gU2V0dGluZ3NJbnRlcm5hbC5tYXhUcmFuc2xhdGlvbiAvIG1hdGhfc3FydCQzKHRyYW5zbGF0aW9uTGVuZ3RoU3FyKTtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVWZWMyKHYsIHJhdGlvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gaCAqIHc7XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBTZXR0aW5nc0ludGVybmFsLm1heFJvdGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBTZXR0aW5nc0ludGVybmFsLm1heFJvdGF0aW9uIC8gbWF0aF9hYnMkNihyb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHcgKj0gcmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEludGVncmF0ZVxuICAgICAgICAgICAgICAgIGFkZE11bFZlYzIoYywgaCwgdik7XG4gICAgICAgICAgICAgICAgYSArPSBoICogdztcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihib2R5LmNfcG9zaXRpb24uYywgYyk7XG4gICAgICAgICAgICAgICAgYm9keS5jX3Bvc2l0aW9uLmEgPSBhO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKGJvZHkuY192ZWxvY2l0eS52LCB2KTtcbiAgICAgICAgICAgICAgICBib2R5LmNfdmVsb2NpdHkudyA9IHc7XG4gICAgICAgICAgICAgICAgLy8gU3luYyBib2RpZXNcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihib2R5Lm1fc3dlZXAuYywgYyk7XG4gICAgICAgICAgICAgICAgYm9keS5tX3N3ZWVwLmEgPSBhO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKGJvZHkubV9saW5lYXJWZWxvY2l0eSwgdik7XG4gICAgICAgICAgICAgICAgYm9keS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHc7XG4gICAgICAgICAgICAgICAgYm9keS5zeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3N0U29sdmVJc2xhbmQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLnBvc3RTb2x2ZUlzbGFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNfNSA9IDA7IGNfNSA8IHRoaXMubV9jb250YWN0cy5sZW5ndGg7ICsrY181KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLm1fY29udGFjdHNbY181XTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fd29ybGQucG9zdFNvbHZlKGNvbnRhY3QsIGNvbnRhY3QubV9pbXB1bHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNvbHZlcjtcbiAgICB9KCkpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBTb2x2ZXIuVGltZVN0ZXAgPSBUaW1lU3RlcDtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIDItYnktMiBtYXRyaXguIFN0b3JlZCBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXG4gICAgICovXG4gICAgdmFyIE1hdDIyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNYXQyMihhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ID0gVmVjMi5jbG9uZShhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV5ID0gVmVjMi5jbG9uZShiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXggPSBWZWMyLm5lbyhhLCBjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV5ID0gVmVjMi5uZW8oYiwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTWF0MjIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5pc1ZhbGlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBWZWMyLmlzVmFsaWQob2JqLmV4KSAmJiBWZWMyLmlzVmFsaWQob2JqLmV5KTtcbiAgICAgICAgfTtcbiAgICAgICAgTWF0MjIuYXNzZXJ0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgfTtcbiAgICAgICAgTWF0MjIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4LnNldE51bShhLCBjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV5LnNldE51bShiLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4LnNldFZlYzIoYSk7XG4gICAgICAgICAgICAgICAgdGhpcy5leS5zZXRWZWMyKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leC5zZXRWZWMyKGEuZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXkuc2V0VmVjMihhLmV5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5wcm90b3R5cGUuc2V0SWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmV4LnggPSAxLjA7XG4gICAgICAgICAgICB0aGlzLmV5LnggPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmV4LnkgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmV5LnkgPSAxLjA7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDIyLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5leC54ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5leS54ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5leC55ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5leS55ID0gMC4wO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5wcm90b3R5cGUuZ2V0SW52ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5leC54O1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmV5Lng7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZXgueTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5leS55O1xuICAgICAgICAgICAgdmFyIGRldCA9IGEgKiBkIC0gYiAqIGM7XG4gICAgICAgICAgICBpZiAoZGV0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW14ID0gbmV3IE1hdDIyKCk7XG4gICAgICAgICAgICBpbXguZXgueCA9IGRldCAqIGQ7XG4gICAgICAgICAgICBpbXguZXkueCA9IC1kZXQgKiBiO1xuICAgICAgICAgICAgaW14LmV4LnkgPSAtZGV0ICogYztcbiAgICAgICAgICAgIGlteC5leS55ID0gZGV0ICogYTtcbiAgICAgICAgICAgIHJldHVybiBpbXg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb2x2ZSBBICogeCA9IGIsIHdoZXJlIGIgaXMgYSBjb2x1bW4gdmVjdG9yLiBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW5cbiAgICAgICAgICogY29tcHV0aW5nIHRoZSBpbnZlcnNlIGluIG9uZS1zaG90IGNhc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgTWF0MjIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5leC54O1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmV5Lng7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZXgueTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5leS55O1xuICAgICAgICAgICAgdmFyIGRldCA9IGEgKiBkIC0gYiAqIGM7XG4gICAgICAgICAgICBpZiAoZGV0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdyA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgdy54ID0gZGV0ICogKGQgKiB2LnggLSBiICogdi55KTtcbiAgICAgICAgICAgIHcueSA9IGRldCAqIChhICogdi55IC0gYyAqIHYueCk7XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfTtcbiAgICAgICAgTWF0MjIubXVsID0gZnVuY3Rpb24gKG14LCB2KSB7XG4gICAgICAgICAgICBpZiAodiAmJiAneCcgaW4gdiAmJiAneScgaW4gdikge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gbXguZXgueCAqIHYueCArIG14LmV5LnggKiB2Lnk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBteC5leC55ICogdi54ICsgbXguZXkueSAqIHYueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ICYmICdleCcgaW4gdiAmJiAnZXknIGluIHYpIHsgLy8gTWF0MjJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbmV3IE1hdDIyKFZlYzIubXVsKG14LCB2LmV4KSwgVmVjMi5tdWwobXgsIHYuZXkpKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG14LmV4LnggKiB2LmV4LnggKyBteC5leS54ICogdi5leC55O1xuICAgICAgICAgICAgICAgIHZhciBiID0gbXguZXgueCAqIHYuZXkueCArIG14LmV5LnggKiB2LmV5Lnk7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBteC5leC55ICogdi5leC54ICsgbXguZXkueSAqIHYuZXgueTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG14LmV4LnkgKiB2LmV5LnggKyBteC5leS55ICogdi5leS55O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MjIoYSwgYiwgYywgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1hdDIyLm11bFZlYzIgPSBmdW5jdGlvbiAobXgsIHYpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbXguZXgueCAqIHYueCArIG14LmV5LnggKiB2Lnk7XG4gICAgICAgICAgICB2YXIgeSA9IG14LmV4LnkgKiB2LnggKyBteC5leS55ICogdi55O1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5tdWxNYXQyMiA9IGZ1bmN0aW9uIChteCwgdikge1xuICAgICAgICAgICAgLy8gcmV0dXJuIG5ldyBNYXQyMihWZWMyLm11bChteCwgdi5leCksIFZlYzIubXVsKG14LCB2LmV5KSk7XG4gICAgICAgICAgICB2YXIgYSA9IG14LmV4LnggKiB2LmV4LnggKyBteC5leS54ICogdi5leC55O1xuICAgICAgICAgICAgdmFyIGIgPSBteC5leC54ICogdi5leS54ICsgbXguZXkueCAqIHYuZXkueTtcbiAgICAgICAgICAgIHZhciBjID0gbXguZXgueSAqIHYuZXgueCArIG14LmV5LnkgKiB2LmV4Lnk7XG4gICAgICAgICAgICB2YXIgZCA9IG14LmV4LnkgKiB2LmV5LnggKyBteC5leS55ICogdi5leS55O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQyMihhLCBiLCBjLCBkKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWF0MjIubXVsVCA9IGZ1bmN0aW9uIChteCwgdikge1xuICAgICAgICAgICAgaWYgKHYgJiYgJ3gnIGluIHYgJiYgJ3knIGluIHYpIHsgLy8gVmVjMlxuICAgICAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhWZWMyLmRvdCh2LCBteC5leCksIFZlYzIuZG90KHYsIG14LmV5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ICYmICdleCcgaW4gdiAmJiAnZXknIGluIHYpIHsgLy8gTWF0MjJcbiAgICAgICAgICAgICAgICB2YXIgYzEgPSBWZWMyLm5lbyhWZWMyLmRvdChteC5leCwgdi5leCksIFZlYzIuZG90KG14LmV5LCB2LmV4KSk7XG4gICAgICAgICAgICAgICAgdmFyIGMyID0gVmVjMi5uZW8oVmVjMi5kb3QobXguZXgsIHYuZXkpLCBWZWMyLmRvdChteC5leSwgdi5leSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MjIoYzEsIGMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWF0MjIubXVsVFZlYzIgPSBmdW5jdGlvbiAobXgsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyhWZWMyLmRvdCh2LCBteC5leCksIFZlYzIuZG90KHYsIG14LmV5KSk7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDIyLm11bFRNYXQyMiA9IGZ1bmN0aW9uIChteCwgdikge1xuICAgICAgICAgICAgdmFyIGMxID0gVmVjMi5uZW8oVmVjMi5kb3QobXguZXgsIHYuZXgpLCBWZWMyLmRvdChteC5leSwgdi5leCkpO1xuICAgICAgICAgICAgdmFyIGMyID0gVmVjMi5uZW8oVmVjMi5kb3QobXguZXgsIHYuZXkpLCBWZWMyLmRvdChteC5leSwgdi5leSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQyMihjMSwgYzIpO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5hYnMgPSBmdW5jdGlvbiAobXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MjIoVmVjMi5hYnMobXguZXgpLCBWZWMyLmFicyhteC5leSkpO1xuICAgICAgICB9O1xuICAgICAgICBNYXQyMi5hZGQgPSBmdW5jdGlvbiAobXgxLCBteDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MjIoVmVjMi5hZGQobXgxLmV4LCBteDIuZXgpLCBWZWMyLmFkZChteDEuZXksIG14Mi5leSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWF0MjI7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX3NxcnQkMiA9IE1hdGguc3FydDtcbiAgICAvKiogQGludGVybmFsICovIHZhciBwb2ludEEkMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcG9pbnRCJDEgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHRlbXAkMyA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY0EkMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY0IkMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZGlzdCA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcGxhbmVQb2ludCQyID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBjbGlwUG9pbnQkMSA9IHZlYzIoMCwgMCk7XG4gICAgZXhwb3J0cy5NYW5pZm9sZFR5cGUgPSB2b2lkIDA7XG4gICAgKGZ1bmN0aW9uIChNYW5pZm9sZFR5cGUpIHtcbiAgICAgICAgTWFuaWZvbGRUeXBlW01hbmlmb2xkVHlwZVtcImVfdW5zZXRcIl0gPSAtMV0gPSBcImVfdW5zZXRcIjtcbiAgICAgICAgTWFuaWZvbGRUeXBlW01hbmlmb2xkVHlwZVtcImVfY2lyY2xlc1wiXSA9IDBdID0gXCJlX2NpcmNsZXNcIjtcbiAgICAgICAgTWFuaWZvbGRUeXBlW01hbmlmb2xkVHlwZVtcImVfZmFjZUFcIl0gPSAxXSA9IFwiZV9mYWNlQVwiO1xuICAgICAgICBNYW5pZm9sZFR5cGVbTWFuaWZvbGRUeXBlW1wiZV9mYWNlQlwiXSA9IDJdID0gXCJlX2ZhY2VCXCI7XG4gICAgfSkoZXhwb3J0cy5NYW5pZm9sZFR5cGUgfHwgKGV4cG9ydHMuTWFuaWZvbGRUeXBlID0ge30pKTtcbiAgICBleHBvcnRzLkNvbnRhY3RGZWF0dXJlVHlwZSA9IHZvaWQgMDtcbiAgICAoZnVuY3Rpb24gKENvbnRhY3RGZWF0dXJlVHlwZSkge1xuICAgICAgICBDb250YWN0RmVhdHVyZVR5cGVbQ29udGFjdEZlYXR1cmVUeXBlW1wiZV91bnNldFwiXSA9IC0xXSA9IFwiZV91bnNldFwiO1xuICAgICAgICBDb250YWN0RmVhdHVyZVR5cGVbQ29udGFjdEZlYXR1cmVUeXBlW1wiZV92ZXJ0ZXhcIl0gPSAwXSA9IFwiZV92ZXJ0ZXhcIjtcbiAgICAgICAgQ29udGFjdEZlYXR1cmVUeXBlW0NvbnRhY3RGZWF0dXJlVHlwZVtcImVfZmFjZVwiXSA9IDFdID0gXCJlX2ZhY2VcIjtcbiAgICB9KShleHBvcnRzLkNvbnRhY3RGZWF0dXJlVHlwZSB8fCAoZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIHN0YXRlIG9mIGNvbnRhY3QgcG9pbnRzLlxuICAgICAqL1xuICAgIGV4cG9ydHMuUG9pbnRTdGF0ZSA9IHZvaWQgMDtcbiAgICAoZnVuY3Rpb24gKFBvaW50U3RhdGUpIHtcbiAgICAgICAgLyoqIFBvaW50IGRvZXMgbm90IGV4aXN0ICovXG4gICAgICAgIFBvaW50U3RhdGVbUG9pbnRTdGF0ZVtcIm51bGxTdGF0ZVwiXSA9IDBdID0gXCJudWxsU3RhdGVcIjtcbiAgICAgICAgLyoqIFBvaW50IHdhcyBhZGRlZCBpbiB0aGUgdXBkYXRlICovXG4gICAgICAgIFBvaW50U3RhdGVbUG9pbnRTdGF0ZVtcImFkZFN0YXRlXCJdID0gMV0gPSBcImFkZFN0YXRlXCI7XG4gICAgICAgIC8qKiBQb2ludCBwZXJzaXN0ZWQgYWNyb3NzIHRoZSB1cGRhdGUgKi9cbiAgICAgICAgUG9pbnRTdGF0ZVtQb2ludFN0YXRlW1wicGVyc2lzdFN0YXRlXCJdID0gMl0gPSBcInBlcnNpc3RTdGF0ZVwiO1xuICAgICAgICAvKiogUG9pbnQgd2FzIHJlbW92ZWQgaW4gdGhlIHVwZGF0ZSAqL1xuICAgICAgICBQb2ludFN0YXRlW1BvaW50U3RhdGVbXCJyZW1vdmVTdGF0ZVwiXSA9IDNdID0gXCJyZW1vdmVTdGF0ZVwiO1xuICAgIH0pKGV4cG9ydHMuUG9pbnRTdGF0ZSB8fCAoZXhwb3J0cy5Qb2ludFN0YXRlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBjb21wdXRpbmcgY29udGFjdCBtYW5pZm9sZHMuXG4gICAgICovXG4gICAgdmFyIENsaXBWZXJ0ZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENsaXBWZXJ0ZXgoKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSB2ZWMyKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5pZCA9IG5ldyBDb250YWN0SUQoKTtcbiAgICAgICAgfVxuICAgICAgICBDbGlwVmVydGV4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgY29weVZlYzIodGhpcy52LCBvLnYpO1xuICAgICAgICAgICAgdGhpcy5pZC5zZXQoby5pZCk7XG4gICAgICAgIH07XG4gICAgICAgIENsaXBWZXJ0ZXgucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLnYpO1xuICAgICAgICAgICAgdGhpcy5pZC5yZWN5Y2xlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDbGlwVmVydGV4O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQSBtYW5pZm9sZCBmb3IgdHdvIHRvdWNoaW5nIGNvbnZleCBzaGFwZXMuIE1hbmlmb2xkcyBhcmUgY3JlYXRlZCBpbiBgZXZhbHVhdGVgXG4gICAgICogbWV0aG9kIG9mIENvbnRhY3Qgc3ViY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIFN1cHBvcnRlZCBtYW5pZm9sZCB0eXBlcyBhcmUgZV9mYWNlQSBvciBlX2ZhY2VCIGZvciBjbGlwIHBvaW50IHZlcnN1cyBwbGFuZVxuICAgICAqIHdpdGggcmFkaXVzIGFuZCBlX2NpcmNsZXMgcG9pbnQgdmVyc3VzIHBvaW50IHdpdGggcmFkaXVzLlxuICAgICAqXG4gICAgICogV2Ugc3RvcmUgY29udGFjdHMgaW4gdGhpcyB3YXkgc28gdGhhdCBwb3NpdGlvbiBjb3JyZWN0aW9uIGNhbiBhY2NvdW50IGZvclxuICAgICAqIG1vdmVtZW50LCB3aGljaCBpcyBjcml0aWNhbCBmb3IgY29udGludW91cyBwaHlzaWNzLiBBbGwgY29udGFjdCBzY2VuYXJpb3NcbiAgICAgKiBtdXN0IGJlIGV4cHJlc3NlZCBpbiBvbmUgb2YgdGhlc2UgdHlwZXMuIFRoaXMgc3RydWN0dXJlIGlzIHN0b3JlZCBhY3Jvc3MgdGltZVxuICAgICAqIHN0ZXBzLCBzbyB3ZSBrZWVwIGl0IHNtYWxsLlxuICAgICAqL1xuICAgIHZhciBNYW5pZm9sZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWFuaWZvbGQoKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzYWdlIGRlcGVuZHMgb24gbWFuaWZvbGQgdHlwZTpcbiAgICAgICAgICAgICAqIC0gY2lyY2xlczogbm90IHVzZWRcbiAgICAgICAgICAgICAqIC0gZmFjZUE6IHRoZSBub3JtYWwgb24gcG9seWdvbkFcbiAgICAgICAgICAgICAqIC0gZmFjZUI6IHRoZSBub3JtYWwgb24gcG9seWdvbkJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5sb2NhbE5vcm1hbCA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzYWdlIGRlcGVuZHMgb24gbWFuaWZvbGQgdHlwZTpcbiAgICAgICAgICAgICAqIC0gY2lyY2xlczogdGhlIGxvY2FsIGNlbnRlciBvZiBjaXJjbGVBXG4gICAgICAgICAgICAgKiAtIGZhY2VBOiB0aGUgY2VudGVyIG9mIGZhY2VBXG4gICAgICAgICAgICAgKiAtIGZhY2VCOiB0aGUgY2VudGVyIG9mIGZhY2VCXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubG9jYWxQb2ludCA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICAvKiogVGhlIHBvaW50cyBvZiBjb250YWN0ICovXG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IFtuZXcgTWFuaWZvbGRQb2ludCgpLCBuZXcgTWFuaWZvbGRQb2ludCgpXTtcbiAgICAgICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIG1hbmlmb2xkIHBvaW50cyAqL1xuICAgICAgICAgICAgdGhpcy5wb2ludENvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBNYW5pZm9sZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHRoYXQudHlwZTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMubG9jYWxOb3JtYWwsIHRoYXQubG9jYWxOb3JtYWwpO1xuICAgICAgICAgICAgY29weVZlYzIodGhpcy5sb2NhbFBvaW50LCB0aGF0LmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5wb2ludENvdW50ID0gdGhhdC5wb2ludENvdW50O1xuICAgICAgICAgICAgdGhpcy5wb2ludHNbMF0uc2V0KHRoYXQucG9pbnRzWzBdKTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzWzFdLnNldCh0aGF0LnBvaW50c1sxXSk7XG4gICAgICAgIH07XG4gICAgICAgIE1hbmlmb2xkLnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gZXhwb3J0cy5NYW5pZm9sZFR5cGUuZV91bnNldDtcbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMubG9jYWxOb3JtYWwpO1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy5sb2NhbFBvaW50KTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnBvaW50c1swXS5yZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLnBvaW50c1sxXS5yZWN5Y2xlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmFsdWF0ZSB0aGUgbWFuaWZvbGQgd2l0aCBzdXBwbGllZCB0cmFuc2Zvcm1zLiBUaGlzIGFzc3VtZXMgbW9kZXN0IG1vdGlvblxuICAgICAgICAgKiBmcm9tIHRoZSBvcmlnaW5hbCBzdGF0ZS4gVGhpcyBkb2VzIG5vdCBjaGFuZ2UgdGhlIHBvaW50IGNvdW50LCBpbXB1bHNlcywgZXRjLlxuICAgICAgICAgKiBUaGUgcmFkaWkgbXVzdCBjb21lIGZyb20gdGhlIHNoYXBlcyB0aGF0IGdlbmVyYXRlZCB0aGUgbWFuaWZvbGQuXG4gICAgICAgICAqL1xuICAgICAgICBNYW5pZm9sZC5wcm90b3R5cGUuZ2V0V29ybGRNYW5pZm9sZCA9IGZ1bmN0aW9uICh3bSwgeGZBLCByYWRpdXNBLCB4ZkIsIHJhZGl1c0IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50Q291bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdtID0gd20gfHwgbmV3IFdvcmxkTWFuaWZvbGQoKTtcbiAgICAgICAgICAgIHdtLnBvaW50Q291bnQgPSB0aGlzLnBvaW50Q291bnQ7XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gd20ubm9ybWFsO1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHdtLnBvaW50cztcbiAgICAgICAgICAgIHZhciBzZXBhcmF0aW9ucyA9IHdtLnNlcGFyYXRpb25zO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuTWFuaWZvbGRUeXBlLmVfY2lyY2xlczoge1xuICAgICAgICAgICAgICAgICAgICBzZXRWZWMyKG5vcm1hbCwgMS4wLCAwLjApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFuaWZvbGRQb2ludCA9IHRoaXMucG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHBvaW50QSQxLCB4ZkEsIHRoaXMubG9jYWxQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZlYzIocG9pbnRCJDEsIHhmQiwgbWFuaWZvbGRQb2ludC5sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZlZlYzIoZGlzdCwgcG9pbnRCJDEsIHBvaW50QSQxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aFNxciA9IGxlbmd0aFNxclZlYzIoZGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGhTcXIgPiBFUFNJTE9OICogRVBTSUxPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gbWF0aF9zcXJ0JDIobGVuZ3RoU3FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIobm9ybWFsLCAxIC8gbGVuZ3RoXzEsIGRpc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVWZWMyKGNBJDEsIDEsIHBvaW50QSQxLCByYWRpdXNBLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICBjb21iaW5lVmVjMihjQiQxLCAxLCBwb2ludEIkMSwgLXJhZGl1c0IsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVWZWMyKHBvaW50c1swXSwgMC41LCBjQSQxLCAwLjUsIGNCJDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uc1swXSA9IGRvdFZlYzIoZGlmZlZlYzIodGVtcCQzLCBjQiQxLCBjQSQxKSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5NYW5pZm9sZFR5cGUuZV9mYWNlQToge1xuICAgICAgICAgICAgICAgICAgICByb3RWZWMyKG5vcm1hbCwgeGZBLnEsIHRoaXMubG9jYWxOb3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHBsYW5lUG9pbnQkMiwgeGZBLCB0aGlzLmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFuaWZvbGRQb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihjbGlwUG9pbnQkMSwgeGZCLCBtYW5pZm9sZFBvaW50LmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZVZlYzIoY0EkMSwgMSwgY2xpcFBvaW50JDEsIHJhZGl1c0EgLSBkb3RWZWMyKGRpZmZWZWMyKHRlbXAkMywgY2xpcFBvaW50JDEsIHBsYW5lUG9pbnQkMiksIG5vcm1hbCksIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lVmVjMihjQiQxLCAxLCBjbGlwUG9pbnQkMSwgLXJhZGl1c0IsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lVmVjMihwb2ludHNbaV0sIDAuNSwgY0EkMSwgMC41LCBjQiQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb25zW2ldID0gZG90VmVjMihkaWZmVmVjMih0ZW1wJDMsIGNCJDEsIGNBJDEpLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuTWFuaWZvbGRUeXBlLmVfZmFjZUI6IHtcbiAgICAgICAgICAgICAgICAgICAgcm90VmVjMihub3JtYWwsIHhmQi5xLCB0aGlzLmxvY2FsTm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwbGFuZVBvaW50JDIsIHhmQiwgdGhpcy5sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hbmlmb2xkUG9pbnQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZlYzIoY2xpcFBvaW50JDEsIHhmQSwgbWFuaWZvbGRQb2ludC5sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmVWZWMyKGNCJDEsIDEsIGNsaXBQb2ludCQxLCByYWRpdXNCIC0gZG90VmVjMihkaWZmVmVjMih0ZW1wJDMsIGNsaXBQb2ludCQxLCBwbGFuZVBvaW50JDIpLCBub3JtYWwpLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZVZlYzIoY0EkMSwgMSwgY2xpcFBvaW50JDEsIC1yYWRpdXNBLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZVZlYzIocG9pbnRzW2ldLCAwLjUsIGNBJDEsIDAuNSwgY0IkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uc1tpXSA9IGRvdFZlYzIoZGlmZlZlYzIodGVtcCQzLCBjQSQxLCBjQiQxKSwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgbm9ybWFsIHBvaW50cyBmcm9tIEEgdG8gQi5cbiAgICAgICAgICAgICAgICAgICAgbmVnVmVjMihub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd207XG4gICAgICAgIH07XG4gICAgICAgIE1hbmlmb2xkLmNsaXBTZWdtZW50VG9MaW5lID0gY2xpcFNlZ21lbnRUb0xpbmU7XG4gICAgICAgIE1hbmlmb2xkLkNsaXBWZXJ0ZXggPSBDbGlwVmVydGV4O1xuICAgICAgICBNYW5pZm9sZC5nZXRQb2ludFN0YXRlcyA9IGdldFBvaW50U3RhdGVzO1xuICAgICAgICBNYW5pZm9sZC5Qb2ludFN0YXRlID0gZXhwb3J0cy5Qb2ludFN0YXRlO1xuICAgICAgICByZXR1cm4gTWFuaWZvbGQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIG1hbmlmb2xkIHBvaW50IGlzIGEgY29udGFjdCBwb2ludCBiZWxvbmdpbmcgdG8gYSBjb250YWN0IG1hbmlmb2xkLiBJdCBob2xkc1xuICAgICAqIGRldGFpbHMgcmVsYXRlZCB0byB0aGUgZ2VvbWV0cnkgYW5kIGR5bmFtaWNzIG9mIHRoZSBjb250YWN0IHBvaW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RydWN0dXJlIGlzIHN0b3JlZCBhY3Jvc3MgdGltZSBzdGVwcywgc28gd2Uga2VlcCBpdCBzbWFsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGltcHVsc2VzIGFyZSB1c2VkIGZvciBpbnRlcm5hbCBjYWNoaW5nIGFuZCBtYXkgbm90IHByb3ZpZGUgcmVsaWFibGVcbiAgICAgKiBjb250YWN0IGZvcmNlcywgZXNwZWNpYWxseSBmb3IgaGlnaCBzcGVlZCBjb2xsaXNpb25zLlxuICAgICAqL1xuICAgIHZhciBNYW5pZm9sZFBvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNYW5pZm9sZFBvaW50KCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2FnZSBkZXBlbmRzIG9uIG1hbmlmb2xkIHR5cGU6XG4gICAgICAgICAgICAgKiAtIGNpcmNsZXM6IHRoZSBsb2NhbCBjZW50ZXIgb2YgY2lyY2xlQlxuICAgICAgICAgICAgICogLSBmYWNlQTogdGhlIGxvY2FsIGNlbnRlciBvZiBjaXJjbGVCIG9yIHRoZSBjbGlwIHBvaW50IG9mIHBvbHlnb25CXG4gICAgICAgICAgICAgKiAtIGZhY2VCOiB0aGUgY2xpcCBwb2ludCBvZiBwb2x5Z29uQVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9pbnQgPSB2ZWMyKDAsIDApO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbm9uLXBlbmV0cmF0aW9uIGltcHVsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGZyaWN0aW9uIGltcHVsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50YW5nZW50SW1wdWxzZSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVuaXF1ZWx5IGlkZW50aWZpZXMgYSBjb250YWN0IHBvaW50IGJldHdlZW4gdHdvIHNoYXBlcyB0byBmYWNpbGl0YXRlIHdhcm0gc3RhcnRpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pZCA9IG5ldyBDb250YWN0SUQoKTtcbiAgICAgICAgfVxuICAgICAgICBNYW5pZm9sZFBvaW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICAgICAgY29weVZlYzIodGhpcy5sb2NhbFBvaW50LCB0aGF0LmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gdGhhdC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgdGhpcy50YW5nZW50SW1wdWxzZSA9IHRoYXQudGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICB0aGlzLmlkLnNldCh0aGF0LmlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWFuaWZvbGRQb2ludC5wcm90b3R5cGUucmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMubG9jYWxQb2ludCk7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgdGhpcy50YW5nZW50SW1wdWxzZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmlkLnJlY3ljbGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1hbmlmb2xkUG9pbnQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBDb250YWN0IGlkcyB0byBmYWNpbGl0YXRlIHdhcm0gc3RhcnRpbmcuXG4gICAgICpcbiAgICAgKiBDb250YWN0RmVhdHVyZTogVGhlIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IHRvIGZvcm0gdGhlIGNvbnRhY3QgcG9pbnQuXG4gICAgICovXG4gICAgdmFyIENvbnRhY3RJRCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29udGFjdElEKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2VkIHRvIHF1aWNrbHkgY29tcGFyZSBjb250YWN0IGlkcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5rZXkgPSAtMTtcbiAgICAgICAgICAgIC8qKiBDb250YWN0RmVhdHVyZSBpbmRleCBvbiBzaGFwZUEgKi9cbiAgICAgICAgICAgIHRoaXMuaW5kZXhBID0gLTE7XG4gICAgICAgICAgICAvKiogQ29udGFjdEZlYXR1cmUgaW5kZXggb24gc2hhcGVCICovXG4gICAgICAgICAgICB0aGlzLmluZGV4QiA9IC0xO1xuICAgICAgICAgICAgLyoqIENvbnRhY3RGZWF0dXJlIHR5cGUgb24gc2hhcGVBICovXG4gICAgICAgICAgICB0aGlzLnR5cGVBID0gZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV91bnNldDtcbiAgICAgICAgICAgIC8qKiBDb250YWN0RmVhdHVyZSB0eXBlIG9uIHNoYXBlQiAqL1xuICAgICAgICAgICAgdGhpcy50eXBlQiA9IGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdW5zZXQ7XG4gICAgICAgIH1cbiAgICAgICAgQ29udGFjdElELnByb3RvdHlwZS5zZXRGZWF0dXJlcyA9IGZ1bmN0aW9uIChpbmRleEEsIHR5cGVBLCBpbmRleEIsIHR5cGVCKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4QSA9IGluZGV4QTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCID0gaW5kZXhCO1xuICAgICAgICAgICAgdGhpcy50eXBlQSA9IHR5cGVBO1xuICAgICAgICAgICAgdGhpcy50eXBlQiA9IHR5cGVCO1xuICAgICAgICAgICAgdGhpcy5rZXkgPSB0aGlzLmluZGV4QSArIHRoaXMuaW5kZXhCICogNCArIHRoaXMudHlwZUEgKiAxNiArIHRoaXMudHlwZUIgKiA2NDtcbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdElELnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleEEgPSB0aGF0LmluZGV4QTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCID0gdGhhdC5pbmRleEI7XG4gICAgICAgICAgICB0aGlzLnR5cGVBID0gdGhhdC50eXBlQTtcbiAgICAgICAgICAgIHRoaXMudHlwZUIgPSB0aGF0LnR5cGVCO1xuICAgICAgICAgICAgdGhpcy5rZXkgPSB0aGlzLmluZGV4QSArIHRoaXMuaW5kZXhCICogNCArIHRoaXMudHlwZUEgKiAxNiArIHRoaXMudHlwZUIgKiA2NDtcbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdElELnByb3RvdHlwZS5zd2FwRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhBID0gdGhpcy5pbmRleEE7XG4gICAgICAgICAgICB2YXIgaW5kZXhCID0gdGhpcy5pbmRleEI7XG4gICAgICAgICAgICB2YXIgdHlwZUEgPSB0aGlzLnR5cGVBO1xuICAgICAgICAgICAgdmFyIHR5cGVCID0gdGhpcy50eXBlQjtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhBID0gaW5kZXhCO1xuICAgICAgICAgICAgdGhpcy5pbmRleEIgPSBpbmRleEE7XG4gICAgICAgICAgICB0aGlzLnR5cGVBID0gdHlwZUI7XG4gICAgICAgICAgICB0aGlzLnR5cGVCID0gdHlwZUE7XG4gICAgICAgICAgICB0aGlzLmtleSA9IHRoaXMuaW5kZXhBICsgdGhpcy5pbmRleEIgKiA0ICsgdGhpcy50eXBlQSAqIDE2ICsgdGhpcy50eXBlQiAqIDY0O1xuICAgICAgICB9O1xuICAgICAgICBDb250YWN0SUQucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4QSA9IDA7XG4gICAgICAgICAgICB0aGlzLmluZGV4QiA9IDA7XG4gICAgICAgICAgICB0aGlzLnR5cGVBID0gZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV91bnNldDtcbiAgICAgICAgICAgIHRoaXMudHlwZUIgPSBleHBvcnRzLkNvbnRhY3RGZWF0dXJlVHlwZS5lX3Vuc2V0O1xuICAgICAgICAgICAgdGhpcy5rZXkgPSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbnRhY3RJRDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBjb21wdXRlIHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgY29udGFjdCBtYW5pZm9sZC5cbiAgICAgKi9cbiAgICB2YXIgV29ybGRNYW5pZm9sZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV29ybGRNYW5pZm9sZCgpIHtcbiAgICAgICAgICAgIC8qKiBXb3JsZCB2ZWN0b3IgcG9pbnRpbmcgZnJvbSBBIHRvIEIgKi9cbiAgICAgICAgICAgIHRoaXMubm9ybWFsID0gdmVjMigwLCAwKTtcbiAgICAgICAgICAgIC8qKiBXb3JsZCBjb250YWN0IHBvaW50IChwb2ludCBvZiBpbnRlcnNlY3Rpb24pICovXG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IFt2ZWMyKDAsIDApLCB2ZWMyKDAsIDApXTsgLy8gW21heE1hbmlmb2xkUG9pbnRzXVxuICAgICAgICAgICAgLyoqIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIG92ZXJsYXAsIGluIG1ldGVycyAqL1xuICAgICAgICAgICAgdGhpcy5zZXBhcmF0aW9ucyA9IFswLCAwXTsgLy8gW21heE1hbmlmb2xkUG9pbnRzXVxuICAgICAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgbWFuaWZvbGQgcG9pbnRzICovXG4gICAgICAgICAgICB0aGlzLnBvaW50Q291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFdvcmxkTWFuaWZvbGQucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLm5vcm1hbCk7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLnBvaW50c1swXSk7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLnBvaW50c1sxXSk7XG4gICAgICAgICAgICB0aGlzLnNlcGFyYXRpb25zWzBdID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2VwYXJhdGlvbnNbMV0gPSAwO1xuICAgICAgICAgICAgdGhpcy5wb2ludENvdW50ID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFdvcmxkTWFuaWZvbGQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBwb2ludCBzdGF0ZXMgZ2l2ZW4gdHdvIG1hbmlmb2xkcy4gVGhlIHN0YXRlcyBwZXJ0YWluIHRvIHRoZVxuICAgICAqIHRyYW5zaXRpb24gZnJvbSBtYW5pZm9sZDEgdG8gbWFuaWZvbGQyLiBTbyBzdGF0ZTEgaXMgZWl0aGVyIHBlcnNpc3Qgb3IgcmVtb3ZlXG4gICAgICogd2hpbGUgc3RhdGUyIGlzIGVpdGhlciBhZGQgb3IgcGVyc2lzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQb2ludFN0YXRlcyhzdGF0ZTEsIHN0YXRlMiwgbWFuaWZvbGQxLCBtYW5pZm9sZDIpIHtcbiAgICAgICAgLy8gc3RhdGUxLCBzdGF0ZTI6IFBvaW50U3RhdGVbU2V0dGluZ3MubWF4TWFuaWZvbGRQb2ludHNdXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgU2V0dGluZ3MubWF4TWFuaWZvbGRQb2ludHM7ICsraSkge1xuICAgICAgICAvLyBzdGF0ZTFbaV0gPSBQb2ludFN0YXRlLm51bGxTdGF0ZTtcbiAgICAgICAgLy8gc3RhdGUyW2ldID0gUG9pbnRTdGF0ZS5udWxsU3RhdGU7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gRGV0ZWN0IHBlcnNpc3RzIGFuZCByZW1vdmVzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hbmlmb2xkMS5wb2ludENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG1hbmlmb2xkMS5wb2ludHNbaV0uaWQ7XG4gICAgICAgICAgICBzdGF0ZTFbaV0gPSBleHBvcnRzLlBvaW50U3RhdGUucmVtb3ZlU3RhdGU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hbmlmb2xkMi5wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAobWFuaWZvbGQyLnBvaW50c1tqXS5pZC5rZXkgPT09IGlkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTFbaV0gPSBleHBvcnRzLlBvaW50U3RhdGUucGVyc2lzdFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZWN0IHBlcnNpc3RzIGFuZCBhZGRzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hbmlmb2xkMi5wb2ludENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG1hbmlmb2xkMi5wb2ludHNbaV0uaWQ7XG4gICAgICAgICAgICBzdGF0ZTJbaV0gPSBleHBvcnRzLlBvaW50U3RhdGUuYWRkU3RhdGU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hbmlmb2xkMS5wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAobWFuaWZvbGQxLnBvaW50c1tqXS5pZC5rZXkgPT09IGlkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTJbaV0gPSBleHBvcnRzLlBvaW50U3RhdGUucGVyc2lzdFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xpcHBpbmcgZm9yIGNvbnRhY3QgbWFuaWZvbGRzLiBTdXRoZXJsYW5kLUhvZGdtYW4gY2xpcHBpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xpcFNlZ21lbnRUb0xpbmUodk91dCwgdkluLCBub3JtYWwsIG9mZnNldCwgdmVydGV4SW5kZXhBKSB7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggbm8gb3V0cHV0IHBvaW50c1xuICAgICAgICB2YXIgbnVtT3V0ID0gMDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBvZiBlbmQgcG9pbnRzIHRvIHRoZSBsaW5lXG4gICAgICAgIHZhciBkaXN0YW5jZTAgPSBkb3RWZWMyKG5vcm1hbCwgdkluWzBdLnYpIC0gb2Zmc2V0O1xuICAgICAgICB2YXIgZGlzdGFuY2UxID0gZG90VmVjMihub3JtYWwsIHZJblsxXS52KSAtIG9mZnNldDtcbiAgICAgICAgLy8gSWYgdGhlIHBvaW50cyBhcmUgYmVoaW5kIHRoZSBwbGFuZVxuICAgICAgICBpZiAoZGlzdGFuY2UwIDw9IDAuMClcbiAgICAgICAgICAgIHZPdXRbbnVtT3V0KytdLnNldCh2SW5bMF0pO1xuICAgICAgICBpZiAoZGlzdGFuY2UxIDw9IDAuMClcbiAgICAgICAgICAgIHZPdXRbbnVtT3V0KytdLnNldCh2SW5bMV0pO1xuICAgICAgICAvLyBJZiB0aGUgcG9pbnRzIGFyZSBvbiBkaWZmZXJlbnQgc2lkZXMgb2YgdGhlIHBsYW5lXG4gICAgICAgIGlmIChkaXN0YW5jZTAgKiBkaXN0YW5jZTEgPCAwLjApIHtcbiAgICAgICAgICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGVkZ2UgYW5kIHBsYW5lXG4gICAgICAgICAgICB2YXIgaW50ZXJwID0gZGlzdGFuY2UwIC8gKGRpc3RhbmNlMCAtIGRpc3RhbmNlMSk7XG4gICAgICAgICAgICBjb21iaW5lVmVjMih2T3V0W251bU91dF0udiwgMSAtIGludGVycCwgdkluWzBdLnYsIGludGVycCwgdkluWzFdLnYpO1xuICAgICAgICAgICAgLy8gVmVydGV4QSBpcyBoaXR0aW5nIGVkZ2VCLlxuICAgICAgICAgICAgdk91dFtudW1PdXRdLmlkLnNldEZlYXR1cmVzKHZlcnRleEluZGV4QSwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgsIHZJblswXS5pZC5pbmRleEIsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfZmFjZSk7XG4gICAgICAgICAgICArK251bU91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtT3V0O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX3NxcnQkMSA9IE1hdGguc3FydDtcbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX21heCQyID0gTWF0aC5tYXg7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9taW4kNCA9IE1hdGgubWluO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGNvbnRhY3RQb29sID0gbmV3IFBvb2woe1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udGFjdCgpO1xuICAgICAgICB9LFxuICAgICAgICByZWxlYXNlOiBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgICAgICAgY29udGFjdC5yZWN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBvbGRNYW5pZm9sZCA9IG5ldyBNYW5pZm9sZCgpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHdvcmxkTWFuaWZvbGQgPSBuZXcgV29ybGRNYW5pZm9sZCgpO1xuICAgIC8qKlxuICAgICAqIEEgY29udGFjdCBlZGdlIGlzIHVzZWQgdG8gY29ubmVjdCBib2RpZXMgYW5kIGNvbnRhY3RzIHRvZ2V0aGVyIGluIGEgY29udGFjdFxuICAgICAqIGdyYXBoIHdoZXJlIGVhY2ggYm9keSBpcyBhIG5vZGUgYW5kIGVhY2ggY29udGFjdCBpcyBhbiBlZGdlLiBBIGNvbnRhY3QgZWRnZVxuICAgICAqIGJlbG9uZ3MgdG8gYSBkb3VibHkgbGlua2VkIGxpc3QgbWFpbnRhaW5lZCBpbiBlYWNoIGF0dGFjaGVkIGJvZHkuIEVhY2hcbiAgICAgKiBjb250YWN0IGhhcyB0d28gY29udGFjdCBub2Rlcywgb25lIGZvciBlYWNoIGF0dGFjaGVkIGJvZHkuXG4gICAgICovXG4gICAgdmFyIENvbnRhY3RFZGdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb250YWN0RWRnZShjb250YWN0KSB7XG4gICAgICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub3RoZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIENvbnRhY3RFZGdlLnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm90aGVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbnRhY3RFZGdlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogRnJpY3Rpb24gbWl4aW5nIGxhdy4gVGhlIGlkZWEgaXMgdG8gYWxsb3cgZWl0aGVyIGZpeHR1cmUgdG8gZHJpdmUgdGhlXG4gICAgICogZnJpY3Rpb24gdG8gemVyby4gRm9yIGV4YW1wbGUsIGFueXRoaW5nIHNsaWRlcyBvbiBpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4RnJpY3Rpb24oZnJpY3Rpb24xLCBmcmljdGlvbjIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGhfc3FydCQxKGZyaWN0aW9uMSAqIGZyaWN0aW9uMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RpdHV0aW9uIG1peGluZyBsYXcuIFRoZSBpZGVhIGlzIGFsbG93IGZvciBhbnl0aGluZyB0byBib3VuY2Ugb2ZmIGFuXG4gICAgICogaW5lbGFzdGljIHN1cmZhY2UuIEZvciBleGFtcGxlLCBhIHN1cGVyYmFsbCBib3VuY2VzIG9uIGFueXRoaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peFJlc3RpdHV0aW9uKHJlc3RpdHV0aW9uMSwgcmVzdGl0dXRpb24yKSB7XG4gICAgICAgIHJldHVybiByZXN0aXR1dGlvbjEgPiByZXN0aXR1dGlvbjIgPyByZXN0aXR1dGlvbjEgOiByZXN0aXR1dGlvbjI7XG4gICAgfVxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyB0byBTZXR0aW5ncz9cbiAgICAvKiogQGludGVybmFsICovIHZhciBzX3JlZ2lzdGVycyA9IFtdO1xuICAgIC8vIFRPRE86IG1lcmdlIHdpdGggTWFuaWZvbGRQb2ludD9cbiAgICB2YXIgVmVsb2NpdHlDb25zdHJhaW50UG9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZlbG9jaXR5Q29uc3RyYWludFBvaW50KCkge1xuICAgICAgICAgICAgdGhpcy5yQSA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLnJCID0gdmVjMigwLCAwKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICB0aGlzLnRhbmdlbnRJbXB1bHNlID0gMDtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsTWFzcyA9IDA7XG4gICAgICAgICAgICB0aGlzLnRhbmdlbnRNYXNzID0gMDtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHlCaWFzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludC5wcm90b3R5cGUucmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMuckEpO1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy5yQik7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgdGhpcy50YW5nZW50SW1wdWxzZSA9IDA7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbE1hc3MgPSAwO1xuICAgICAgICAgICAgdGhpcy50YW5nZW50TWFzcyA9IDA7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5QmlhcyA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludDtcbiAgICB9KCkpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGNBID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciB2QSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY0IgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHZCID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciB0YW5nZW50JDEgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHhmQSA9IHRyYW5zZm9ybSgwLCAwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciB4ZkIgPSB0cmFuc2Zvcm0oMCwgMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcG9pbnRBID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBwb2ludEIgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGNsaXBQb2ludCA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcGxhbmVQb2ludCQxID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciByQSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgckIgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIFAkMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbm9ybWFsJDIgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHBvaW50ID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBkdiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZHYxID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBkdjIgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGIgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGEgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHggPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGQgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIFAxID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBQMiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdGVtcCQyID0gdmVjMigwLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgbWFuYWdlcyBjb250YWN0IGJldHdlZW4gdHdvIHNoYXBlcy4gQSBjb250YWN0IGV4aXN0cyBmb3IgZWFjaFxuICAgICAqIG92ZXJsYXBwaW5nIEFBQkIgaW4gdGhlIGJyb2FkLXBoYXNlIChleGNlcHQgaWYgZmlsdGVyZWQpLiBUaGVyZWZvcmUgYSBjb250YWN0XG4gICAgICogb2JqZWN0IG1heSBleGlzdCB0aGF0IGhhcyBubyBjb250YWN0IHBvaW50cy5cbiAgICAgKi9cbiAgICB2YXIgQ29udGFjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29udGFjdCgpIHtcbiAgICAgICAgICAgIC8vIE5vZGVzIGZvciBjb25uZWN0aW5nIGJvZGllcy5cbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMubV9ub2RlQSA9IG5ldyBDb250YWN0RWRnZSh0aGlzKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMubV9ub2RlQiA9IG5ldyBDb250YWN0RWRnZSh0aGlzKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMubV9maXh0dXJlQSA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLm1fZml4dHVyZUIgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5tX2luZGV4QSA9IC0xO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5tX2luZGV4QiA9IC0xO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5tX2V2YWx1YXRlRmNuID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMubV9tYW5pZm9sZCA9IG5ldyBNYW5pZm9sZCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5tX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5tX3RvaSA9IDEuMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMubV90b2lDb3VudCA9IDA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsIFRoaXMgY29udGFjdCBoYXMgYSB2YWxpZCBUT0kgaW4gbV90b2kgKi9cbiAgICAgICAgICAgIHRoaXMubV90b2lGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLm1fZnJpY3Rpb24gPSAwLjA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSAwLjA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLm1fdGFuZ2VudFNwZWVkID0gMC4wO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCBUaGlzIGNvbnRhY3QgY2FuIGJlIGRpc2FibGVkIChieSB1c2VyKSAqL1xuICAgICAgICAgICAgdGhpcy5tX2VuYWJsZWRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgVXNlZCB3aGVuIGNyYXdsaW5nIGNvbnRhY3QgZ3JhcGggd2hlbiBmb3JtaW5nIGlzbGFuZHMuICovXG4gICAgICAgICAgICB0aGlzLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCBTZXQgd2hlbiB0aGUgc2hhcGVzIGFyZSB0b3VjaGluZy4gKi9cbiAgICAgICAgICAgIHRoaXMubV90b3VjaGluZ0ZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgVGhpcyBjb250YWN0IG5lZWRzIGZpbHRlcmluZyBiZWNhdXNlIGEgZml4dHVyZSBmaWx0ZXIgd2FzIGNoYW5nZWQuICovXG4gICAgICAgICAgICB0aGlzLm1fZmlsdGVyRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCBUaGlzIGJ1bGxldCBjb250YWN0IGhhZCBhIFRPSSBldmVudCAqL1xuICAgICAgICAgICAgdGhpcy5tX2J1bGxldEhpdEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgQ29udGFjdCByZXBvcnRpbmcgaW1wdWxzZSBvYmplY3QgY2FjaGUgKi9cbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlID0gbmV3IENvbnRhY3RJbXB1bHNlKHRoaXMpO1xuICAgICAgICAgICAgLy8gVmVsb2NpdHlDb25zdHJhaW50XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLnZfcG9pbnRzID0gW25ldyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludCgpLCBuZXcgVmVsb2NpdHlDb25zdHJhaW50UG9pbnQoKV07IC8vIFttYXhNYW5pZm9sZFBvaW50c107XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLnZfbm9ybWFsID0gdmVjMigwLCAwKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X25vcm1hbE1hc3MgPSBuZXcgTWF0MjIoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X0sgPSBuZXcgTWF0MjIoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X3BvaW50Q291bnQgPSAwO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLnZfdGFuZ2VudFNwZWVkID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X2ZyaWN0aW9uID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X3Jlc3RpdHV0aW9uID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X2ludk1hc3NBID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X2ludk1hc3NCID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X2ludklBID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy52X2ludklCID0gMDtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uQ29uc3RyYWludFxuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLnBfbG9jYWxQb2ludHMgPSBbdmVjMigwLCAwKSwgdmVjMigwLCAwKV07IC8vIFttYXhNYW5pZm9sZFBvaW50c107XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9sb2NhbE5vcm1hbCA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9sb2NhbFBvaW50ID0gdmVjMigwLCAwKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy5wX2xvY2FsQ2VudGVyQSA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9sb2NhbENlbnRlckIgPSB2ZWMyKDAsIDApO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLnBfdHlwZSA9IGV4cG9ydHMuTWFuaWZvbGRUeXBlLmVfdW5zZXQ7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9yYWRpdXNBID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gdGhpcy5wX3JhZGl1c0IgPSAwO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqLyB0aGlzLnBfcG9pbnRDb3VudCA9IDA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9pbnZNYXNzQSA9IDA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9pbnZNYXNzQiA9IDA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9pbnZJQSA9IDA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovIHRoaXMucF9pbnZJQiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDb250YWN0LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGZBLCBpbmRleEEsIGZCLCBpbmRleEIsIGV2YWx1YXRlRmNuKSB7XG4gICAgICAgICAgICB0aGlzLm1fZml4dHVyZUEgPSBmQTtcbiAgICAgICAgICAgIHRoaXMubV9maXh0dXJlQiA9IGZCO1xuICAgICAgICAgICAgdGhpcy5tX2luZGV4QSA9IGluZGV4QTtcbiAgICAgICAgICAgIHRoaXMubV9pbmRleEIgPSBpbmRleEI7XG4gICAgICAgICAgICB0aGlzLm1fZXZhbHVhdGVGY24gPSBldmFsdWF0ZUZjbjtcbiAgICAgICAgICAgIHRoaXMubV9mcmljdGlvbiA9IG1peEZyaWN0aW9uKHRoaXMubV9maXh0dXJlQS5tX2ZyaWN0aW9uLCB0aGlzLm1fZml4dHVyZUIubV9mcmljdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSBtaXhSZXN0aXR1dGlvbih0aGlzLm1fZml4dHVyZUEubV9yZXN0aXR1dGlvbiwgdGhpcy5tX2ZpeHR1cmVCLm1fcmVzdGl0dXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1fbm9kZUEucmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5tX25vZGVCLnJlY3ljbGUoKTtcbiAgICAgICAgICAgIHRoaXMubV9maXh0dXJlQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fZml4dHVyZUIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX2luZGV4QSA9IC0xO1xuICAgICAgICAgICAgdGhpcy5tX2luZGV4QiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5tX2V2YWx1YXRlRmNuID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9tYW5pZm9sZC5yZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLm1fcHJldiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1fdG9pID0gMTtcbiAgICAgICAgICAgIHRoaXMubV90b2lDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLm1fdG9pRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX2ZyaWN0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9yZXN0aXR1dGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLm1fdGFuZ2VudFNwZWVkID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9lbmFibGVkRmxhZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX3RvdWNoaW5nRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX2ZpbHRlckZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubV9idWxsZXRIaXRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5yZWN5Y2xlKCk7XG4gICAgICAgICAgICAvLyBWZWxvY2l0eUNvbnN0cmFpbnRcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnZfcG9pbnRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludF8xID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHBvaW50XzEucmVjeWNsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy52X25vcm1hbCk7XG4gICAgICAgICAgICB0aGlzLnZfbm9ybWFsTWFzcy5zZXRaZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnZfSy5zZXRaZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnZfcG9pbnRDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnZfdGFuZ2VudFNwZWVkID0gMDtcbiAgICAgICAgICAgIHRoaXMudl9mcmljdGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLnZfcmVzdGl0dXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy52X2ludk1hc3NBID0gMDtcbiAgICAgICAgICAgIHRoaXMudl9pbnZNYXNzQiA9IDA7XG4gICAgICAgICAgICB0aGlzLnZfaW52SUEgPSAwO1xuICAgICAgICAgICAgdGhpcy52X2ludklCID0gMDtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uQ29uc3RyYWludFxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMucF9sb2NhbFBvaW50czsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRfMiA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICB6ZXJvVmVjMihwb2ludF8yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMucF9sb2NhbE5vcm1hbCk7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLnBfbG9jYWxQb2ludCk7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLnBfbG9jYWxDZW50ZXJBKTtcbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMucF9sb2NhbENlbnRlckIpO1xuICAgICAgICAgICAgdGhpcy5wX3R5cGUgPSBleHBvcnRzLk1hbmlmb2xkVHlwZS5lX3Vuc2V0O1xuICAgICAgICAgICAgdGhpcy5wX3JhZGl1c0EgPSAwO1xuICAgICAgICAgICAgdGhpcy5wX3JhZGl1c0IgPSAwO1xuICAgICAgICAgICAgdGhpcy5wX3BvaW50Q291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5wX2ludk1hc3NBID0gMDtcbiAgICAgICAgICAgIHRoaXMucF9pbnZNYXNzQiA9IDA7XG4gICAgICAgICAgICB0aGlzLnBfaW52SUEgPSAwO1xuICAgICAgICAgICAgdGhpcy5wX2ludklCID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuaW5pdENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgaWYgKGZpeHR1cmVBID09PSBudWxsIHx8IGZpeHR1cmVCID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gbnVsbCB8fCBib2R5QiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2hhcGVBID0gZml4dHVyZUEubV9zaGFwZTtcbiAgICAgICAgICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5tX3NoYXBlO1xuICAgICAgICAgICAgaWYgKHNoYXBlQSA9PT0gbnVsbCB8fCBzaGFwZUIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG1hbmlmb2xkID0gdGhpcy5tX21hbmlmb2xkO1xuICAgICAgICAgICAgdmFyIHBvaW50Q291bnQgPSBtYW5pZm9sZC5wb2ludENvdW50O1xuICAgICAgICAgICAgdGhpcy52X2ludk1hc3NBID0gYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy52X2ludk1hc3NCID0gYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy52X2ludklBID0gYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy52X2ludklCID0gYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy52X2ZyaWN0aW9uID0gdGhpcy5tX2ZyaWN0aW9uO1xuICAgICAgICAgICAgdGhpcy52X3Jlc3RpdHV0aW9uID0gdGhpcy5tX3Jlc3RpdHV0aW9uO1xuICAgICAgICAgICAgdGhpcy52X3RhbmdlbnRTcGVlZCA9IHRoaXMubV90YW5nZW50U3BlZWQ7XG4gICAgICAgICAgICB0aGlzLnZfcG9pbnRDb3VudCA9IHBvaW50Q291bnQ7XG4gICAgICAgICAgICB0aGlzLnZfSy5zZXRaZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnZfbm9ybWFsTWFzcy5zZXRaZXJvKCk7XG4gICAgICAgICAgICB0aGlzLnBfaW52TWFzc0EgPSBib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLnBfaW52TWFzc0IgPSBib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLnBfaW52SUEgPSBib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLnBfaW52SUIgPSBib2R5Qi5tX2ludkk7XG4gICAgICAgICAgICBjb3B5VmVjMih0aGlzLnBfbG9jYWxDZW50ZXJBLCBib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMucF9sb2NhbENlbnRlckIsIGJvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5wX3JhZGl1c0EgPSBzaGFwZUEubV9yYWRpdXM7XG4gICAgICAgICAgICB0aGlzLnBfcmFkaXVzQiA9IHNoYXBlQi5tX3JhZGl1cztcbiAgICAgICAgICAgIHRoaXMucF90eXBlID0gbWFuaWZvbGQudHlwZTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMucF9sb2NhbE5vcm1hbCwgbWFuaWZvbGQubG9jYWxOb3JtYWwpO1xuICAgICAgICAgICAgY29weVZlYzIodGhpcy5wX2xvY2FsUG9pbnQsIG1hbmlmb2xkLmxvY2FsUG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5wX3BvaW50Q291bnQgPSBwb2ludENvdW50O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBTZXR0aW5nc0ludGVybmFsLm1heE1hbmlmb2xkUG9pbnRzOyArK2opIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZfcG9pbnRzW2pdLnJlY3ljbGUoKTtcbiAgICAgICAgICAgICAgICB6ZXJvVmVjMih0aGlzLnBfbG9jYWxQb2ludHNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgY3AgPSBtYW5pZm9sZC5wb2ludHNbal07XG4gICAgICAgICAgICAgICAgdmFyIHZjcCA9IHRoaXMudl9wb2ludHNbal07XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZjcC5ub3JtYWxJbXB1bHNlID0gc3RlcC5kdFJhdGlvICogY3Aubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmNwLnRhbmdlbnRJbXB1bHNlID0gc3RlcC5kdFJhdGlvICogY3AudGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMucF9sb2NhbFBvaW50c1tqXSwgY3AubG9jYWxQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRhY3QgbWFuaWZvbGQuIERvIG5vdCBtb2RpZnkgdGhlIG1hbmlmb2xkIHVubGVzcyB5b3UgdW5kZXJzdGFuZFxuICAgICAgICAgKiB0aGUgaW50ZXJuYWxzIG9mIHRoZSBsaWJyYXJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuZ2V0TWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21hbmlmb2xkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3b3JsZCBtYW5pZm9sZC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldFdvcmxkTWFuaWZvbGQgPSBmdW5jdGlvbiAod29ybGRNYW5pZm9sZCkge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgaWYgKGZpeHR1cmVBID09PSBudWxsIHx8IGZpeHR1cmVCID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gbnVsbCB8fCBib2R5QiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2hhcGVBID0gZml4dHVyZUEubV9zaGFwZTtcbiAgICAgICAgICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5tX3NoYXBlO1xuICAgICAgICAgICAgaWYgKHNoYXBlQSA9PT0gbnVsbCB8fCBzaGFwZUIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tYW5pZm9sZC5nZXRXb3JsZE1hbmlmb2xkKHdvcmxkTWFuaWZvbGQsIGJvZHlBLmdldFRyYW5zZm9ybSgpLCBzaGFwZUEubV9yYWRpdXMsIGJvZHlCLmdldFRyYW5zZm9ybSgpLCBzaGFwZUIubV9yYWRpdXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgdGhpcyBjb250YWN0LiBUaGlzIGNhbiBiZSB1c2VkIGluc2lkZSB0aGUgcHJlLXNvbHZlIGNvbnRhY3RcbiAgICAgICAgICogbGlzdGVuZXIuIFRoZSBjb250YWN0IGlzIG9ubHkgZGlzYWJsZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgc3RlcCAob3Igc3ViLXN0ZXBcbiAgICAgICAgICogaW4gY29udGludW91cyBjb2xsaXNpb25zKS5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgdGhpcy5tX2VuYWJsZWRGbGFnID0gISFmbGFnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFzIHRoaXMgY29udGFjdCBiZWVuIGRpc2FibGVkP1xuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVkRmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoaXMgY29udGFjdCB0b3VjaGluZz9cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmlzVG91Y2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3RvdWNoaW5nRmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbmV4dCBjb250YWN0IGluIHRoZSB3b3JsZCdzIGNvbnRhY3QgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX25leHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZml4dHVyZSBBIGluIHRoaXMgY29udGFjdC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldEZpeHR1cmVBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9maXh0dXJlQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBmaXh0dXJlIEIgaW4gdGhpcyBjb250YWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuZ2V0Rml4dHVyZUIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjaGlsZCBwcmltaXRpdmUgaW5kZXggZm9yIGZpeHR1cmUgQS5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldENoaWxkSW5kZXhBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9pbmRleEE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNoaWxkIHByaW1pdGl2ZSBpbmRleCBmb3IgZml4dHVyZSBCLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleEIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2luZGV4QjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgdGhpcyBjb250YWN0IGZvciBmaWx0ZXJpbmcuIEZpbHRlcmluZyB3aWxsIG9jY3VyIHRoZSBuZXh0IHRpbWUgc3RlcC5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmZsYWdGb3JGaWx0ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1fZmlsdGVyRmxhZyA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBmcmljdGlvbiBtaXh0dXJlLiBZb3UgY2FuIGNhbGwgdGhpcyBpblxuICAgICAgICAgKiBDb250YWN0TGlzdGVuZXIucHJlU29sdmUuIFRoaXMgdmFsdWUgcGVyc2lzdHMgdW50aWwgc2V0IG9yIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuc2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubV9mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmcmljdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmdldEZyaWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9mcmljdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IHRoZSBmcmljdGlvbiBtaXh0dXJlIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUucmVzZXRGcmljdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQSA9IHRoaXMubV9maXh0dXJlQTtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IHRoaXMubV9maXh0dXJlQjtcbiAgICAgICAgICAgIGlmIChmaXh0dXJlQSA9PT0gbnVsbCB8fCBmaXh0dXJlQiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLm1fZnJpY3Rpb24gPSBtaXhGcmljdGlvbihmaXh0dXJlQS5tX2ZyaWN0aW9uLCBmaXh0dXJlQi5tX2ZyaWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHJlc3RpdHV0aW9uIG1peHR1cmUuIFlvdSBjYW4gY2FsbCB0aGlzIGluXG4gICAgICAgICAqIENvbnRhY3RMaXN0ZW5lci5wcmVTb2x2ZS4gVGhlIHZhbHVlIHBlcnNpc3RzIHVudGlsIHlvdSBzZXQgb3IgcmVzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBDb250YWN0LnByb3RvdHlwZS5zZXRSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uIChyZXN0aXR1dGlvbikge1xuICAgICAgICAgICAgdGhpcy5tX3Jlc3RpdHV0aW9uID0gcmVzdGl0dXRpb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlc3RpdHV0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuZ2V0UmVzdGl0dXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3Jlc3RpdHV0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgdGhlIHJlc3RpdHV0aW9uIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUucmVzZXRSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQSA9IHRoaXMubV9maXh0dXJlQTtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IHRoaXMubV9maXh0dXJlQjtcbiAgICAgICAgICAgIGlmIChmaXh0dXJlQSA9PT0gbnVsbCB8fCBmaXh0dXJlQiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSBtaXhSZXN0aXR1dGlvbihmaXh0dXJlQS5tX3Jlc3RpdHV0aW9uLCBmaXh0dXJlQi5tX3Jlc3RpdHV0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgZGVzaXJlZCB0YW5nZW50IHNwZWVkIGZvciBhIGNvbnZleW9yIGJlbHQgYmVoYXZpb3IuIEluIG1ldGVycyBwZXJcbiAgICAgICAgICogc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuc2V0VGFuZ2VudFNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLm1fdGFuZ2VudFNwZWVkID0gc3BlZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGRlc2lyZWQgdGFuZ2VudCBzcGVlZC4gSW4gbWV0ZXJzIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBDb250YWN0LnByb3RvdHlwZS5nZXRUYW5nZW50U3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3RhbmdlbnRTcGVlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBieSBVcGRhdGUgbWV0aG9kLCBhbmQgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlcy5cbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKG1hbmlmb2xkLCB4ZkEsIHhmQikge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgaWYgKGZpeHR1cmVBID09PSBudWxsIHx8IGZpeHR1cmVCID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubV9ldmFsdWF0ZUZjbihtYW5pZm9sZCwgeGZBLCBmaXh0dXJlQSwgdGhpcy5tX2luZGV4QSwgeGZCLCBmaXh0dXJlQiwgdGhpcy5tX2luZGV4Qik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb250YWN0IG1hbmlmb2xkIGFuZCB0b3VjaGluZyBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IGRvIG5vdCBhc3N1bWUgdGhlIGZpeHR1cmUgQUFCQnMgYXJlIG92ZXJsYXBwaW5nIG9yIGFyZSB2YWxpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxpc3RlbmVyLmJlZ2luQ29udGFjdFxuICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXIuZW5kQ29udGFjdFxuICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXIucHJlU29sdmVcbiAgICAgICAgICovXG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgaWYgKGZpeHR1cmVBID09PSBudWxsIHx8IGZpeHR1cmVCID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gbnVsbCB8fCBib2R5QiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2hhcGVBID0gZml4dHVyZUEubV9zaGFwZTtcbiAgICAgICAgICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5tX3NoYXBlO1xuICAgICAgICAgICAgaWYgKHNoYXBlQSA9PT0gbnVsbCB8fCBzaGFwZUIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gUmUtZW5hYmxlIHRoaXMgY29udGFjdC5cbiAgICAgICAgICAgIHRoaXMubV9lbmFibGVkRmxhZyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgdG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB3YXNUb3VjaGluZyA9IHRoaXMubV90b3VjaGluZ0ZsYWc7XG4gICAgICAgICAgICB2YXIgc2Vuc29yQSA9IGZpeHR1cmVBLm1faXNTZW5zb3I7XG4gICAgICAgICAgICB2YXIgc2Vuc29yQiA9IGZpeHR1cmVCLm1faXNTZW5zb3I7XG4gICAgICAgICAgICB2YXIgc2Vuc29yID0gc2Vuc29yQSB8fCBzZW5zb3JCO1xuICAgICAgICAgICAgdmFyIHhmQSA9IGJvZHlBLm1feGY7XG4gICAgICAgICAgICB2YXIgeGZCID0gYm9keUIubV94ZjtcbiAgICAgICAgICAgIC8vIElzIHRoaXMgY29udGFjdCBhIHNlbnNvcj9cbiAgICAgICAgICAgIGlmIChzZW5zb3IpIHtcbiAgICAgICAgICAgICAgICB0b3VjaGluZyA9IHRlc3RPdmVybGFwKHNoYXBlQSwgdGhpcy5tX2luZGV4QSwgc2hhcGVCLCB0aGlzLm1faW5kZXhCLCB4ZkEsIHhmQik7XG4gICAgICAgICAgICAgICAgLy8gU2Vuc29ycyBkb24ndCBnZW5lcmF0ZSBtYW5pZm9sZHMuXG4gICAgICAgICAgICAgICAgdGhpcy5tX21hbmlmb2xkLnBvaW50Q291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2xkTWFuaWZvbGQucmVjeWNsZSgpO1xuICAgICAgICAgICAgICAgIG9sZE1hbmlmb2xkLnNldCh0aGlzLm1fbWFuaWZvbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tYW5pZm9sZC5yZWN5Y2xlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZSh0aGlzLm1fbWFuaWZvbGQsIHhmQSwgeGZCKTtcbiAgICAgICAgICAgICAgICB0b3VjaGluZyA9IHRoaXMubV9tYW5pZm9sZC5wb2ludENvdW50ID4gMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCBvbGQgY29udGFjdCBpZHMgdG8gbmV3IGNvbnRhY3QgaWRzIGFuZCBjb3B5IHRoZVxuICAgICAgICAgICAgICAgIC8vIHN0b3JlZCBpbXB1bHNlcyB0byB3YXJtIHN0YXJ0IHRoZSBzb2x2ZXIuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fbWFuaWZvbGQucG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBubXAgPSB0aGlzLm1fbWFuaWZvbGQucG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBubXAubm9ybWFsSW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgbm1wLnRhbmdlbnRJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9sZE1hbmlmb2xkLnBvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9tcCA9IG9sZE1hbmlmb2xkLnBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbXAuaWQua2V5ID09PSBubXAuaWQua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm1wLm5vcm1hbEltcHVsc2UgPSBvbXAubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBubXAudGFuZ2VudEltcHVsc2UgPSBvbXAudGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoaW5nICE9PSB3YXNUb3VjaGluZykge1xuICAgICAgICAgICAgICAgICAgICBib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX3RvdWNoaW5nRmxhZyA9IHRvdWNoaW5nO1xuICAgICAgICAgICAgdmFyIGhhc0xpc3RlbmVyID0gdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lciAhPT0gbnVsbDtcbiAgICAgICAgICAgIGlmICghd2FzVG91Y2hpbmcgJiYgdG91Y2hpbmcgJiYgaGFzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5iZWdpbkNvbnRhY3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FzVG91Y2hpbmcgJiYgIXRvdWNoaW5nICYmIGhhc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuZW5kQ29udGFjdCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2Vuc29yICYmIHRvdWNoaW5nICYmIGhhc0xpc3RlbmVyICYmIG9sZE1hbmlmb2xkKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucHJlU29sdmUodGhpcywgb2xkTWFuaWZvbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDb250YWN0LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc29sdmVQb3NpdGlvbkNvbnN0cmFpbnQoc3RlcCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50VE9JID0gZnVuY3Rpb24gKHN0ZXAsIHRvaUEsIHRvaUIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb2x2ZVBvc2l0aW9uQ29uc3RyYWludChzdGVwLCB0b2lBLCB0b2lCKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuX3NvbHZlUG9zaXRpb25Db25zdHJhaW50ID0gZnVuY3Rpb24gKHN0ZXAsIHRvaUEsIHRvaUIpIHtcbiAgICAgICAgICAgIHZhciB0b2kgPSB0b2lBICE9PSBudWxsICYmIHRvaUIgIT09IG51bGwgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICB2YXIgbWluU2VwYXJhdGlvbiA9IDAuMDtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQSA9IHRoaXMubV9maXh0dXJlQTtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IHRoaXMubV9maXh0dXJlQjtcbiAgICAgICAgICAgIGlmIChmaXh0dXJlQSA9PT0gbnVsbCB8fCBmaXh0dXJlQiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWluU2VwYXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gbnVsbCB8fCBib2R5QiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWluU2VwYXJhdGlvbjtcbiAgICAgICAgICAgIGJvZHlBLmNfdmVsb2NpdHk7XG4gICAgICAgICAgICBib2R5Qi5jX3ZlbG9jaXR5O1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQSA9IGJvZHlBLmNfcG9zaXRpb247XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25CID0gYm9keUIuY19wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBsb2NhbENlbnRlckEgPSB0aGlzLnBfbG9jYWxDZW50ZXJBO1xuICAgICAgICAgICAgdmFyIGxvY2FsQ2VudGVyQiA9IHRoaXMucF9sb2NhbENlbnRlckI7XG4gICAgICAgICAgICB2YXIgbUEgPSAwLjA7XG4gICAgICAgICAgICB2YXIgaUEgPSAwLjA7XG4gICAgICAgICAgICBpZiAoIXRvaSB8fCAoYm9keUEgPT09IHRvaUEgfHwgYm9keUEgPT09IHRvaUIpKSB7XG4gICAgICAgICAgICAgICAgbUEgPSB0aGlzLnBfaW52TWFzc0E7XG4gICAgICAgICAgICAgICAgaUEgPSB0aGlzLnBfaW52SUE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbUIgPSAwLjA7XG4gICAgICAgICAgICB2YXIgaUIgPSAwLjA7XG4gICAgICAgICAgICBpZiAoIXRvaSB8fCAoYm9keUIgPT09IHRvaUEgfHwgYm9keUIgPT09IHRvaUIpKSB7XG4gICAgICAgICAgICAgICAgbUIgPSB0aGlzLnBfaW52TWFzc0I7XG4gICAgICAgICAgICAgICAgaUIgPSB0aGlzLnBfaW52SUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B5VmVjMihjQSwgcG9zaXRpb25BLmMpO1xuICAgICAgICAgICAgdmFyIGFBID0gcG9zaXRpb25BLmE7XG4gICAgICAgICAgICBjb3B5VmVjMihjQiwgcG9zaXRpb25CLmMpO1xuICAgICAgICAgICAgdmFyIGFCID0gcG9zaXRpb25CLmE7XG4gICAgICAgICAgICAvLyBTb2x2ZSBub3JtYWwgY29uc3RyYWludHNcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5wX3BvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybSh4ZkEsIGxvY2FsQ2VudGVyQSwgY0EsIGFBKTtcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2Zvcm0oeGZCLCBsb2NhbENlbnRlckIsIGNCLCBhQik7XG4gICAgICAgICAgICAgICAgLy8gUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZFxuICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLk1hbmlmb2xkVHlwZS5lX2NpcmNsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZlYzIocG9pbnRBLCB4ZkEsIHRoaXMucF9sb2NhbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZlYzIocG9pbnRCLCB4ZkIsIHRoaXMucF9sb2NhbFBvaW50c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmVmVjMihub3JtYWwkMiwgcG9pbnRCLCBwb2ludEEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplVmVjMihub3JtYWwkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lVmVjMihwb2ludCwgMC41LCBwb2ludEEsIDAuNSwgcG9pbnRCKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSBkb3RWZWMyKHBvaW50Qiwgbm9ybWFsJDIpIC0gZG90VmVjMihwb2ludEEsIG5vcm1hbCQyKSAtIHRoaXMucF9yYWRpdXNBIC0gdGhpcy5wX3JhZGl1c0I7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuTWFuaWZvbGRUeXBlLmVfZmFjZUE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdFZlYzIobm9ybWFsJDIsIHhmQS5xLCB0aGlzLnBfbG9jYWxOb3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihwbGFuZVBvaW50JDEsIHhmQSwgdGhpcy5wX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmVjMihjbGlwUG9pbnQsIHhmQiwgdGhpcy5wX2xvY2FsUG9pbnRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSBkb3RWZWMyKGNsaXBQb2ludCwgbm9ybWFsJDIpIC0gZG90VmVjMihwbGFuZVBvaW50JDEsIG5vcm1hbCQyKSAtIHRoaXMucF9yYWRpdXNBIC0gdGhpcy5wX3JhZGl1c0I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihwb2ludCwgY2xpcFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5NYW5pZm9sZFR5cGUuZV9mYWNlQjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm90VmVjMihub3JtYWwkMiwgeGZCLnEsIHRoaXMucF9sb2NhbE5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHBsYW5lUG9pbnQkMSwgeGZCLCB0aGlzLnBfbG9jYWxQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKGNsaXBQb2ludCwgeGZBLCB0aGlzLnBfbG9jYWxQb2ludHNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGlvbiA9IGRvdFZlYzIoY2xpcFBvaW50LCBub3JtYWwkMikgLSBkb3RWZWMyKHBsYW5lUG9pbnQkMSwgbm9ybWFsJDIpIC0gdGhpcy5wX3JhZGl1c0EgLSB0aGlzLnBfcmFkaXVzQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKHBvaW50LCBjbGlwUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIG5vcm1hbCBwb2ludHMgZnJvbSBBIHRvIEJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ1ZlYzIobm9ybWFsJDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogd2hhdCBzaG91bGQgd2UgZG8gaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pblNlcGFyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlmZlZlYzIockEsIHBvaW50LCBjQSk7XG4gICAgICAgICAgICAgICAgZGlmZlZlYzIockIsIHBvaW50LCBjQik7XG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgbWF4IGNvbnN0cmFpbnQgZXJyb3IuXG4gICAgICAgICAgICAgICAgbWluU2VwYXJhdGlvbiA9IG1hdGhfbWluJDQobWluU2VwYXJhdGlvbiwgc2VwYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgdmFyIGJhdW1nYXJ0ZSA9IHRvaSA/IFNldHRpbmdzSW50ZXJuYWwudG9pQmF1Z2FydGUgOiBTZXR0aW5nc0ludGVybmFsLmJhdW1nYXJ0ZTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZWFyU2xvcCA9IFNldHRpbmdzSW50ZXJuYWwubGluZWFyU2xvcDtcbiAgICAgICAgICAgICAgICB2YXIgbWF4TGluZWFyQ29ycmVjdGlvbiA9IFNldHRpbmdzSW50ZXJuYWwubWF4TGluZWFyQ29ycmVjdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzbG9wLlxuICAgICAgICAgICAgICAgIHZhciBDID0gY2xhbXAoYmF1bWdhcnRlICogKHNlcGFyYXRpb24gKyBsaW5lYXJTbG9wKSwgLW1heExpbmVhckNvcnJlY3Rpb24sIDAuMCk7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MuXG4gICAgICAgICAgICAgICAgdmFyIHJuQSA9IGNyb3NzVmVjMlZlYzIockEsIG5vcm1hbCQyKTtcbiAgICAgICAgICAgICAgICB2YXIgcm5CID0gY3Jvc3NWZWMyVmVjMihyQiwgbm9ybWFsJDIpO1xuICAgICAgICAgICAgICAgIHZhciBLID0gbUEgKyBtQiArIGlBICogcm5BICogcm5BICsgaUIgKiBybkIgKiBybkI7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBub3JtYWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gSyA+IDAuMCA/IC1DIC8gSyA6IDAuMDtcbiAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKFAkMSwgaW1wdWxzZSwgbm9ybWFsJDIpO1xuICAgICAgICAgICAgICAgIHN1Yk11bFZlYzIoY0EsIG1BLCBQJDEpO1xuICAgICAgICAgICAgICAgIGFBIC09IGlBICogY3Jvc3NWZWMyVmVjMihyQSwgUCQxKTtcbiAgICAgICAgICAgICAgICBhZGRNdWxWZWMyKGNCLCBtQiwgUCQxKTtcbiAgICAgICAgICAgICAgICBhQiArPSBpQiAqIGNyb3NzVmVjMlZlYzIockIsIFAkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B5VmVjMihwb3NpdGlvbkEuYywgY0EpO1xuICAgICAgICAgICAgcG9zaXRpb25BLmEgPSBhQTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHBvc2l0aW9uQi5jLCBjQik7XG4gICAgICAgICAgICBwb3NpdGlvbkIuYSA9IGFCO1xuICAgICAgICAgICAgcmV0dXJuIG1pblNlcGFyYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgaWYgKGZpeHR1cmVBID09PSBudWxsIHx8IGZpeHR1cmVCID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gbnVsbCB8fCBib2R5QiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHlBID0gYm9keUEuY192ZWxvY2l0eTtcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eUIgPSBib2R5Qi5jX3ZlbG9jaXR5O1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQSA9IGJvZHlBLmNfcG9zaXRpb247XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25CID0gYm9keUIuY19wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciByYWRpdXNBID0gdGhpcy5wX3JhZGl1c0E7XG4gICAgICAgICAgICB2YXIgcmFkaXVzQiA9IHRoaXMucF9yYWRpdXNCO1xuICAgICAgICAgICAgdmFyIG1hbmlmb2xkID0gdGhpcy5tX21hbmlmb2xkO1xuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy52X2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy52X2ludk1hc3NCO1xuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy52X2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy52X2ludklCO1xuICAgICAgICAgICAgdmFyIGxvY2FsQ2VudGVyQSA9IHRoaXMucF9sb2NhbENlbnRlckE7XG4gICAgICAgICAgICB2YXIgbG9jYWxDZW50ZXJCID0gdGhpcy5wX2xvY2FsQ2VudGVyQjtcbiAgICAgICAgICAgIGNvcHlWZWMyKGNBLCBwb3NpdGlvbkEuYyk7XG4gICAgICAgICAgICB2YXIgYUEgPSBwb3NpdGlvbkEuYTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHZBLCB2ZWxvY2l0eUEudik7XG4gICAgICAgICAgICB2YXIgd0EgPSB2ZWxvY2l0eUEudztcbiAgICAgICAgICAgIGNvcHlWZWMyKGNCLCBwb3NpdGlvbkIuYyk7XG4gICAgICAgICAgICB2YXIgYUIgPSBwb3NpdGlvbkIuYTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHZCLCB2ZWxvY2l0eUIudik7XG4gICAgICAgICAgICB2YXIgd0IgPSB2ZWxvY2l0eUIudztcbiAgICAgICAgICAgIGdldFRyYW5zZm9ybSh4ZkEsIGxvY2FsQ2VudGVyQSwgY0EsIGFBKTtcbiAgICAgICAgICAgIGdldFRyYW5zZm9ybSh4ZkIsIGxvY2FsQ2VudGVyQiwgY0IsIGFCKTtcbiAgICAgICAgICAgIHdvcmxkTWFuaWZvbGQucmVjeWNsZSgpO1xuICAgICAgICAgICAgbWFuaWZvbGQuZ2V0V29ybGRNYW5pZm9sZCh3b3JsZE1hbmlmb2xkLCB4ZkEsIHJhZGl1c0EsIHhmQiwgcmFkaXVzQik7XG4gICAgICAgICAgICBjb3B5VmVjMih0aGlzLnZfbm9ybWFsLCB3b3JsZE1hbmlmb2xkLm5vcm1hbCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudl9wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmNwID0gdGhpcy52X3BvaW50c1tqXTsgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgd21wID0gd29ybGRNYW5pZm9sZC5wb2ludHNbal07XG4gICAgICAgICAgICAgICAgZGlmZlZlYzIodmNwLnJBLCB3bXAsIGNBKTtcbiAgICAgICAgICAgICAgICBkaWZmVmVjMih2Y3AuckIsIHdtcCwgY0IpO1xuICAgICAgICAgICAgICAgIHZhciBybkEgPSBjcm9zc1ZlYzJWZWMyKHZjcC5yQSwgdGhpcy52X25vcm1hbCk7XG4gICAgICAgICAgICAgICAgdmFyIHJuQiA9IGNyb3NzVmVjMlZlYzIodmNwLnJCLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIga05vcm1hbCA9IG1BICsgbUIgKyBpQSAqIHJuQSAqIHJuQSArIGlCICogcm5CICogcm5CO1xuICAgICAgICAgICAgICAgIHZjcC5ub3JtYWxNYXNzID0ga05vcm1hbCA+IDAuMCA/IDEuMCAvIGtOb3JtYWwgOiAwLjA7XG4gICAgICAgICAgICAgICAgY3Jvc3NWZWMyTnVtKHRhbmdlbnQkMSwgdGhpcy52X25vcm1hbCwgMS4wKTtcbiAgICAgICAgICAgICAgICB2YXIgcnRBID0gY3Jvc3NWZWMyVmVjMih2Y3AuckEsIHRhbmdlbnQkMSk7XG4gICAgICAgICAgICAgICAgdmFyIHJ0QiA9IGNyb3NzVmVjMlZlYzIodmNwLnJCLCB0YW5nZW50JDEpO1xuICAgICAgICAgICAgICAgIHZhciBrVGFuZ2VudCA9IG1BICsgbUIgKyBpQSAqIHJ0QSAqIHJ0QSArIGlCICogcnRCICogcnRCO1xuICAgICAgICAgICAgICAgIHZjcC50YW5nZW50TWFzcyA9IGtUYW5nZW50ID4gMC4wID8gMS4wIC8ga1RhbmdlbnQgOiAwLjA7XG4gICAgICAgICAgICAgICAgLy8gU2V0dXAgYSB2ZWxvY2l0eSBiaWFzIGZvciByZXN0aXR1dGlvbi5cbiAgICAgICAgICAgICAgICB2Y3AudmVsb2NpdHlCaWFzID0gMC4wO1xuICAgICAgICAgICAgICAgIHZhciB2UmVsID0gMDtcbiAgICAgICAgICAgICAgICB2UmVsICs9IGRvdFZlYzIodGhpcy52X25vcm1hbCwgdkIpO1xuICAgICAgICAgICAgICAgIHZSZWwgKz0gZG90VmVjMih0aGlzLnZfbm9ybWFsLCBjcm9zc051bVZlYzIodGVtcCQyLCB3QiwgdmNwLnJCKSk7XG4gICAgICAgICAgICAgICAgdlJlbCAtPSBkb3RWZWMyKHRoaXMudl9ub3JtYWwsIHZBKTtcbiAgICAgICAgICAgICAgICB2UmVsIC09IGRvdFZlYzIodGhpcy52X25vcm1hbCwgY3Jvc3NOdW1WZWMyKHRlbXAkMiwgd0EsIHZjcC5yQSkpO1xuICAgICAgICAgICAgICAgIGlmICh2UmVsIDwgLVNldHRpbmdzSW50ZXJuYWwudmVsb2NpdHlUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmNwLnZlbG9jaXR5QmlhcyA9IC10aGlzLnZfcmVzdGl0dXRpb24gKiB2UmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgdHdvIHBvaW50cywgdGhlbiBwcmVwYXJlIHRoZSBibG9jayBzb2x2ZXIuXG4gICAgICAgICAgICBpZiAodGhpcy52X3BvaW50Q291bnQgPT0gMiAmJiBzdGVwLmJsb2NrU29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmNwMSA9IHRoaXMudl9wb2ludHNbMF07IC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50XG4gICAgICAgICAgICAgICAgdmFyIHZjcDIgPSB0aGlzLnZfcG9pbnRzWzFdOyAvLyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludFxuICAgICAgICAgICAgICAgIHZhciBybjFBID0gY3Jvc3NWZWMyVmVjMih2Y3AxLnJBLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgcm4xQiA9IGNyb3NzVmVjMlZlYzIodmNwMS5yQiwgdGhpcy52X25vcm1hbCk7XG4gICAgICAgICAgICAgICAgdmFyIHJuMkEgPSBjcm9zc1ZlYzJWZWMyKHZjcDIuckEsIHRoaXMudl9ub3JtYWwpO1xuICAgICAgICAgICAgICAgIHZhciBybjJCID0gY3Jvc3NWZWMyVmVjMih2Y3AyLnJCLCB0aGlzLnZfbm9ybWFsKTtcbiAgICAgICAgICAgICAgICB2YXIgazExID0gbUEgKyBtQiArIGlBICogcm4xQSAqIHJuMUEgKyBpQiAqIHJuMUIgKiBybjFCO1xuICAgICAgICAgICAgICAgIHZhciBrMjIgPSBtQSArIG1CICsgaUEgKiBybjJBICogcm4yQSArIGlCICogcm4yQiAqIHJuMkI7XG4gICAgICAgICAgICAgICAgdmFyIGsxMiA9IG1BICsgbUIgKyBpQSAqIHJuMUEgKiBybjJBICsgaUIgKiBybjFCICogcm4yQjtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgYSByZWFzb25hYmxlIGNvbmRpdGlvbiBudW1iZXIuXG4gICAgICAgICAgICAgICAgdmFyIGtfbWF4Q29uZGl0aW9uTnVtYmVyID0gMTAwMC4wO1xuICAgICAgICAgICAgICAgIGlmIChrMTEgKiBrMTEgPCBrX21heENvbmRpdGlvbk51bWJlciAqIChrMTEgKiBrMjIgLSBrMTIgKiBrMTIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEsgaXMgc2FmZSB0byBpbnZlcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudl9LLmV4LnNldE51bShrMTEsIGsxMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudl9LLmV5LnNldE51bShrMTIsIGsyMik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMudl9ub3JtYWxNYXNzLnNldCh0aGlzLnZfSy5nZXRJbnZlcnNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYV8xID0gdGhpcy52X0suZXgueDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJfMSA9IHRoaXMudl9LLmV5Lng7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy52X0suZXgueTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRfMSA9IHRoaXMudl9LLmV5Lnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXQgPSBhXzEgKiBkXzEgLSBiXzEgKiBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZfbm9ybWFsTWFzcy5leC54ID0gZGV0ICogZF8xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZfbm9ybWFsTWFzcy5leS54ID0gLWRldCAqIGJfMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52X25vcm1hbE1hc3MuZXgueSA9IC1kZXQgKiBjO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZfbm9ybWFsTWFzcy5leS55ID0gZGV0ICogYV8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbnN0cmFpbnRzIGFyZSByZWR1bmRhbnQsIGp1c3QgdXNlIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ET19FUklOIHVzZSBkZWVwZXN0P1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZfcG9pbnRDb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29weVZlYzIocG9zaXRpb25BLmMsIGNBKTtcbiAgICAgICAgICAgIHBvc2l0aW9uQS5hID0gYUE7XG4gICAgICAgICAgICBjb3B5VmVjMih2ZWxvY2l0eUEudiwgdkEpO1xuICAgICAgICAgICAgdmVsb2NpdHlBLncgPSB3QTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHBvc2l0aW9uQi5jLCBjQik7XG4gICAgICAgICAgICBwb3NpdGlvbkIuYSA9IGFCO1xuICAgICAgICAgICAgY29weVZlYzIodmVsb2NpdHlCLnYsIHZCKTtcbiAgICAgICAgICAgIHZlbG9jaXR5Qi53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIENvbnRhY3QucHJvdG90eXBlLndhcm1TdGFydENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgaWYgKGZpeHR1cmVBID09PSBudWxsIHx8IGZpeHR1cmVCID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gbnVsbCB8fCBib2R5QiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHlBID0gYm9keUEuY192ZWxvY2l0eTtcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eUIgPSBib2R5Qi5jX3ZlbG9jaXR5O1xuICAgICAgICAgICAgYm9keUEuY19wb3NpdGlvbjtcbiAgICAgICAgICAgIGJvZHlCLmNfcG9zaXRpb247XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLnZfaW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLnZfaW52SUE7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLnZfaW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLnZfaW52SUI7XG4gICAgICAgICAgICBjb3B5VmVjMih2QSwgdmVsb2NpdHlBLnYpO1xuICAgICAgICAgICAgdmFyIHdBID0gdmVsb2NpdHlBLnc7XG4gICAgICAgICAgICBjb3B5VmVjMih2QiwgdmVsb2NpdHlCLnYpO1xuICAgICAgICAgICAgdmFyIHdCID0gdmVsb2NpdHlCLnc7XG4gICAgICAgICAgICBjb3B5VmVjMihub3JtYWwkMiwgdGhpcy52X25vcm1hbCk7XG4gICAgICAgICAgICBjcm9zc1ZlYzJOdW0odGFuZ2VudCQxLCBub3JtYWwkMiwgMS4wKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52X3BvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2Y3AgPSB0aGlzLnZfcG9pbnRzW2pdOyAvLyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludFxuICAgICAgICAgICAgICAgIGNvbWJpbmVWZWMyKFAkMSwgdmNwLm5vcm1hbEltcHVsc2UsIG5vcm1hbCQyLCB2Y3AudGFuZ2VudEltcHVsc2UsIHRhbmdlbnQkMSk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBjcm9zc1ZlYzJWZWMyKHZjcC5yQSwgUCQxKTtcbiAgICAgICAgICAgICAgICBzdWJNdWxWZWMyKHZBLCBtQSwgUCQxKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIGNyb3NzVmVjMlZlYzIodmNwLnJCLCBQJDEpO1xuICAgICAgICAgICAgICAgIGFkZE11bFZlYzIodkIsIG1CLCBQJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29weVZlYzIodmVsb2NpdHlBLnYsIHZBKTtcbiAgICAgICAgICAgIHZlbG9jaXR5QS53ID0gd0E7XG4gICAgICAgICAgICBjb3B5VmVjMih2ZWxvY2l0eUIudiwgdkIpO1xuICAgICAgICAgICAgdmVsb2NpdHlCLncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuc3RvcmVDb25zdHJhaW50SW1wdWxzZXMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIG1hbmlmb2xkID0gdGhpcy5tX21hbmlmb2xkO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZfcG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzW2pdLm5vcm1hbEltcHVsc2UgPSB0aGlzLnZfcG9pbnRzW2pdLm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzW2pdLnRhbmdlbnRJbXB1bHNlID0gdGhpcy52X3BvaW50c1tqXS50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ29udGFjdC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gdGhpcy5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gdGhpcy5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgaWYgKGZpeHR1cmVBID09PSBudWxsIHx8IGZpeHR1cmVCID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gbnVsbCB8fCBib2R5QiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHlBID0gYm9keUEuY192ZWxvY2l0eTtcbiAgICAgICAgICAgIGJvZHlBLmNfcG9zaXRpb247XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHlCID0gYm9keUIuY192ZWxvY2l0eTtcbiAgICAgICAgICAgIGJvZHlCLmNfcG9zaXRpb247XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLnZfaW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLnZfaW52SUE7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLnZfaW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLnZfaW52SUI7XG4gICAgICAgICAgICBjb3B5VmVjMih2QSwgdmVsb2NpdHlBLnYpO1xuICAgICAgICAgICAgdmFyIHdBID0gdmVsb2NpdHlBLnc7XG4gICAgICAgICAgICBjb3B5VmVjMih2QiwgdmVsb2NpdHlCLnYpO1xuICAgICAgICAgICAgdmFyIHdCID0gdmVsb2NpdHlCLnc7XG4gICAgICAgICAgICBjb3B5VmVjMihub3JtYWwkMiwgdGhpcy52X25vcm1hbCk7XG4gICAgICAgICAgICBjcm9zc1ZlYzJOdW0odGFuZ2VudCQxLCBub3JtYWwkMiwgMS4wKTtcbiAgICAgICAgICAgIHZhciBmcmljdGlvbiA9IHRoaXMudl9mcmljdGlvbjtcbiAgICAgICAgICAgIC8vIFNvbHZlIHRhbmdlbnQgY29uc3RyYWludHMgZmlyc3QgYmVjYXVzZSBub24tcGVuZXRyYXRpb24gaXMgbW9yZSBpbXBvcnRhbnRcbiAgICAgICAgICAgIC8vIHRoYW4gZnJpY3Rpb24uXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudl9wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmNwID0gdGhpcy52X3BvaW50c1tqXTsgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgICAgICAgICAvLyBSZWxhdGl2ZSB2ZWxvY2l0eSBhdCBjb250YWN0XG4gICAgICAgICAgICAgICAgemVyb1ZlYzIoZHYpO1xuICAgICAgICAgICAgICAgIGFkZFZlYzIoZHYsIHZCKTtcbiAgICAgICAgICAgICAgICBhZGRWZWMyKGR2LCBjcm9zc051bVZlYzIodGVtcCQyLCB3QiwgdmNwLnJCKSk7XG4gICAgICAgICAgICAgICAgc3ViVmVjMihkdiwgdkEpO1xuICAgICAgICAgICAgICAgIHN1YlZlYzIoZHYsIGNyb3NzTnVtVmVjMih0ZW1wJDIsIHdBLCB2Y3AuckEpKTtcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRhbmdlbnQgZm9yY2VcbiAgICAgICAgICAgICAgICB2YXIgdnQgPSBkb3RWZWMyKGR2LCB0YW5nZW50JDEpIC0gdGhpcy52X3RhbmdlbnRTcGVlZDtcbiAgICAgICAgICAgICAgICB2YXIgbGFtYmRhID0gdmNwLnRhbmdlbnRNYXNzICogKC12dCk7XG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlXG4gICAgICAgICAgICAgICAgdmFyIG1heEZyaWN0aW9uID0gZnJpY3Rpb24gKiB2Y3Aubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3SW1wdWxzZSA9IGNsYW1wKHZjcC50YW5nZW50SW1wdWxzZSArIGxhbWJkYSwgLW1heEZyaWN0aW9uLCBtYXhGcmljdGlvbik7XG4gICAgICAgICAgICAgICAgbGFtYmRhID0gbmV3SW1wdWxzZSAtIHZjcC50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICB2Y3AudGFuZ2VudEltcHVsc2UgPSBuZXdJbXB1bHNlO1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNvbnRhY3QgaW1wdWxzZVxuICAgICAgICAgICAgICAgIHNldE11bFZlYzIoUCQxLCBsYW1iZGEsIHRhbmdlbnQkMSk7XG4gICAgICAgICAgICAgICAgc3ViTXVsVmVjMih2QSwgbUEsIFAkMSk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBjcm9zc1ZlYzJWZWMyKHZjcC5yQSwgUCQxKTtcbiAgICAgICAgICAgICAgICBhZGRNdWxWZWMyKHZCLCBtQiwgUCQxKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIGNyb3NzVmVjMlZlYzIodmNwLnJCLCBQJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29sdmUgbm9ybWFsIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICBpZiAodGhpcy52X3BvaW50Q291bnQgPT0gMSB8fCBzdGVwLmJsb2NrU29sdmUgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudl9wb2ludENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZjcCA9IHRoaXMudl9wb2ludHNbaV07IC8vIFZlbG9jaXR5Q29uc3RyYWludFBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbGF0aXZlIHZlbG9jaXR5IGF0IGNvbnRhY3RcbiAgICAgICAgICAgICAgICAgICAgemVyb1ZlYzIoZHYpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZWMyKGR2LCB2Qik7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlYzIoZHYsIGNyb3NzTnVtVmVjMih0ZW1wJDIsIHdCLCB2Y3AuckIpKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViVmVjMihkdiwgdkEpO1xuICAgICAgICAgICAgICAgICAgICBzdWJWZWMyKGR2LCBjcm9zc051bVZlYzIodGVtcCQyLCB3QSwgdmNwLnJBKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZuID0gZG90VmVjMihkdiwgbm9ybWFsJDIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFtYmRhID0gLXZjcC5ub3JtYWxNYXNzICogKHZuIC0gdmNwLnZlbG9jaXR5Qmlhcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsYW1wIHRoZSBhY2N1bXVsYXRlZCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbXB1bHNlID0gbWF0aF9tYXgkMih2Y3Aubm9ybWFsSW1wdWxzZSArIGxhbWJkYSwgMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgbGFtYmRhID0gbmV3SW1wdWxzZSAtIHZjcC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgICAgICB2Y3Aubm9ybWFsSW1wdWxzZSA9IG5ld0ltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNvbnRhY3QgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKFAkMSwgbGFtYmRhLCBub3JtYWwkMik7XG4gICAgICAgICAgICAgICAgICAgIHN1Yk11bFZlYzIodkEsIG1BLCBQJDEpO1xuICAgICAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIGNyb3NzVmVjMlZlYzIodmNwLnJBLCBQJDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRNdWxWZWMyKHZCLCBtQiwgUCQxKTtcbiAgICAgICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBjcm9zc1ZlYzJWZWMyKHZjcC5yQiwgUCQxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayBzb2x2ZXIgZGV2ZWxvcGVkIGluIGNvbGxhYm9yYXRpb24gd2l0aCBEaXJrIEdyZWdvcml1cyAoYmFjayBpblxuICAgICAgICAgICAgICAgIC8vIDAxLzA3IG9uIEJveDJEX0xpdGUpLlxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBtaW5pIExDUCBmb3IgdGhpcyBjb250YWN0IHBhdGNoXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyB2biA9IEEgKiB4ICsgYiwgdm4gPj0gMCwgeCA+PSAwIGFuZCB2bl9pICogeF9pID0gMCB3aXRoIGkgPSAxLi4yXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBID0gSiAqIFcgKiBKVCBhbmQgSiA9ICggLW4sIC1yMSB4IG4sIG4sIHIyIHggbiApXG4gICAgICAgICAgICAgICAgLy8gYiA9IHZuMCAtIHZlbG9jaXR5Qmlhc1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVGhlIHN5c3RlbSBpcyBzb2x2ZWQgdXNpbmcgdGhlIFwiVG90YWwgZW51bWVyYXRpb24gbWV0aG9kXCIgKHMuIE11cnR5KS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY29tcGxlbWVudGFyeSBjb25zdHJhaW50IHZuX2kgKiB4X2lcbiAgICAgICAgICAgICAgICAvLyBpbXBsaWVzIHRoYXQgd2UgbXVzdCBoYXZlIGluIGFueSBzb2x1dGlvbiBlaXRoZXIgdm5faSA9IDAgb3IgeF9pID0gMC5cbiAgICAgICAgICAgICAgICAvLyBTbyBmb3IgdGhlIDJEIGNvbnRhY3QgcHJvYmxlbSB0aGUgY2FzZXNcbiAgICAgICAgICAgICAgICAvLyB2bjEgPSAwIGFuZCB2bjIgPSAwLCB4MSA9IDAgYW5kIHgyID0gMCwgeDEgPSAwIGFuZCB2bjIgPSAwLCB4MiA9IDAgYW5kXG4gICAgICAgICAgICAgICAgLy8gdm4xID0gMCBuZWVkIHRvIGJlIHRlc3RlZC4gVGhlIGZpcnN0IHZhbGlkXG4gICAgICAgICAgICAgICAgLy8gc29sdXRpb24gdGhhdCBzYXRpc2ZpZXMgdGhlIHByb2JsZW0gaXMgY2hvc2VuLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBvZiB0aGUgYWNjdW11bGF0ZWQgaW1wdWxzZSAnYScgKGJlY2F1c2Ugb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0aXZlIG5hdHVyZSBvZiB0aGUgc29sdmVyIHdoaWNoIG9ubHkgcmVxdWlyZXNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZSBhY2N1bXVsYXRlZCBpbXB1bHNlIGlzIGNsYW1wZWQgYW5kIG5vdCB0aGUgaW5jcmVtZW50YWxcbiAgICAgICAgICAgICAgICAvLyBpbXB1bHNlKSB3ZSBjaGFuZ2UgdGhlIGltcHVsc2UgdmFyaWFibGUgKHhfaSkuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTdWJzdGl0dXRlOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8geCA9IGEgKyBkXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBhIDo9IG9sZCB0b3RhbCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgLy8geCA6PSBuZXcgdG90YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIC8vIGQgOj0gaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBjdXJyZW50IGl0ZXJhdGlvbiB3ZSBleHRlbmQgdGhlIGZvcm11bGEgZm9yIHRoZSBpbmNyZW1lbnRhbFxuICAgICAgICAgICAgICAgIC8vIGltcHVsc2VcbiAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIHRoZSBuZXcgdG90YWwgaW1wdWxzZTpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIHZuID0gQSAqIGQgKyBiXG4gICAgICAgICAgICAgICAgLy8gPSBBICogKHggLSBhKSArIGJcbiAgICAgICAgICAgICAgICAvLyA9IEEgKiB4ICsgYiAtIEEgKiBhXG4gICAgICAgICAgICAgICAgLy8gPSBBICogeCArIGInXG4gICAgICAgICAgICAgICAgLy8gYicgPSBiIC0gQSAqIGE7XG4gICAgICAgICAgICAgICAgdmFyIHZjcDEgPSB0aGlzLnZfcG9pbnRzWzBdOyAvLyBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludFxuICAgICAgICAgICAgICAgIHZhciB2Y3AyID0gdGhpcy52X3BvaW50c1sxXTsgLy8gVmVsb2NpdHlDb25zdHJhaW50UG9pbnRcbiAgICAgICAgICAgICAgICBzZXRWZWMyKGEsIHZjcDEubm9ybWFsSW1wdWxzZSwgdmNwMi5ub3JtYWxJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICAvLyBSZWxhdGl2ZSB2ZWxvY2l0eSBhdCBjb250YWN0XG4gICAgICAgICAgICAgICAgLy8gbGV0IGR2MSA9IFZlYzIuemVybygpLmFkZCh2QikuYWRkKFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB2Y3AxLnJCKSkuc3ViKHZBKS5zdWIoVmVjMi5jcm9zc051bVZlYzIod0EsIHZjcDEuckEpKTtcbiAgICAgICAgICAgICAgICB6ZXJvVmVjMihkdjEpO1xuICAgICAgICAgICAgICAgIGFkZFZlYzIoZHYxLCB2Qik7XG4gICAgICAgICAgICAgICAgYWRkVmVjMihkdjEsIGNyb3NzTnVtVmVjMih0ZW1wJDIsIHdCLCB2Y3AxLnJCKSk7XG4gICAgICAgICAgICAgICAgc3ViVmVjMihkdjEsIHZBKTtcbiAgICAgICAgICAgICAgICBzdWJWZWMyKGR2MSwgY3Jvc3NOdW1WZWMyKHRlbXAkMiwgd0EsIHZjcDEuckEpKTtcbiAgICAgICAgICAgICAgICAvLyBsZXQgZHYyID0gVmVjMi56ZXJvKCkuYWRkKHZCKS5hZGQoVmVjMi5jcm9zc051bVZlYzIod0IsIHZjcDIuckIpKS5zdWIodkEpLnN1YihWZWMyLmNyb3NzTnVtVmVjMih3QSwgdmNwMi5yQSkpO1xuICAgICAgICAgICAgICAgIHplcm9WZWMyKGR2Mik7XG4gICAgICAgICAgICAgICAgYWRkVmVjMihkdjIsIHZCKTtcbiAgICAgICAgICAgICAgICBhZGRWZWMyKGR2MiwgY3Jvc3NOdW1WZWMyKHRlbXAkMiwgd0IsIHZjcDIuckIpKTtcbiAgICAgICAgICAgICAgICBzdWJWZWMyKGR2MiwgdkEpO1xuICAgICAgICAgICAgICAgIHN1YlZlYzIoZHYyLCBjcm9zc051bVZlYzIodGVtcCQyLCB3QSwgdmNwMi5yQSkpO1xuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIHZlbG9jaXR5XG4gICAgICAgICAgICAgICAgdmFyIHZuMSA9IGRvdFZlYzIoZHYxLCBub3JtYWwkMik7XG4gICAgICAgICAgICAgICAgdmFyIHZuMiA9IGRvdFZlYzIoZHYyLCBub3JtYWwkMik7XG4gICAgICAgICAgICAgICAgc2V0VmVjMihiLCB2bjEgLSB2Y3AxLnZlbG9jaXR5Qmlhcywgdm4yIC0gdmNwMi52ZWxvY2l0eUJpYXMpO1xuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYidcbiAgICAgICAgICAgICAgICAvLyBiLnN1YihNYXQyMi5tdWxWZWMyKHRoaXMudl9LLCBhKSk7XG4gICAgICAgICAgICAgICAgYi54IC09IHRoaXMudl9LLmV4LnggKiBhLnggKyB0aGlzLnZfSy5leS54ICogYS55O1xuICAgICAgICAgICAgICAgIGIueSAtPSB0aGlzLnZfSy5leC55ICogYS54ICsgdGhpcy52X0suZXkueSAqIGEueTtcbiAgICAgICAgICAgICAgICAvLyBOT1RfVVNFRChrX2Vycm9yVG9sKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXNlIDE6IHZuID0gMFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAwID0gQSAqIHggKyBiJ1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBTb2x2ZSBmb3IgeDpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8geCA9IC0gaW52KEEpICogYidcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgeCA9IE1hdDIyLm11bFZlYzIodGhpcy52X25vcm1hbE1hc3MsIGIpLm5lZygpO1xuICAgICAgICAgICAgICAgICAgICB6ZXJvVmVjMih4KTtcbiAgICAgICAgICAgICAgICAgICAgeC54ID0gLSh0aGlzLnZfbm9ybWFsTWFzcy5leC54ICogYi54ICsgdGhpcy52X25vcm1hbE1hc3MuZXkueCAqIGIueSk7XG4gICAgICAgICAgICAgICAgICAgIHgueSA9IC0odGhpcy52X25vcm1hbE1hc3MuZXgueSAqIGIueCArIHRoaXMudl9ub3JtYWxNYXNzLmV5LnkgKiBiLnkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeC54ID49IDAuMCAmJiB4LnkgPj0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluY3JlbWVudGFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZWZWMyKGQsIHgsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihQMSwgZC54LCBub3JtYWwkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKFAyLCBkLnksIG5vcm1hbCQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZBLnN1YkNvbWJpbmUobUEsIFAxLCBtQSwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTXVsVmVjMih2QSwgbUEsIFAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk11bFZlYzIodkEsIG1BLCBQMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIChjcm9zc1ZlYzJWZWMyKHZjcDEuckEsIFAxKSArIGNyb3NzVmVjMlZlYzIodmNwMi5yQSwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZCLmFkZENvbWJpbmUobUIsIFAxLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTXVsVmVjMih2QiwgbUIsIFAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE11bFZlYzIodkIsIG1CLCBQMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3QiArPSBpQiAqIChjcm9zc1ZlYzJWZWMyKHZjcDEuckIsIFAxKSArIGNyb3NzVmVjMlZlYzIodmNwMi5yQiwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjcDEubm9ybWFsSW1wdWxzZSA9IHgueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjcDIubm9ybWFsSW1wdWxzZSA9IHgueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMjogdm4xID0gMCBhbmQgeDIgPSAwXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIDAgPSBhMTEgKiB4MSArIGExMiAqIDAgKyBiMSdcbiAgICAgICAgICAgICAgICAgICAgLy8gdm4yID0gYTIxICogeDEgKyBhMjIgKiAwICsgYjInXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIHgueCA9IC12Y3AxLm5vcm1hbE1hc3MgKiBiLng7XG4gICAgICAgICAgICAgICAgICAgIHgueSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgdm4xID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB2bjIgPSB0aGlzLnZfSy5leC55ICogeC54ICsgYi55O1xuICAgICAgICAgICAgICAgICAgICBpZiAoeC54ID49IDAuMCAmJiB2bjIgPj0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluY3JlbWVudGFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZWZWMyKGQsIHgsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihQMSwgZC54LCBub3JtYWwkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKFAyLCBkLnksIG5vcm1hbCQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZBLnN1YkNvbWJpbmUobUEsIFAxLCBtQSwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTXVsVmVjMih2QSwgbUEsIFAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk11bFZlYzIodkEsIG1BLCBQMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIChjcm9zc1ZlYzJWZWMyKHZjcDEuckEsIFAxKSArIGNyb3NzVmVjMlZlYzIodmNwMi5yQSwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZCLmFkZENvbWJpbmUobUIsIFAxLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTXVsVmVjMih2QiwgbUIsIFAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE11bFZlYzIodkIsIG1CLCBQMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3QiArPSBpQiAqIChjcm9zc1ZlYzJWZWMyKHZjcDEuckIsIFAxKSArIGNyb3NzVmVjMlZlYzIodmNwMi5yQiwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjcDEubm9ybWFsSW1wdWxzZSA9IHgueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjcDIubm9ybWFsSW1wdWxzZSA9IHgueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMzogdm4yID0gMCBhbmQgeDEgPSAwXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIHZuMSA9IGExMSAqIDAgKyBhMTIgKiB4MiArIGIxJ1xuICAgICAgICAgICAgICAgICAgICAvLyAwID0gYTIxICogMCArIGEyMiAqIHgyICsgYjInXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIHgueCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgeC55ID0gLXZjcDIubm9ybWFsTWFzcyAqIGIueTtcbiAgICAgICAgICAgICAgICAgICAgdm4xID0gdGhpcy52X0suZXkueCAqIHgueSArIGIueDtcbiAgICAgICAgICAgICAgICAgICAgdm4yID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeC55ID49IDAuMCAmJiB2bjEgPj0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN1YnN0aXR1dGUgZm9yIHRoZSBpbmNyZW1lbnRhbCBpbXB1bHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmVmVjMihkLCB4LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGluY3JlbWVudGFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIoUDEsIGQueCwgbm9ybWFsJDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihQMiwgZC55LCBub3JtYWwkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2QS5zdWJDb21iaW5lKG1BLCBQMSwgbUEsIFAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk11bFZlYzIodkEsIG1BLCBQMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJNdWxWZWMyKHZBLCBtQSwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd0EgLT0gaUEgKiAoY3Jvc3NWZWMyVmVjMih2Y3AxLnJBLCBQMSkgKyBjcm9zc1ZlYzJWZWMyKHZjcDIuckEsIFAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2Qi5hZGRDb21iaW5lKG1CLCBQMSwgbUIsIFAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE11bFZlYzIodkIsIG1CLCBQMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNdWxWZWMyKHZCLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd0IgKz0gaUIgKiAoY3Jvc3NWZWMyVmVjMih2Y3AxLnJCLCBQMSkgKyBjcm9zc1ZlYzJWZWMyKHZjcDIuckIsIFAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB2Y3AxLm5vcm1hbEltcHVsc2UgPSB4Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2Y3AyLm5vcm1hbEltcHVsc2UgPSB4Lnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXNlIDQ6IHgxID0gMCBhbmQgeDIgPSAwXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIHZuMSA9IGIxXG4gICAgICAgICAgICAgICAgICAgIC8vIHZuMiA9IGIyO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICB4LnggPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIHgueSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgdm4xID0gYi54O1xuICAgICAgICAgICAgICAgICAgICB2bjIgPSBiLnk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2bjEgPj0gMC4wICYmIHZuMiA+PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3Vic3RpdHV0ZSBmb3IgdGhlIGluY3JlbWVudGFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZWZWMyKGQsIHgsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihQMSwgZC54LCBub3JtYWwkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKFAyLCBkLnksIG5vcm1hbCQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZBLnN1YkNvbWJpbmUobUEsIFAxLCBtQSwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTXVsVmVjMih2QSwgbUEsIFAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk11bFZlYzIodkEsIG1BLCBQMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIChjcm9zc1ZlYzJWZWMyKHZjcDEuckEsIFAxKSArIGNyb3NzVmVjMlZlYzIodmNwMi5yQSwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZCLmFkZENvbWJpbmUobUIsIFAxLCBtQiwgUDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTXVsVmVjMih2QiwgbUIsIFAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE11bFZlYzIodkIsIG1CLCBQMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3QiArPSBpQiAqIChjcm9zc1ZlYzJWZWMyKHZjcDEuckIsIFAxKSArIGNyb3NzVmVjMlZlYzIodmNwMi5yQiwgUDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjcDEubm9ybWFsSW1wdWxzZSA9IHgueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjcDIubm9ybWFsSW1wdWxzZSA9IHgueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHNvbHV0aW9uLCBnaXZlIHVwLiBUaGlzIGlzIGhpdCBzb21ldGltZXMsIGJ1dCBpdCBkb2Vzbid0IHNlZW0gdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0dGVyLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B5VmVjMih2ZWxvY2l0eUEudiwgdkEpO1xuICAgICAgICAgICAgdmVsb2NpdHlBLncgPSB3QTtcbiAgICAgICAgICAgIGNvcHlWZWMyKHZlbG9jaXR5Qi52LCB2Qik7XG4gICAgICAgICAgICB2ZWxvY2l0eUIudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIENvbnRhY3QuYWRkVHlwZSA9IGZ1bmN0aW9uICh0eXBlMSwgdHlwZTIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzX3JlZ2lzdGVyc1t0eXBlMV0gPSBzX3JlZ2lzdGVyc1t0eXBlMV0gfHwge307XG4gICAgICAgICAgICBzX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdID0gY2FsbGJhY2s7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQ29udGFjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGluZGV4QSwgZml4dHVyZUIsIGluZGV4Qikge1xuICAgICAgICAgICAgdmFyIHR5cGVBID0gZml4dHVyZUEubV9zaGFwZS5tX3R5cGU7XG4gICAgICAgICAgICB2YXIgdHlwZUIgPSBmaXh0dXJlQi5tX3NoYXBlLm1fdHlwZTtcbiAgICAgICAgICAgIHZhciBjb250YWN0ID0gY29udGFjdFBvb2wuYWxsb2NhdGUoKTtcbiAgICAgICAgICAgIHZhciBldmFsdWF0ZUZjbjtcbiAgICAgICAgICAgIGlmIChldmFsdWF0ZUZjbiA9IHNfcmVnaXN0ZXJzW3R5cGVBXSAmJiBzX3JlZ2lzdGVyc1t0eXBlQV1bdHlwZUJdKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdC5pbml0aWFsaXplKGZpeHR1cmVBLCBpbmRleEEsIGZpeHR1cmVCLCBpbmRleEIsIGV2YWx1YXRlRmNuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2YWx1YXRlRmNuID0gc19yZWdpc3RlcnNbdHlwZUJdICYmIHNfcmVnaXN0ZXJzW3R5cGVCXVt0eXBlQV0pIHtcbiAgICAgICAgICAgICAgICBjb250YWN0LmluaXRpYWxpemUoZml4dHVyZUIsIGluZGV4QiwgZml4dHVyZUEsIGluZGV4QSwgZXZhbHVhdGVGY24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb250YWN0IGNyZWF0aW9uIG1heSBzd2FwIGZpeHR1cmVzLlxuICAgICAgICAgICAgZml4dHVyZUEgPSBjb250YWN0Lm1fZml4dHVyZUE7XG4gICAgICAgICAgICBmaXh0dXJlQiA9IGNvbnRhY3QubV9maXh0dXJlQjtcbiAgICAgICAgICAgIGluZGV4QSA9IGNvbnRhY3QuZ2V0Q2hpbGRJbmRleEEoKTtcbiAgICAgICAgICAgIGluZGV4QiA9IGNvbnRhY3QuZ2V0Q2hpbGRJbmRleEIoKTtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gYm9keSBBXG4gICAgICAgICAgICBjb250YWN0Lm1fbm9kZUEuY29udGFjdCA9IGNvbnRhY3Q7XG4gICAgICAgICAgICBjb250YWN0Lm1fbm9kZUEub3RoZXIgPSBib2R5QjtcbiAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQS5uZXh0ID0gYm9keUEubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIGlmIChib2R5QS5tX2NvbnRhY3RMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib2R5QS5tX2NvbnRhY3RMaXN0LnByZXYgPSBjb250YWN0Lm1fbm9kZUE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5QS5tX2NvbnRhY3RMaXN0ID0gY29udGFjdC5tX25vZGVBO1xuICAgICAgICAgICAgLy8gQ29ubmVjdCB0byBib2R5IEJcbiAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQi5jb250YWN0ID0gY29udGFjdDtcbiAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQi5vdGhlciA9IGJvZHlBO1xuICAgICAgICAgICAgY29udGFjdC5tX25vZGVCLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgY29udGFjdC5tX25vZGVCLm5leHQgPSBib2R5Qi5tX2NvbnRhY3RMaXN0O1xuICAgICAgICAgICAgaWYgKGJvZHlCLm1fY29udGFjdExpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvZHlCLm1fY29udGFjdExpc3QucHJldiA9IGNvbnRhY3QubV9ub2RlQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHlCLm1fY29udGFjdExpc3QgPSBjb250YWN0Lm1fbm9kZUI7XG4gICAgICAgICAgICAvLyBXYWtlIHVwIHRoZSBib2RpZXNcbiAgICAgICAgICAgIGlmIChmaXh0dXJlQS5pc1NlbnNvcigpID09IGZhbHNlICYmIGZpeHR1cmVCLmlzU2Vuc29yKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250YWN0O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIENvbnRhY3QuZGVzdHJveSA9IGZ1bmN0aW9uIChjb250YWN0LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gY29udGFjdC5tX2ZpeHR1cmVBO1xuICAgICAgICAgICAgdmFyIGZpeHR1cmVCID0gY29udGFjdC5tX2ZpeHR1cmVCO1xuICAgICAgICAgICAgaWYgKGZpeHR1cmVBID09PSBudWxsIHx8IGZpeHR1cmVCID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gbnVsbCB8fCBib2R5QiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoY29udGFjdC5pc1RvdWNoaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5lbmRDb250YWN0KGNvbnRhY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYm9keSAxXG4gICAgICAgICAgICBpZiAoY29udGFjdC5tX25vZGVBLnByZXYpIHtcbiAgICAgICAgICAgICAgICBjb250YWN0Lm1fbm9kZUEucHJldi5uZXh0ID0gY29udGFjdC5tX25vZGVBLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFjdC5tX25vZGVBLm5leHQpIHtcbiAgICAgICAgICAgICAgICBjb250YWN0Lm1fbm9kZUEubmV4dC5wcmV2ID0gY29udGFjdC5tX25vZGVBLnByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFjdC5tX25vZGVBID09IGJvZHlBLm1fY29udGFjdExpc3QpIHtcbiAgICAgICAgICAgICAgICBib2R5QS5tX2NvbnRhY3RMaXN0ID0gY29udGFjdC5tX25vZGVBLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBib2R5IDJcbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fbm9kZUIucHJldikge1xuICAgICAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQi5wcmV2Lm5leHQgPSBjb250YWN0Lm1fbm9kZUIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fbm9kZUIubmV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3QubV9ub2RlQi5uZXh0LnByZXYgPSBjb250YWN0Lm1fbm9kZUIucHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fbm9kZUIgPT0gYm9keUIubV9jb250YWN0TGlzdCkge1xuICAgICAgICAgICAgICAgIGJvZHlCLm1fY29udGFjdExpc3QgPSBjb250YWN0Lm1fbm9kZUIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fbWFuaWZvbGQucG9pbnRDb3VudCA+IDAgJiYgIWZpeHR1cmVBLm1faXNTZW5zb3IgJiYgIWZpeHR1cmVCLm1faXNTZW5zb3IpIHtcbiAgICAgICAgICAgICAgICBib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0IHR5cGVBID0gZml4dHVyZUEuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgLy8gY29uc3QgdHlwZUIgPSBmaXh0dXJlQi5nZXRUeXBlKCk7XG4gICAgICAgICAgICAvLyBjb25zdCBkZXN0cm95RmNuID0gc19yZWdpc3RlcnNbdHlwZUFdW3R5cGVCXS5kZXN0cm95RmNuO1xuICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBkZXN0cm95RmNuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyAgIGRlc3Ryb3lGY24oY29udGFjdCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBjb250YWN0UG9vbC5yZWxlYXNlKGNvbnRhY3QpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29udGFjdDtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIFdvcmxkRGVmRGVmYXVsdCA9IHtcbiAgICAgICAgZ3Jhdml0eTogVmVjMi56ZXJvKCksXG4gICAgICAgIGFsbG93U2xlZXA6IHRydWUsXG4gICAgICAgIHdhcm1TdGFydGluZzogdHJ1ZSxcbiAgICAgICAgY29udGludW91c1BoeXNpY3M6IHRydWUsXG4gICAgICAgIHN1YlN0ZXBwaW5nOiBmYWxzZSxcbiAgICAgICAgYmxvY2tTb2x2ZTogdHJ1ZSxcbiAgICAgICAgdmVsb2NpdHlJdGVyYXRpb25zOiA4LFxuICAgICAgICBwb3NpdGlvbkl0ZXJhdGlvbnM6IDNcbiAgICB9O1xuICAgIHZhciBXb3JsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBkZWYgV29ybGQgZGVmaW5pdGlvbiBvciBncmF2aXR5IHZlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFdvcmxkKGRlZikge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdvcmxkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV29ybGQoZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc19zdGVwID0gbmV3IFRpbWVTdGVwKCk7XG4gICAgICAgICAgICBpZiAoZGVmICYmIFZlYzIuaXNWYWxpZChkZWYpKSB7XG4gICAgICAgICAgICAgICAgZGVmID0geyBncmF2aXR5OiBkZWYgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBXb3JsZERlZkRlZmF1bHQpO1xuICAgICAgICAgICAgdGhpcy5tX3NvbHZlciA9IG5ldyBTb2x2ZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1fYnJvYWRQaGFzZSA9IG5ldyBCcm9hZFBoYXNlKCk7XG4gICAgICAgICAgICB0aGlzLm1fY29udGFjdExpc3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRhY3RDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUxpc3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLm1fam9pbnRMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9qb2ludENvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMubV9zdGVwQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tX2FsbG93U2xlZXAgPSBkZWYuYWxsb3dTbGVlcDtcbiAgICAgICAgICAgIHRoaXMubV9ncmF2aXR5ID0gVmVjMi5jbG9uZShkZWYuZ3Jhdml0eSk7XG4gICAgICAgICAgICB0aGlzLm1fY2xlYXJGb3JjZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tX25ld0ZpeHR1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBmb3IgZGVidWdnaW5nIHRoZSBzb2x2ZXIuXG4gICAgICAgICAgICB0aGlzLm1fd2FybVN0YXJ0aW5nID0gZGVmLndhcm1TdGFydGluZztcbiAgICAgICAgICAgIHRoaXMubV9jb250aW51b3VzUGh5c2ljcyA9IGRlZi5jb250aW51b3VzUGh5c2ljcztcbiAgICAgICAgICAgIHRoaXMubV9zdWJTdGVwcGluZyA9IGRlZi5zdWJTdGVwcGluZztcbiAgICAgICAgICAgIHRoaXMubV9ibG9ja1NvbHZlID0gZGVmLmJsb2NrU29sdmU7XG4gICAgICAgICAgICB0aGlzLm1fdmVsb2NpdHlJdGVyYXRpb25zID0gZGVmLnZlbG9jaXR5SXRlcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMubV9wb3NpdGlvbkl0ZXJhdGlvbnMgPSBkZWYucG9zaXRpb25JdGVyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5tX3QgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYm9kaWVzID0gW107XG4gICAgICAgICAgICB2YXIgam9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5nZXRCb2R5TGlzdCgpOyBiOyBiID0gYi5nZXROZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBib2RpZXMucHVzaChiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSB0aGlzLmdldEpvaW50TGlzdCgpOyBqOyBqID0gai5nZXROZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqLl9zZXJpYWxpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbnRzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBncmF2aXR5OiB0aGlzLm1fZ3Jhdml0eSxcbiAgICAgICAgICAgICAgICBib2RpZXM6IGJvZGllcyxcbiAgICAgICAgICAgICAgICBqb2ludHM6IGpvaW50cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgV29ybGQuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRleHQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV29ybGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZChkYXRhLmdyYXZpdHkpO1xuICAgICAgICAgICAgaWYgKGRhdGEuYm9kaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEuYm9kaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLl9hZGRCb2R5KHJlc3RvcmUoQm9keSwgZGF0YS5ib2RpZXNbaV0sIHdvcmxkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuam9pbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEuam9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLmNyZWF0ZUpvaW50KHJlc3RvcmUoSm9pbnQsIGRhdGEuam9pbnRzW2ldLCB3b3JsZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3b3JsZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd29ybGQgYm9keSBsaXN0LiBXaXRoIHRoZSByZXR1cm5lZCBib2R5LCB1c2UgQm9keS5nZXROZXh0IHRvIGdldCB0aGVcbiAgICAgICAgICogbmV4dCBib2R5IGluIHRoZSB3b3JsZCBsaXN0LiBBIG51bGwgYm9keSBpbmRpY2F0ZXMgdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgaGVhZCBvZiB0aGUgd29ybGQgYm9keSBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldEJvZHlMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5TGlzdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd29ybGQgam9pbnQgbGlzdC4gV2l0aCB0aGUgcmV0dXJuZWQgam9pbnQsIHVzZSBKb2ludC5nZXROZXh0IHRvIGdldFxuICAgICAgICAgKiB0aGUgbmV4dCBqb2ludCBpbiB0aGUgd29ybGQgbGlzdC4gQSBudWxsIGpvaW50IGluZGljYXRlcyB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBoZWFkIG9mIHRoZSB3b3JsZCBqb2ludCBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldEpvaW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fam9pbnRMaXN0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3b3JsZCBjb250YWN0IGxpc3QuIFdpdGggdGhlIHJldHVybmVkIGNvbnRhY3QsIHVzZSBDb250YWN0LmdldE5leHQgdG9cbiAgICAgICAgICogZ2V0IHRoZSBuZXh0IGNvbnRhY3QgaW4gdGhlIHdvcmxkIGxpc3QuIEEgbnVsbCBjb250YWN0IGluZGljYXRlcyB0aGUgZW5kIG9mXG4gICAgICAgICAqIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBXYXJuaW5nOiBjb250YWN0cyBhcmUgY3JlYXRlZCBhbmQgZGVzdHJveWVkIGluIHRoZSBtaWRkbGUgb2YgYSB0aW1lIHN0ZXAuXG4gICAgICAgICAqIFVzZSBDb250YWN0TGlzdGVuZXIgdG8gYXZvaWQgbWlzc2luZyBjb250YWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgaGVhZCBvZiB0aGUgd29ybGQgY29udGFjdCBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgICAgfTtcbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldEJvZHlDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUNvdW50O1xuICAgICAgICB9O1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Sm9pbnRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fam9pbnRDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbnRhY3RzIChlYWNoIG1heSBoYXZlIDAgb3IgbW9yZSBjb250YWN0IHBvaW50cykuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9jb250YWN0Q291bnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgdGhlIGdsb2JhbCBncmF2aXR5IHZlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5zZXRHcmF2aXR5ID0gZnVuY3Rpb24gKGdyYXZpdHkpIHtcbiAgICAgICAgICAgIHRoaXMubV9ncmF2aXR5ID0gZ3Jhdml0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZ2xvYmFsIGdyYXZpdHkgdmVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldEdyYXZpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2dyYXZpdHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgd29ybGQgbG9ja2VkIChpbiB0aGUgbWlkZGxlIG9mIGEgdGltZSBzdGVwKS5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5pc0xvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG9ja2VkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgc2xlZXAuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuc2V0QWxsb3dTbGVlcGluZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICBpZiAoZmxhZyA9PSB0aGlzLm1fYWxsb3dTbGVlcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9hbGxvd1NsZWVwID0gZmxhZztcbiAgICAgICAgICAgIGlmICh0aGlzLm1fYWxsb3dTbGVlcCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBiLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldEFsbG93U2xlZXBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2FsbG93U2xlZXA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUvZGlzYWJsZSB3YXJtIHN0YXJ0aW5nLiBGb3IgdGVzdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5zZXRXYXJtU3RhcnRpbmcgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgdGhpcy5tX3dhcm1TdGFydGluZyA9IGZsYWc7XG4gICAgICAgIH07XG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5nZXRXYXJtU3RhcnRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3dhcm1TdGFydGluZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIGNvbnRpbnVvdXMgcGh5c2ljcy4gRm9yIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuc2V0Q29udGludW91c1BoeXNpY3MgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRpbnVvdXNQaHlzaWNzID0gZmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldENvbnRpbnVvdXNQaHlzaWNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9jb250aW51b3VzUGh5c2ljcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIHNpbmdsZSBzdGVwcGVkIGNvbnRpbnVvdXMgcGh5c2ljcy4gRm9yIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuc2V0U3ViU3RlcHBpbmcgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgdGhpcy5tX3N1YlN0ZXBwaW5nID0gZmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldFN1YlN0ZXBwaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9zdWJTdGVwcGluZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBmbGFnIHRvIGNvbnRyb2wgYXV0b21hdGljIGNsZWFyaW5nIG9mIGZvcmNlcyBhZnRlciBlYWNoIHRpbWUgc3RlcC5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5zZXRBdXRvQ2xlYXJGb3JjZXMgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgdGhpcy5tX2NsZWFyRm9yY2VzID0gZmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmxhZyB0aGF0IGNvbnRyb2xzIGF1dG9tYXRpYyBjbGVhcmluZyBvZiBmb3JjZXMgYWZ0ZXIgZWFjaCB0aW1lIHN0ZXAuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0QXV0b0NsZWFyRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9jbGVhckZvcmNlcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbnVhbGx5IGNsZWFyIHRoZSBmb3JjZSBidWZmZXIgb24gYWxsIGJvZGllcy4gQnkgZGVmYXVsdCwgZm9yY2VzIGFyZSBjbGVhcmVkXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgZWFjaCBjYWxsIHRvIHN0ZXAuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIG1vZGlmaWVkIGJ5XG4gICAgICAgICAqIGNhbGxpbmcgc2V0QXV0b0NsZWFyRm9yY2VzLiBUaGUgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIHN1cHBvcnRcbiAgICAgICAgICogc3ViLXN0ZXBwaW5nLiBTdWItc3RlcHBpbmcgaXMgb2Z0ZW4gdXNlZCB0byBtYWludGFpbiBhIGZpeGVkIHNpemVkIHRpbWUgc3RlcFxuICAgICAgICAgKiB1bmRlciBhIHZhcmlhYmxlIGZyYW1lLXJhdGUuIFdoZW4geW91IHBlcmZvcm0gc3ViLXN0ZXBwaW5nIHlvdSB3aWxsIGRpc2FibGVcbiAgICAgICAgICogYXV0byBjbGVhcmluZyBvZiBmb3JjZXMgYW5kIGluc3RlYWQgY2FsbCBjbGVhckZvcmNlcyBhZnRlciBhbGwgc3ViLXN0ZXBzIGFyZVxuICAgICAgICAgKiBjb21wbGV0ZSBpbiBvbmUgcGFzcyBvZiB5b3VyIGdhbWUgbG9vcC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIHtAbGluayBXb3JsZC5zZXRBdXRvQ2xlYXJGb3JjZXN9XG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuY2xlYXJGb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBib2R5ID0gdGhpcy5tX2JvZHlMaXN0OyBib2R5OyBib2R5ID0gYm9keS5nZXROZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBib2R5Lm1fZm9yY2Uuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIGJvZHkubV90b3JxdWUgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWVyeSB0aGUgd29ybGQgZm9yIGFsbCBmaXh0dXJlcyB0aGF0IHBvdGVudGlhbGx5IG92ZXJsYXAgdGhlIHByb3ZpZGVkIEFBQkIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhYWJiIFRoZSBxdWVyeSBib3guXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayBDYWxsZWQgZm9yIGVhY2ggZml4dHVyZSBmb3VuZCBpbiB0aGUgcXVlcnkgQUFCQi4gSXQgbWF5IHJldHVybiBgZmFsc2VgIHRvIHRlcm1pbmF0ZSB0aGUgcXVlcnkuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUucXVlcnlBQUJCID0gZnVuY3Rpb24gKGFhYmIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV9icm9hZFBoYXNlO1xuICAgICAgICAgICAgdGhpcy5tX2Jyb2FkUGhhc2UucXVlcnkoYWFiYiwgZnVuY3Rpb24gKHByb3h5SWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBicm9hZFBoYXNlLmdldFVzZXJEYXRhKHByb3h5SWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhwcm94eS5maXh0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmF5LWNhc3QgdGhlIHdvcmxkIGZvciBhbGwgZml4dHVyZXMgaW4gdGhlIHBhdGggb2YgdGhlIHJheS4gWW91ciBjYWxsYmFja1xuICAgICAgICAgKiBjb250cm9scyB3aGV0aGVyIHlvdSBnZXQgdGhlIGNsb3Nlc3QgcG9pbnQsIGFueSBwb2ludCwgb3Igbi1wb2ludHMuIFRoZVxuICAgICAgICAgKiByYXktY2FzdCBpZ25vcmVzIHNoYXBlcyB0aGF0IGNvbnRhaW4gdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQxIFRoZSByYXkgc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHBvaW50MiBUaGUgcmF5IGVuZGluZyBwb2ludFxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSB1c2VyIGltcGxlbWVudGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV9icm9hZFBoYXNlO1xuICAgICAgICAgICAgdGhpcy5tX2Jyb2FkUGhhc2UucmF5Q2FzdCh7XG4gICAgICAgICAgICAgICAgbWF4RnJhY3Rpb246IDEuMCxcbiAgICAgICAgICAgICAgICBwMTogcG9pbnQxLFxuICAgICAgICAgICAgICAgIHAyOiBwb2ludDJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChpbnB1dCwgcHJveHlJZCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IGJyb2FkUGhhc2UuZ2V0VXNlckRhdGEocHJveHlJZCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmUgPSBwcm94eS5maXh0dXJlO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHByb3h5LmNoaWxkSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB7fTsgLy8gVE9ETyBHQ1xuICAgICAgICAgICAgICAgIHZhciBoaXQgPSBmaXh0dXJlLnJheUNhc3Qob3V0cHV0LCBpbnB1dCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWN0aW9uID0gb3V0cHV0LmZyYWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBWZWMyLmFkZChWZWMyLm11bE51bVZlYzIoKDEuMCAtIGZyYWN0aW9uKSwgaW5wdXQucDEpLCBWZWMyLm11bE51bVZlYzIoZnJhY3Rpb24sIGlucHV0LnAyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhmaXh0dXJlLCBwb2ludCwgb3V0cHV0Lm5vcm1hbCwgZnJhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQubWF4RnJhY3Rpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGJyb2FkLXBoYXNlIHByb3hpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0UHJveHlDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYnJvYWRQaGFzZS5nZXRQcm94eUNvdW50KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGhlaWdodCBvZiBicm9hZC1waGFzZSBkeW5hbWljIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0VHJlZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYnJvYWRQaGFzZS5nZXRUcmVlSGVpZ2h0KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGJhbGFuY2Ugb2YgYnJvYWQtcGhhc2UgZHluYW1pYyB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmdldFRyZWVCYWxhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9icm9hZFBoYXNlLmdldFRyZWVCYWxhbmNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHF1YWxpdHkgbWV0cmljIG9mIGJyb2FkLXBoYXNlIGR5bmFtaWMgdHJlZS4gVGhlIHNtYWxsZXIgdGhlIGJldHRlci5cbiAgICAgICAgICogVGhlIG1pbmltdW0gaXMgMS5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5nZXRUcmVlUXVhbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYnJvYWRQaGFzZS5nZXRUcmVlUXVhbGl0eSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hpZnQgdGhlIHdvcmxkIG9yaWdpbi4gVXNlZnVsIGZvciBsYXJnZSB3b3JsZHMuIFRoZSBib2R5IHNoaWZ0IGZvcm11bGEgaXM6XG4gICAgICAgICAqIHBvc2l0aW9uIC09IG5ld09yaWdpblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV3T3JpZ2luIFRoZSBuZXcgb3JpZ2luIHdpdGggcmVzcGVjdCB0byB0aGUgb2xkIG9yaWdpblxuICAgICAgICAgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLnNoaWZ0T3JpZ2luID0gZnVuY3Rpb24gKG5ld09yaWdpbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9sb2NrZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5tX2JvZHlMaXN0OyBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgICAgICAgICAgICBiLm1feGYucC5zdWIobmV3T3JpZ2luKTtcbiAgICAgICAgICAgICAgICBiLm1fc3dlZXAuYzAuc3ViKG5ld09yaWdpbik7XG4gICAgICAgICAgICAgICAgYi5tX3N3ZWVwLmMuc3ViKG5ld09yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gdGhpcy5tX2pvaW50TGlzdDsgajsgaiA9IGoubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgai5zaGlmdE9yaWdpbihuZXdPcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2Jyb2FkUGhhc2Uuc2hpZnRPcmlnaW4obmV3T3JpZ2luKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBVc2VkIGZvciBkZXNlcmlhbGl6ZS4gKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLl9hZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdG8gd29ybGQgZG91Ymx5IGxpbmtlZCBsaXN0LlxuICAgICAgICAgICAgYm9keS5tX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgYm9keS5tX25leHQgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2JvZHlMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlMaXN0Lm1fcHJldiA9IGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUxpc3QgPSBib2R5O1xuICAgICAgICAgICAgKyt0aGlzLm1fYm9keUNvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHlwZWRlZlxuICAgICAgICAvKiogQGludGVybmFsICovIFdvcmxkLnByb3RvdHlwZS5jcmVhdGVCb2R5ID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZWYgPSB7fTtcbiAgICAgICAgICAgIGlmICghYXJnMSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoVmVjMi5pc1ZhbGlkKGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgZGVmID0geyBwb3NpdGlvbjogYXJnMSwgYW5nbGU6IGFyZzIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGRlZiA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHRoaXMsIGRlZik7XG4gICAgICAgICAgICB0aGlzLl9hZGRCb2R5KGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gV29ybGQucHJvdG90eXBlLmNyZWF0ZUR5bmFtaWNCb2R5ID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSB7fTtcbiAgICAgICAgICAgIGlmICghYXJnMSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoVmVjMi5pc1ZhbGlkKGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgZGVmID0geyBwb3NpdGlvbjogYXJnMSwgYW5nbGU6IGFyZzIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGRlZiA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYudHlwZSA9ICdkeW5hbWljJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUJvZHkoZGVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgV29ybGQucHJvdG90eXBlLmNyZWF0ZUtpbmVtYXRpY0JvZHkgPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHt9O1xuICAgICAgICAgICAgaWYgKCFhcmcxKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChWZWMyLmlzVmFsaWQoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICBkZWYgPSB7IHBvc2l0aW9uOiBhcmcxLCBhbmdsZTogYXJnMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZGVmID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZi50eXBlID0gJ2tpbmVtYXRpYyc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVCb2R5KGRlZik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95IGEgcmlnaWQgYm9keSBnaXZlbiBhIGRlZmluaXRpb24uIE5vIHJlZmVyZW5jZSB0byB0aGUgZGVmaW5pdGlvbiBpc1xuICAgICAgICAgKiByZXRhaW5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2FybmluZzogVGhpcyBhdXRvbWF0aWNhbGx5IGRlbGV0ZXMgYWxsIGFzc29jaWF0ZWQgc2hhcGVzIGFuZCBqb2ludHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdhcm5pbmc6IFRoaXMgZnVuY3Rpb24gaXMgbG9ja2VkIGR1cmluZyBjYWxsYmFja3MuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZGVzdHJveUJvZHkgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiLm1fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBhdHRhY2hlZCBqb2ludHMuXG4gICAgICAgICAgICB2YXIgamUgPSBiLm1fam9pbnRMaXN0O1xuICAgICAgICAgICAgd2hpbGUgKGplKSB7XG4gICAgICAgICAgICAgICAgdmFyIGplMCA9IGplO1xuICAgICAgICAgICAgICAgIGplID0gamUubmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goJ3JlbW92ZS1qb2ludCcsIGplMC5qb2ludCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95Sm9pbnQoamUwLmpvaW50KTtcbiAgICAgICAgICAgICAgICBiLm1fam9pbnRMaXN0ID0gamU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm1fam9pbnRMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgYXR0YWNoZWQgY29udGFjdHMuXG4gICAgICAgICAgICB2YXIgY2UgPSBiLm1fY29udGFjdExpc3Q7XG4gICAgICAgICAgICB3aGlsZSAoY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2UwID0gY2U7XG4gICAgICAgICAgICAgICAgY2UgPSBjZS5uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUNvbnRhY3QoY2UwLmNvbnRhY3QpO1xuICAgICAgICAgICAgICAgIGIubV9jb250YWN0TGlzdCA9IGNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5tX2NvbnRhY3RMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgYXR0YWNoZWQgZml4dHVyZXMuIFRoaXMgZGVzdHJveXMgYnJvYWQtcGhhc2UgcHJveGllcy5cbiAgICAgICAgICAgIHZhciBmID0gYi5tX2ZpeHR1cmVMaXN0O1xuICAgICAgICAgICAgd2hpbGUgKGYpIHtcbiAgICAgICAgICAgICAgICB2YXIgZjAgPSBmO1xuICAgICAgICAgICAgICAgIGYgPSBmLm1fbmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goJ3JlbW92ZS1maXh0dXJlJywgZjApO1xuICAgICAgICAgICAgICAgIGYwLmRlc3Ryb3lQcm94aWVzKHRoaXMubV9icm9hZFBoYXNlKTtcbiAgICAgICAgICAgICAgICBiLm1fZml4dHVyZUxpc3QgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5tX2ZpeHR1cmVMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB3b3JsZCBib2R5IGxpc3QuXG4gICAgICAgICAgICBpZiAoYi5tX3ByZXYpIHtcbiAgICAgICAgICAgICAgICBiLm1fcHJldi5tX25leHQgPSBiLm1fbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiLm1fbmV4dCkge1xuICAgICAgICAgICAgICAgIGIubV9uZXh0Lm1fcHJldiA9IGIubV9wcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIgPT0gdGhpcy5tX2JvZHlMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gYi5tX25leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm1fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC0tdGhpcy5tX2JvZHlDb3VudDtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCgncmVtb3ZlLWJvZHknLCBiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgam9pbnQgdG8gY29uc3RyYWluIGJvZGllcyB0b2dldGhlci4gTm8gcmVmZXJlbmNlIHRvIHRoZSBkZWZpbml0aW9uXG4gICAgICAgICAqIGlzIHJldGFpbmVkLiBUaGlzIG1heSBjYXVzZSB0aGUgY29ubmVjdGVkIGJvZGllcyB0byBjZWFzZSBjb2xsaWRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdhcm5pbmc6IFRoaXMgZnVuY3Rpb24gaXMgbG9ja2VkIGR1cmluZyBjYWxsYmFja3MuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuY3JlYXRlSm9pbnQgPSBmdW5jdGlvbiAoam9pbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIHdvcmxkIGxpc3QuXG4gICAgICAgICAgICBqb2ludC5tX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgam9pbnQubV9uZXh0ID0gdGhpcy5tX2pvaW50TGlzdDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fam9pbnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2pvaW50TGlzdC5tX3ByZXYgPSBqb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9qb2ludExpc3QgPSBqb2ludDtcbiAgICAgICAgICAgICsrdGhpcy5tX2pvaW50Q291bnQ7XG4gICAgICAgICAgICAvLyBDb25uZWN0IHRvIHRoZSBib2RpZXMnIGRvdWJseSBsaW5rZWQgbGlzdHMuXG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VBLmpvaW50ID0gam9pbnQ7XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VBLm90aGVyID0gam9pbnQubV9ib2R5QjtcbiAgICAgICAgICAgIGpvaW50Lm1fZWRnZUEucHJldiA9IG51bGw7XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VBLm5leHQgPSBqb2ludC5tX2JvZHlBLm1fam9pbnRMaXN0O1xuICAgICAgICAgICAgaWYgKGpvaW50Lm1fYm9keUEubV9qb2ludExpc3QpXG4gICAgICAgICAgICAgICAgam9pbnQubV9ib2R5QS5tX2pvaW50TGlzdC5wcmV2ID0gam9pbnQubV9lZGdlQTtcbiAgICAgICAgICAgIGpvaW50Lm1fYm9keUEubV9qb2ludExpc3QgPSBqb2ludC5tX2VkZ2VBO1xuICAgICAgICAgICAgam9pbnQubV9lZGdlQi5qb2ludCA9IGpvaW50O1xuICAgICAgICAgICAgam9pbnQubV9lZGdlQi5vdGhlciA9IGpvaW50Lm1fYm9keUE7XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VCLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgam9pbnQubV9lZGdlQi5uZXh0ID0gam9pbnQubV9ib2R5Qi5tX2pvaW50TGlzdDtcbiAgICAgICAgICAgIGlmIChqb2ludC5tX2JvZHlCLm1fam9pbnRMaXN0KVxuICAgICAgICAgICAgICAgIGpvaW50Lm1fYm9keUIubV9qb2ludExpc3QucHJldiA9IGpvaW50Lm1fZWRnZUI7XG4gICAgICAgICAgICBqb2ludC5tX2JvZHlCLm1fam9pbnRMaXN0ID0gam9pbnQubV9lZGdlQjtcbiAgICAgICAgICAgIC8vIElmIHRoZSBqb2ludCBwcmV2ZW50cyBjb2xsaXNpb25zLCB0aGVuIGZsYWcgYW55IGNvbnRhY3RzIGZvciBmaWx0ZXJpbmcuXG4gICAgICAgICAgICBpZiAoam9pbnQubV9jb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZWRnZSA9IGpvaW50Lm1fYm9keUIuZ2V0Q29udGFjdExpc3QoKTsgZWRnZTsgZWRnZSA9IGVkZ2UubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBqb2ludC5tX2JvZHlBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIHRoZSBjb250YWN0IGZvciBmaWx0ZXJpbmcgYXQgdGhlIG5leHQgdGltZSBzdGVwICh3aGVyZSBlaXRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHkgaXMgYXdha2UpLlxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZS5jb250YWN0LmZsYWdGb3JGaWx0ZXJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGU6IGNyZWF0aW5nIGEgam9pbnQgZG9lc24ndCB3YWtlIHRoZSBib2RpZXMuXG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95IGEgam9pbnQuIFRoaXMgbWF5IGNhdXNlIHRoZSBjb25uZWN0ZWQgYm9kaWVzIHRvIGJlZ2luIGNvbGxpZGluZy5cbiAgICAgICAgICogV2FybmluZzogVGhpcyBmdW5jdGlvbiBpcyBsb2NrZWQgZHVyaW5nIGNhbGxiYWNrcy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5kZXN0cm95Sm9pbnQgPSBmdW5jdGlvbiAoam9pbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0LlxuICAgICAgICAgICAgaWYgKGpvaW50Lm1fcHJldikge1xuICAgICAgICAgICAgICAgIGpvaW50Lm1fcHJldi5tX25leHQgPSBqb2ludC5tX25leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoam9pbnQubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgam9pbnQubV9uZXh0Lm1fcHJldiA9IGpvaW50Lm1fcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2ludCA9PSB0aGlzLm1fam9pbnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2pvaW50TGlzdCA9IGpvaW50Lm1fbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgZnJvbSBib2RpZXMuXG4gICAgICAgICAgICB2YXIgYm9keUEgPSBqb2ludC5tX2JvZHlBO1xuICAgICAgICAgICAgdmFyIGJvZHlCID0gam9pbnQubV9ib2R5QjtcbiAgICAgICAgICAgIC8vIFdha2UgdXAgY29ubmVjdGVkIGJvZGllcy5cbiAgICAgICAgICAgIGJvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBib2R5IDEuXG4gICAgICAgICAgICBpZiAoam9pbnQubV9lZGdlQS5wcmV2KSB7XG4gICAgICAgICAgICAgICAgam9pbnQubV9lZGdlQS5wcmV2Lm5leHQgPSBqb2ludC5tX2VkZ2VBLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoam9pbnQubV9lZGdlQS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgam9pbnQubV9lZGdlQS5uZXh0LnByZXYgPSBqb2ludC5tX2VkZ2VBLnByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoam9pbnQubV9lZGdlQSA9PSBib2R5QS5tX2pvaW50TGlzdCkge1xuICAgICAgICAgICAgICAgIGJvZHlBLm1fam9pbnRMaXN0ID0gam9pbnQubV9lZGdlQS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgam9pbnQubV9lZGdlQS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGpvaW50Lm1fZWRnZUEubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBib2R5IDJcbiAgICAgICAgICAgIGlmIChqb2ludC5tX2VkZ2VCLnByZXYpIHtcbiAgICAgICAgICAgICAgICBqb2ludC5tX2VkZ2VCLnByZXYubmV4dCA9IGpvaW50Lm1fZWRnZUIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2ludC5tX2VkZ2VCLm5leHQpIHtcbiAgICAgICAgICAgICAgICBqb2ludC5tX2VkZ2VCLm5leHQucHJldiA9IGpvaW50Lm1fZWRnZUIucHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2ludC5tX2VkZ2VCID09IGJvZHlCLm1fam9pbnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgYm9keUIubV9qb2ludExpc3QgPSBqb2ludC5tX2VkZ2VCLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqb2ludC5tX2VkZ2VCLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgam9pbnQubV9lZGdlQi5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC0tdGhpcy5tX2pvaW50Q291bnQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgam9pbnQgcHJldmVudHMgY29sbGlzaW9ucywgdGhlbiBmbGFnIGFueSBjb250YWN0cyBmb3IgZmlsdGVyaW5nLlxuICAgICAgICAgICAgaWYgKGpvaW50Lm1fY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBlZGdlID0gYm9keUIuZ2V0Q29udGFjdExpc3QoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBib2R5QSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyB0aGUgY29udGFjdCBmb3IgZmlsdGVyaW5nIGF0IHRoZSBuZXh0IHRpbWUgc3RlcCAod2hlcmUgZWl0aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib2R5IGlzIGF3YWtlKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2UuY29udGFjdC5mbGFnRm9yRmlsdGVyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2goJ3JlbW92ZS1qb2ludCcsIGpvaW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2UgYSB0aW1lIHN0ZXAuIFRoaXMgcGVyZm9ybXMgY29sbGlzaW9uIGRldGVjdGlvbiwgaW50ZWdyYXRpb24sIGFuZFxuICAgICAgICAgKiBjb25zdHJhaW50IHNvbHV0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCcm9hZC1waGFzZSwgbmFycm93LXBoYXNlLCBzb2x2ZSBhbmQgc29sdmUgdGltZSBvZiBpbXBhY3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdGltZVN0ZXAgVGltZSBzdGVwLCB0aGlzIHNob3VsZCBub3QgdmFyeS5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKHRpbWVTdGVwLCB2ZWxvY2l0eUl0ZXJhdGlvbnMsIHBvc2l0aW9uSXRlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKCdwcmUtc3RlcCcsIHRpbWVTdGVwKTtcbiAgICAgICAgICAgIGlmICgodmVsb2NpdHlJdGVyYXRpb25zIHwgMCkgIT09IHZlbG9jaXR5SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGluIGZ1dHVyZVxuICAgICAgICAgICAgICAgIHZlbG9jaXR5SXRlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZWxvY2l0eUl0ZXJhdGlvbnMgPSB2ZWxvY2l0eUl0ZXJhdGlvbnMgfHwgdGhpcy5tX3ZlbG9jaXR5SXRlcmF0aW9ucztcbiAgICAgICAgICAgIHBvc2l0aW9uSXRlcmF0aW9ucyA9IHBvc2l0aW9uSXRlcmF0aW9ucyB8fCB0aGlzLm1fcG9zaXRpb25JdGVyYXRpb25zO1xuICAgICAgICAgICAgLy8gSWYgbmV3IGZpeHR1cmVzIHdlcmUgYWRkZWQsIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV3IGNvbnRhY3RzLlxuICAgICAgICAgICAgaWYgKHRoaXMubV9uZXdGaXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTmV3Q29udGFjdHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbmV3Rml4dHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2xvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNfc3RlcC5yZXNldCh0aW1lU3RlcCk7XG4gICAgICAgICAgICB0aGlzLnNfc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnMgPSB2ZWxvY2l0eUl0ZXJhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnNfc3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnMgPSBwb3NpdGlvbkl0ZXJhdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnNfc3RlcC53YXJtU3RhcnRpbmcgPSB0aGlzLm1fd2FybVN0YXJ0aW5nO1xuICAgICAgICAgICAgdGhpcy5zX3N0ZXAuYmxvY2tTb2x2ZSA9IHRoaXMubV9ibG9ja1NvbHZlO1xuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3RzLiBUaGlzIGlzIHdoZXJlIHNvbWUgY29udGFjdHMgYXJlIGRlc3Ryb3llZC5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGFjdHMoKTtcbiAgICAgICAgICAgIC8vIEludGVncmF0ZSB2ZWxvY2l0aWVzLCBzb2x2ZSB2ZWxvY2l0eSBjb25zdHJhaW50cywgYW5kIGludGVncmF0ZSBwb3NpdGlvbnMuXG4gICAgICAgICAgICBpZiAodGhpcy5tX3N0ZXBDb21wbGV0ZSAmJiB0aW1lU3RlcCA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9zb2x2ZXIuc29sdmVXb3JsZCh0aGlzLnNfc3RlcCk7XG4gICAgICAgICAgICAgICAgLy8gU3luY2hyb25pemUgZml4dHVyZXMsIGNoZWNrIGZvciBvdXQgb2YgcmFuZ2UgYm9kaWVzLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSB0aGlzLm1fYm9keUxpc3Q7IGI7IGIgPSBiLmdldE5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGJvZHkgd2FzIG5vdCBpbiBhbiBpc2xhbmQgdGhlbiBpdCBkaWQgbm90IG1vdmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLm1faXNsYW5kRmxhZyA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGZpeHR1cmVzIChmb3IgYnJvYWQtcGhhc2UpLlxuICAgICAgICAgICAgICAgICAgICBiLnN5bmNocm9uaXplRml4dHVyZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgbmV3IGNvbnRhY3RzLlxuICAgICAgICAgICAgICAgIHRoaXMuZmluZE5ld0NvbnRhY3RzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgVE9JIGV2ZW50cy5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fY29udGludW91c1BoeXNpY3MgJiYgdGltZVN0ZXAgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc29sdmVyLnNvbHZlV29ybGRUT0kodGhpcy5zX3N0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV9jbGVhckZvcmNlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGb3JjZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCgncG9zdC1zdGVwJywgdGltZVN0ZXApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIENhbGwgdGhpcyBtZXRob2QgdG8gZmluZCBuZXcgY29udGFjdHMuXG4gICAgICAgICAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuZmluZE5ld0NvbnRhY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubV9icm9hZFBoYXNlLnVwZGF0ZVBhaXJzKGZ1bmN0aW9uIChwcm94eUEsIHByb3h5QikgeyByZXR1cm4gX3RoaXMuY3JlYXRlQ29udGFjdChwcm94eUEsIHByb3h5Qik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIENhbGxiYWNrIGZvciBicm9hZC1waGFzZS5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5jcmVhdGVDb250YWN0ID0gZnVuY3Rpb24gKHByb3h5QSwgcHJveHlCKSB7XG4gICAgICAgICAgICB2YXIgZml4dHVyZUEgPSBwcm94eUEuZml4dHVyZTtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IHByb3h5Qi5maXh0dXJlO1xuICAgICAgICAgICAgdmFyIGluZGV4QSA9IHByb3h5QS5jaGlsZEluZGV4O1xuICAgICAgICAgICAgdmFyIGluZGV4QiA9IHByb3h5Qi5jaGlsZEluZGV4O1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gZml4dHVyZUEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgdmFyIGJvZHlCID0gZml4dHVyZUIuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgLy8gQXJlIHRoZSBmaXh0dXJlcyBvbiB0aGUgc2FtZSBib2R5P1xuICAgICAgICAgICAgaWYgKGJvZHlBID09IGJvZHlCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ET19FUklOIHVzZSBhIGhhc2ggdGFibGUgdG8gcmVtb3ZlIGEgcG90ZW50aWFsIGJvdHRsZW5lY2sgd2hlbiBib3RoXG4gICAgICAgICAgICAvLyBib2RpZXMgaGF2ZSBhIGxvdCBvZiBjb250YWN0cy5cbiAgICAgICAgICAgIC8vIERvZXMgYSBjb250YWN0IGFscmVhZHkgZXhpc3Q/XG4gICAgICAgICAgICB2YXIgZWRnZSA9IGJvZHlCLmdldENvbnRhY3RMaXN0KCk7IC8vIENvbnRhY3RFZGdlXG4gICAgICAgICAgICB3aGlsZSAoZWRnZSkge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlLm90aGVyID09IGJvZHlBKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmQSA9IGVkZ2UuY29udGFjdC5nZXRGaXh0dXJlQSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZkIgPSBlZGdlLmNvbnRhY3QuZ2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlBID0gZWRnZS5jb250YWN0LmdldENoaWxkSW5kZXhBKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpQiA9IGVkZ2UuY29udGFjdC5nZXRDaGlsZEluZGV4QigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZkEgPT0gZml4dHVyZUEgJiYgZkIgPT0gZml4dHVyZUIgJiYgaUEgPT0gaW5kZXhBICYmIGlCID09IGluZGV4Qikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBjb250YWN0IGFscmVhZHkgZXhpc3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmQSA9PSBmaXh0dXJlQiAmJiBmQiA9PSBmaXh0dXJlQSAmJiBpQSA9PSBpbmRleEIgJiYgaUIgPT0gaW5kZXhBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGNvbnRhY3QgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib2R5Qi5zaG91bGRDb2xsaWRlKGJvZHlBKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXh0dXJlQi5zaG91bGRDb2xsaWRlKGZpeHR1cmVBKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGZhY3RvcnkuXG4gICAgICAgICAgICB2YXIgY29udGFjdCA9IENvbnRhY3QuY3JlYXRlKGZpeHR1cmVBLCBpbmRleEEsIGZpeHR1cmVCLCBpbmRleEIpO1xuICAgICAgICAgICAgaWYgKGNvbnRhY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSB3b3JsZC5cbiAgICAgICAgICAgIGNvbnRhY3QubV9wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fY29udGFjdExpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3QubV9uZXh0ID0gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgICAgICAgICAgIHRoaXMubV9jb250YWN0TGlzdC5tX3ByZXYgPSBjb250YWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0ID0gY29udGFjdDtcbiAgICAgICAgICAgICsrdGhpcy5tX2NvbnRhY3RDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBSZW1vdmVzIG9sZCBub24tb3ZlcmxhcHBpbmcgY29udGFjdHMsIGFwcGxpZXMgZmlsdGVycyBhbmQgdXBkYXRlcyBjb250YWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS51cGRhdGVDb250YWN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhd2FrZSBjb250YWN0cy5cbiAgICAgICAgICAgIHZhciBjO1xuICAgICAgICAgICAgdmFyIG5leHRfYyA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIHdoaWxlIChjID0gbmV4dF9jKSB7XG4gICAgICAgICAgICAgICAgbmV4dF9jID0gYy5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpeHR1cmVBID0gYy5nZXRGaXh0dXJlQSgpO1xuICAgICAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IGMuZ2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhBID0gYy5nZXRDaGlsZEluZGV4QSgpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleEIgPSBjLmdldENoaWxkSW5kZXhCKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlBID0gZml4dHVyZUEuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLmdldEJvZHkoKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGNvbnRhY3QgZmxhZ2dlZCBmb3IgZmlsdGVyaW5nP1xuICAgICAgICAgICAgICAgIGlmIChjLm1fZmlsdGVyRmxhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUIuc2hvdWxkQ29sbGlkZShib2R5QSkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUNvbnRhY3QoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZml4dHVyZUIuc2hvdWxkQ29sbGlkZShmaXh0dXJlQSkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUNvbnRhY3QoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgZmlsdGVyaW5nIGZsYWcuXG4gICAgICAgICAgICAgICAgICAgIGMubV9maWx0ZXJGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVBID0gYm9keUEuaXNBd2FrZSgpICYmICFib2R5QS5pc1N0YXRpYygpO1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVCID0gYm9keUIuaXNBd2FrZSgpICYmICFib2R5Qi5pc1N0YXRpYygpO1xuICAgICAgICAgICAgICAgIC8vIEF0IGxlYXN0IG9uZSBib2R5IG11c3QgYmUgYXdha2UgYW5kIGl0IG11c3QgYmUgZHluYW1pYyBvciBraW5lbWF0aWMuXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUEgPT0gZmFsc2UgJiYgYWN0aXZlQiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByb3h5SWRBID0gZml4dHVyZUEubV9wcm94aWVzW2luZGV4QV0ucHJveHlJZDtcbiAgICAgICAgICAgICAgICB2YXIgcHJveHlJZEIgPSBmaXh0dXJlQi5tX3Byb3hpZXNbaW5kZXhCXS5wcm94eUlkO1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGFwID0gdGhpcy5tX2Jyb2FkUGhhc2UudGVzdE92ZXJsYXAocHJveHlJZEEsIHByb3h5SWRCKTtcbiAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIGRlc3Ryb3kgY29udGFjdHMgdGhhdCBjZWFzZSB0byBvdmVybGFwIGluIHRoZSBicm9hZC1waGFzZS5cbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lDb250YWN0KGMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbnRhY3QgcGVyc2lzdHMuXG4gICAgICAgICAgICAgICAgYy51cGRhdGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgV29ybGQucHJvdG90eXBlLmRlc3Ryb3lDb250YWN0ID0gZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSB3b3JsZC5cbiAgICAgICAgICAgIGlmIChjb250YWN0Lm1fcHJldikge1xuICAgICAgICAgICAgICAgIGNvbnRhY3QubV9wcmV2Lm1fbmV4dCA9IGNvbnRhY3QubV9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhY3QubV9uZXh0KSB7XG4gICAgICAgICAgICAgICAgY29udGFjdC5tX25leHQubV9wcmV2ID0gY29udGFjdC5tX3ByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFjdCA9PSB0aGlzLm1fY29udGFjdExpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fY29udGFjdExpc3QgPSBjb250YWN0Lm1fbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENvbnRhY3QuZGVzdHJveShjb250YWN0LCB0aGlzKTtcbiAgICAgICAgICAgIC0tdGhpcy5tX2NvbnRhY3RDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnR5cGVkZWZcbiAgICAgICAgV29ybGQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzICYmIHRoaXMuX2xpc3RlbmVyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKG5hbWUsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGlzdGVuZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2xdLmNhbGwodGhpcywgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUuYmVnaW5Db250YWN0ID0gZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCgnYmVnaW4tY29udGFjdCcsIGNvbnRhY3QpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5lbmRDb250YWN0ID0gZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCgnZW5kLWNvbnRhY3QnLCBjb250YWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXb3JsZC5wcm90b3R5cGUucHJlU29sdmUgPSBmdW5jdGlvbiAoY29udGFjdCwgb2xkTWFuaWZvbGQpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCgncHJlLXNvbHZlJywgY29udGFjdCwgb2xkTWFuaWZvbGQpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFdvcmxkLnByb3RvdHlwZS5wb3N0U29sdmUgPSBmdW5jdGlvbiAoY29udGFjdCwgaW1wdWxzZSkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKCdwb3N0LXNvbHZlJywgY29udGFjdCwgaW1wdWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXb3JsZDtcbiAgICB9KCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIHZhciBWZWMzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWZWMzKHgsIHksIHopIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWZWMzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy56ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHgueDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB4Lnk7XG4gICAgICAgICAgICAgICAgdGhpcy56ID0geC56O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBWZWMzLnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgICAgICAgICAgeTogdGhpcy55LFxuICAgICAgICAgICAgICAgIHo6IHRoaXMuelxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBWZWMzLl9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShWZWMzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBvYmoueCA9IGRhdGEueDtcbiAgICAgICAgICAgIG9iai55ID0gZGF0YS55O1xuICAgICAgICAgICAgb2JqLnogPSBkYXRhLno7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZlYzMubmVvID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKFZlYzMucHJvdG90eXBlKTtcbiAgICAgICAgICAgIG9iai54ID0geDtcbiAgICAgICAgICAgIG9iai55ID0geTtcbiAgICAgICAgICAgIG9iai56ID0gejtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMuemVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKFZlYzMucHJvdG90eXBlKTtcbiAgICAgICAgICAgIG9iai54ID0gMDtcbiAgICAgICAgICAgIG9iai55ID0gMDtcbiAgICAgICAgICAgIG9iai56ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMuY2xvbmUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzMubmVvKHYueCwgdi55LCB2LnopO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZlYzMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogRG9lcyB0aGlzIHZlY3RvciBjb250YWluIGZpbml0ZSBjb29yZGluYXRlcz8gKi9cbiAgICAgICAgVmVjMy5pc1ZhbGlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUob2JqLngpICYmIE51bWJlci5pc0Zpbml0ZShvYmoueSkgJiYgTnVtYmVyLmlzRmluaXRlKG9iai56KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMy5hc3NlcnQgPSBmdW5jdGlvbiAobykge1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy54ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy55ID0gMC4wO1xuICAgICAgICAgICAgdGhpcy56ID0gMC4wO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIHRoaXMueCArPSB3Lng7XG4gICAgICAgICAgICB0aGlzLnkgKz0gdy55O1xuICAgICAgICAgICAgdGhpcy56ICs9IHcuejtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgdGhpcy54IC09IHcueDtcbiAgICAgICAgICAgIHRoaXMueSAtPSB3Lnk7XG4gICAgICAgICAgICB0aGlzLnogLT0gdy56O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB0aGlzLnggKj0gbTtcbiAgICAgICAgICAgIHRoaXMueSAqPSBtO1xuICAgICAgICAgICAgdGhpcy56ICo9IG07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMy5hcmVFcXVhbCA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gdiA9PT0gdyB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3ID09PSAnb2JqZWN0JyAmJiB3ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHYueCA9PT0gdy54ICYmIHYueSA9PT0gdy55ICYmIHYueiA9PT0gdy56O1xuICAgICAgICB9O1xuICAgICAgICAvKiogRG90IHByb2R1Y3Qgb24gdHdvIHZlY3RvcnMgKi9cbiAgICAgICAgVmVjMy5kb3QgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIHYueCAqIHcueCArIHYueSAqIHcueSArIHYueiAqIHcuejtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIENyb3NzIHByb2R1Y3Qgb24gdHdvIHZlY3RvcnMgKi9cbiAgICAgICAgVmVjMy5jcm9zcyA9IGZ1bmN0aW9uICh2LCB3KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModi55ICogdy56IC0gdi56ICogdy55LCB2LnogKiB3LnggLSB2LnggKiB3LnosIHYueCAqIHcueSAtIHYueSAqIHcueCk7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMuYWRkID0gZnVuY3Rpb24gKHYsIHcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh2LnggKyB3LngsIHYueSArIHcueSwgdi56ICsgdy56KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVjMy5zdWIgPSBmdW5jdGlvbiAodiwgdykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHYueCAtIHcueCwgdi55IC0gdy55LCB2LnogLSB3LnopO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLm11bCA9IGZ1bmN0aW9uICh2LCBtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMobSAqIHYueCwgbSAqIHYueSwgbSAqIHYueik7XG4gICAgICAgIH07XG4gICAgICAgIFZlYzMucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgICAgICAgICAgdGhpcy56ID0gLXRoaXMuejtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBWZWMzLm5lZyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoLXYueCwgLXYueSwgLXYueik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWZWMzO1xuICAgIH0oKSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdjEkMiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdjIkMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqXG4gICAgICogQSBsaW5lIHNlZ21lbnQgKGVkZ2UpIHNoYXBlLiBUaGVzZSBjYW4gYmUgY29ubmVjdGVkIGluIGNoYWlucyBvciBsb29wcyB0b1xuICAgICAqIG90aGVyIGVkZ2Ugc2hhcGVzLiBUaGUgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uIGlzIHVzZWQgdG8gZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb250YWN0IG5vcm1hbHMuXG4gICAgICovXG4gICAgdmFyIEVkZ2VTaGFwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVkZ2VTaGFwZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRWRnZVNoYXBlKHYxLCB2Mikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICghKF90aGlzIGluc3RhbmNlb2YgRWRnZVNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRWRnZVNoYXBlKHYxLCB2Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBFZGdlU2hhcGUuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fcmFkaXVzID0gU2V0dGluZ3NJbnRlcm5hbC5wb2x5Z29uUmFkaXVzO1xuICAgICAgICAgICAgX3RoaXMubV92ZXJ0ZXgxID0gdjEgPyBWZWMyLmNsb25lKHYxKSA6IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV92ZXJ0ZXgyID0gdjIgPyBWZWMyLmNsb25lKHYyKSA6IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV92ZXJ0ZXgwID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX3ZlcnRleDMgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIF90aGlzLm1faGFzVmVydGV4MCA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMubV9oYXNWZXJ0ZXgzID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFZGdlU2hhcGUucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIHZlcnRleDE6IHRoaXMubV92ZXJ0ZXgxLFxuICAgICAgICAgICAgICAgIHZlcnRleDI6IHRoaXMubV92ZXJ0ZXgyLFxuICAgICAgICAgICAgICAgIHZlcnRleDA6IHRoaXMubV92ZXJ0ZXgwLFxuICAgICAgICAgICAgICAgIHZlcnRleDM6IHRoaXMubV92ZXJ0ZXgzLFxuICAgICAgICAgICAgICAgIGhhc1ZlcnRleDA6IHRoaXMubV9oYXNWZXJ0ZXgwLFxuICAgICAgICAgICAgICAgIGhhc1ZlcnRleDM6IHRoaXMubV9oYXNWZXJ0ZXgzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFZGdlU2hhcGUuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBFZGdlU2hhcGUoZGF0YS52ZXJ0ZXgxLCBkYXRhLnZlcnRleDIpO1xuICAgICAgICAgICAgaWYgKHNoYXBlLm1faGFzVmVydGV4MCkge1xuICAgICAgICAgICAgICAgIHNoYXBlLnNldFByZXZWZXJ0ZXgoZGF0YS52ZXJ0ZXgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaGFwZS5tX2hhc1ZlcnRleDMpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5zZXROZXh0VmVydGV4KGRhdGEudmVydGV4Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH07XG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuZ2V0UmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9yYWRpdXM7XG4gICAgICAgIH07XG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBFZGdlU2hhcGUucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dFZlcnRleCh2KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIG5leHQgdmVydGV4LCB1c2VkIGZvciBzbW9vdGggY29sbGlzaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5zZXROZXh0VmVydGV4ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3ZlcnRleDMuc2V0VmVjMih2KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1faGFzVmVydGV4MyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdmVydGV4My5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2hhc1ZlcnRleDMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgbmV4dCB2ZXJ0ZXgsIHVzZWQgZm9yIHNtb290aCBjb2xsaXNpb24uXG4gICAgICAgICAqL1xuICAgICAgICBFZGdlU2hhcGUucHJvdG90eXBlLmdldE5leHRWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3ZlcnRleDM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5zZXRQcmV2ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFByZXZWZXJ0ZXgodik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCBwcmV2IHZlcnRleCwgdXNlZCBmb3Igc21vb3RoIGNvbGxpc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuc2V0UHJldlZlcnRleCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHRoaXMubV92ZXJ0ZXgwLnNldFZlYzIodik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2hhc1ZlcnRleDAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3ZlcnRleDAuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9oYXNWZXJ0ZXgwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIHByZXYgdmVydGV4LCB1c2VkIGZvciBzbW9vdGggY29sbGlzaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5nZXRQcmV2VmVydGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0ZXgwO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgYXMgYW4gaXNvbGF0ZWQgZWRnZS5cbiAgICAgICAgICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0ZXgxLnNldFZlYzIodjEpO1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRleDIuc2V0VmVjMih2Mik7XG4gICAgICAgICAgICB0aGlzLm1faGFzVmVydGV4MCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX2hhc1ZlcnRleDMgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsIEBkZXByZWNhdGVkIFNoYXBlcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBpbW11dGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIGNsb25lIHRoZSBjb25jcmV0ZSBzaGFwZS5cbiAgICAgICAgICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNsb25lID0gbmV3IEVkZ2VTaGFwZSgpO1xuICAgICAgICAgICAgY2xvbmUubV90eXBlID0gdGhpcy5tX3R5cGU7XG4gICAgICAgICAgICBjbG9uZS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG4gICAgICAgICAgICBjbG9uZS5tX3ZlcnRleDEuc2V0VmVjMih0aGlzLm1fdmVydGV4MSk7XG4gICAgICAgICAgICBjbG9uZS5tX3ZlcnRleDIuc2V0VmVjMih0aGlzLm1fdmVydGV4Mik7XG4gICAgICAgICAgICBjbG9uZS5tX3ZlcnRleDAuc2V0VmVjMih0aGlzLm1fdmVydGV4MCk7XG4gICAgICAgICAgICBjbG9uZS5tX3ZlcnRleDMuc2V0VmVjMih0aGlzLm1fdmVydGV4Myk7XG4gICAgICAgICAgICBjbG9uZS5tX2hhc1ZlcnRleDAgPSB0aGlzLm1faGFzVmVydGV4MDtcbiAgICAgICAgICAgIGNsb25lLm1faGFzVmVydGV4MyA9IHRoaXMubV9oYXNWZXJ0ZXgzO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hpbGQgcHJpbWl0aXZlcy5cbiAgICAgICAgICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIHNoYXBlLiBUaGlzIG9ubHkgd29ya3MgZm9yIGNvbnZleFxuICAgICAgICAgKiBzaGFwZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gcCBBIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS50ZXN0UG9pbnQgPSBmdW5jdGlvbiAoeGYsIHApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhc3QgYSByYXkgYWdhaW5zdCBhIGNoaWxkIHNoYXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb3V0cHV0IFRoZSByYXktY2FzdCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIHJheS1jYXN0IGlucHV0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNoYXBlLlxuICAgICAgICAgKiBAcGFyYW0gY2hpbGRJbmRleCBUaGUgY2hpbGQgc2hhcGUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCB4ZiwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgLy8gcCA9IHAxICsgdCAqIGRcbiAgICAgICAgICAgIC8vIHYgPSB2MSArIHMgKiBlXG4gICAgICAgICAgICAvLyBwMSArIHQgKiBkID0gdjEgKyBzICogZVxuICAgICAgICAgICAgLy8gcyAqIGUgLSB0ICogZCA9IHAxIC0gdjFcbiAgICAgICAgICAgIC8vIE5PVF9VU0VEKGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgLy8gUHV0IHRoZSByYXkgaW50byB0aGUgZWRnZSdzIGZyYW1lIG9mIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIHZhciBwMSA9IFJvdC5tdWxUVmVjMih4Zi5xLCBWZWMyLnN1YihpbnB1dC5wMSwgeGYucCkpO1xuICAgICAgICAgICAgdmFyIHAyID0gUm90Lm11bFRWZWMyKHhmLnEsIFZlYzIuc3ViKGlucHV0LnAyLCB4Zi5wKSk7XG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHAyLCBwMSk7XG4gICAgICAgICAgICB2YXIgdjEgPSB0aGlzLm1fdmVydGV4MTtcbiAgICAgICAgICAgIHZhciB2MiA9IHRoaXMubV92ZXJ0ZXgyO1xuICAgICAgICAgICAgdmFyIGUgPSBWZWMyLnN1Yih2MiwgdjEpO1xuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IFZlYzIubmVvKGUueSwgLWUueCk7XG4gICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAvLyBxID0gcDEgKyB0ICogZFxuICAgICAgICAgICAgLy8gZG90KG5vcm1hbCwgcSAtIHYxKSA9IDBcbiAgICAgICAgICAgIC8vIGRvdChub3JtYWwsIHAxIC0gdjEpICsgdCAqIGRvdChub3JtYWwsIGQpID0gMFxuICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IFZlYzIuZG90KG5vcm1hbCwgVmVjMi5zdWIodjEsIHAxKSk7XG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBWZWMyLmRvdChub3JtYWwsIGQpO1xuICAgICAgICAgICAgaWYgKGRlbm9taW5hdG9yID09IDAuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICBpZiAodCA8IDAuMCB8fCBpbnB1dC5tYXhGcmFjdGlvbiA8IHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcSA9IFZlYzIuYWRkKHAxLCBWZWMyLm11bE51bVZlYzIodCwgZCkpO1xuICAgICAgICAgICAgLy8gcSA9IHYxICsgcyAqIHJcbiAgICAgICAgICAgIC8vIHMgPSBkb3QocSAtIHYxLCByKSAvIGRvdChyLCByKVxuICAgICAgICAgICAgdmFyIHIgPSBWZWMyLnN1Yih2MiwgdjEpO1xuICAgICAgICAgICAgdmFyIHJyID0gVmVjMi5kb3Qociwgcik7XG4gICAgICAgICAgICBpZiAocnIgPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHMgPSBWZWMyLmRvdChWZWMyLnN1YihxLCB2MSksIHIpIC8gcnI7XG4gICAgICAgICAgICBpZiAocyA8IDAuMCB8fCAxLjAgPCBzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LmZyYWN0aW9uID0gdDtcbiAgICAgICAgICAgIGlmIChudW1lcmF0b3IgPiAwLjApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQubm9ybWFsID0gUm90Lm11bFZlYzIoeGYucSwgbm9ybWFsKS5uZWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5ub3JtYWwgPSBSb3QubXVsVmVjMih4Zi5xLCBub3JtYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHRyYW5zZm9ybSwgY29tcHV0ZSB0aGUgYXNzb2NpYXRlZCBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhXG4gICAgICAgICAqIGNoaWxkIHNoYXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWFiYiBSZXR1cm5zIHRoZSBheGlzIGFsaWduZWQgYm94LlxuICAgICAgICAgKiBAcGFyYW0geGYgVGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZEluZGV4IFRoZSBjaGlsZCBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uIChhYWJiLCB4ZiwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtVmVjMih2MSQyLCB4ZiwgdGhpcy5tX3ZlcnRleDEpO1xuICAgICAgICAgICAgdHJhbnNmb3JtVmVjMih2MiQxLCB4ZiwgdGhpcy5tX3ZlcnRleDIpO1xuICAgICAgICAgICAgQUFCQi5jb21iaW5lUG9pbnRzKGFhYmIsIHYxJDIsIHYyJDEpO1xuICAgICAgICAgICAgQUFCQi5leHRlbmQoYWFiYiwgdGhpcy5tX3JhZGl1cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhpcyBzaGFwZSB1c2luZyBpdHMgZGltZW5zaW9ucyBhbmQgZGVuc2l0eS5cbiAgICAgICAgICogVGhlIGluZXJ0aWEgdGVuc29yIGlzIGNvbXB1dGVkIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtYXNzRGF0YSBSZXR1cm5zIHRoZSBtYXNzIGRhdGEgZm9yIHRoaXMgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBkZW5zaXR5IFRoZSBkZW5zaXR5IGluIGtpbG9ncmFtcyBwZXIgbWV0ZXIgc3F1YXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIEVkZ2VTaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbiAobWFzc0RhdGEsIGRlbnNpdHkpIHtcbiAgICAgICAgICAgIG1hc3NEYXRhLm1hc3MgPSAwLjA7XG4gICAgICAgICAgICBjb21iaW5lVmVjMihtYXNzRGF0YS5jZW50ZXIsIDAuNSwgdGhpcy5tX3ZlcnRleDEsIDAuNSwgdGhpcy5tX3ZlcnRleDIpO1xuICAgICAgICAgICAgbWFzc0RhdGEuSSA9IDAuMDtcbiAgICAgICAgfTtcbiAgICAgICAgRWRnZVNoYXBlLnByb3RvdHlwZS5jb21wdXRlRGlzdGFuY2VQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgICAgICAgICAgcHJveHkubV92ZXJ0aWNlc1swXSA9IHRoaXMubV92ZXJ0ZXgxO1xuICAgICAgICAgICAgcHJveHkubV92ZXJ0aWNlc1sxXSA9IHRoaXMubV92ZXJ0ZXgyO1xuICAgICAgICAgICAgcHJveHkubV92ZXJ0aWNlcy5sZW5ndGggPSAyO1xuICAgICAgICAgICAgcHJveHkubV9jb3VudCA9IDI7XG4gICAgICAgICAgICBwcm94eS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG4gICAgICAgIH07XG4gICAgICAgIEVkZ2VTaGFwZS5UWVBFID0gJ2VkZ2UnO1xuICAgICAgICByZXR1cm4gRWRnZVNoYXBlO1xuICAgIH0oU2hhcGUpKTtcbiAgICB2YXIgRWRnZSA9IEVkZ2VTaGFwZTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciB2MSQxID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciB2MiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqXG4gICAgICogQSBjaGFpbiBzaGFwZSBpcyBhIGZyZWUgZm9ybSBzZXF1ZW5jZSBvZiBsaW5lIHNlZ21lbnRzLiBUaGUgY2hhaW4gaGFzXG4gICAgICogdHdvLXNpZGVkIGNvbGxpc2lvbiwgc28geW91IGNhbiB1c2UgaW5zaWRlIGFuZCBvdXRzaWRlIGNvbGxpc2lvbi4gVGhlcmVmb3JlLFxuICAgICAqIHlvdSBtYXkgdXNlIGFueSB3aW5kaW5nIG9yZGVyLiBDb25uZWN0aXZpdHkgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBjcmVhdGVcbiAgICAgKiBzbW9vdGggY29sbGlzaW9ucy5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IFRoZSBjaGFpbiB3aWxsIG5vdCBjb2xsaWRlIHByb3Blcmx5IGlmIHRoZXJlIGFyZSBzZWxmLWludGVyc2VjdGlvbnMuXG4gICAgICovXG4gICAgdmFyIENoYWluU2hhcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhDaGFpblNoYXBlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDaGFpblNoYXBlKHZlcnRpY2VzLCBsb29wKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBDaGFpblNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5TaGFwZSh2ZXJ0aWNlcywgbG9vcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBDaGFpblNoYXBlLlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX3JhZGl1cyA9IFNldHRpbmdzSW50ZXJuYWwucG9seWdvblJhZGl1cztcbiAgICAgICAgICAgIF90aGlzLm1fdmVydGljZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLm1fY291bnQgPSAwO1xuICAgICAgICAgICAgX3RoaXMubV9wcmV2VmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLm1fbmV4dFZlcnRleCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5tX2hhc1ByZXZWZXJ0ZXggPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLm1faGFzTmV4dFZlcnRleCA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMubV9pc0xvb3AgPSAhIWxvb3A7XG4gICAgICAgICAgICBpZiAodmVydGljZXMgJiYgdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZUxvb3AodmVydGljZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZUNoYWluKHZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgdmVydGljZXM6IHRoaXMubV92ZXJ0aWNlcyxcbiAgICAgICAgICAgICAgICBpc0xvb3A6IHRoaXMubV9pc0xvb3AsXG4gICAgICAgICAgICAgICAgaGFzUHJldlZlcnRleDogdGhpcy5tX2hhc1ByZXZWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgaGFzTmV4dFZlcnRleDogdGhpcy5tX2hhc05leHRWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgcHJldlZlcnRleDogbnVsbCxcbiAgICAgICAgICAgICAgICBuZXh0VmVydGV4OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fcHJldlZlcnRleCkge1xuICAgICAgICAgICAgICAgIGRhdGEucHJldlZlcnRleCA9IHRoaXMubV9wcmV2VmVydGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV9uZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5uZXh0VmVydGV4ID0gdGhpcy5tX25leHRWZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaGFpblNoYXBlLl9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCBmaXh0dXJlLCByZXN0b3JlKSB7XG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChkYXRhLnZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gocmVzdG9yZShWZWMyLCBkYXRhLnZlcnRpY2VzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IENoYWluU2hhcGUodmVydGljZXMsIGRhdGEuaXNMb29wKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnByZXZWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5zZXRQcmV2VmVydGV4KGRhdGEucHJldlZlcnRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5uZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuc2V0TmV4dFZlcnRleChkYXRhLm5leHRWZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjbGVhcigpIHtcbiAgICAgICAgLy8gICB0aGlzLm1fdmVydGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gICB0aGlzLm1fY291bnQgPSAwO1xuICAgICAgICAvLyB9XG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fcmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIENyZWF0ZSBhIGxvb3AuIFRoaXMgYXV0b21hdGljYWxseSBhZGp1c3RzIGNvbm5lY3Rpdml0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZlcnRpY2VzIGFuIGFycmF5IG9mIHZlcnRpY2VzLCB0aGVzZSBhcmUgY29waWVkXG4gICAgICAgICAqIEBwYXJhbSBjb3VudCB0aGUgdmVydGV4IGNvdW50XG4gICAgICAgICAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5fY3JlYXRlTG9vcCA9IGZ1bmN0aW9uICh2ZXJ0aWNlcykge1xuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzID0gW107XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGggKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1tpXSA9IFZlYzIuY2xvbmUodmVydGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW3ZlcnRpY2VzLmxlbmd0aF0gPSBWZWMyLmNsb25lKHZlcnRpY2VzWzBdKTtcbiAgICAgICAgICAgIHRoaXMubV9wcmV2VmVydGV4ID0gdGhpcy5tX3ZlcnRpY2VzW3RoaXMubV9jb3VudCAtIDJdO1xuICAgICAgICAgICAgdGhpcy5tX25leHRWZXJ0ZXggPSB0aGlzLm1fdmVydGljZXNbMV07XG4gICAgICAgICAgICB0aGlzLm1faGFzUHJldlZlcnRleCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1faGFzTmV4dFZlcnRleCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBDcmVhdGUgYSBjaGFpbiB3aXRoIGlzb2xhdGVkIGVuZCB2ZXJ0aWNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZlcnRpY2VzIGFuIGFycmF5IG9mIHZlcnRpY2VzLCB0aGVzZSBhcmUgY29waWVkXG4gICAgICAgICAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5fY3JlYXRlQ2hhaW4gPSBmdW5jdGlvbiAodmVydGljZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29kZSBjcmFzaGVzIGhlcmUsIGl0IG1lYW5zIHlvdXIgdmVydGljZXMgYXJlIHRvbyBjbG9zZSB0b2dldGhlci5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgdmVydGljZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW2ldID0gVmVjMi5jbG9uZSh2ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1faGFzUHJldlZlcnRleCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tX2hhc05leHRWZXJ0ZXggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubV9wcmV2VmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubV9uZXh0VmVydGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1faXNMb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTG9vcCh0aGlzLm1fdmVydGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ2hhaW4odGhpcy5tX3ZlcnRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVzdGFibGlzaCBjb25uZWN0aXZpdHkgdG8gYSB2ZXJ0ZXggdGhhdCBwcmVjZWRlcyB0aGUgZmlyc3QgdmVydGV4LiBEb24ndCBjYWxsXG4gICAgICAgICAqIHRoaXMgZm9yIGxvb3BzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuc2V0UHJldlZlcnRleCA9IGZ1bmN0aW9uIChwcmV2VmVydGV4KSB7XG4gICAgICAgICAgICB0aGlzLm1fcHJldlZlcnRleCA9IHByZXZWZXJ0ZXg7XG4gICAgICAgICAgICB0aGlzLm1faGFzUHJldlZlcnRleCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmdldFByZXZWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3ByZXZWZXJ0ZXg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFc3RhYmxpc2ggY29ubmVjdGl2aXR5IHRvIGEgdmVydGV4IHRoYXQgZm9sbG93cyB0aGUgbGFzdCB2ZXJ0ZXguIERvbid0IGNhbGxcbiAgICAgICAgICogdGhpcyBmb3IgbG9vcHMuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5zZXROZXh0VmVydGV4ID0gZnVuY3Rpb24gKG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIHRoaXMubV9uZXh0VmVydGV4ID0gbmV4dFZlcnRleDtcbiAgICAgICAgICAgIHRoaXMubV9oYXNOZXh0VmVydGV4ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuZ2V0TmV4dFZlcnRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbmV4dFZlcnRleDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbCBAZGVwcmVjYXRlZCBTaGFwZXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgaW1tdXRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBjbG9uZSB0aGUgY29uY3JldGUgc2hhcGUuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBuZXcgQ2hhaW5TaGFwZSgpO1xuICAgICAgICAgICAgY2xvbmUuX2NyZWF0ZUNoYWluKHRoaXMubV92ZXJ0aWNlcyk7XG4gICAgICAgICAgICBjbG9uZS5tX3R5cGUgPSB0aGlzLm1fdHlwZTtcbiAgICAgICAgICAgIGNsb25lLm1fcmFkaXVzID0gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgICAgIGNsb25lLm1fcHJldlZlcnRleCA9IHRoaXMubV9wcmV2VmVydGV4O1xuICAgICAgICAgICAgY2xvbmUubV9uZXh0VmVydGV4ID0gdGhpcy5tX25leHRWZXJ0ZXg7XG4gICAgICAgICAgICBjbG9uZS5tX2hhc1ByZXZWZXJ0ZXggPSB0aGlzLm1faGFzUHJldlZlcnRleDtcbiAgICAgICAgICAgIGNsb25lLm1faGFzTmV4dFZlcnRleCA9IHRoaXMubV9oYXNOZXh0VmVydGV4O1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hpbGQgcHJpbWl0aXZlcy5cbiAgICAgICAgICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBlZGdlIGNvdW50ID0gdmVydGV4IGNvdW50IC0gMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9jb3VudCAtIDE7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdldCBhIGNoaWxkIGVkZ2UuXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmdldENoaWxkRWRnZSA9IGZ1bmN0aW9uIChlZGdlLCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICBlZGdlLm1fdHlwZSA9IEVkZ2VTaGFwZS5UWVBFO1xuICAgICAgICAgICAgZWRnZS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG4gICAgICAgICAgICBlZGdlLm1fdmVydGV4MSA9IHRoaXMubV92ZXJ0aWNlc1tjaGlsZEluZGV4XTtcbiAgICAgICAgICAgIGVkZ2UubV92ZXJ0ZXgyID0gdGhpcy5tX3ZlcnRpY2VzW2NoaWxkSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGVkZ2UubV92ZXJ0ZXgwID0gdGhpcy5tX3ZlcnRpY2VzW2NoaWxkSW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGdlLm1faGFzVmVydGV4MCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGdlLm1fdmVydGV4MCA9IHRoaXMubV9wcmV2VmVydGV4O1xuICAgICAgICAgICAgICAgIGVkZ2UubV9oYXNWZXJ0ZXgwID0gdGhpcy5tX2hhc1ByZXZWZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRJbmRleCA8IHRoaXMubV9jb3VudCAtIDIpIHtcbiAgICAgICAgICAgICAgICBlZGdlLm1fdmVydGV4MyA9IHRoaXMubV92ZXJ0aWNlc1tjaGlsZEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgZWRnZS5tX2hhc1ZlcnRleDMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRnZS5tX3ZlcnRleDMgPSB0aGlzLm1fbmV4dFZlcnRleDtcbiAgICAgICAgICAgICAgICBlZGdlLm1faGFzVmVydGV4MyA9IHRoaXMubV9oYXNOZXh0VmVydGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDaGFpblNoYXBlLnByb3RvdHlwZS5nZXRWZXJ0ZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubV9jb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuaXNMb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9pc0xvb3A7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IGEgcG9pbnQgZm9yIGNvbnRhaW5tZW50IGluIHRoaXMgc2hhcGUuIFRoaXMgb25seSB3b3JrcyBmb3IgY29udmV4XG4gICAgICAgICAqIHNoYXBlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geGYgVGhlIHNoYXBlIHdvcmxkIHRyYW5zZm9ybS5cbiAgICAgICAgICogQHBhcmFtIHAgQSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLnRlc3RQb2ludCA9IGZ1bmN0aW9uICh4ZiwgcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FzdCBhIHJheSBhZ2FpbnN0IGEgY2hpbGQgc2hhcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvdXRwdXQgVGhlIHJheS1jYXN0IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgcmF5LWNhc3QgaW5wdXQgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHhmIFRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZEluZGV4IFRoZSBjaGlsZCBzaGFwZSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCB4ZiwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgdmFyIGVkZ2VTaGFwZSA9IG5ldyBFZGdlU2hhcGUodGhpcy5nZXRWZXJ0ZXgoY2hpbGRJbmRleCksIHRoaXMuZ2V0VmVydGV4KGNoaWxkSW5kZXggKyAxKSk7XG4gICAgICAgICAgICByZXR1cm4gZWRnZVNoYXBlLnJheUNhc3Qob3V0cHV0LCBpbnB1dCwgeGYsIDApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSB0cmFuc2Zvcm0sIGNvbXB1dGUgdGhlIGFzc29jaWF0ZWQgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYVxuICAgICAgICAgKiBjaGlsZCBzaGFwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFhYmIgUmV0dXJucyB0aGUgYXhpcyBhbGlnbmVkIGJveC5cbiAgICAgICAgICogQHBhcmFtIHhmIFRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHNoYXBlLlxuICAgICAgICAgKiBAcGFyYW0gY2hpbGRJbmRleCBUaGUgY2hpbGQgc2hhcGVcbiAgICAgICAgICovXG4gICAgICAgIENoYWluU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHhmLCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHYxJDEsIHhmLCB0aGlzLmdldFZlcnRleChjaGlsZEluZGV4KSk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHYyLCB4ZiwgdGhpcy5nZXRWZXJ0ZXgoY2hpbGRJbmRleCArIDEpKTtcbiAgICAgICAgICAgIEFBQkIuY29tYmluZVBvaW50cyhhYWJiLCB2MSQxLCB2Mik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhpcyBzaGFwZSB1c2luZyBpdHMgZGltZW5zaW9ucyBhbmQgZGVuc2l0eS5cbiAgICAgICAgICogVGhlIGluZXJ0aWEgdGVuc29yIGlzIGNvbXB1dGVkIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIENoYWlucyBoYXZlIHplcm8gbWFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1hc3NEYXRhIFJldHVybnMgdGhlIG1hc3MgZGF0YSBmb3IgdGhpcyBzaGFwZS5cbiAgICAgICAgICogQHBhcmFtIGRlbnNpdHkgVGhlIGRlbnNpdHkgaW4ga2lsb2dyYW1zIHBlciBtZXRlciBzcXVhcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbiAobWFzc0RhdGEsIGRlbnNpdHkpIHtcbiAgICAgICAgICAgIG1hc3NEYXRhLm1hc3MgPSAwLjA7XG4gICAgICAgICAgICB6ZXJvVmVjMihtYXNzRGF0YS5jZW50ZXIpO1xuICAgICAgICAgICAgbWFzc0RhdGEuSSA9IDAuMDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhaW5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZURpc3RhbmNlUHJveHkgPSBmdW5jdGlvbiAocHJveHksIGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIHByb3h5Lm1fdmVydGljZXNbMF0gPSB0aGlzLmdldFZlcnRleChjaGlsZEluZGV4KTtcbiAgICAgICAgICAgIHByb3h5Lm1fdmVydGljZXNbMV0gPSB0aGlzLmdldFZlcnRleChjaGlsZEluZGV4ICsgMSk7XG4gICAgICAgICAgICBwcm94eS5tX2NvdW50ID0gMjtcbiAgICAgICAgICAgIHByb3h5Lm1fcmFkaXVzID0gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhaW5TaGFwZS5UWVBFID0gJ2NoYWluJztcbiAgICAgICAgcmV0dXJuIENoYWluU2hhcGU7XG4gICAgfShTaGFwZSkpO1xuICAgIHZhciBDaGFpbiA9IENoYWluU2hhcGU7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9tYXgkMSA9IE1hdGgubWF4O1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfbWluJDMgPSBNYXRoLm1pbjtcbiAgICAvKiogQGludGVybmFsICovIHZhciB0ZW1wJDEgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGUkMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZTEkMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZTIkMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY2VudGVyID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBzID0gdmVjMigwLCAwKTtcbiAgICAvKipcbiAgICAgKiBBIGNvbnZleCBwb2x5Z29uLiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIGludGVyaW9yIG9mIHRoZSBwb2x5Z29uIGlzIHRvIHRoZVxuICAgICAqIGxlZnQgb2YgZWFjaCBlZGdlLiBQb2x5Z29ucyBoYXZlIGEgbWF4aW11bSBudW1iZXIgb2YgdmVydGljZXMgZXF1YWwgdG9cbiAgICAgKiBTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXMuIEluIG1vc3QgY2FzZXMgeW91IHNob3VsZCBub3QgbmVlZCBtYW55IHZlcnRpY2VzXG4gICAgICogZm9yIGEgY29udmV4IHBvbHlnb24uIGV4dGVuZHMgU2hhcGVcbiAgICAgKi9cbiAgICB2YXIgUG9seWdvblNoYXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUG9seWdvblNoYXBlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBQb2x5Z29uU2hhcGUodmVydGljZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoIShfdGhpcyBpbnN0YW5jZW9mIFBvbHlnb25TaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25TaGFwZSh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBQb2x5Z29uU2hhcGUuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fcmFkaXVzID0gU2V0dGluZ3NJbnRlcm5hbC5wb2x5Z29uUmFkaXVzO1xuICAgICAgICAgICAgX3RoaXMubV9jZW50cm9pZCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV92ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMubV9ub3JtYWxzID0gW107XG4gICAgICAgICAgICBfdGhpcy5tX2NvdW50ID0gMDtcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcyAmJiB2ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0KHZlcnRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgdmVydGljZXM6IHRoaXMubV92ZXJ0aWNlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLl9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCBmaXh0dXJlLCByZXN0b3JlKSB7XG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChkYXRhLnZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gocmVzdG9yZShWZWMyLCBkYXRhLnZlcnRpY2VzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IFBvbHlnb25TaGFwZSh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH07XG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3JhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbCBAZGVwcmVjYXRlZCBTaGFwZXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgaW1tdXRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBjbG9uZSB0aGUgY29uY3JldGUgc2hhcGUuXG4gICAgICAgICAqL1xuICAgICAgICBQb2x5Z29uU2hhcGUucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IG5ldyBQb2x5Z29uU2hhcGUoKTtcbiAgICAgICAgICAgIGNsb25lLm1fdHlwZSA9IHRoaXMubV90eXBlO1xuICAgICAgICAgICAgY2xvbmUubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xuICAgICAgICAgICAgY2xvbmUubV9jb3VudCA9IHRoaXMubV9jb3VudDtcbiAgICAgICAgICAgIGNsb25lLm1fY2VudHJvaWQuc2V0VmVjMih0aGlzLm1fY2VudHJvaWQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNsb25lLm1fdmVydGljZXMucHVzaCh0aGlzLm1fdmVydGljZXNbaV0uY2xvbmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9ub3JtYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUubV9ub3JtYWxzLnB1c2godGhpcy5tX25vcm1hbHNbaV0uY2xvbmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBjaGlsZCBwcmltaXRpdmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS5nZXRDaGlsZENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gUG9seWdvblNoYXBlLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXQodGhpcy5tX3ZlcnRpY2VzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBDcmVhdGUgYSBjb252ZXggaHVsbCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBsb2NhbCBwb2ludHMuIFRoZSBjb3VudCBtdXN0IGJlXG4gICAgICAgICAqIGluIHRoZSByYW5nZSBbMywgU2V0dGluZ3MubWF4UG9seWdvblZlcnRpY2VzXS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2FybmluZzogdGhlIHBvaW50cyBtYXkgYmUgcmUtb3JkZXJlZCwgZXZlbiBpZiB0aGV5IGZvcm0gYSBjb252ZXggcG9seWdvblxuICAgICAgICAgKiBXYXJuaW5nOiBjb2xsaW5lYXIgcG9pbnRzIGFyZSBoYW5kbGVkIGJ1dCBub3QgcmVtb3ZlZC4gQ29sbGluZWFyIHBvaW50cyBtYXlcbiAgICAgICAgICogbGVhZCB0byBwb29yIHN0YWNraW5nIGJlaGF2aW9yLlxuICAgICAgICAgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHZlcnRpY2VzKSB7XG4gICAgICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFzQm94KDEuMCwgMS4wKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbiA9IG1hdGhfbWluJDModmVydGljZXMubGVuZ3RoLCBTZXR0aW5nc0ludGVybmFsLm1heFBvbHlnb25WZXJ0aWNlcyk7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIHdlbGRpbmcgYW5kIGNvcHkgdmVydGljZXMgaW50byBsb2NhbCBidWZmZXIuXG4gICAgICAgICAgICB2YXIgcHMgPSBbXTsgLy8gW1NldHRpbmdzLm1heFBvbHlnb25WZXJ0aWNlc107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHVuaXF1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVmVjMi5kaXN0YW5jZVNxdWFyZWQodiwgcHNbal0pIDwgMC4yNSAqIFNldHRpbmdzSW50ZXJuYWwubGluZWFyU2xvcFNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVuaXF1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcy5wdXNoKFZlYzIuY2xvbmUodikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBwcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA8IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBc0JveCgxLjAsIDEuMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBjb252ZXggaHVsbCB1c2luZyB0aGUgR2lmdCB3cmFwcGluZyBhbGdvcml0aG1cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2lmdF93cmFwcGluZ19hbGdvcml0aG1cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJpZ2h0IG1vc3QgcG9pbnQgb24gdGhlIGh1bGwgKGluIGNhc2Ugb2YgbXVsdGlwbGUgcG9pbnRzIGJvdHRvbSBtb3N0IGlzIHVzZWQpXG4gICAgICAgICAgICB2YXIgaTAgPSAwO1xuICAgICAgICAgICAgdmFyIHgwID0gcHNbMF0ueDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBwc1tpXS54O1xuICAgICAgICAgICAgICAgIGlmICh4ID4geDAgfHwgKHggPT09IHgwICYmIHBzW2ldLnkgPCBwc1tpMF0ueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaTAgPSBpO1xuICAgICAgICAgICAgICAgICAgICB4MCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGh1bGwgPSBbXTsgLy8gW1NldHRpbmdzLm1heFBvbHlnb25WZXJ0aWNlc107XG4gICAgICAgICAgICB2YXIgbSA9IDA7XG4gICAgICAgICAgICB2YXIgaWggPSBpMDtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaHVsbFttXSA9IGloO1xuICAgICAgICAgICAgICAgIHZhciBpZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGllID09PSBpaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWUgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBWZWMyLnN1Yihwc1tpZV0sIHBzW2h1bGxbbV1dKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBWZWMyLnN1Yihwc1tqXSwgcHNbaHVsbFttXV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYyA8IDAgbWVhbnMgY291bnRlci1jbG9ja3dpc2Ugd3JhcHBpbmcsIGMgPiAwIG1lYW5zIGNsb2Nrd2lzZSB3cmFwcGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWUgPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbGxpbmVhcml0eSBjaGVja1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gMC4wICYmIHYubGVuZ3RoU3F1YXJlZCgpID4gci5sZW5ndGhTcXVhcmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGllID0gajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK207XG4gICAgICAgICAgICAgICAgaWggPSBpZTtcbiAgICAgICAgICAgICAgICBpZiAoaWUgPT09IGkwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtIDwgMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFzQm94KDEuMCwgMS4wKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSBtO1xuICAgICAgICAgICAgLy8gQ29weSB2ZXJ0aWNlcy5cbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0gPSBwc1todWxsW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgbm9ybWFscy4gRW5zdXJlIHRoZSBlZGdlcyBoYXZlIG5vbi16ZXJvIGxlbmd0aC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkxID0gaTtcbiAgICAgICAgICAgICAgICB2YXIgaTIgPSBpICsgMSA8IG0gPyBpICsgMSA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbaTJdLCB0aGlzLm1fdmVydGljZXNbaTFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsc1tpXSA9IFZlYzIuY3Jvc3NWZWMyTnVtKGVkZ2UsIDEuMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0ubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBwb2x5Z29uIGNlbnRyb2lkLlxuICAgICAgICAgICAgdGhpcy5tX2NlbnRyb2lkID0gY29tcHV0ZUNlbnRyb2lkKHRoaXMubV92ZXJ0aWNlcywgbSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi8gUG9seWdvblNoYXBlLnByb3RvdHlwZS5fc2V0QXNCb3ggPSBmdW5jdGlvbiAoaHgsIGh5LCBjZW50ZXIsIGFuZ2xlKSB7XG4gICAgICAgICAgICAvLyBzdGFydCB3aXRoIHJpZ2h0LWJvdHRvbSwgY291bnRlci1jbG9ja3dpc2UsIGFzIGluIEdpZnQgd3JhcHBpbmcgYWxnb3JpdGhtIGluIFBvbHlnb25TaGFwZS5fc2V0KClcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1swXSA9IFZlYzIubmVvKGh4LCAtaHkpO1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzWzFdID0gVmVjMi5uZW8oaHgsIGh5KTtcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1syXSA9IFZlYzIubmVvKC1oeCwgaHkpO1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzWzNdID0gVmVjMi5uZW8oLWh4LCAtaHkpO1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbHNbMF0gPSBWZWMyLm5lbygxLjAsIDAuMCk7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsc1sxXSA9IFZlYzIubmVvKDAuMCwgMS4wKTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWxzWzJdID0gVmVjMi5uZW8oLTEuMCwgMC4wKTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWxzWzNdID0gVmVjMi5uZW8oMC4wLCAtMS4wKTtcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDQ7XG4gICAgICAgICAgICBpZiAoY2VudGVyICYmIFZlYzIuaXNWYWxpZChjZW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKHRoaXMubV9jZW50cm9pZCwgY2VudGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgeGYgPSBUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgICAgICAgICB4Zi5wLnNldFZlYzIoY2VudGVyKTtcbiAgICAgICAgICAgICAgICB4Zi5xLnNldEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgYW5kIG5vcm1hbHMuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0gPSBUcmFuc2Zvcm0ubXVsVmVjMih4ZiwgdGhpcy5tX3ZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0gPSBSb3QubXVsVmVjMih4Zi5xLCB0aGlzLm1fbm9ybWFsc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIHNoYXBlLiBUaGlzIG9ubHkgd29ya3MgZm9yIGNvbnZleFxuICAgICAgICAgKiBzaGFwZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gcCBBIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS50ZXN0UG9pbnQgPSBmdW5jdGlvbiAoeGYsIHApIHtcbiAgICAgICAgICAgIHZhciBwTG9jYWwgPSBpbnZUcmFuc2Zvcm1WZWMyKHRlbXAkMSwgeGYsIHApO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBkb3QgPSBkb3RWZWMyKHRoaXMubV9ub3JtYWxzW2ldLCBwTG9jYWwpIC0gZG90VmVjMih0aGlzLm1fbm9ybWFsc1tpXSwgdGhpcy5tX3ZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhc3QgYSByYXkgYWdhaW5zdCBhIGNoaWxkIHNoYXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb3V0cHV0IFRoZSByYXktY2FzdCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIHJheS1jYXN0IGlucHV0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNoYXBlLlxuICAgICAgICAgKiBAcGFyYW0gY2hpbGRJbmRleCBUaGUgY2hpbGQgc2hhcGUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCB4ZiwgY2hpbGRJbmRleCkge1xuICAgICAgICAgICAgLy8gUHV0IHRoZSByYXkgaW50byB0aGUgcG9seWdvbidzIGZyYW1lIG9mIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIHZhciBwMSA9IFJvdC5tdWxUVmVjMih4Zi5xLCBWZWMyLnN1YihpbnB1dC5wMSwgeGYucCkpO1xuICAgICAgICAgICAgdmFyIHAyID0gUm90Lm11bFRWZWMyKHhmLnEsIFZlYzIuc3ViKGlucHV0LnAyLCB4Zi5wKSk7XG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuc3ViKHAyLCBwMSk7XG4gICAgICAgICAgICB2YXIgbG93ZXIgPSAwLjA7XG4gICAgICAgICAgICB2YXIgdXBwZXIgPSBpbnB1dC5tYXhGcmFjdGlvbjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIHAgPSBwMSArIGEgKiBkXG4gICAgICAgICAgICAgICAgLy8gZG90KG5vcm1hbCwgcCAtIHYpID0gMFxuICAgICAgICAgICAgICAgIC8vIGRvdChub3JtYWwsIHAxIC0gdikgKyBhICogZG90KG5vcm1hbCwgZCkgPSAwXG4gICAgICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IFZlYzIuZG90KHRoaXMubV9ub3JtYWxzW2ldLCBWZWMyLnN1Yih0aGlzLm1fdmVydGljZXNbaV0sIHAxKSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gVmVjMi5kb3QodGhpcy5tX25vcm1hbHNbaV0sIGQpO1xuICAgICAgICAgICAgICAgIGlmIChkZW5vbWluYXRvciA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyYXRvciA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSB3YW50IHRoaXMgcHJlZGljYXRlIHdpdGhvdXQgZGl2aXNpb246XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvd2VyIDwgbnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIHdoZXJlIGRlbm9taW5hdG9yIDwgMFxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBkZW5vbWluYXRvciA8IDAsIHdlIGhhdmUgdG8gZmxpcCB0aGUgaW5lcXVhbGl0eTpcbiAgICAgICAgICAgICAgICAgICAgLy8gbG93ZXIgPCBudW1lcmF0b3IgLyBkZW5vbWluYXRvciA8PT0+IGRlbm9taW5hdG9yICogbG93ZXIgPiBudW1lcmF0b3IuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZW5vbWluYXRvciA8IDAuMCAmJiBudW1lcmF0b3IgPCBsb3dlciAqIGRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZWFzZSBsb3dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZWdtZW50IGVudGVycyB0aGlzIGhhbGYtc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlbm9taW5hdG9yID4gMC4wICYmIG51bWVyYXRvciA8IHVwcGVyICogZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY3JlYXNlIHVwcGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgZXhpdHMgdGhpcyBoYWxmLXNwYWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXIgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlIG9mIGVwc2lsb24gaGVyZSBjYXVzZXMgdGhlIGFzc2VydCBvbiBsb3dlciB0byB0cmlwXG4gICAgICAgICAgICAgICAgLy8gaW4gc29tZSBjYXNlcy4gQXBwYXJlbnRseSB0aGUgdXNlIG9mIGVwc2lsb24gd2FzIHRvIG1ha2UgZWRnZVxuICAgICAgICAgICAgICAgIC8vIHNoYXBlcyB3b3JrLCBidXQgbm93IHRob3NlIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICAgICAgLy8gaWYgKHVwcGVyIDwgbG93ZXIgLSBtYXRyaXguRVBTSUxPTilcbiAgICAgICAgICAgICAgICBpZiAodXBwZXIgPCBsb3dlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZnJhY3Rpb24gPSBsb3dlcjtcbiAgICAgICAgICAgICAgICBvdXRwdXQubm9ybWFsID0gUm90Lm11bFZlYzIoeGYucSwgdGhpcy5tX25vcm1hbHNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBhc3NvY2lhdGVkIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGFcbiAgICAgICAgICogY2hpbGQgc2hhcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhYWJiIFJldHVybnMgdGhlIGF4aXMgYWxpZ25lZCBib3guXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZS5cbiAgICAgICAgICogQHBhcmFtIGNoaWxkSW5kZXggVGhlIGNoaWxkIHNoYXBlXG4gICAgICAgICAqL1xuICAgICAgICBQb2x5Z29uU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHhmLCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0cmFuc2Zvcm1WZWMyKHRlbXAkMSwgeGYsIHRoaXMubV92ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICAgICAgbWluWCA9IG1hdGhfbWluJDMobWluWCwgdi54KTtcbiAgICAgICAgICAgICAgICBtYXhYID0gbWF0aF9tYXgkMShtYXhYLCB2LngpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBtYXRoX21pbiQzKG1pblksIHYueSk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IG1hdGhfbWF4JDEobWF4WSwgdi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFZlYzIoYWFiYi5sb3dlckJvdW5kLCBtaW5YIC0gdGhpcy5tX3JhZGl1cywgbWluWSAtIHRoaXMubV9yYWRpdXMpO1xuICAgICAgICAgICAgc2V0VmVjMihhYWJiLnVwcGVyQm91bmQsIG1heFggKyB0aGlzLm1fcmFkaXVzLCBtYXhZICsgdGhpcy5tX3JhZGl1cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhpcyBzaGFwZSB1c2luZyBpdHMgZGltZW5zaW9ucyBhbmQgZGVuc2l0eS5cbiAgICAgICAgICogVGhlIGluZXJ0aWEgdGVuc29yIGlzIGNvbXB1dGVkIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtYXNzRGF0YSBSZXR1cm5zIHRoZSBtYXNzIGRhdGEgZm9yIHRoaXMgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBkZW5zaXR5IFRoZSBkZW5zaXR5IGluIGtpbG9ncmFtcyBwZXIgbWV0ZXIgc3F1YXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIFBvbHlnb25TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1hc3MgPSBmdW5jdGlvbiAobWFzc0RhdGEsIGRlbnNpdHkpIHtcbiAgICAgICAgICAgIHplcm9WZWMyKGNlbnRlcik7XG4gICAgICAgICAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICAgICAgICAgIHZhciBJID0gMC4wO1xuICAgICAgICAgICAgLy8gcyBpcyB0aGUgcmVmZXJlbmNlIHBvaW50IGZvciBmb3JtaW5nIHRyaWFuZ2xlcy5cbiAgICAgICAgICAgIC8vIEl0J3MgbG9jYXRpb24gZG9lc24ndCBjaGFuZ2UgdGhlIHJlc3VsdCAoZXhjZXB0IGZvciByb3VuZGluZyBlcnJvcikuXG4gICAgICAgICAgICB6ZXJvVmVjMihzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3b3VsZCBwdXQgdGhlIHJlZmVyZW5jZSBwb2ludCBpbnNpZGUgdGhlIHBvbHlnb24uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgYWRkVmVjMihzLCB0aGlzLm1fdmVydGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TXVsVmVjMihzLCAxLjAgLyB0aGlzLm1fY291bnQsIHMpO1xuICAgICAgICAgICAgdmFyIGtfaW52MyA9IDEuMCAvIDMuMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlhbmdsZSB2ZXJ0aWNlcy5cbiAgICAgICAgICAgICAgICBkaWZmVmVjMihlMSQxLCB0aGlzLm1fdmVydGljZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IHRoaXMubV9jb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmVmVjMihlMiQxLCB0aGlzLm1fdmVydGljZXNbaSArIDFdLCBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZWZWMyKGUyJDEsIHRoaXMubV92ZXJ0aWNlc1swXSwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBEID0gY3Jvc3NWZWMyVmVjMihlMSQxLCBlMiQxKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJpYW5nbGVBcmVhID0gMC41ICogRDtcbiAgICAgICAgICAgICAgICBhcmVhICs9IHRyaWFuZ2xlQXJlYTtcbiAgICAgICAgICAgICAgICAvLyBBcmVhIHdlaWdodGVkIGNlbnRyb2lkXG4gICAgICAgICAgICAgICAgY29tYmluZVZlYzIoY2VudGVyLCAxLCBjZW50ZXIsIHRyaWFuZ2xlQXJlYSAqIGtfaW52MywgZTEkMSk7XG4gICAgICAgICAgICAgICAgY29tYmluZVZlYzIoY2VudGVyLCAxLCBjZW50ZXIsIHRyaWFuZ2xlQXJlYSAqIGtfaW52MywgZTIkMSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4MSA9IGUxJDEueDtcbiAgICAgICAgICAgICAgICB2YXIgZXkxID0gZTEkMS55O1xuICAgICAgICAgICAgICAgIHZhciBleDIgPSBlMiQxLng7XG4gICAgICAgICAgICAgICAgdmFyIGV5MiA9IGUyJDEueTtcbiAgICAgICAgICAgICAgICB2YXIgaW50eDIgPSBleDEgKiBleDEgKyBleDIgKiBleDEgKyBleDIgKiBleDI7XG4gICAgICAgICAgICAgICAgdmFyIGludHkyID0gZXkxICogZXkxICsgZXkyICogZXkxICsgZXkyICogZXkyO1xuICAgICAgICAgICAgICAgIEkgKz0gKDAuMjUgKiBrX2ludjMgKiBEKSAqIChpbnR4MiArIGludHkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvdGFsIG1hc3NcbiAgICAgICAgICAgIG1hc3NEYXRhLm1hc3MgPSBkZW5zaXR5ICogYXJlYTtcbiAgICAgICAgICAgIHNldE11bFZlYzIoY2VudGVyLCAxLjAgLyBhcmVhLCBjZW50ZXIpO1xuICAgICAgICAgICAgc3VtVmVjMihtYXNzRGF0YS5jZW50ZXIsIGNlbnRlciwgcyk7XG4gICAgICAgICAgICAvLyBJbmVydGlhIHRlbnNvciByZWxhdGl2ZSB0byB0aGUgbG9jYWwgb3JpZ2luIChwb2ludCBzKS5cbiAgICAgICAgICAgIG1hc3NEYXRhLkkgPSBkZW5zaXR5ICogSTtcbiAgICAgICAgICAgIC8vIFNoaWZ0IHRvIGNlbnRlciBvZiBtYXNzIHRoZW4gdG8gb3JpZ2luYWwgYm9keSBvcmlnaW4uXG4gICAgICAgICAgICBtYXNzRGF0YS5JICs9IG1hc3NEYXRhLm1hc3MgKiAoZG90VmVjMihtYXNzRGF0YS5jZW50ZXIsIG1hc3NEYXRhLmNlbnRlcikgLSBkb3RWZWMyKGNlbnRlciwgY2VudGVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0ZSBjb252ZXhpdHkuIFRoaXMgaXMgYSB2ZXJ5IHRpbWUgY29uc3VtaW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiB2YWxpZFxuICAgICAgICAgKi9cbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTEgPSBpO1xuICAgICAgICAgICAgICAgIHZhciBpMiA9IGkgPCB0aGlzLm1fY291bnQgLSAxID8gaTEgKyAxIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMubV92ZXJ0aWNlc1tpMV07XG4gICAgICAgICAgICAgICAgZGlmZlZlYzIoZSQxLCB0aGlzLm1fdmVydGljZXNbaTJdLCBwKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubV9jb3VudDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGkxIHx8IGogPT0gaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gY3Jvc3NWZWMyVmVjMihlJDEsIGRpZmZWZWMyKHRlbXAkMSwgdGhpcy5tX3ZlcnRpY2VzW2pdLCBwKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9seWdvblNoYXBlLnByb3RvdHlwZS5jb21wdXRlRGlzdGFuY2VQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHByb3h5Lm1fdmVydGljZXNbaV0gPSB0aGlzLm1fdmVydGljZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm94eS5tX3ZlcnRpY2VzLmxlbmd0aCA9IHRoaXMubV9jb3VudDtcbiAgICAgICAgICAgIHByb3h5Lm1fY291bnQgPSB0aGlzLm1fY291bnQ7XG4gICAgICAgICAgICBwcm94eS5tX3JhZGl1cyA9IHRoaXMubV9yYWRpdXM7XG4gICAgICAgIH07XG4gICAgICAgIFBvbHlnb25TaGFwZS5UWVBFID0gJ3BvbHlnb24nO1xuICAgICAgICByZXR1cm4gUG9seWdvblNoYXBlO1xuICAgIH0oU2hhcGUpKTtcbiAgICAvKiogQGludGVybmFsICovIGZ1bmN0aW9uIGNvbXB1dGVDZW50cm9pZCh2cywgY291bnQpIHtcbiAgICAgICAgdmFyIGMgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgdmFyIGFyZWEgPSAwLjA7XG4gICAgICAgIC8vIHBSZWYgaXMgdGhlIHJlZmVyZW5jZSBwb2ludCBmb3IgZm9ybWluZyB0cmlhbmdsZXMuXG4gICAgICAgIC8vIEl0J3MgbG9jYXRpb24gZG9lc24ndCBjaGFuZ2UgdGhlIHJlc3VsdCAoZXhjZXB0IGZvciByb3VuZGluZyBlcnJvcikuXG4gICAgICAgIHZhciBwUmVmID0gVmVjMi56ZXJvKCk7XG4gICAgICAgIHZhciBpOyBcbiAgICAgICAgdmFyIGludjMgPSAxLjAgLyAzLjA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgLy8gVHJpYW5nbGUgdmVydGljZXMuXG4gICAgICAgICAgICB2YXIgcDEgPSBwUmVmO1xuICAgICAgICAgICAgdmFyIHAyID0gdnNbaV07XG4gICAgICAgICAgICB2YXIgcDMgPSBpICsgMSA8IGNvdW50ID8gdnNbaSArIDFdIDogdnNbMF07XG4gICAgICAgICAgICB2YXIgZTFfMSA9IFZlYzIuc3ViKHAyLCBwMSk7XG4gICAgICAgICAgICB2YXIgZTJfMSA9IFZlYzIuc3ViKHAzLCBwMSk7XG4gICAgICAgICAgICB2YXIgRCA9IFZlYzIuY3Jvc3NWZWMyVmVjMihlMV8xLCBlMl8xKTtcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZUFyZWEgPSAwLjUgKiBEO1xuICAgICAgICAgICAgYXJlYSArPSB0cmlhbmdsZUFyZWE7XG4gICAgICAgICAgICAvLyBBcmVhIHdlaWdodGVkIGNlbnRyb2lkXG4gICAgICAgICAgICBjLmFkZE11bCh0cmlhbmdsZUFyZWEgKiBpbnYzLCBwMSk7XG4gICAgICAgICAgICBjLmFkZE11bCh0cmlhbmdsZUFyZWEgKiBpbnYzLCBwMik7XG4gICAgICAgICAgICBjLmFkZE11bCh0cmlhbmdsZUFyZWEgKiBpbnYzLCBwMyk7XG4gICAgICAgIH1cbiAgICAgICAgYy5tdWwoMS4wIC8gYXJlYSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICB2YXIgUG9seWdvbiA9IFBvbHlnb25TaGFwZTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIHJlY3RhbmdsZSBwb2x5Z29uIHdoaWNoIGV4dGVuZCBQb2x5Z29uU2hhcGUuXG4gICAgICovXG4gICAgdmFyIEJveFNoYXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQm94U2hhcGUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJveFNoYXBlKGh4LCBoeSwgY2VudGVyLCBhbmdsZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICghKF90aGlzIGluc3RhbmNlb2YgQm94U2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3hTaGFwZShoeCwgaHksIGNlbnRlciwgYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuX3NldEFzQm94KGh4LCBoeSwgY2VudGVyLCBhbmdsZSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgQm94U2hhcGUuVFlQRSA9ICdwb2x5Z29uJztcbiAgICAgICAgcmV0dXJuIEJveFNoYXBlO1xuICAgIH0oUG9seWdvblNoYXBlKSk7XG4gICAgdmFyIEJveCA9IEJveFNoYXBlO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfc3FydCA9IE1hdGguc3FydDtcbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX1BJJDQgPSBNYXRoLlBJO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHRlbXAgPSB2ZWMyKDAsIDApO1xuICAgIHZhciBDaXJjbGVTaGFwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKENpcmNsZVNoYXBlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDaXJjbGVTaGFwZShhLCBiKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBDaXJjbGVTaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENpcmNsZVNoYXBlKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gQ2lyY2xlU2hhcGUuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fcCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV9yYWRpdXMgPSAxO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBWZWMyLmlzVmFsaWQoYSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3Auc2V0VmVjMihhKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1fcmFkaXVzID0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3JhZGl1cyA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgcDogdGhpcy5tX3AsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiB0aGlzLm1fcmFkaXVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVTaGFwZShkYXRhLnAsIGRhdGEucmFkaXVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9O1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2lyY2xlU2hhcGUucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fcmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9wO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsIEBkZXByZWNhdGVkIFNoYXBlcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBpbW11dGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIGNsb25lIHRoZSBjb25jcmV0ZSBzaGFwZS5cbiAgICAgICAgICovXG4gICAgICAgIENpcmNsZVNoYXBlLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBuZXcgQ2lyY2xlU2hhcGUoKTtcbiAgICAgICAgICAgIGNsb25lLm1fdHlwZSA9IHRoaXMubV90eXBlO1xuICAgICAgICAgICAgY2xvbmUubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xuICAgICAgICAgICAgY2xvbmUubV9wID0gdGhpcy5tX3AuY2xvbmUoKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNoaWxkIHByaW1pdGl2ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIHNoYXBlLiBUaGlzIG9ubHkgd29ya3MgZm9yIGNvbnZleFxuICAgICAgICAgKiBzaGFwZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4ZiBUaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gcCBBIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2lyY2xlU2hhcGUucHJvdG90eXBlLnRlc3RQb2ludCA9IGZ1bmN0aW9uICh4ZiwgcCkge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRyYW5zZm9ybVZlYzIodGVtcCwgeGYsIHRoaXMubV9wKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0U3FyVmVjMihwLCBjZW50ZXIpIDw9IHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FzdCBhIHJheSBhZ2FpbnN0IGEgY2hpbGQgc2hhcGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvdXRwdXQgVGhlIHJheS1jYXN0IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgcmF5LWNhc3QgaW5wdXQgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHhmIFRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZEluZGV4IFRoZSBjaGlsZCBzaGFwZSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgQ2lyY2xlU2hhcGUucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCwgeGYsIGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIENvbGxpc2lvbiBEZXRlY3Rpb24gaW4gSW50ZXJhY3RpdmUgM0QgRW52aXJvbm1lbnRzIGJ5IEdpbm8gdmFuIGRlbiBCZXJnZW5cbiAgICAgICAgICAgIC8vIEZyb20gU2VjdGlvbiAzLjEuMlxuICAgICAgICAgICAgLy8geCA9IHMgKyBhICogclxuICAgICAgICAgICAgLy8gbm9ybSh4KSA9IHJhZGl1c1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gVmVjMi5hZGQoeGYucCwgUm90Lm11bFZlYzIoeGYucSwgdGhpcy5tX3ApKTtcbiAgICAgICAgICAgIHZhciBzID0gVmVjMi5zdWIoaW5wdXQucDEsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBiID0gVmVjMi5kb3QocywgcykgLSB0aGlzLm1fcmFkaXVzICogdGhpcy5tX3JhZGl1cztcbiAgICAgICAgICAgIC8vIFNvbHZlIHF1YWRyYXRpYyBlcXVhdGlvbi5cbiAgICAgICAgICAgIHZhciByID0gVmVjMi5zdWIoaW5wdXQucDIsIGlucHV0LnAxKTtcbiAgICAgICAgICAgIHZhciBjID0gVmVjMi5kb3Qocywgcik7XG4gICAgICAgICAgICB2YXIgcnIgPSBWZWMyLmRvdChyLCByKTtcbiAgICAgICAgICAgIHZhciBzaWdtYSA9IGMgKiBjIC0gcnIgKiBiO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIGRpc2NyaW1pbmFudCBhbmQgc2hvcnQgc2VnbWVudC5cbiAgICAgICAgICAgIGlmIChzaWdtYSA8IDAuMCB8fCByciA8IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gb2YgdGhlIGxpbmUgd2l0aCB0aGUgY2lyY2xlLlxuICAgICAgICAgICAgdmFyIGEgPSAtKGMgKyBtYXRoX3NxcnQoc2lnbWEpKTtcbiAgICAgICAgICAgIC8vIElzIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHNlZ21lbnQ/XG4gICAgICAgICAgICBpZiAoMC4wIDw9IGEgJiYgYSA8PSBpbnB1dC5tYXhGcmFjdGlvbiAqIHJyKSB7XG4gICAgICAgICAgICAgICAgYSAvPSBycjtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZnJhY3Rpb24gPSBhO1xuICAgICAgICAgICAgICAgIG91dHB1dC5ub3JtYWwgPSBWZWMyLmFkZChzLCBWZWMyLm11bE51bVZlYzIoYSwgcikpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5ub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHRyYW5zZm9ybSwgY29tcHV0ZSB0aGUgYXNzb2NpYXRlZCBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhXG4gICAgICAgICAqIGNoaWxkIHNoYXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWFiYiBSZXR1cm5zIHRoZSBheGlzIGFsaWduZWQgYm94LlxuICAgICAgICAgKiBAcGFyYW0geGYgVGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgc2hhcGUuXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZEluZGV4IFRoZSBjaGlsZCBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgQ2lyY2xlU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHhmLCBjaGlsZEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRyYW5zZm9ybVZlYzIodGVtcCwgeGYsIHRoaXMubV9wKTtcbiAgICAgICAgICAgIHNldFZlYzIoYWFiYi5sb3dlckJvdW5kLCBwLnggLSB0aGlzLm1fcmFkaXVzLCBwLnkgLSB0aGlzLm1fcmFkaXVzKTtcbiAgICAgICAgICAgIHNldFZlYzIoYWFiYi51cHBlckJvdW5kLCBwLnggKyB0aGlzLm1fcmFkaXVzLCBwLnkgKyB0aGlzLm1fcmFkaXVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXB1dGUgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGlzIHNoYXBlIHVzaW5nIGl0cyBkaW1lbnNpb25zIGFuZCBkZW5zaXR5LlxuICAgICAgICAgKiBUaGUgaW5lcnRpYSB0ZW5zb3IgaXMgY29tcHV0ZWQgYWJvdXQgdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1hc3NEYXRhIFJldHVybnMgdGhlIG1hc3MgZGF0YSBmb3IgdGhpcyBzaGFwZS5cbiAgICAgICAgICogQHBhcmFtIGRlbnNpdHkgVGhlIGRlbnNpdHkgaW4ga2lsb2dyYW1zIHBlciBtZXRlciBzcXVhcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2lyY2xlU2hhcGUucHJvdG90eXBlLmNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XG4gICAgICAgICAgICBtYXNzRGF0YS5tYXNzID0gZGVuc2l0eSAqIG1hdGhfUEkkNCAqIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xuICAgICAgICAgICAgY29weVZlYzIobWFzc0RhdGEuY2VudGVyLCB0aGlzLm1fcCk7XG4gICAgICAgICAgICAvLyBpbmVydGlhIGFib3V0IHRoZSBsb2NhbCBvcmlnaW5cbiAgICAgICAgICAgIG1hc3NEYXRhLkkgPSBtYXNzRGF0YS5tYXNzICogKDAuNSAqIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzICsgbGVuZ3RoU3FyVmVjMih0aGlzLm1fcCkpO1xuICAgICAgICB9O1xuICAgICAgICBDaXJjbGVTaGFwZS5wcm90b3R5cGUuY29tcHV0ZURpc3RhbmNlUHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgICAgICAgIHByb3h5Lm1fdmVydGljZXNbMF0gPSB0aGlzLm1fcDtcbiAgICAgICAgICAgIHByb3h5Lm1fdmVydGljZXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHByb3h5Lm1fY291bnQgPSAxO1xuICAgICAgICAgICAgcHJveHkubV9yYWRpdXMgPSB0aGlzLm1fcmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICBDaXJjbGVTaGFwZS5UWVBFID0gJ2NpcmNsZSc7XG4gICAgICAgIHJldHVybiBDaXJjbGVTaGFwZTtcbiAgICB9KFNoYXBlKSk7XG4gICAgdmFyIENpcmNsZSA9IENpcmNsZVNoYXBlO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfYWJzJDUgPSBNYXRoLmFicztcbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX1BJJDMgPSBNYXRoLlBJO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIERFRkFVTFRTJGEgPSB7XG4gICAgICAgIGZyZXF1ZW5jeUh6OiAwLjAsXG4gICAgICAgIGRhbXBpbmdSYXRpbzogMC4wXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpc3RhbmNlIGpvaW50IGNvbnN0cmFpbnMgdHdvIHBvaW50cyBvbiB0d28gYm9kaWVzIHRvIHJlbWFpbiBhdCBhIGZpeGVkXG4gICAgICogZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLiBZb3UgY2FuIHZpZXcgdGhpcyBhcyBhIG1hc3NsZXNzLCByaWdpZCByb2QuXG4gICAgICovXG4gICAgdmFyIERpc3RhbmNlSm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhEaXN0YW5jZUpvaW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBEaXN0YW5jZUpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3JBLCBhbmNob3JCKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBEaXN0YW5jZUpvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGlzdGFuY2VKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yQSwgYW5jaG9yQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvcmRlciBvZiBjb25zdHJ1Y3RvciBhcmd1bWVudHMgaXMgY2hhbmdlZCBpbiB2MC4yXG4gICAgICAgICAgICBpZiAoYm9keUIgJiYgYW5jaG9yQSAmJiAoJ21fdHlwZScgaW4gYW5jaG9yQSkgJiYgKCd4JyBpbiBib2R5QikgJiYgKCd5JyBpbiBib2R5QikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGJvZHlCO1xuICAgICAgICAgICAgICAgIGJvZHlCID0gYW5jaG9yQTtcbiAgICAgICAgICAgICAgICBhbmNob3JBID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyRhKTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICBib2R5QSA9IF90aGlzLm1fYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IF90aGlzLm1fYm9keUI7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBEaXN0YW5jZUpvaW50LlRZUEU7XG4gICAgICAgICAgICAvLyBTb2x2ZXIgc2hhcmVkXG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IFZlYzIuY2xvbmUoYW5jaG9yQSA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yQSkgOiBkZWYubG9jYWxBbmNob3JBIHx8IFZlYzIuemVybygpKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JCID0gVmVjMi5jbG9uZShhbmNob3JCID8gYm9keUIuZ2V0TG9jYWxQb2ludChhbmNob3JCKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgX3RoaXMubV9sZW5ndGggPSBOdW1iZXIuaXNGaW5pdGUoZGVmLmxlbmd0aCkgPyBkZWYubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICBWZWMyLmRpc3RhbmNlKGJvZHlBLmdldFdvcmxkUG9pbnQoX3RoaXMubV9sb2NhbEFuY2hvckEpLCBib2R5Qi5nZXRXb3JsZFBvaW50KF90aGlzLm1fbG9jYWxBbmNob3JCKSk7XG4gICAgICAgICAgICBfdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gZGVmLmZyZXF1ZW5jeUh6O1xuICAgICAgICAgICAgX3RoaXMubV9kYW1waW5nUmF0aW8gPSBkZWYuZGFtcGluZ1JhdGlvO1xuICAgICAgICAgICAgX3RoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9nYW1tYSA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fYmlhcyA9IDAuMDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIC8vIDEtRCBjb25zdHJhaW5lZCBzeXN0ZW1cbiAgICAgICAgICAgIC8vIG0gKHYyIC0gdjEpID0gbGFtYmRhXG4gICAgICAgICAgICAvLyB2MiArIChiZXRhL2gpICogeDEgKyBnYW1tYSAqIGxhbWJkYSA9IDAsIGdhbW1hIGhhcyB1bml0cyBvZiBpbnZlcnNlIG1hc3MuXG4gICAgICAgICAgICAvLyB4MiA9IHgxICsgaCAqIHYyXG4gICAgICAgICAgICAvLyAxLUQgbWFzcy1kYW1wZXItc3ByaW5nIHN5c3RlbVxuICAgICAgICAgICAgLy8gbSAodjIgLSB2MSkgKyBoICogZCAqIHYyICsgaCAqIGsgKlxuICAgICAgICAgICAgLy8gQyA9IG5vcm0ocDIgLSBwMSkgLSBMXG4gICAgICAgICAgICAvLyB1ID0gKHAyIC0gcDEpIC8gbm9ybShwMiAtIHAxKVxuICAgICAgICAgICAgLy8gQ2RvdCA9IGRvdCh1LCB2MiArIGNyb3NzKHcyLCByMikgLSB2MSAtIGNyb3NzKHcxLCByMSkpXG4gICAgICAgICAgICAvLyBKID0gWy11IC1jcm9zcyhyMSwgdSkgdSBjcm9zcyhyMiwgdSldXG4gICAgICAgICAgICAvLyBLID0gSiAqIGludk0gKiBKVFxuICAgICAgICAgICAgLy8gPSBpbnZNYXNzMSArIGludkkxICogY3Jvc3MocjEsIHUpXjIgKyBpbnZNYXNzMiArIGludkkyICogY3Jvc3MocjIsIHUpXjJcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3lIejogdGhpcy5tX2ZyZXF1ZW5jeUh6LFxuICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbzogdGhpcy5tX2RhbXBpbmdSYXRpbyxcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5tX2xlbmd0aCxcbiAgICAgICAgICAgICAgICBpbXB1bHNlOiB0aGlzLm1faW1wdWxzZSxcbiAgICAgICAgICAgICAgICBnYW1tYTogdGhpcy5tX2dhbW1hLFxuICAgICAgICAgICAgICAgIGJpYXM6IHRoaXMubV9iaWFzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEaXN0YW5jZUpvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IG5ldyBEaXN0YW5jZUpvaW50KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLl9zZXRBbmNob3JzID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKHRoaXMubV9ib2R5QS5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JBKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKHRoaXMubV9ib2R5Qi5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JCKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xlbmd0aCA9ICtkZWYubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxlbmd0aCA8IDApIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5hbmNob3JBIHx8IGRlZi5hbmNob3JBIHx8IGRlZi5hbmNob3JBIHx8IGRlZi5hbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xlbmd0aCA9IFZlYzIuZGlzdGFuY2UodGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSksIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbmF0dXJhbCBsZW5ndGguIE1hbmlwdWxhdGluZyB0aGUgbGVuZ3RoIGNhbiBsZWFkIHRvIG5vbi1waHlzaWNhbFxuICAgICAgICAgKiBiZWhhdmlvciB3aGVuIHRoZSBmcmVxdWVuY3kgaXMgemVyby5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubV9sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5hdHVyYWwgbGVuZ3RoLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLnNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChoeikge1xuICAgICAgICAgICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gaHo7XG4gICAgICAgIH07XG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLmdldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgIH07XG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLnNldERhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uIChyYXRpbykge1xuICAgICAgICAgICAgdGhpcy5tX2RhbXBpbmdSYXRpbyA9IHJhdGlvO1xuICAgICAgICB9O1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5nZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlBIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlCIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gZm9yY2Ugb24gYm9keUIgYXQgdGhlIGpvaW50IGFuY2hvciBpbiBOZXd0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm11bE51bVZlYzIodGhpcy5tX2ltcHVsc2UsIHRoaXMubV91KS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfTtcbiAgICAgICAgRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52SUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIHRoaXMubV9yQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgdGhpcy5tX3UgPSBWZWMyLnN1YihWZWMyLmFkZChjQiwgdGhpcy5tX3JCKSwgVmVjMi5hZGQoY0EsIHRoaXMubV9yQSkpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNpbmd1bGFyaXR5LlxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubV91Lmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IFNldHRpbmdzSW50ZXJuYWwubGluZWFyU2xvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV91Lm11bCgxLjAgLyBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3Uuc2V0TnVtKDAuMCwgMC4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjckF1ID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgdGhpcy5tX3UpO1xuICAgICAgICAgICAgdmFyIGNyQnUgPSBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCB0aGlzLm1fdSk7XG4gICAgICAgICAgICB2YXIgaW52TWFzcyA9IHRoaXMubV9pbnZNYXNzQSArIHRoaXMubV9pbnZJQSAqIGNyQXUgKiBjckF1ICsgdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklCICogY3JCdSAqIGNyQnU7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXG4gICAgICAgICAgICB0aGlzLm1fbWFzcyA9IGludk1hc3MgIT0gMC4wID8gMS4wIC8gaW52TWFzcyA6IDAuMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fZnJlcXVlbmN5SHogPiAwLjApIHtcbiAgICAgICAgICAgICAgICB2YXIgQyA9IGxlbmd0aCAtIHRoaXMubV9sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gRnJlcXVlbmN5XG4gICAgICAgICAgICAgICAgdmFyIG9tZWdhID0gMi4wICogbWF0aF9QSSQzICogdGhpcy5tX2ZyZXF1ZW5jeUh6O1xuICAgICAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcbiAgICAgICAgICAgICAgICB2YXIgZCA9IDIuMCAqIHRoaXMubV9tYXNzICogdGhpcy5tX2RhbXBpbmdSYXRpbyAqIG9tZWdhO1xuICAgICAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcbiAgICAgICAgICAgICAgICB2YXIgayA9IHRoaXMubV9tYXNzICogb21lZ2EgKiBvbWVnYTtcbiAgICAgICAgICAgICAgICAvLyBtYWdpYyBmb3JtdWxhc1xuICAgICAgICAgICAgICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSBoICogKGQgKyBoICogayk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gdGhpcy5tX2dhbW1hICE9IDAuMCA/IDEuMCAvIHRoaXMubV9nYW1tYSA6IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYmlhcyA9IEMgKiBoICogayAqIHRoaXMubV9nYW1tYTtcbiAgICAgICAgICAgICAgICBpbnZNYXNzICs9IHRoaXMubV9nYW1tYTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcyA9IGludk1hc3MgIT0gMC4wID8gMS4wIC8gaW52TWFzcyA6IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9nYW1tYSA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYmlhcyA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlIHRoZSBpbXB1bHNlIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fdSk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKHRoaXMubV9pbnZNYXNzQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCk7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gdGhpcy5tX2ludklCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2QSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIC8vIENkb3QgPSBkb3QodSwgdiArIGNyb3NzKHcsIHIpKVxuICAgICAgICAgICAgdmFyIHZwQSA9IFZlYzIuYWRkKHZBLCBWZWMyLmNyb3NzTnVtVmVjMih3QSwgdGhpcy5tX3JBKSk7XG4gICAgICAgICAgICB2YXIgdnBCID0gVmVjMi5hZGQodkIsIFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB0aGlzLm1fckIpKTtcbiAgICAgICAgICAgIHZhciBDZG90ID0gVmVjMi5kb3QodGhpcy5tX3UsIHZwQikgLSBWZWMyLmRvdCh0aGlzLm1fdSwgdnBBKTtcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogKENkb3QgKyB0aGlzLm1fYmlhcyArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlKTtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlICs9IGltcHVsc2U7XG4gICAgICAgICAgICB2YXIgUCA9IFZlYzIubXVsTnVtVmVjMihpbXB1bHNlLCB0aGlzLm1fdSk7XG4gICAgICAgICAgICB2QS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgICAgIHdBIC09IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIFApO1xuICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUCk7XG4gICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBQKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2QSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGVycm9ycyBhcmUgd2l0aGluIHRvbGVyYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIERpc3RhbmNlSm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gcG9zaXRpb24gY29ycmVjdGlvbiBmb3Igc29mdCBkaXN0YW5jZSBjb25zdHJhaW50cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFN1YihxQSwgdGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSk7XG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsU3ViKHFCLCB0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKTtcbiAgICAgICAgICAgIHZhciB1ID0gVmVjMi5zdWIoVmVjMi5hZGQoY0IsIHJCKSwgVmVjMi5hZGQoY0EsIHJBKSk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHZhciBDID0gY2xhbXAobGVuZ3RoIC0gdGhpcy5tX2xlbmd0aCwgLVNldHRpbmdzSW50ZXJuYWwubWF4TGluZWFyQ29ycmVjdGlvbiwgU2V0dGluZ3NJbnRlcm5hbC5tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogQztcbiAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKGltcHVsc2UsIHUpO1xuICAgICAgICAgICAgY0Euc3ViTXVsKHRoaXMubV9pbnZNYXNzQSwgUCk7XG4gICAgICAgICAgICBhQSAtPSB0aGlzLm1faW52SUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIockEsIFApO1xuICAgICAgICAgICAgY0IuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUCk7XG4gICAgICAgICAgICBhQiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIockIsIFApO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNBKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmEgPSBhQTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmMuc2V0VmVjMihjQik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgICAgICAgICByZXR1cm4gbWF0aF9hYnMkNShDKSA8IFNldHRpbmdzSW50ZXJuYWwubGluZWFyU2xvcDtcbiAgICAgICAgfTtcbiAgICAgICAgRGlzdGFuY2VKb2ludC5UWVBFID0gJ2Rpc3RhbmNlLWpvaW50JztcbiAgICAgICAgcmV0dXJuIERpc3RhbmNlSm9pbnQ7XG4gICAgfShKb2ludCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIERFRkFVTFRTJDkgPSB7XG4gICAgICAgIG1heEZvcmNlOiAwLjAsXG4gICAgICAgIG1heFRvcnF1ZTogMC4wLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogRnJpY3Rpb24gam9pbnQuIFRoaXMgaXMgdXNlZCBmb3IgdG9wLWRvd24gZnJpY3Rpb24uIEl0IHByb3ZpZGVzIDJEXG4gICAgICogdHJhbnNsYXRpb25hbCBmcmljdGlvbiBhbmQgYW5ndWxhciBmcmljdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgRnJpY3Rpb25Kb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEZyaWN0aW9uSm9pbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZyaWN0aW9uSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICghKF90aGlzIGluc3RhbmNlb2YgRnJpY3Rpb25Kb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZyaWN0aW9uSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkOSk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gRnJpY3Rpb25Kb2ludC5UWVBFO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBWZWMyLmNsb25lKGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSBWZWMyLmNsb25lKGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgLy8gU29sdmVyIHNoYXJlZFxuICAgICAgICAgICAgX3RoaXMubV9saW5lYXJJbXB1bHNlID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9tYXhGb3JjZSA9IGRlZi5tYXhGb3JjZTtcbiAgICAgICAgICAgIF90aGlzLm1fbWF4VG9ycXVlID0gZGVmLm1heFRvcnF1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIC8vIFBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcbiAgICAgICAgICAgIC8vIENkb3QgPSB2MiAtIHYxXG4gICAgICAgICAgICAvLyA9IHYyICsgY3Jvc3ModzIsIHIyKSAtIHYxIC0gY3Jvc3ModzEsIHIxKVxuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXcgXVxuICAgICAgICAgICAgLy8gSWRlbnRpdHkgdXNlZDpcbiAgICAgICAgICAgIC8vIHcgayAlIChyeCBpICsgcnkgaikgPSB3ICogKC1yeSBpICsgcnggailcbiAgICAgICAgICAgIC8vIEFuZ2xlIGNvbnN0cmFpbnRcbiAgICAgICAgICAgIC8vIENkb3QgPSB3MiAtIHcxXG4gICAgICAgICAgICAvLyBKID0gWzAgMCAtMSAwIDAgMV1cbiAgICAgICAgICAgIC8vIEsgPSBpbnZJMSArIGludkkyXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICBib2R5QTogdGhpcy5tX2JvZHlBLFxuICAgICAgICAgICAgICAgIGJvZHlCOiB0aGlzLm1fYm9keUIsXG4gICAgICAgICAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWF4Rm9yY2U6IHRoaXMubV9tYXhGb3JjZSxcbiAgICAgICAgICAgICAgICBtYXhUb3JxdWU6IHRoaXMubV9tYXhUb3JxdWUsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JBOiB0aGlzLm1fbG9jYWxBbmNob3JBLFxuICAgICAgICAgICAgICAgIGxvY2FsQW5jaG9yQjogdGhpcy5tX2xvY2FsQW5jaG9yQixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRnJpY3Rpb25Kb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgRnJpY3Rpb25Kb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5fc2V0QW5jaG9ycyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIGlmIChkZWYuYW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuc2V0VmVjMih0aGlzLm1fYm9keUEuZ2V0TG9jYWxQb2ludChkZWYuYW5jaG9yQSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxvY2FsQW5jaG9yQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuc2V0VmVjMihkZWYubG9jYWxBbmNob3JBKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYuYW5jaG9yQikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuc2V0VmVjMih0aGlzLm1fYm9keUIuZ2V0TG9jYWxQb2ludChkZWYuYW5jaG9yQikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLmxvY2FsQW5jaG9yQikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuc2V0VmVjMihkZWYubG9jYWxBbmNob3JCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWF4aW11bSBmcmljdGlvbiBmb3JjZSBpbiBOLlxuICAgICAgICAgKi9cbiAgICAgICAgRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGZvcmNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXhpbXVtIGZyaWN0aW9uIGZvcmNlIGluIE4uXG4gICAgICAgICAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1heGltdW0gZnJpY3Rpb24gdG9ycXVlIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXhUb3JxdWUgPSB0b3JxdWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG1heGltdW0gZnJpY3Rpb24gdG9ycXVlIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4VG9ycXVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUIgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiBmb3JjZSBvbiBib2R5QiBhdCB0aGUgam9pbnQgYW5jaG9yIGluIE5ld3RvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBGcmljdGlvbkpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubXVsTnVtVmVjMihpbnZfZHQsIHRoaXMubV9saW5lYXJJbXB1bHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIEZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9hbmd1bGFySW1wdWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52SUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXG4gICAgICAgICAgICB0aGlzLm1fckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgICAgICAgICAgdGhpcy5tX3JCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3XVxuICAgICAgICAgICAgLy8gWyAwIC0xIDAgMV1cbiAgICAgICAgICAgIC8vIHJfc2tldyA9IFstcnk7IHJ4XVxuICAgICAgICAgICAgLy8gTWF0bGFiXG4gICAgICAgICAgICAvLyBLID0gWyBtQStyMXleMippQSttQityMnleMippQiwgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgLXIxeSppQS1yMnkqaUJdXG4gICAgICAgICAgICAvLyBbIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIG1BK3IxeF4yKmlBK21CK3IyeF4yKmlCLCByMXgqaUErcjJ4KmlCXVxuICAgICAgICAgICAgLy8gWyAtcjF5KmlBLXIyeSppQiwgcjF4KmlBK3IyeCppQiwgaUEraUJdXG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgICAgICAgICAgSy5leC54ID0gbUEgKyBtQiArIGlBICogdGhpcy5tX3JBLnkgKiB0aGlzLm1fckEueSArIGlCICogdGhpcy5tX3JCLnlcbiAgICAgICAgICAgICAgICAqIHRoaXMubV9yQi55O1xuICAgICAgICAgICAgSy5leC55ID0gLWlBICogdGhpcy5tX3JBLnggKiB0aGlzLm1fckEueSAtIGlCICogdGhpcy5tX3JCLnggKiB0aGlzLm1fckIueTtcbiAgICAgICAgICAgIEsuZXkueCA9IEsuZXgueTtcbiAgICAgICAgICAgIEsuZXkueSA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9yQS54ICogdGhpcy5tX3JBLnggKyBpQiAqIHRoaXMubV9yQi54XG4gICAgICAgICAgICAgICAgKiB0aGlzLm1fckIueDtcbiAgICAgICAgICAgIHRoaXMubV9saW5lYXJNYXNzID0gSy5nZXRJbnZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLm1fYW5ndWxhck1hc3MgPSBpQSArIGlCO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9hbmd1bGFyTWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9hbmd1bGFyTWFzcyA9IDEuMCAvIHRoaXMubV9hbmd1bGFyTWFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UubXVsKHN0ZXAuZHRSYXRpbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVvKHRoaXMubV9saW5lYXJJbXB1bHNlLngsIHRoaXMubV9saW5lYXJJbXB1bHNlLnkpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCkgKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgUCkgKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2Uuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9hbmd1bGFySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYgPSB2QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICB2YXIgaCA9IHN0ZXAuZHQ7XG4gICAgICAgICAgICAvLyBTb2x2ZSBhbmd1bGFyIGZyaWN0aW9uXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSB3QiAtIHdBO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9hbmd1bGFyTWFzcyAqIENkb3Q7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fYW5ndWxhckltcHVsc2U7XG4gICAgICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBoICogdGhpcy5tX21heFRvcnF1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgPSBjbGFtcCh0aGlzLm1fYW5ndWxhckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9hbmd1bGFySW1wdWxzZSAtIG9sZEltcHVsc2U7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogaW1wdWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbHZlIGxpbmVhciBmcmljdGlvblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gVmVjMi5zdWIoVmVjMi5hZGQodkIsIFZlYzIuY3Jvc3NOdW1WZWMyKHdCLCB0aGlzLm1fckIpKSwgVmVjMi5hZGQodkEsIFZlYzIuY3Jvc3NOdW1WZWMyKHdBLCB0aGlzLm1fckEpKSk7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBWZWMyLm5lZyhNYXQyMi5tdWxWZWMyKHRoaXMubV9saW5lYXJNYXNzLCBDZG90KSk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fbGluZWFySW1wdWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBoICogdGhpcy5tX21heEZvcmNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1fbGluZWFySW1wdWxzZS5sZW5ndGhTcXVhcmVkKCkgPiBtYXhJbXB1bHNlICogbWF4SW1wdWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UubXVsKG1heEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gVmVjMi5zdWIodGhpcy5tX2xpbmVhckltcHVsc2UsIG9sZEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIGltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBGcmljdGlvbkpvaW50LlRZUEUgPSAnZnJpY3Rpb24tam9pbnQnO1xuICAgICAgICByZXR1cm4gRnJpY3Rpb25Kb2ludDtcbiAgICB9KEpvaW50KSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSAzLWJ5LTMgbWF0cml4LiBTdG9yZWQgaW4gY29sdW1uLW1ham9yIG9yZGVyLlxuICAgICAqL1xuICAgIHZhciBNYXQzMyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWF0MzMoYSwgYiwgYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leCA9IFZlYzMuY2xvbmUoYSk7XG4gICAgICAgICAgICAgICAgdGhpcy5leSA9IFZlYzMuY2xvbmUoYik7XG4gICAgICAgICAgICAgICAgdGhpcy5leiA9IFZlYzMuY2xvbmUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ID0gVmVjMy56ZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leSA9IFZlYzMuemVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXogPSBWZWMzLnplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE1hdDMzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWF0MzMuaXNWYWxpZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVmVjMy5pc1ZhbGlkKG9iai5leCkgJiYgVmVjMy5pc1ZhbGlkKG9iai5leSkgJiYgVmVjMy5pc1ZhbGlkKG9iai5leik7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDMzLmFzc2VydCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBtYXRyaXggdG8gYWxsIHplcm9zLlxuICAgICAgICAgKi9cbiAgICAgICAgTWF0MzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmV4LnNldFplcm8oKTtcbiAgICAgICAgICAgIHRoaXMuZXkuc2V0WmVybygpO1xuICAgICAgICAgICAgdGhpcy5lei5zZXRaZXJvKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbHZlIEEgKiB4ID0gYiwgd2hlcmUgYiBpcyBhIGNvbHVtbiB2ZWN0b3IuIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhblxuICAgICAgICAgKiBjb21wdXRpbmcgdGhlIGludmVyc2UgaW4gb25lLXNob3QgY2FzZXMuXG4gICAgICAgICAqL1xuICAgICAgICBNYXQzMy5wcm90b3R5cGUuc29sdmUzMyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAvLyBsZXQgZGV0ID0gbWF0cml4LmRvdFZlYzModGhpcy5leCwgbWF0cml4Lm5ld0Nyb3NzVmVjMyh0aGlzLmV5LCB0aGlzLmV6KSk7XG4gICAgICAgICAgICB2YXIgY3Jvc3NfeCA9IHRoaXMuZXkueSAqIHRoaXMuZXoueiAtIHRoaXMuZXkueiAqIHRoaXMuZXoueTtcbiAgICAgICAgICAgIHZhciBjcm9zc195ID0gdGhpcy5leS56ICogdGhpcy5lei54IC0gdGhpcy5leS54ICogdGhpcy5lei56O1xuICAgICAgICAgICAgdmFyIGNyb3NzX3ogPSB0aGlzLmV5LnggKiB0aGlzLmV6LnkgLSB0aGlzLmV5LnkgKiB0aGlzLmV6Lng7XG4gICAgICAgICAgICB2YXIgZGV0ID0gdGhpcy5leC54ICogY3Jvc3NfeCArIHRoaXMuZXgueSAqIGNyb3NzX3kgKyB0aGlzLmV4LnogKiBjcm9zc196O1xuICAgICAgICAgICAgaWYgKGRldCAhPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgLy8gci54ID0gZGV0ICogbWF0cml4LmRvdFZlYzModiwgbWF0cml4Lm5ld0Nyb3NzVmVjMyh0aGlzLmV5LCB0aGlzLmV6KSk7XG4gICAgICAgICAgICBjcm9zc194ID0gdGhpcy5leS55ICogdGhpcy5lei56IC0gdGhpcy5leS56ICogdGhpcy5lei55O1xuICAgICAgICAgICAgY3Jvc3NfeSA9IHRoaXMuZXkueiAqIHRoaXMuZXoueCAtIHRoaXMuZXkueCAqIHRoaXMuZXouejtcbiAgICAgICAgICAgIGNyb3NzX3ogPSB0aGlzLmV5LnggKiB0aGlzLmV6LnkgLSB0aGlzLmV5LnkgKiB0aGlzLmV6Lng7XG4gICAgICAgICAgICByLnggPSBkZXQgKiAodi54ICogY3Jvc3NfeCArIHYueSAqIGNyb3NzX3kgKyB2LnogKiBjcm9zc196KTtcbiAgICAgICAgICAgIC8vIHIueSA9IGRldCAqIG1hdHJpeC5kb3RWZWMzKHRoaXMuZXgsIG1hdHJpeC5uZXdDcm9zc1ZlYzModiwgdGhpcy5leikpO1xuICAgICAgICAgICAgY3Jvc3NfeCA9IHYueSAqIHRoaXMuZXoueiAtIHYueiAqIHRoaXMuZXoueTtcbiAgICAgICAgICAgIGNyb3NzX3kgPSB2LnogKiB0aGlzLmV6LnggLSB2LnggKiB0aGlzLmV6Lno7XG4gICAgICAgICAgICBjcm9zc196ID0gdi54ICogdGhpcy5lei55IC0gdi55ICogdGhpcy5lei54O1xuICAgICAgICAgICAgci55ID0gZGV0ICogKHRoaXMuZXgueCAqIGNyb3NzX3ggKyB0aGlzLmV4LnkgKiBjcm9zc195ICsgdGhpcy5leC56ICogY3Jvc3Nfeik7XG4gICAgICAgICAgICAvLyByLnogPSBkZXQgKiBtYXRyaXguZG90VmVjMyh0aGlzLmV4LCBtYXRyaXgubmV3Q3Jvc3NWZWMzKHRoaXMuZXksIHYpKTtcbiAgICAgICAgICAgIGNyb3NzX3ggPSB0aGlzLmV5LnkgKiB2LnogLSB0aGlzLmV5LnogKiB2Lnk7XG4gICAgICAgICAgICBjcm9zc195ID0gdGhpcy5leS56ICogdi54IC0gdGhpcy5leS54ICogdi56O1xuICAgICAgICAgICAgY3Jvc3NfeiA9IHRoaXMuZXkueCAqIHYueSAtIHRoaXMuZXkueSAqIHYueDtcbiAgICAgICAgICAgIHIueiA9IGRldCAqICh0aGlzLmV4LnggKiBjcm9zc194ICsgdGhpcy5leC55ICogY3Jvc3NfeSArIHRoaXMuZXgueiAqIGNyb3NzX3opO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb2x2ZSBBICogeCA9IGIsIHdoZXJlIGIgaXMgYSBjb2x1bW4gdmVjdG9yLiBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW5cbiAgICAgICAgICogY29tcHV0aW5nIHRoZSBpbnZlcnNlIGluIG9uZS1zaG90IGNhc2VzLiBTb2x2ZSBvbmx5IHRoZSB1cHBlciAyLWJ5LTIgbWF0cml4XG4gICAgICAgICAqIGVxdWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgTWF0MzMucHJvdG90eXBlLnNvbHZlMjIgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIGExMSA9IHRoaXMuZXgueDtcbiAgICAgICAgICAgIHZhciBhMTIgPSB0aGlzLmV5Lng7XG4gICAgICAgICAgICB2YXIgYTIxID0gdGhpcy5leC55O1xuICAgICAgICAgICAgdmFyIGEyMiA9IHRoaXMuZXkueTtcbiAgICAgICAgICAgIHZhciBkZXQgPSBhMTEgKiBhMjIgLSBhMTIgKiBhMjE7XG4gICAgICAgICAgICBpZiAoZGV0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgciA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgci54ID0gZGV0ICogKGEyMiAqIHYueCAtIGExMiAqIHYueSk7XG4gICAgICAgICAgICByLnkgPSBkZXQgKiAoYTExICogdi55IC0gYTIxICogdi54KTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4IGFzIGEgMi1ieS0yLiBSZXR1cm5zIHRoZSB6ZXJvIG1hdHJpeCBpZlxuICAgICAgICAgKiBzaW5ndWxhci5cbiAgICAgICAgICovXG4gICAgICAgIE1hdDMzLnByb3RvdHlwZS5nZXRJbnZlcnNlMjIgPSBmdW5jdGlvbiAoTSkge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmV4Lng7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuZXkueDtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5leC55O1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmV5Lnk7XG4gICAgICAgICAgICB2YXIgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgICAgICAgICAgIGlmIChkZXQgIT09IDAuMCkge1xuICAgICAgICAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE0uZXgueCA9IGRldCAqIGQ7XG4gICAgICAgICAgICBNLmV5LnggPSAtZGV0ICogYjtcbiAgICAgICAgICAgIE0uZXgueiA9IDAuMDtcbiAgICAgICAgICAgIE0uZXgueSA9IC1kZXQgKiBjO1xuICAgICAgICAgICAgTS5leS55ID0gZGV0ICogYTtcbiAgICAgICAgICAgIE0uZXkueiA9IDAuMDtcbiAgICAgICAgICAgIE0uZXoueCA9IDAuMDtcbiAgICAgICAgICAgIE0uZXoueSA9IDAuMDtcbiAgICAgICAgICAgIE0uZXoueiA9IDAuMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3ltbWV0cmljIGludmVyc2Ugb2YgdGhpcyBtYXRyaXggYXMgYSAzLWJ5LTMuIFJldHVybnMgdGhlIHplcm8gbWF0cml4XG4gICAgICAgICAqIGlmIHNpbmd1bGFyLlxuICAgICAgICAgKi9cbiAgICAgICAgTWF0MzMucHJvdG90eXBlLmdldFN5bUludmVyc2UzMyA9IGZ1bmN0aW9uIChNKSB7XG4gICAgICAgICAgICB2YXIgZGV0ID0gVmVjMy5kb3QodGhpcy5leCwgVmVjMy5jcm9zcyh0aGlzLmV5LCB0aGlzLmV6KSk7XG4gICAgICAgICAgICBpZiAoZGV0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYTExID0gdGhpcy5leC54O1xuICAgICAgICAgICAgdmFyIGExMiA9IHRoaXMuZXkueDtcbiAgICAgICAgICAgIHZhciBhMTMgPSB0aGlzLmV6Lng7XG4gICAgICAgICAgICB2YXIgYTIyID0gdGhpcy5leS55O1xuICAgICAgICAgICAgdmFyIGEyMyA9IHRoaXMuZXoueTtcbiAgICAgICAgICAgIHZhciBhMzMgPSB0aGlzLmV6Lno7XG4gICAgICAgICAgICBNLmV4LnggPSBkZXQgKiAoYTIyICogYTMzIC0gYTIzICogYTIzKTtcbiAgICAgICAgICAgIE0uZXgueSA9IGRldCAqIChhMTMgKiBhMjMgLSBhMTIgKiBhMzMpO1xuICAgICAgICAgICAgTS5leC56ID0gZGV0ICogKGExMiAqIGEyMyAtIGExMyAqIGEyMik7XG4gICAgICAgICAgICBNLmV5LnggPSBNLmV4Lnk7XG4gICAgICAgICAgICBNLmV5LnkgPSBkZXQgKiAoYTExICogYTMzIC0gYTEzICogYTEzKTtcbiAgICAgICAgICAgIE0uZXkueiA9IGRldCAqIChhMTMgKiBhMTIgLSBhMTEgKiBhMjMpO1xuICAgICAgICAgICAgTS5lei54ID0gTS5leC56O1xuICAgICAgICAgICAgTS5lei55ID0gTS5leS56O1xuICAgICAgICAgICAgTS5lei56ID0gZGV0ICogKGExMSAqIGEyMiAtIGExMiAqIGExMik7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDMzLm11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYiAmJiAneicgaW4gYiAmJiAneScgaW4gYiAmJiAneCcgaW4gYikge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gYS5leC54ICogYi54ICsgYS5leS54ICogYi55ICsgYS5lei54ICogYi56O1xuICAgICAgICAgICAgICAgIHZhciB5ID0gYS5leC55ICogYi54ICsgYS5leS55ICogYi55ICsgYS5lei55ICogYi56O1xuICAgICAgICAgICAgICAgIHZhciB6ID0gYS5leC56ICogYi54ICsgYS5leS56ICogYi55ICsgYS5lei56ICogYi56O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgJiYgJ3knIGluIGIgJiYgJ3gnIGluIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGEuZXgueCAqIGIueCArIGEuZXkueCAqIGIueTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGEuZXgueSAqIGIueCArIGEuZXkueSAqIGIueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1hdDMzLm11bFZlYzMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIHggPSBhLmV4LnggKiBiLnggKyBhLmV5LnggKiBiLnkgKyBhLmV6LnggKiBiLno7XG4gICAgICAgICAgICB2YXIgeSA9IGEuZXgueSAqIGIueCArIGEuZXkueSAqIGIueSArIGEuZXoueSAqIGIuejtcbiAgICAgICAgICAgIHZhciB6ID0gYS5leC56ICogYi54ICsgYS5leS56ICogYi55ICsgYS5lei56ICogYi56O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHgsIHksIHopO1xuICAgICAgICB9O1xuICAgICAgICBNYXQzMy5tdWxWZWMyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gYS5leC54ICogYi54ICsgYS5leS54ICogYi55O1xuICAgICAgICAgICAgdmFyIHkgPSBhLmV4LnkgKiBiLnggKyBhLmV5LnkgKiBiLnk7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5uZW8oeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIE1hdDMzLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdDMzKFZlYzMuYWRkKGEuZXgsIGIuZXgpLCBWZWMzLmFkZChhLmV5LCBiLmV5KSwgVmVjMy5hZGQoYS5leiwgYi5leikpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWF0MzM7XG4gICAgfSgpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX2FicyQ0ID0gTWF0aC5hYnM7XG4gICAgLy8gdG9kbzogdXNlIHN0cmluZz9cbiAgICAvKiogQGludGVybmFsICovIHZhciBMaW1pdFN0YXRlJDI7XG4gICAgKGZ1bmN0aW9uIChMaW1pdFN0YXRlKSB7XG4gICAgICAgIExpbWl0U3RhdGVbTGltaXRTdGF0ZVtcImluYWN0aXZlTGltaXRcIl0gPSAwXSA9IFwiaW5hY3RpdmVMaW1pdFwiO1xuICAgICAgICBMaW1pdFN0YXRlW0xpbWl0U3RhdGVbXCJhdExvd2VyTGltaXRcIl0gPSAxXSA9IFwiYXRMb3dlckxpbWl0XCI7XG4gICAgICAgIExpbWl0U3RhdGVbTGltaXRTdGF0ZVtcImF0VXBwZXJMaW1pdFwiXSA9IDJdID0gXCJhdFVwcGVyTGltaXRcIjtcbiAgICAgICAgTGltaXRTdGF0ZVtMaW1pdFN0YXRlW1wiZXF1YWxMaW1pdHNcIl0gPSAzXSA9IFwiZXF1YWxMaW1pdHNcIjtcbiAgICB9KShMaW1pdFN0YXRlJDIgfHwgKExpbWl0U3RhdGUkMiA9IHt9KSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgREVGQVVMVFMkOCA9IHtcbiAgICAgICAgbG93ZXJBbmdsZTogMC4wLFxuICAgICAgICB1cHBlckFuZ2xlOiAwLjAsXG4gICAgICAgIG1heE1vdG9yVG9ycXVlOiAwLjAsXG4gICAgICAgIG1vdG9yU3BlZWQ6IDAuMCxcbiAgICAgICAgZW5hYmxlTGltaXQ6IGZhbHNlLFxuICAgICAgICBlbmFibGVNb3RvcjogZmFsc2VcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgcmV2b2x1dGUgam9pbnQgY29uc3RyYWlucyB0d28gYm9kaWVzIHRvIHNoYXJlIGEgY29tbW9uIHBvaW50IHdoaWxlIHRoZXkgYXJlXG4gICAgICogZnJlZSB0byByb3RhdGUgYWJvdXQgdGhlIHBvaW50LiBUaGUgcmVsYXRpdmUgcm90YXRpb24gYWJvdXQgdGhlIHNoYXJlZCBwb2ludFxuICAgICAqIGlzIHRoZSBqb2ludCBhbmdsZS4gWW91IGNhbiBsaW1pdCB0aGUgcmVsYXRpdmUgcm90YXRpb24gd2l0aCBhIGpvaW50IGxpbWl0XG4gICAgICogdGhhdCBzcGVjaWZpZXMgYSBsb3dlciBhbmQgdXBwZXIgYW5nbGUuIFlvdSBjYW4gdXNlIGEgbW90b3IgdG8gZHJpdmUgdGhlXG4gICAgICogcmVsYXRpdmUgcm90YXRpb24gYWJvdXQgdGhlIHNoYXJlZCBwb2ludC4gQSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSBpcyBwcm92aWRlZFxuICAgICAqIHNvIHRoYXQgaW5maW5pdGUgZm9yY2VzIGFyZSBub3QgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIHZhciBSZXZvbHV0ZUpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmV2b2x1dGVKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUmV2b2x1dGVKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoIShfdGhpcyBpbnN0YW5jZW9mIFJldm9sdXRlSm9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXZvbHV0ZUpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmID0gZGVmICE9PSBudWxsICYmIGRlZiAhPT0gdm9pZCAwID8gZGVmIDoge307XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV9tYXNzID0gbmV3IE1hdDMzKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlJDIuaW5hY3RpdmVMaW1pdDtcbiAgICAgICAgICAgIF90aGlzLm1fdHlwZSA9IFJldm9sdXRlSm9pbnQuVFlQRTtcbiAgICAgICAgICAgIGlmIChWZWMyLmlzVmFsaWQoYW5jaG9yKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JBID0gYm9keUEuZ2V0TG9jYWxQb2ludChhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoVmVjMi5pc1ZhbGlkKGRlZi5sb2NhbEFuY2hvckEpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBWZWMyLmNsb25lKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChWZWMyLmlzVmFsaWQoYW5jaG9yKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JCID0gYm9keUIuZ2V0TG9jYWxQb2ludChhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoVmVjMi5pc1ZhbGlkKGRlZi5sb2NhbEFuY2hvckIpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSBWZWMyLmNsb25lKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZGVmLnJlZmVyZW5jZUFuZ2xlKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm1fcmVmZXJlbmNlQW5nbGUgPSBkZWYucmVmZXJlbmNlQW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gYm9keUIuZ2V0QW5nbGUoKSAtIGJvZHlBLmdldEFuZ2xlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5tX2ltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgX3RoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2xvd2VyQW5nbGUgPSAoX2EgPSBkZWYubG93ZXJBbmdsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVFMkOC5sb3dlckFuZ2xlO1xuICAgICAgICAgICAgX3RoaXMubV91cHBlckFuZ2xlID0gKF9iID0gZGVmLnVwcGVyQW5nbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERFRkFVTFRTJDgudXBwZXJBbmdsZTtcbiAgICAgICAgICAgIF90aGlzLm1fbWF4TW90b3JUb3JxdWUgPSAoX2MgPSBkZWYubWF4TW90b3JUb3JxdWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRTJDgubWF4TW90b3JUb3JxdWU7XG4gICAgICAgICAgICBfdGhpcy5tX21vdG9yU3BlZWQgPSAoX2QgPSBkZWYubW90b3JTcGVlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogREVGQVVMVFMkOC5tb3RvclNwZWVkO1xuICAgICAgICAgICAgX3RoaXMubV9lbmFibGVMaW1pdCA9IChfZSA9IGRlZi5lbmFibGVMaW1pdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogREVGQVVMVFMkOC5lbmFibGVMaW1pdDtcbiAgICAgICAgICAgIF90aGlzLm1fZW5hYmxlTW90b3IgPSAoX2YgPSBkZWYuZW5hYmxlTW90b3IpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IERFRkFVTFRTJDguZW5hYmxlTW90b3I7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAvLyBQb2ludC10by1wb2ludCBjb25zdHJhaW50XG4gICAgICAgICAgICAvLyBDID0gcDIgLSBwMVxuICAgICAgICAgICAgLy8gQ2RvdCA9IHYyIC0gdjFcbiAgICAgICAgICAgIC8vID0gdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tldyBdXG4gICAgICAgICAgICAvLyBJZGVudGl0eSB1c2VkOlxuICAgICAgICAgICAgLy8gdyBrICUgKHJ4IGkgKyByeSBqKSA9IHcgKiAoLXJ5IGkgKyByeCBqKVxuICAgICAgICAgICAgLy8gTW90b3IgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQ2RvdCA9IHcyIC0gdzFcbiAgICAgICAgICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxuICAgICAgICAgICAgLy8gSyA9IGludkkxICsgaW52STJcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICBsb3dlckFuZ2xlOiB0aGlzLm1fbG93ZXJBbmdsZSxcbiAgICAgICAgICAgICAgICB1cHBlckFuZ2xlOiB0aGlzLm1fdXBwZXJBbmdsZSxcbiAgICAgICAgICAgICAgICBtYXhNb3RvclRvcnF1ZTogdGhpcy5tX21heE1vdG9yVG9ycXVlLFxuICAgICAgICAgICAgICAgIG1vdG9yU3BlZWQ6IHRoaXMubV9tb3RvclNwZWVkLFxuICAgICAgICAgICAgICAgIGVuYWJsZUxpbWl0OiB0aGlzLm1fZW5hYmxlTGltaXQsXG4gICAgICAgICAgICAgICAgZW5hYmxlTW90b3I6IHRoaXMubV9lbmFibGVNb3RvcixcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUFuZ2xlOiB0aGlzLm1fcmVmZXJlbmNlQW5nbGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIHdvcmxkLCByZXN0b3JlKSB7XG4gICAgICAgICAgICBkYXRhID0gX19hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICAgICAgZGF0YS5ib2R5QSA9IHJlc3RvcmUoQm9keSwgZGF0YS5ib2R5QSwgd29ybGQpO1xuICAgICAgICAgICAgZGF0YS5ib2R5QiA9IHJlc3RvcmUoQm9keSwgZGF0YS5ib2R5Qiwgd29ybGQpO1xuICAgICAgICAgICAgdmFyIGpvaW50ID0gbmV3IFJldm9sdXRlSm9pbnQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuX3NldEFuY2hvcnMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmFuY2hvckEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLnNldFZlYzIodGhpcy5tX2JvZHlBLmdldExvY2FsUG9pbnQoZGVmLmFuY2hvckEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5sb2NhbEFuY2hvckEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLnNldFZlYzIoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmLmFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JCLnNldFZlYzIodGhpcy5tX2JvZHlCLmdldExvY2FsUG9pbnQoZGVmLmFuY2hvckIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5sb2NhbEFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JCLnNldFZlYzIoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlZmVyZW5jZSBhbmdsZS5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldFJlZmVyZW5jZUFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCBqb2ludCBhbmdsZSBpbiByYWRpYW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnRBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgICAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgICAgICAgIHJldHVybiBiQi5tX3N3ZWVwLmEgLSBiQS5tX3N3ZWVwLmEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgam9pbnQgYW5nbGUgc3BlZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnRTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgICAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgICAgICAgIHJldHVybiBiQi5tX2FuZ3VsYXJWZWxvY2l0eSAtIGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGpvaW50IG1vdG9yIGVuYWJsZWQ/XG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5pc01vdG9yRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTW90b3I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUvZGlzYWJsZSB0aGUgam9pbnQgbW90b3IuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICBpZiAoZmxhZyA9PSB0aGlzLm1fZW5hYmxlTW90b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCBtb3RvciB0b3JxdWUgZ2l2ZW4gdGhlIGludmVyc2UgdGltZSBzdGVwLiBVbml0IGlzIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldE1vdG9yVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9tb3RvckltcHVsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1vdG9yIHNwZWVkIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcbiAgICAgICAgICAgIGlmIChzcGVlZCA9PSB0aGlzLm1fbW90b3JTcGVlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fbW90b3JTcGVlZCA9IHNwZWVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtb3RvciBzcGVlZCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tb3RvclNwZWVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSwgdXN1YWxseSBpbiBOLW0uXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5zZXRNYXhNb3RvclRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcbiAgICAgICAgICAgIGlmICh0b3JxdWUgPT0gdGhpcy5tX21heE1vdG9yVG9ycXVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9tYXhNb3RvclRvcnF1ZSA9IHRvcnF1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0TWF4TW90b3JUb3JxdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21heE1vdG9yVG9ycXVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGpvaW50IGxpbWl0IGVuYWJsZWQ/XG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5pc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTGltaXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUvZGlzYWJsZSB0aGUgam9pbnQgbGltaXQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5lbmFibGVMaW1pdCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICBpZiAoZmxhZyAhPSB0aGlzLm1fZW5hYmxlTGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGZsYWc7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbG93ZXIgam9pbnQgbGltaXQgaW4gcmFkaWFucy5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldExvd2VyTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvd2VyQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHVwcGVyIGpvaW50IGxpbWl0IGluIHJhZGlhbnMuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5nZXRVcHBlckxpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV91cHBlckFuZ2xlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBqb2ludCBsaW1pdHMgaW4gcmFkaWFucy5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICAgICAgICAgIGlmIChsb3dlciAhPSB0aGlzLm1fbG93ZXJBbmdsZSB8fCB1cHBlciAhPSB0aGlzLm1fdXBwZXJBbmdsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG93ZXJBbmdsZSA9IGxvd2VyO1xuICAgICAgICAgICAgICAgIHRoaXMubV91cHBlckFuZ2xlID0gdXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QSBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIGdpdmVuIHRoZSBpbnZlcnNlIHRpbWUgc3RlcC4gVW5pdCBpcyBOLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWMyLm5lbyh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1faW1wdWxzZS55KS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIGR1ZSB0byB0aGUgam9pbnQgbGltaXQgZ2l2ZW4gdGhlIGludmVyc2UgdGltZSBzdGVwLlxuICAgICAgICAgKiBVbml0IGlzIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9pbXB1bHNlLno7XG4gICAgICAgIH07XG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludklBID0gdGhpcy5tX2JvZHlBLm1faW52STtcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQiA9IHRoaXMubV9ib2R5Qi5tX2ludkk7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgIHRoaXMubV9yQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tld11cbiAgICAgICAgICAgIC8vIFsgMCAtMSAwIDFdXG4gICAgICAgICAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cbiAgICAgICAgICAgIC8vIE1hdGxhYlxuICAgICAgICAgICAgLy8gSyA9IFsgbUErcjF5XjIqaUErbUIrcjJ5XjIqaUIsIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIC1yMXkqaUEtcjJ5KmlCXVxuICAgICAgICAgICAgLy8gWyAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCBtQStyMXheMippQSttQityMnheMippQiwgcjF4KmlBK3IyeCppQl1cbiAgICAgICAgICAgIC8vIFsgLXIxeSppQS1yMnkqaUIsIHIxeCppQStyMngqaUIsIGlBK2lCXVxuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgICAgdmFyIGZpeGVkUm90YXRpb24gPSAoaUEgKyBpQiA9PT0gMC4wKTtcbiAgICAgICAgICAgIHRoaXMubV9tYXNzLmV4LnggPSBtQSArIG1CICsgdGhpcy5tX3JBLnkgKiB0aGlzLm1fckEueSAqIGlBICsgdGhpcy5tX3JCLnkgKiB0aGlzLm1fckIueSAqIGlCO1xuICAgICAgICAgICAgdGhpcy5tX21hc3MuZXkueCA9IC10aGlzLm1fckEueSAqIHRoaXMubV9yQS54ICogaUEgLSB0aGlzLm1fckIueSAqIHRoaXMubV9yQi54ICogaUI7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcy5lei54ID0gLXRoaXMubV9yQS55ICogaUEgLSB0aGlzLm1fckIueSAqIGlCO1xuICAgICAgICAgICAgdGhpcy5tX21hc3MuZXgueSA9IHRoaXMubV9tYXNzLmV5Lng7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcy5leS55ID0gbUEgKyBtQiArIHRoaXMubV9yQS54ICogdGhpcy5tX3JBLnggKiBpQSArIHRoaXMubV9yQi54ICogdGhpcy5tX3JCLnggKiBpQjtcbiAgICAgICAgICAgIHRoaXMubV9tYXNzLmV6LnkgPSB0aGlzLm1fckEueCAqIGlBICsgdGhpcy5tX3JCLnggKiBpQjtcbiAgICAgICAgICAgIHRoaXMubV9tYXNzLmV4LnogPSB0aGlzLm1fbWFzcy5lei54O1xuICAgICAgICAgICAgdGhpcy5tX21hc3MuZXkueiA9IHRoaXMubV9tYXNzLmV6Lnk7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcy5lei56ID0gaUEgKyBpQjtcbiAgICAgICAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSBpQSArIGlCO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9tb3Rvck1hc3MgPiAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gMS4wIC8gdGhpcy5tX21vdG9yTWFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgPT0gZmFsc2UgfHwgZml4ZWRSb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0ICYmIGZpeGVkUm90YXRpb24gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgam9pbnRBbmdsZSA9IGFCIC0gYUEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhfYWJzJDQodGhpcy5tX3VwcGVyQW5nbGUgLSB0aGlzLm1fbG93ZXJBbmdsZSkgPCAyLjAgKiBTZXR0aW5nc0ludGVybmFsLmFuZ3VsYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gTGltaXRTdGF0ZSQyLmVxdWFsTGltaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqb2ludEFuZ2xlIDw9IHRoaXMubV9sb3dlckFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlJDIuYXRMb3dlckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gTGltaXRTdGF0ZSQyLmF0TG93ZXJMaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRBbmdsZSA+PSB0aGlzLm1fdXBwZXJBbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZSQyLmF0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUkMi5hdFVwcGVyTGltaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUkMi5pbmFjdGl2ZUxpbWl0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gTGltaXRTdGF0ZSQyLmluYWN0aXZlTGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSBpbXB1bHNlcyB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLm11bChzdGVwLmR0UmF0aW8pO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5uZW8odGhpcy5tX2ltcHVsc2UueCwgdGhpcy5tX2ltcHVsc2UueSk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBQKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIChWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCBQKSArIHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogKFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIFApICsgdGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2Uuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIFJldm9sdXRlSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgICAgdmFyIGZpeGVkUm90YXRpb24gPSAoaUEgKyBpQiA9PT0gMC4wKTtcbiAgICAgICAgICAgIC8vIFNvbHZlIG1vdG9yIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yICYmIHRoaXMubV9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUkMi5lcXVhbExpbWl0cyAmJiBmaXhlZFJvdGF0aW9uID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSB3QiAtIHdBIC0gdGhpcy5tX21vdG9yU3BlZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX21vdG9yTWFzcyAqIENkb3Q7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gY2xhbXAodGhpcy5tX21vdG9ySW1wdWxzZSArIGltcHVsc2UsIC1tYXhJbXB1bHNlLCBtYXhJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZSAtIG9sZEltcHVsc2U7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogaW1wdWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbHZlIGxpbWl0IGNvbnN0cmFpbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0ICYmIHRoaXMubV9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUkMi5pbmFjdGl2ZUxpbWl0ICYmIGZpeGVkUm90YXRpb24gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdDEgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgICAgICBDZG90MS5hZGRDb21iaW5lKDEsIHZCLCAxLCBWZWMyLmNyb3NzTnVtVmVjMih3QiwgdGhpcy5tX3JCKSk7XG4gICAgICAgICAgICAgICAgQ2RvdDEuc3ViQ29tYmluZSgxLCB2QSwgMSwgVmVjMi5jcm9zc051bVZlYzIod0EsIHRoaXMubV9yQSkpO1xuICAgICAgICAgICAgICAgIHZhciBDZG90MiA9IHdCIC0gd0E7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSBuZXcgVmVjMyhDZG90MS54LCBDZG90MS55LCBDZG90Mik7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBWZWMzLm5lZyh0aGlzLm1fbWFzcy5zb2x2ZTMzKENkb3QpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZSQyLmVxdWFsTGltaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZSQyLmF0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlLnogKyBpbXB1bHNlLno7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbXB1bHNlIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmhzID0gVmVjMi5jb21iaW5lKC0xLCBDZG90MSwgdGhpcy5tX2ltcHVsc2UueiwgVmVjMi5uZW8odGhpcy5tX21hc3MuZXoueCwgdGhpcy5tX21hc3MuZXoueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZHVjZWQgPSB0aGlzLm1fbWFzcy5zb2x2ZTIyKHJocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnggPSByZWR1Y2VkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnkgPSByZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnogPSAtdGhpcy5tX2ltcHVsc2UuejtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gcmVkdWNlZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSByZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IExpbWl0U3RhdGUkMi5hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ltcHVsc2UgPSB0aGlzLm1faW1wdWxzZS56ICsgaW1wdWxzZS56O1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW1wdWxzZSA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJocyA9IFZlYzIuY29tYmluZSgtMSwgQ2RvdDEsIHRoaXMubV9pbXB1bHNlLnosIFZlYzIubmVvKHRoaXMubV9tYXNzLmV6LngsIHRoaXMubV9tYXNzLmV6LnkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkID0gdGhpcy5tX21hc3Muc29sdmUyMihyaHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS54ID0gcmVkdWNlZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS55ID0gcmVkdWNlZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS56ID0gLXRoaXMubV9pbXB1bHNlLno7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS54ICs9IHJlZHVjZWQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gcmVkdWNlZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVvKGltcHVsc2UueCwgaW1wdWxzZS55KTtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogKFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIFApICsgaW1wdWxzZS56KTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogKFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIFApICsgaW1wdWxzZS56KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIENkb3QuYWRkQ29tYmluZSgxLCB2QiwgMSwgVmVjMi5jcm9zc051bVZlYzIod0IsIHRoaXMubV9yQikpO1xuICAgICAgICAgICAgICAgIENkb3Quc3ViQ29tYmluZSgxLCB2QSwgMSwgVmVjMi5jcm9zc051bVZlYzIod0EsIHRoaXMubV9yQSkpO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5tX21hc3Muc29sdmUyMihWZWMyLm5lZyhDZG90KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSBpbXB1bHNlLng7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSBpbXB1bHNlLnk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIGltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYgPSB2QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBlcnJvcnMgYXJlIHdpdGhpbiB0b2xlcmFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB2YXIgYW5ndWxhckVycm9yID0gMC4wO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uRXJyb3IgPSAwLjA7XG4gICAgICAgICAgICB2YXIgZml4ZWRSb3RhdGlvbiA9ICh0aGlzLm1faW52SUEgKyB0aGlzLm1faW52SUIgPT0gMC4wKTtcbiAgICAgICAgICAgIC8vIFNvbHZlIGFuZ3VsYXIgbGltaXQgY29uc3RyYWludC5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZSQyLmluYWN0aXZlTGltaXQgJiYgZml4ZWRSb3RhdGlvbiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IGFCIC0gYUEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0SW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZSQyLmVxdWFsTGltaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICB2YXIgQyA9IGNsYW1wKGFuZ2xlIC0gdGhpcy5tX2xvd2VyQW5nbGUsIC1TZXR0aW5nc0ludGVybmFsLm1heEFuZ3VsYXJDb3JyZWN0aW9uLCBTZXR0aW5nc0ludGVybmFsLm1heEFuZ3VsYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLXRoaXMubV9tb3Rvck1hc3MgKiBDO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBtYXRoX2FicyQ0KEMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlJDIuYXRMb3dlckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBDID0gYW5nbGUgLSB0aGlzLm1fbG93ZXJBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhckVycm9yID0gLUM7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxuICAgICAgICAgICAgICAgICAgICBDID0gY2xhbXAoQyArIFNldHRpbmdzSW50ZXJuYWwuYW5ndWxhclNsb3AsIC1TZXR0aW5nc0ludGVybmFsLm1heEFuZ3VsYXJDb3JyZWN0aW9uLCAwLjApO1xuICAgICAgICAgICAgICAgICAgICBsaW1pdEltcHVsc2UgPSAtdGhpcy5tX21vdG9yTWFzcyAqIEM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IExpbWl0U3RhdGUkMi5hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEMgPSBhbmdsZSAtIHRoaXMubV91cHBlckFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBDO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cbiAgICAgICAgICAgICAgICAgICAgQyA9IGNsYW1wKEMgLSBTZXR0aW5nc0ludGVybmFsLmFuZ3VsYXJTbG9wLCAwLjAsIFNldHRpbmdzSW50ZXJuYWwubWF4QW5ndWxhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBsaW1pdEltcHVsc2UgPSAtdGhpcy5tX21vdG9yTWFzcyAqIEM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFBIC09IHRoaXMubV9pbnZJQSAqIGxpbWl0SW1wdWxzZTtcbiAgICAgICAgICAgICAgICBhQiArPSB0aGlzLm1faW52SUIgKiBsaW1pdEltcHVsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb2x2ZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50LlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHFBLnNldEFuZ2xlKGFBKTtcbiAgICAgICAgICAgICAgICBxQi5zZXRBbmdsZShhQik7XG4gICAgICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgICAgIHZhciBDID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgQy5hZGRDb21iaW5lKDEsIGNCLCAxLCByQik7XG4gICAgICAgICAgICAgICAgQy5zdWJDb21iaW5lKDEsIGNBLCAxLCByQSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25FcnJvciA9IEMubGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgICAgICAgIHZhciBLID0gbmV3IE1hdDIyKCk7XG4gICAgICAgICAgICAgICAgSy5leC54ID0gbUEgKyBtQiArIGlBICogckEueSAqIHJBLnkgKyBpQiAqIHJCLnkgKiByQi55O1xuICAgICAgICAgICAgICAgIEsuZXgueSA9IC1pQSAqIHJBLnggKiByQS55IC0gaUIgKiByQi54ICogckIueTtcbiAgICAgICAgICAgICAgICBLLmV5LnggPSBLLmV4Lnk7XG4gICAgICAgICAgICAgICAgSy5leS55ID0gbUEgKyBtQiArIGlBICogckEueCAqIHJBLnggKyBpQiAqIHJCLnggKiByQi54O1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gVmVjMi5uZWcoSy5zb2x2ZShDKSk7XG4gICAgICAgICAgICAgICAgY0Euc3ViTXVsKG1BLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICBhQSAtPSBpQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgY0IuYWRkTXVsKG1CLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICBhQiArPSBpQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jLnNldFZlYzIoY0EpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IFNldHRpbmdzSW50ZXJuYWwubGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gU2V0dGluZ3NJbnRlcm5hbC5hbmd1bGFyU2xvcDtcbiAgICAgICAgfTtcbiAgICAgICAgUmV2b2x1dGVKb2ludC5UWVBFID0gJ3Jldm9sdXRlLWpvaW50JztcbiAgICAgICAgcmV0dXJuIFJldm9sdXRlSm9pbnQ7XG4gICAgfShKb2ludCkpO1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfYWJzJDMgPSBNYXRoLmFicztcbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX21heCA9IE1hdGgubWF4O1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfbWluJDIgPSBNYXRoLm1pbjtcbiAgICAvKiogQGludGVybmFsICovIHZhciBMaW1pdFN0YXRlJDE7XG4gICAgKGZ1bmN0aW9uIChMaW1pdFN0YXRlKSB7XG4gICAgICAgIExpbWl0U3RhdGVbTGltaXRTdGF0ZVtcImluYWN0aXZlTGltaXRcIl0gPSAwXSA9IFwiaW5hY3RpdmVMaW1pdFwiO1xuICAgICAgICBMaW1pdFN0YXRlW0xpbWl0U3RhdGVbXCJhdExvd2VyTGltaXRcIl0gPSAxXSA9IFwiYXRMb3dlckxpbWl0XCI7XG4gICAgICAgIExpbWl0U3RhdGVbTGltaXRTdGF0ZVtcImF0VXBwZXJMaW1pdFwiXSA9IDJdID0gXCJhdFVwcGVyTGltaXRcIjtcbiAgICAgICAgTGltaXRTdGF0ZVtMaW1pdFN0YXRlW1wiZXF1YWxMaW1pdHNcIl0gPSAzXSA9IFwiZXF1YWxMaW1pdHNcIjtcbiAgICB9KShMaW1pdFN0YXRlJDEgfHwgKExpbWl0U3RhdGUkMSA9IHt9KSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgREVGQVVMVFMkNyA9IHtcbiAgICAgICAgZW5hYmxlTGltaXQ6IGZhbHNlLFxuICAgICAgICBsb3dlclRyYW5zbGF0aW9uOiAwLjAsXG4gICAgICAgIHVwcGVyVHJhbnNsYXRpb246IDAuMCxcbiAgICAgICAgZW5hYmxlTW90b3I6IGZhbHNlLFxuICAgICAgICBtYXhNb3RvckZvcmNlOiAwLjAsXG4gICAgICAgIG1vdG9yU3BlZWQ6IDAuMFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBwcmlzbWF0aWMgam9pbnQuIFRoaXMgam9pbnQgcHJvdmlkZXMgb25lIGRlZ3JlZSBvZiBmcmVlZG9tOiB0cmFuc2xhdGlvblxuICAgICAqIGFsb25nIGFuIGF4aXMgZml4ZWQgaW4gYm9keUEuIFJlbGF0aXZlIHJvdGF0aW9uIGlzIHByZXZlbnRlZC4gWW91IGNhbiB1c2UgYVxuICAgICAqIGpvaW50IGxpbWl0IHRvIHJlc3RyaWN0IHRoZSByYW5nZSBvZiBtb3Rpb24gYW5kIGEgam9pbnQgbW90b3IgdG8gZHJpdmUgdGhlXG4gICAgICogbW90aW9uIG9yIHRvIG1vZGVsIGpvaW50IGZyaWN0aW9uLlxuICAgICAqL1xuICAgIHZhciBQcmlzbWF0aWNKb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFByaXNtYXRpY0pvaW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBQcmlzbWF0aWNKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yLCBheGlzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBQcmlzbWF0aWNKb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByaXNtYXRpY0pvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBhbmNob3IsIGF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmID0gb3B0aW9ucyhkZWYsIERFRkFVTFRTJDcpO1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIGJvZHlBLCBib2R5QikgfHwgdGhpcztcbiAgICAgICAgICAgIGJvZHlBID0gX3RoaXMubV9ib2R5QTtcbiAgICAgICAgICAgIGJvZHlCID0gX3RoaXMubV9ib2R5QjtcbiAgICAgICAgICAgIF90aGlzLm1fdHlwZSA9IFByaXNtYXRpY0pvaW50LlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUEuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQiA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUIuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQiB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsWEF4aXNBID0gVmVjMi5jbG9uZShheGlzID8gYm9keUEuZ2V0TG9jYWxWZWN0b3IoYXhpcykgOiBkZWYubG9jYWxBeGlzQSB8fCBWZWMyLm5lbygxLjAsIDAuMCkpO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbFhBeGlzQS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxZQXhpc0EgPSBWZWMyLmNyb3NzTnVtVmVjMigxLjAsIF90aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgICAgICAgICAgX3RoaXMubV9yZWZlcmVuY2VBbmdsZSA9IE51bWJlci5pc0Zpbml0ZShkZWYucmVmZXJlbmNlQW5nbGUpID8gZGVmLnJlZmVyZW5jZUFuZ2xlIDogYm9keUIuZ2V0QW5nbGUoKSAtIGJvZHlBLmdldEFuZ2xlKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2ltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgX3RoaXMubV9tb3Rvck1hc3MgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiA9IGRlZi5sb3dlclRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgX3RoaXMubV91cHBlclRyYW5zbGF0aW9uID0gZGVmLnVwcGVyVHJhbnNsYXRpb247XG4gICAgICAgICAgICBfdGhpcy5tX21heE1vdG9yRm9yY2UgPSBkZWYubWF4TW90b3JGb3JjZTtcbiAgICAgICAgICAgIF90aGlzLm1fbW90b3JTcGVlZCA9IGRlZi5tb3RvclNwZWVkO1xuICAgICAgICAgICAgX3RoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcbiAgICAgICAgICAgIF90aGlzLm1fZW5hYmxlTW90b3IgPSBkZWYuZW5hYmxlTW90b3I7XG4gICAgICAgICAgICBfdGhpcy5tX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlJDEuaW5hY3RpdmVMaW1pdDtcbiAgICAgICAgICAgIF90aGlzLm1fYXhpcyA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV9wZXJwID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX0sgPSBuZXcgTWF0MzMoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIC8vIExpbmVhciBjb25zdHJhaW50IChwb2ludC10by1saW5lKVxuICAgICAgICAgICAgLy8gZCA9IHAyIC0gcDEgPSB4MiArIHIyIC0geDEgLSByMVxuICAgICAgICAgICAgLy8gQyA9IGRvdChwZXJwLCBkKVxuICAgICAgICAgICAgLy8gQ2RvdCA9IGRvdChkLCBjcm9zcyh3MSwgcGVycCkpICsgZG90KHBlcnAsIHYyICsgY3Jvc3ModzIsIHIyKSAtIHYxIC1cbiAgICAgICAgICAgIC8vIGNyb3NzKHcxLCByMSkpXG4gICAgICAgICAgICAvLyA9IC1kb3QocGVycCwgdjEpIC0gZG90KGNyb3NzKGQgKyByMSwgcGVycCksIHcxKSArIGRvdChwZXJwLCB2MikgK1xuICAgICAgICAgICAgLy8gZG90KGNyb3NzKHIyLCBwZXJwKSwgdjIpXG4gICAgICAgICAgICAvLyBKID0gWy1wZXJwLCAtY3Jvc3MoZCArIHIxLCBwZXJwKSwgcGVycCwgY3Jvc3MocjIscGVycCldXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQW5ndWxhciBjb25zdHJhaW50XG4gICAgICAgICAgICAvLyBDID0gYTIgLSBhMSArIGFfaW5pdGlhbFxuICAgICAgICAgICAgLy8gQ2RvdCA9IHcyIC0gdzFcbiAgICAgICAgICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEsgPSBKICogaW52TSAqIEpUXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSiA9IFstYSAtczEgYSBzMl1cbiAgICAgICAgICAgIC8vIFswIC0xIDAgMV1cbiAgICAgICAgICAgIC8vIGEgPSBwZXJwXG4gICAgICAgICAgICAvLyBzMSA9IGNyb3NzKGQgKyByMSwgYSkgPSBjcm9zcyhwMiAtIHgxLCBhKVxuICAgICAgICAgICAgLy8gczIgPSBjcm9zcyhyMiwgYSkgPSBjcm9zcyhwMiAtIHgyLCBhKVxuICAgICAgICAgICAgLy8gTW90b3IvTGltaXQgbGluZWFyIGNvbnN0cmFpbnRcbiAgICAgICAgICAgIC8vIEMgPSBkb3QoYXgxLCBkKVxuICAgICAgICAgICAgLy8gQ2RvdCA9ID0gLWRvdChheDEsIHYxKSAtIGRvdChjcm9zcyhkICsgcjEsIGF4MSksIHcxKSArIGRvdChheDEsIHYyKSArXG4gICAgICAgICAgICAvLyBkb3QoY3Jvc3MocjIsIGF4MSksIHYyKVxuICAgICAgICAgICAgLy8gSiA9IFstYXgxIC1jcm9zcyhkK3IxLGF4MSkgYXgxIGNyb3NzKHIyLGF4MSldXG4gICAgICAgICAgICAvLyBCbG9jayBTb2x2ZXJcbiAgICAgICAgICAgIC8vIFdlIGRldmVsb3AgYSBibG9jayBzb2x2ZXIgdGhhdCBpbmNsdWRlcyB0aGUgam9pbnQgbGltaXQuIFRoaXMgbWFrZXMgdGhlXG4gICAgICAgICAgICAvLyBsaW1pdCBzdGlmZiAoaW5lbGFzdGljKSBldmVuXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBtYXNzIGhhcyBwb29yIGRpc3RyaWJ1dGlvbiAobGVhZGluZyB0byBsYXJnZSB0b3JxdWVzIGFib3V0IHRoZVxuICAgICAgICAgICAgLy8gam9pbnQgYW5jaG9yIHBvaW50cykuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIEphY29iaWFuIGhhcyAzIHJvd3M6XG4gICAgICAgICAgICAvLyBKID0gWy11VCAtczEgdVQgczJdIC8vIGxpbmVhclxuICAgICAgICAgICAgLy8gWzAgLTEgMCAxXSAvLyBhbmd1bGFyXG4gICAgICAgICAgICAvLyBbLXZUIC1hMSB2VCBhMl0gLy8gbGltaXRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1ID0gcGVycFxuICAgICAgICAgICAgLy8gdiA9IGF4aXNcbiAgICAgICAgICAgIC8vIHMxID0gY3Jvc3MoZCArIHIxLCB1KSwgczIgPSBjcm9zcyhyMiwgdSlcbiAgICAgICAgICAgIC8vIGExID0gY3Jvc3MoZCArIHIxLCB2KSwgYTIgPSBjcm9zcyhyMiwgdilcbiAgICAgICAgICAgIC8vIE0gKiAodjIgLSB2MSkgPSBKVCAqIGRmXG4gICAgICAgICAgICAvLyBKICogdjIgPSBiaWFzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdjIgPSB2MSArIGludk0gKiBKVCAqIGRmXG4gICAgICAgICAgICAvLyBKICogKHYxICsgaW52TSAqIEpUICogZGYpID0gYmlhc1xuICAgICAgICAgICAgLy8gSyAqIGRmID0gYmlhcyAtIEogKiB2MSA9IC1DZG90XG4gICAgICAgICAgICAvLyBLID0gSiAqIGludk0gKiBKVFxuICAgICAgICAgICAgLy8gQ2RvdCA9IEogKiB2MSAtIGJpYXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBOb3cgc29sdmUgZm9yIGYyLlxuICAgICAgICAgICAgLy8gZGYgPSBmMiAtIGYxXG4gICAgICAgICAgICAvLyBLICogKGYyIC0gZjEpID0gLUNkb3RcbiAgICAgICAgICAgIC8vIGYyID0gaW52SyAqICgtQ2RvdCkgKyBmMVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENsYW1wIGFjY3VtdWxhdGVkIGxpbWl0IGltcHVsc2UuXG4gICAgICAgICAgICAvLyBsb3dlcjogZjIoMykgPSBtYXgoZjIoMyksIDApXG4gICAgICAgICAgICAvLyB1cHBlcjogZjIoMykgPSBtaW4oZjIoMyksIDApXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU29sdmUgZm9yIGNvcnJlY3QgZjIoMToyKVxuICAgICAgICAgICAgLy8gSygxOjIsIDE6MikgKiBmMigxOjIpID0gLUNkb3QoMToyKSAtIEsoMToyLDMpICogZjIoMykgKyBLKDE6MiwxOjMpICogZjFcbiAgICAgICAgICAgIC8vID0gLUNkb3QoMToyKSAtIEsoMToyLDMpICogZjIoMykgKyBLKDE6MiwxOjIpICogZjEoMToyKSArIEsoMToyLDMpICogZjEoMylcbiAgICAgICAgICAgIC8vIEsoMToyLCAxOjIpICogZjIoMToyKSA9IC1DZG90KDE6MikgLSBLKDE6MiwzKSAqIChmMigzKSAtIGYxKDMpKSArXG4gICAgICAgICAgICAvLyBLKDE6MiwxOjIpICogZjEoMToyKVxuICAgICAgICAgICAgLy8gZjIoMToyKSA9IGludksoMToyLDE6MikgKiAoLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpKSArXG4gICAgICAgICAgICAvLyBmMSgxOjIpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTm93IGNvbXB1dGUgaW1wdWxzZSB0byBiZSBhcHBsaWVkOlxuICAgICAgICAgICAgLy8gZGYgPSBmMiAtIGYxXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgYm9keUE6IHRoaXMubV9ib2R5QSxcbiAgICAgICAgICAgICAgICBib2R5QjogdGhpcy5tX2JvZHlCLFxuICAgICAgICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkLFxuICAgICAgICAgICAgICAgIGxvd2VyVHJhbnNsYXRpb246IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uLFxuICAgICAgICAgICAgICAgIHVwcGVyVHJhbnNsYXRpb246IHRoaXMubV91cHBlclRyYW5zbGF0aW9uLFxuICAgICAgICAgICAgICAgIG1heE1vdG9yRm9yY2U6IHRoaXMubV9tYXhNb3RvckZvcmNlLFxuICAgICAgICAgICAgICAgIG1vdG9yU3BlZWQ6IHRoaXMubV9tb3RvclNwZWVkLFxuICAgICAgICAgICAgICAgIGVuYWJsZUxpbWl0OiB0aGlzLm1fZW5hYmxlTGltaXQsXG4gICAgICAgICAgICAgICAgZW5hYmxlTW90b3I6IHRoaXMubV9lbmFibGVNb3RvcixcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgICAgIGxvY2FsQXhpc0E6IHRoaXMubV9sb2NhbFhBeGlzQSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VBbmdsZTogdGhpcy5tX3JlZmVyZW5jZUFuZ2xlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmxvY2FsQXhpc0EgPSBWZWMyLmNsb25lKGRhdGEubG9jYWxBeGlzQSk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgUHJpc21hdGljSm9pbnQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLl9zZXRBbmNob3JzID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKHRoaXMubV9ib2R5QS5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JBKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKHRoaXMubV9ib2R5Qi5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JCKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5sb2NhbEF4aXNBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsWEF4aXNBLnNldFZlYzIoZGVmLmxvY2FsQXhpc0EpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbFlBeGlzQS5zZXRWZWMyKFZlYzIuY3Jvc3NOdW1WZWMyKDEuMCwgZGVmLmxvY2FsQXhpc0EpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sb2NhbEFuY2hvckE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvY2FsIGpvaW50IGF4aXMgcmVsYXRpdmUgdG8gYm9keUEuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBeGlzQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxYQXhpc0E7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlZmVyZW5jZSBhbmdsZS5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRSZWZlcmVuY2VBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgam9pbnQgdHJhbnNsYXRpb24sIHVzdWFsbHkgaW4gbWV0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldEpvaW50VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcEEgPSB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbiAgICAgICAgICAgIHZhciBwQiA9IHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgdmFyIGQgPSBWZWMyLnN1YihwQiwgcEEpO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLm1fYm9keUEuZ2V0V29ybGRWZWN0b3IodGhpcy5tX2xvY2FsWEF4aXNBKTtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IFZlYzIuZG90KGQsIGF4aXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGpvaW50IHRyYW5zbGF0aW9uIHNwZWVkLCB1c3VhbGx5IGluIG1ldGVycyBwZXIgc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldEpvaW50U3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICAgICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsVmVjMihiQS5tX3hmLnEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIpKTtcbiAgICAgICAgICAgIHZhciByQiA9IFJvdC5tdWxWZWMyKGJCLm1feGYucSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgYkIubV9zd2VlcC5sb2NhbENlbnRlcikpO1xuICAgICAgICAgICAgdmFyIHAxID0gVmVjMi5hZGQoYkEubV9zd2VlcC5jLCByQSk7XG4gICAgICAgICAgICB2YXIgcDIgPSBWZWMyLmFkZChiQi5tX3N3ZWVwLmMsIHJCKTtcbiAgICAgICAgICAgIHZhciBkID0gVmVjMi5zdWIocDIsIHAxKTtcbiAgICAgICAgICAgIHZhciBheGlzID0gUm90Lm11bFZlYzIoYkEubV94Zi5xLCB0aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgICAgICAgICAgdmFyIHZBID0gYkEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgICAgICAgIHZhciB2QiA9IGJCLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgd0EgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgICAgIHZhciB3QiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgdmFyIHNwZWVkID0gVmVjMi5kb3QoZCwgVmVjMi5jcm9zc051bVZlYzIod0EsIGF4aXMpKSArIFZlYzIuZG90KGF4aXMsIFZlYzIuc3ViKFZlYzIuYWRkQ3Jvc3NOdW1WZWMyKHZCLCB3QiwgckIpLCBWZWMyLmFkZENyb3NzTnVtVmVjMih2QSwgd0EsIHJBKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHNwZWVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIGpvaW50IGxpbWl0IGVuYWJsZWQ/XG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuaXNMaW1pdEVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2VuYWJsZUxpbWl0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgdGhlIGpvaW50IGxpbWl0LlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmVuYWJsZUxpbWl0ID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIGlmIChmbGFnICE9IHRoaXMubV9lbmFibGVMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZmxhZztcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsb3dlciBqb2ludCBsaW1pdCwgdXN1YWxseSBpbiBtZXRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0TG93ZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdXBwZXIgam9pbnQgbGltaXQsIHVzdWFsbHkgaW4gbWV0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldFVwcGVyTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGpvaW50IGxpbWl0cywgdXN1YWxseSBpbiBtZXRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuc2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgICAgICAgICAgaWYgKGxvd2VyICE9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uIHx8IHVwcGVyICE9IHRoaXMubV91cHBlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiA9IGxvd2VyO1xuICAgICAgICAgICAgICAgIHRoaXMubV91cHBlclRyYW5zbGF0aW9uID0gdXBwZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBqb2ludCBtb3RvciBlbmFibGVkP1xuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmlzTW90b3JFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVNb3RvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIHRoZSBqb2ludCBtb3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgICAgICBpZiAoZmxhZyA9PSB0aGlzLm1fZW5hYmxlTW90b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZmxhZztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbW90b3Igc3BlZWQsIHVzdWFsbHkgaW4gbWV0ZXJzIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCkge1xuICAgICAgICAgICAgaWYgKHNwZWVkID09IHRoaXMubV9tb3RvclNwZWVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV9tb3RvclNwZWVkID0gc3BlZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1heGltdW0gbW90b3IgZm9yY2UsIHVzdWFsbHkgaW4gTi5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5zZXRNYXhNb3RvckZvcmNlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2UgPT0gdGhpcy5tX21heE1vdG9yRm9yY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX21heE1vdG9yRm9yY2UgPSBmb3JjZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21heE1vdG9yRm9yY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG1vdG9yIHNwZWVkLCB1c3VhbGx5IGluIG1ldGVycyBwZXIgc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX21vdG9yU3BlZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbW90b3IgZm9yY2UgZ2l2ZW4gdGhlIGludmVyc2UgdGltZSBzdGVwLCB1c3VhbGx5IGluIE4uXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0TW90b3JGb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlCIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIuY29tYmluZSh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1fcGVycCwgdGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnosIHRoaXMubV9heGlzKS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIFByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS55O1xuICAgICAgICB9O1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52SUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzZXMuXG4gICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIHZhciBkID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBkLmFkZENvbWJpbmUoMSwgY0IsIDEsIHJCKTtcbiAgICAgICAgICAgIGQuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpO1xuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtb3RvciBKYWNvYmlhbiBhbmQgZWZmZWN0aXZlIG1hc3MuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2F4aXMgPSBSb3QubXVsVmVjMihxQSwgdGhpcy5tX2xvY2FsWEF4aXNBKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYTEgPSBWZWMyLmNyb3NzVmVjMlZlYzIoVmVjMi5hZGQoZCwgckEpLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2EyID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIGlCICogdGhpcy5tX2EyXG4gICAgICAgICAgICAgICAgICAgICogdGhpcy5tX2EyO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1fbW90b3JNYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAxLjAgLyB0aGlzLm1fbW90b3JNYXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByaXNtYXRpYyBjb25zdHJhaW50LlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMubV9wZXJwID0gUm90Lm11bFZlYzIocUEsIHRoaXMubV9sb2NhbFlBeGlzQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3MxID0gVmVjMi5jcm9zc1ZlYzJWZWMyKFZlYzIuYWRkKGQsIHJBKSwgdGhpcy5tX3BlcnApO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zMiA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgdGhpcy5tX3BlcnApO1xuICAgICAgICAgICAgICAgIFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgdGhpcy5tX3BlcnApO1xuICAgICAgICAgICAgICAgIHZhciBrMTEgPSBtQSArIG1CICsgaUEgKiB0aGlzLm1fczEgKiB0aGlzLm1fczEgKyBpQiAqIHRoaXMubV9zMiAqIHRoaXMubV9zMjtcbiAgICAgICAgICAgICAgICB2YXIgazEyID0gaUEgKiB0aGlzLm1fczEgKyBpQiAqIHRoaXMubV9zMjtcbiAgICAgICAgICAgICAgICB2YXIgazEzID0gaUEgKiB0aGlzLm1fczEgKiB0aGlzLm1fYTEgKyBpQiAqIHRoaXMubV9zMiAqIHRoaXMubV9hMjtcbiAgICAgICAgICAgICAgICB2YXIgazIyID0gaUEgKyBpQjtcbiAgICAgICAgICAgICAgICBpZiAoazIyID09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYm9kaWVzIHdpdGggZml4ZWQgcm90YXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGsyMiA9IDEuMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGsyMyA9IGlBICogdGhpcy5tX2ExICsgaUIgKiB0aGlzLm1fYTI7XG4gICAgICAgICAgICAgICAgdmFyIGszMyA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIGlCICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgICAgICAgIHRoaXMubV9LLmV4LnNldChrMTEsIGsxMiwgazEzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fSy5leS5zZXQoazEyLCBrMjIsIGsyMyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0suZXouc2V0KGsxMywgazIzLCBrMzMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtb3RvciBhbmQgbGltaXQgdGVybXMuXG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGpvaW50VHJhbnNsYXRpb24gPSBWZWMyLmRvdCh0aGlzLm1fYXhpcywgZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhfYWJzJDModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlJDEuZXF1YWxMaW1pdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpvaW50VHJhbnNsYXRpb24gPD0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUkMS5hdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gTGltaXRTdGF0ZSQxLmF0TG93ZXJMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2xhdGlvbiA+PSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZSQxLmF0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlJDEuYXRVcHBlckxpbWl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlJDEuaW5hY3RpdmVMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUkMS5pbmFjdGl2ZUxpbWl0O1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5tdWwoc3RlcC5kdFJhdGlvKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIuY29tYmluZSh0aGlzLm1faW1wdWxzZS54LCB0aGlzLm1fcGVycCwgdGhpcy5tX21vdG9ySW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICArIHRoaXMubV9pbXB1bHNlLnosIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgTEEgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MxICsgdGhpcy5tX2ltcHVsc2UueVxuICAgICAgICAgICAgICAgICAgICArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYTE7XG4gICAgICAgICAgICAgICAgdmFyIExCID0gdGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9zMiArIHRoaXMubV9pbXB1bHNlLnlcbiAgICAgICAgICAgICAgICAgICAgKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopICogdGhpcy5tX2EyO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBMQTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogTEI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2QSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgbW90b3IgY29uc3RyYWludC5cbiAgICAgICAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZSQxLmVxdWFsTGltaXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSBWZWMyLmRvdCh0aGlzLm1fYXhpcywgVmVjMi5zdWIodkIsIHZBKSkgKyB0aGlzLm1fYTIgKiB3QlxuICAgICAgICAgICAgICAgICAgICAtIHRoaXMubV9hMSAqIHdBO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5tX21vdG9yTWFzcyAqICh0aGlzLm1fbW90b3JTcGVlZCAtIENkb3QpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4TW90b3JGb3JjZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gY2xhbXAodGhpcy5tX21vdG9ySW1wdWxzZSArIGltcHVsc2UsIC1tYXhJbXB1bHNlLCBtYXhJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZSAtIG9sZEltcHVsc2U7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm11bE51bVZlYzIoaW1wdWxzZSwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgICAgIHZhciBMQSA9IGltcHVsc2UgKiB0aGlzLm1fYTE7XG4gICAgICAgICAgICAgICAgdmFyIExCID0gaW1wdWxzZSAqIHRoaXMubV9hMjtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIExCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIENkb3QxID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBDZG90MS54ICs9IFZlYzIuZG90KHRoaXMubV9wZXJwLCB2QikgKyB0aGlzLm1fczIgKiB3QjtcbiAgICAgICAgICAgIENkb3QxLnggLT0gVmVjMi5kb3QodGhpcy5tX3BlcnAsIHZBKSArIHRoaXMubV9zMSAqIHdBO1xuICAgICAgICAgICAgQ2RvdDEueSA9IHdCIC0gd0E7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0ICYmIHRoaXMubV9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUkMS5pbmFjdGl2ZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgLy8gU29sdmUgcHJpc21hdGljIGFuZCBsaW1pdCBjb25zdHJhaW50IGluIGJsb2NrIGZvcm0uXG4gICAgICAgICAgICAgICAgdmFyIENkb3QyID0gMDtcbiAgICAgICAgICAgICAgICBDZG90MiArPSBWZWMyLmRvdCh0aGlzLm1fYXhpcywgdkIpICsgdGhpcy5tX2EyICogd0I7XG4gICAgICAgICAgICAgICAgQ2RvdDIgLT0gVmVjMi5kb3QodGhpcy5tX2F4aXMsIHZBKSArIHRoaXMubV9hMSAqIHdBO1xuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gbmV3IFZlYzMoQ2RvdDEueCwgQ2RvdDEueSwgQ2RvdDIpO1xuICAgICAgICAgICAgICAgIHZhciBmMSA9IFZlYzMuY2xvbmUodGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZhciBkZiA9IHRoaXMubV9LLnNvbHZlMzMoVmVjMy5uZWcoQ2RvdCkpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLmFkZChkZik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IExpbWl0U3RhdGUkMS5hdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IG1hdGhfbWF4KHRoaXMubV9pbXB1bHNlLnosIDAuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IExpbWl0U3RhdGUkMS5hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IG1hdGhfbWluJDIodGhpcy5tX2ltcHVsc2UueiwgMC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZjIoMToyKSA9IGludksoMToyLDE6MikgKiAoLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpKSArXG4gICAgICAgICAgICAgICAgLy8gZjEoMToyKVxuICAgICAgICAgICAgICAgIHZhciBiID0gVmVjMi5jb21iaW5lKC0xLCBDZG90MSwgLSh0aGlzLm1faW1wdWxzZS56IC0gZjEueiksIFZlYzIubmVvKHRoaXMubV9LLmV6LngsIHRoaXMubV9LLmV6LnkpKTtcbiAgICAgICAgICAgICAgICB2YXIgZjJyID0gVmVjMi5hZGQodGhpcy5tX0suc29sdmUyMihiKSwgVmVjMi5uZW8oZjEueCwgZjEueSkpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggPSBmMnIueDtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gZjJyLnk7XG4gICAgICAgICAgICAgICAgZGYgPSBWZWMzLnN1Yih0aGlzLm1faW1wdWxzZSwgZjEpO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5jb21iaW5lKGRmLngsIHRoaXMubV9wZXJwLCBkZi56LCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIExBID0gZGYueCAqIHRoaXMubV9zMSArIGRmLnkgKyBkZi56ICogdGhpcy5tX2ExO1xuICAgICAgICAgICAgICAgIHZhciBMQiA9IGRmLnggKiB0aGlzLm1fczIgKyBkZi55ICsgZGYueiAqIHRoaXMubV9hMjtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIExCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGltaXQgaXMgaW5hY3RpdmUsIGp1c3Qgc29sdmUgdGhlIHByaXNtYXRpYyBjb25zdHJhaW50IGluIGJsb2NrIGZvcm0uXG4gICAgICAgICAgICAgICAgdmFyIGRmID0gdGhpcy5tX0suc29sdmUyMihWZWMyLm5lZyhDZG90MSkpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gZGYueDtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ICs9IGRmLnk7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm11bE51bVZlYzIoZGYueCwgdGhpcy5tX3BlcnApO1xuICAgICAgICAgICAgICAgIHZhciBMQSA9IGRmLnggKiB0aGlzLm1fczEgKyBkZi55O1xuICAgICAgICAgICAgICAgIHZhciBMQiA9IGRmLnggKiB0aGlzLm1fczIgKyBkZi55O1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBMQTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogTEI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgUHJpc21hdGljSm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgZnJlc2ggSmFjb2JpYW5zXG4gICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIHZhciBkID0gVmVjMi5zdWIoVmVjMi5hZGQoY0IsIHJCKSwgVmVjMi5hZGQoY0EsIHJBKSk7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgICAgICAgICAgdmFyIGExID0gVmVjMi5jcm9zc1ZlYzJWZWMyKFZlYzIuYWRkKGQsIHJBKSwgYXhpcyk7XG4gICAgICAgICAgICB2YXIgYTIgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIGF4aXMpO1xuICAgICAgICAgICAgdmFyIHBlcnAgPSBSb3QubXVsVmVjMihxQSwgdGhpcy5tX2xvY2FsWUF4aXNBKTtcbiAgICAgICAgICAgIHZhciBzMSA9IFZlYzIuY3Jvc3NWZWMyVmVjMihWZWMyLmFkZChkLCByQSksIHBlcnApO1xuICAgICAgICAgICAgdmFyIHMyID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCBwZXJwKTtcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBDMSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgQzEueCA9IFZlYzIuZG90KHBlcnAsIGQpO1xuICAgICAgICAgICAgQzEueSA9IGFCIC0gYUEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgICAgICB2YXIgbGluZWFyRXJyb3IgPSBtYXRoX2FicyQzKEMxLngpO1xuICAgICAgICAgICAgdmFyIGFuZ3VsYXJFcnJvciA9IG1hdGhfYWJzJDMoQzEueSk7XG4gICAgICAgICAgICB2YXIgbGluZWFyU2xvcCA9IFNldHRpbmdzSW50ZXJuYWwubGluZWFyU2xvcDtcbiAgICAgICAgICAgIHZhciBtYXhMaW5lYXJDb3JyZWN0aW9uID0gU2V0dGluZ3NJbnRlcm5hbC5tYXhMaW5lYXJDb3JyZWN0aW9uO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlOyAvLyBib29sXG4gICAgICAgICAgICB2YXIgQzIgPSAwLjA7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gVmVjMi5kb3QoYXhpcywgZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhfYWJzJDModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBsaW5lYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBDMiA9IGNsYW1wKHRyYW5zbGF0aW9uLCAtbWF4TGluZWFyQ29ycmVjdGlvbiwgbWF4TGluZWFyQ29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gbWF0aF9tYXgobGluZWFyRXJyb3IsIG1hdGhfYWJzJDModHJhbnNsYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPD0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBsaW5lYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cbiAgICAgICAgICAgICAgICAgICAgQzIgPSBjbGFtcCh0cmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uICsgbGluZWFyU2xvcCwgLW1heExpbmVhckNvcnJlY3Rpb24sIDAuMCk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLm1heChsaW5lYXJFcnJvciwgdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gLSB0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zbGF0aW9uID49IHRoaXMubV91cHBlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgbGluZWFyIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzb21lIHNsb3AuXG4gICAgICAgICAgICAgICAgICAgIEMyID0gY2xhbXAodHJhbnNsYXRpb24gLSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiAtIGxpbmVhclNsb3AsIDAuMCwgbWF4TGluZWFyQ29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gTWF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLm1heChsaW5lYXJFcnJvciwgdHJhbnNsYXRpb24gLSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrMTEgPSBtQSArIG1CICsgaUEgKiBzMSAqIHMxICsgaUIgKiBzMiAqIHMyO1xuICAgICAgICAgICAgICAgIHZhciBrMTIgPSBpQSAqIHMxICsgaUIgKiBzMjtcbiAgICAgICAgICAgICAgICB2YXIgazEzID0gaUEgKiBzMSAqIGExICsgaUIgKiBzMiAqIGEyO1xuICAgICAgICAgICAgICAgIHZhciBrMjIgPSBpQSArIGlCO1xuICAgICAgICAgICAgICAgIGlmIChrMjIgPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBmaXhlZCByb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICBrMjIgPSAxLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrMjMgPSBpQSAqIGExICsgaUIgKiBhMjtcbiAgICAgICAgICAgICAgICB2YXIgazMzID0gbUEgKyBtQiArIGlBICogYTEgKiBhMSArIGlCICogYTIgKiBhMjtcbiAgICAgICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQzMygpO1xuICAgICAgICAgICAgICAgIEsuZXguc2V0KGsxMSwgazEyLCBrMTMpO1xuICAgICAgICAgICAgICAgIEsuZXkuc2V0KGsxMiwgazIyLCBrMjMpO1xuICAgICAgICAgICAgICAgIEsuZXouc2V0KGsxMywgazIzLCBrMzMpO1xuICAgICAgICAgICAgICAgIHZhciBDID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBDLnggPSBDMS54O1xuICAgICAgICAgICAgICAgIEMueSA9IEMxLnk7XG4gICAgICAgICAgICAgICAgQy56ID0gQzI7XG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IEsuc29sdmUzMyhWZWMzLm5lZyhDKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgazExID0gbUEgKyBtQiArIGlBICogczEgKiBzMSArIGlCICogczIgKiBzMjtcbiAgICAgICAgICAgICAgICB2YXIgazEyID0gaUEgKiBzMSArIGlCICogczI7XG4gICAgICAgICAgICAgICAgdmFyIGsyMiA9IGlBICsgaUI7XG4gICAgICAgICAgICAgICAgaWYgKGsyMiA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgazIyID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgICAgICAgICAgICAgIEsuZXguc2V0TnVtKGsxMSwgazEyKTtcbiAgICAgICAgICAgICAgICBLLmV5LnNldE51bShrMTIsIGsyMik7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UxID0gSy5zb2x2ZShWZWMyLm5lZyhDMSkpO1xuICAgICAgICAgICAgICAgIGltcHVsc2UueCA9IGltcHVsc2UxLng7XG4gICAgICAgICAgICAgICAgaW1wdWxzZS55ID0gaW1wdWxzZTEueTtcbiAgICAgICAgICAgICAgICBpbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgUCA9IFZlYzIuY29tYmluZShpbXB1bHNlLngsIHBlcnAsIGltcHVsc2UueiwgYXhpcyk7XG4gICAgICAgICAgICB2YXIgTEEgPSBpbXB1bHNlLnggKiBzMSArIGltcHVsc2UueSArIGltcHVsc2UueiAqIGExO1xuICAgICAgICAgICAgdmFyIExCID0gaW1wdWxzZS54ICogczIgKyBpbXB1bHNlLnkgKyBpbXB1bHNlLnogKiBhMjtcbiAgICAgICAgICAgIGNBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICBhQSAtPSBpQSAqIExBO1xuICAgICAgICAgICAgY0IuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgIGFCICs9IGlCICogTEI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jID0gY0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hID0gYUE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jID0gY0I7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgICAgICAgICByZXR1cm4gbGluZWFyRXJyb3IgPD0gU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbG9wXG4gICAgICAgICAgICAgICAgJiYgYW5ndWxhckVycm9yIDw9IFNldHRpbmdzSW50ZXJuYWwuYW5ndWxhclNsb3A7XG4gICAgICAgIH07XG4gICAgICAgIFByaXNtYXRpY0pvaW50LlRZUEUgPSAncHJpc21hdGljLWpvaW50JztcbiAgICAgICAgcmV0dXJuIFByaXNtYXRpY0pvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBERUZBVUxUUyQ2ID0ge1xuICAgICAgICByYXRpbzogMS4wXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGdlYXIgam9pbnQgaXMgdXNlZCB0byBjb25uZWN0IHR3byBqb2ludHMgdG9nZXRoZXIuIEVpdGhlciBqb2ludCBjYW4gYmUgYVxuICAgICAqIHJldm9sdXRlIG9yIHByaXNtYXRpYyBqb2ludC4gWW91IHNwZWNpZnkgYSBnZWFyIHJhdGlvIHRvIGJpbmQgdGhlIG1vdGlvbnNcbiAgICAgKiB0b2dldGhlcjogY29vcmRpbmF0ZTEgKyByYXRpbyAqIGNvb3JkaW5hdGUyID0gY29uc3RhbnRcbiAgICAgKlxuICAgICAqIFRoZSByYXRpbyBjYW4gYmUgbmVnYXRpdmUgb3IgcG9zaXRpdmUuIElmIG9uZSBqb2ludCBpcyBhIHJldm9sdXRlIGpvaW50IGFuZFxuICAgICAqIHRoZSBvdGhlciBqb2ludCBpcyBhIHByaXNtYXRpYyBqb2ludCwgdGhlbiB0aGUgcmF0aW8gd2lsbCBoYXZlIHVuaXRzIG9mXG4gICAgICogbGVuZ3RoIG9yIHVuaXRzIG9mIDEvbGVuZ3RoLiBXYXJuaW5nOiBZb3UgaGF2ZSB0byBtYW51YWxseSBkZXN0cm95IHRoZSBnZWFyXG4gICAgICogam9pbnQgaWYgam9pbnQxIG9yIGpvaW50MiBpcyBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGRlZmluaXRpb24gcmVxdWlyZXMgdHdvIGV4aXN0aW5nIHJldm9sdXRlIG9yIHByaXNtYXRpYyBqb2ludHMgKGFueVxuICAgICAqIGNvbWJpbmF0aW9uIHdpbGwgd29yaykuXG4gICAgICovXG4gICAgdmFyIEdlYXJKb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEdlYXJKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gR2VhckpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBqb2ludDEsIGpvaW50MiwgcmF0aW8pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoIShfdGhpcyBpbnN0YW5jZW9mIEdlYXJKb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdlYXJKb2ludChkZWYsIGJvZHlBLCBib2R5Qiwgam9pbnQxLCBqb2ludDIsIHJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyQ2KTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICBib2R5QSA9IF90aGlzLm1fYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IF90aGlzLm1fYm9keUI7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBHZWFySm9pbnQuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fam9pbnQxID0gam9pbnQxID8gam9pbnQxIDogZGVmLmpvaW50MTtcbiAgICAgICAgICAgIF90aGlzLm1fam9pbnQyID0gam9pbnQyID8gam9pbnQyIDogZGVmLmpvaW50MjtcbiAgICAgICAgICAgIF90aGlzLm1fcmF0aW8gPSBOdW1iZXIuaXNGaW5pdGUocmF0aW8pID8gcmF0aW8gOiBkZWYucmF0aW87XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUxID0gX3RoaXMubV9qb2ludDEuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlMiA9IF90aGlzLm1fam9pbnQyLmdldFR5cGUoKTtcbiAgICAgICAgICAgIC8vIGpvaW50MSBjb25uZWN0cyBib2R5IEEgdG8gYm9keSBDXG4gICAgICAgICAgICAvLyBqb2ludDIgY29ubmVjdHMgYm9keSBCIHRvIGJvZHkgRFxuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVBO1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVCO1xuICAgICAgICAgICAgLy8gVE9ET19FUklOIHRoZXJlIG1pZ2h0IGJlIHNvbWUgcHJvYmxlbSB3aXRoIHRoZSBqb2ludCBlZGdlcyBpbiBKb2ludC5cbiAgICAgICAgICAgIF90aGlzLm1fYm9keUMgPSBfdGhpcy5tX2pvaW50MS5nZXRCb2R5QSgpO1xuICAgICAgICAgICAgX3RoaXMubV9ib2R5QSA9IF90aGlzLm1fam9pbnQxLmdldEJvZHlCKCk7XG4gICAgICAgICAgICAvLyBHZXQgZ2VvbWV0cnkgb2Ygam9pbnQxXG4gICAgICAgICAgICB2YXIgeGZBID0gX3RoaXMubV9ib2R5QS5tX3hmO1xuICAgICAgICAgICAgdmFyIGFBID0gX3RoaXMubV9ib2R5QS5tX3N3ZWVwLmE7XG4gICAgICAgICAgICB2YXIgeGZDID0gX3RoaXMubV9ib2R5Qy5tX3hmO1xuICAgICAgICAgICAgdmFyIGFDID0gX3RoaXMubV9ib2R5Qy5tX3N3ZWVwLmE7XG4gICAgICAgICAgICBpZiAoX3RoaXMubV90eXBlMSA9PT0gUmV2b2x1dGVKb2ludC5UWVBFKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldm9sdXRlID0gX3RoaXMubV9qb2ludDE7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckMgPSByZXZvbHV0ZS5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IHJldm9sdXRlLm1fbG9jYWxBbmNob3JCO1xuICAgICAgICAgICAgICAgIF90aGlzLm1fcmVmZXJlbmNlQW5nbGVBID0gcmV2b2x1dGUubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQXhpc0MgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlQSA9IGFBIC0gYUMgLSBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmlzbWF0aWMgPSBfdGhpcy5tX2pvaW50MTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQyA9IHByaXNtYXRpYy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IHByaXNtYXRpYy5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlQSA9IHByaXNtYXRpYy5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBeGlzQyA9IHByaXNtYXRpYy5tX2xvY2FsWEF4aXNBO1xuICAgICAgICAgICAgICAgIHZhciBwQyA9IF90aGlzLm1fbG9jYWxBbmNob3JDO1xuICAgICAgICAgICAgICAgIHZhciBwQSA9IFJvdC5tdWxUVmVjMih4ZkMucSwgVmVjMi5hZGQoUm90Lm11bFZlYzIoeGZBLnEsIF90aGlzLm1fbG9jYWxBbmNob3JBKSwgVmVjMi5zdWIoeGZBLnAsIHhmQy5wKSkpO1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVBID0gVmVjMi5kb3QocEEsIF90aGlzLm1fbG9jYWxBeGlzQykgLSBWZWMyLmRvdChwQywgX3RoaXMubV9sb2NhbEF4aXNDKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1fYm9keUQgPSBfdGhpcy5tX2pvaW50Mi5nZXRCb2R5QSgpO1xuICAgICAgICAgICAgX3RoaXMubV9ib2R5QiA9IF90aGlzLm1fam9pbnQyLmdldEJvZHlCKCk7XG4gICAgICAgICAgICAvLyBHZXQgZ2VvbWV0cnkgb2Ygam9pbnQyXG4gICAgICAgICAgICB2YXIgeGZCID0gX3RoaXMubV9ib2R5Qi5tX3hmO1xuICAgICAgICAgICAgdmFyIGFCID0gX3RoaXMubV9ib2R5Qi5tX3N3ZWVwLmE7XG4gICAgICAgICAgICB2YXIgeGZEID0gX3RoaXMubV9ib2R5RC5tX3hmO1xuICAgICAgICAgICAgdmFyIGFEID0gX3RoaXMubV9ib2R5RC5tX3N3ZWVwLmE7XG4gICAgICAgICAgICBpZiAoX3RoaXMubV90eXBlMiA9PT0gUmV2b2x1dGVKb2ludC5UWVBFKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldm9sdXRlID0gX3RoaXMubV9qb2ludDI7XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckQgPSByZXZvbHV0ZS5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQiA9IHJldm9sdXRlLm1fbG9jYWxBbmNob3JCO1xuICAgICAgICAgICAgICAgIF90aGlzLm1fcmVmZXJlbmNlQW5nbGVCID0gcmV2b2x1dGUubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQXhpc0QgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlQiA9IGFCIC0gYUQgLSBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmlzbWF0aWMgPSBfdGhpcy5tX2pvaW50MjtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yRCA9IHByaXNtYXRpYy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQiA9IHByaXNtYXRpYy5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlQiA9IHByaXNtYXRpYy5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBeGlzRCA9IHByaXNtYXRpYy5tX2xvY2FsWEF4aXNBO1xuICAgICAgICAgICAgICAgIHZhciBwRCA9IF90aGlzLm1fbG9jYWxBbmNob3JEO1xuICAgICAgICAgICAgICAgIHZhciBwQiA9IFJvdC5tdWxUVmVjMih4ZkQucSwgVmVjMi5hZGQoUm90Lm11bFZlYzIoeGZCLnEsIF90aGlzLm1fbG9jYWxBbmNob3JCKSwgVmVjMi5zdWIoeGZCLnAsIHhmRC5wKSkpO1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVCID0gVmVjMi5kb3QocEIsIF90aGlzLm1fbG9jYWxBeGlzRCkgLSBWZWMyLmRvdChwRCwgX3RoaXMubV9sb2NhbEF4aXNEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1fY29uc3RhbnQgPSBjb29yZGluYXRlQSArIF90aGlzLm1fcmF0aW8gKiBjb29yZGluYXRlQjtcbiAgICAgICAgICAgIF90aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIC8vIEdlYXIgSm9pbnQ6XG4gICAgICAgICAgICAvLyBDMCA9IChjb29yZGluYXRlMSArIHJhdGlvICogY29vcmRpbmF0ZTIpX2luaXRpYWxcbiAgICAgICAgICAgIC8vIEMgPSAoY29vcmRpbmF0ZTEgKyByYXRpbyAqIGNvb3JkaW5hdGUyKSAtIEMwID0gMFxuICAgICAgICAgICAgLy8gSiA9IFtKMSByYXRpbyAqIEoyXVxuICAgICAgICAgICAgLy8gSyA9IEogKiBpbnZNICogSlRcbiAgICAgICAgICAgIC8vID0gSjEgKiBpbnZNMSAqIEoxVCArIHJhdGlvICogcmF0aW8gKiBKMiAqIGludk0yICogSjJUXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gUmV2b2x1dGU6XG4gICAgICAgICAgICAvLyBjb29yZGluYXRlID0gcm90YXRpb25cbiAgICAgICAgICAgIC8vIENkb3QgPSBhbmd1bGFyVmVsb2NpdHlcbiAgICAgICAgICAgIC8vIEogPSBbMCAwIDFdXG4gICAgICAgICAgICAvLyBLID0gSiAqIGludk0gKiBKVCA9IGludklcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBQcmlzbWF0aWM6XG4gICAgICAgICAgICAvLyBjb29yZGluYXRlID0gZG90KHAgLSBwZywgdWcpXG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KHYgKyBjcm9zcyh3LCByKSwgdWcpXG4gICAgICAgICAgICAvLyBKID0gW3VnIGNyb3NzKHIsIHVnKV1cbiAgICAgICAgICAgIC8vIEsgPSBKICogaW52TSAqIEpUID0gaW52TWFzcyArIGludkkgKiBjcm9zcyhyLCB1ZyleMlxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgR2VhckpvaW50LnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICBib2R5QTogdGhpcy5tX2JvZHlBLFxuICAgICAgICAgICAgICAgIGJvZHlCOiB0aGlzLm1fYm9keUIsXG4gICAgICAgICAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgam9pbnQxOiB0aGlzLm1fam9pbnQxLFxuICAgICAgICAgICAgICAgIGpvaW50MjogdGhpcy5tX2pvaW50MixcbiAgICAgICAgICAgICAgICByYXRpbzogdGhpcy5tX3JhdGlvLFxuICAgICAgICAgICAgICAgIC8vIF9jb25zdGFudDogdGhpcy5tX2NvbnN0YW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBHZWFySm9pbnQuX2Rlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIHdvcmxkLCByZXN0b3JlKSB7XG4gICAgICAgICAgICBkYXRhID0gX19hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICAgICAgZGF0YS5ib2R5QSA9IHJlc3RvcmUoQm9keSwgZGF0YS5ib2R5QSwgd29ybGQpO1xuICAgICAgICAgICAgZGF0YS5ib2R5QiA9IHJlc3RvcmUoQm9keSwgZGF0YS5ib2R5Qiwgd29ybGQpO1xuICAgICAgICAgICAgZGF0YS5qb2ludDEgPSByZXN0b3JlKEpvaW50LCBkYXRhLmpvaW50MSwgd29ybGQpO1xuICAgICAgICAgICAgZGF0YS5qb2ludDIgPSByZXN0b3JlKEpvaW50LCBkYXRhLmpvaW50Miwgd29ybGQpO1xuICAgICAgICAgICAgdmFyIGpvaW50ID0gbmV3IEdlYXJKb2ludChkYXRhKTtcbiAgICAgICAgICAgIC8vIGlmIChkYXRhLl9jb25zdGFudCkgam9pbnQubV9jb25zdGFudCA9IGRhdGEuX2NvbnN0YW50O1xuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmaXJzdCBqb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9qb2ludDE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHNlY29uZCBqb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9qb2ludDI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGdlYXIgcmF0aW8uXG4gICAgICAgICAqL1xuICAgICAgICBHZWFySm9pbnQucHJvdG90eXBlLnNldFJhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICAgICAgICB0aGlzLm1fcmF0aW8gPSByYXRpbztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZ2VhciByYXRpby5cbiAgICAgICAgICovXG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuZ2V0UmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3JhdGlvO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBHZWFySm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gZm9yY2Ugb24gYm9keUIgYXQgdGhlIGpvaW50IGFuY2hvciBpbiBOZXd0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgR2VhckpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubXVsTnVtVmVjMih0aGlzLm1faW1wdWxzZSwgdGhpcy5tX0p2QUMpLm11bChpbnZfZHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgb24gYm9keUIgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgR2VhckpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHZhciBMID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSndBO1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIEw7XG4gICAgICAgIH07XG4gICAgICAgIEdlYXJKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdGhpcy5tX2xjQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xjQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xjQyA9IHRoaXMubV9ib2R5Qy5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xjRCA9IHRoaXMubV9ib2R5RC5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX21BID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9tQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1fbUMgPSB0aGlzLm1fYm9keUMubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX21EID0gdGhpcy5tX2JvZHlELm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy5tX2lDID0gdGhpcy5tX2JvZHlDLm1faW52STtcbiAgICAgICAgICAgIHRoaXMubV9pRCA9IHRoaXMubV9ib2R5RC5tX2ludkk7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgYUMgPSB0aGlzLm1fYm9keUMuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZDID0gdGhpcy5tX2JvZHlDLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QyA9IHRoaXMubV9ib2R5Qy5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgYUQgPSB0aGlzLm1fYm9keUQuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZEID0gdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3RCA9IHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdmFyIHFDID0gUm90Lm5lbyhhQyk7XG4gICAgICAgICAgICB2YXIgcUQgPSBSb3QubmVvKGFEKTtcbiAgICAgICAgICAgIHRoaXMubV9tYXNzID0gMC4wO1xuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlMSA9PSBSZXZvbHV0ZUpvaW50LlRZUEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fSnZBQyA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9Kd0EgPSAxLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0p3QyA9IDEuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcyArPSB0aGlzLm1faUEgKyB0aGlzLm1faUM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IFJvdC5tdWxWZWMyKHFDLCB0aGlzLm1fbG9jYWxBeGlzQyk7XG4gICAgICAgICAgICAgICAgdmFyIHJDID0gUm90Lm11bFN1YihxQywgdGhpcy5tX2xvY2FsQW5jaG9yQywgdGhpcy5tX2xjQyk7XG4gICAgICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFN1YihxQSwgdGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xjQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0p2QUMgPSB1O1xuICAgICAgICAgICAgICAgIHRoaXMubV9Kd0MgPSBWZWMyLmNyb3NzVmVjMlZlYzIockMsIHUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9Kd0EgPSBWZWMyLmNyb3NzVmVjMlZlYzIockEsIHUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tYXNzICs9IHRoaXMubV9tQyArIHRoaXMubV9tQSArIHRoaXMubV9pQyAqIHRoaXMubV9Kd0MgKiB0aGlzLm1fSndDICsgdGhpcy5tX2lBICogdGhpcy5tX0p3QSAqIHRoaXMubV9Kd0E7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tX3R5cGUyID09IFJldm9sdXRlSm9pbnQuVFlQRSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9KdkJEID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0p3QiA9IHRoaXMubV9yYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLm1fSndEID0gdGhpcy5tX3JhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1faUIgKyB0aGlzLm1faUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSBSb3QubXVsVmVjMihxRCwgdGhpcy5tX2xvY2FsQXhpc0QpO1xuICAgICAgICAgICAgICAgIHZhciByRCA9IFJvdC5tdWxTdWIocUQsIHRoaXMubV9sb2NhbEFuY2hvckQsIHRoaXMubV9sY0QpO1xuICAgICAgICAgICAgICAgIHZhciByQiA9IFJvdC5tdWxTdWIocUIsIHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sY0IpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9KdkJEID0gVmVjMi5tdWxOdW1WZWMyKHRoaXMubV9yYXRpbywgdSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0p3RCA9IHRoaXMubV9yYXRpbyAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyRCwgdSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX0p3QiA9IHRoaXMubV9yYXRpbyAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgdSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgKz0gdGhpcy5tX3JhdGlvICogdGhpcy5tX3JhdGlvICogKHRoaXMubV9tRCArIHRoaXMubV9tQikgKyB0aGlzLm1faUQgKiB0aGlzLm1fSndEICogdGhpcy5tX0p3RCArIHRoaXMubV9pQiAqIHRoaXMubV9Kd0IgKiB0aGlzLm1fSndCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cbiAgICAgICAgICAgIHRoaXMubV9tYXNzID0gdGhpcy5tX21hc3MgPiAwLjAgPyAxLjAgLyB0aGlzLm1fbWFzcyA6IDAuMDtcbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIHZBLmFkZE11bCh0aGlzLm1fbUEgKiB0aGlzLm1faW1wdWxzZSwgdGhpcy5tX0p2QUMpO1xuICAgICAgICAgICAgICAgIHdBICs9IHRoaXMubV9pQSAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX0p3QTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwodGhpcy5tX21CICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV9KdkJEKTtcbiAgICAgICAgICAgICAgICB3QiArPSB0aGlzLm1faUIgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9Kd0I7XG4gICAgICAgICAgICAgICAgdkMuc3ViTXVsKHRoaXMubV9tQyAqIHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fSnZBQyk7XG4gICAgICAgICAgICAgICAgd0MgLT0gdGhpcy5tX2lDICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSndDO1xuICAgICAgICAgICAgICAgIHZELnN1Yk11bCh0aGlzLm1fbUQgKiB0aGlzLm1faW1wdWxzZSwgdGhpcy5tX0p2QkQpO1xuICAgICAgICAgICAgICAgIHdEIC09IHRoaXMubV9pRCAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX0p3RDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZBKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2Qik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUMuY192ZWxvY2l0eS52LnNldFZlYzIodkMpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlDLmNfdmVsb2NpdHkudyA9IHdDO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudi5zZXRWZWMyKHZEKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5LncgPSB3RDtcbiAgICAgICAgfTtcbiAgICAgICAgR2VhckpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2QyA9IHRoaXMubV9ib2R5Qy5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0MgPSB0aGlzLm1fYm9keUMuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZEID0gdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3RCA9IHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuZG90KHRoaXMubV9KdkFDLCB2QSkgLSBWZWMyLmRvdCh0aGlzLm1fSnZBQywgdkMpICsgVmVjMi5kb3QodGhpcy5tX0p2QkQsIHZCKSAtIFZlYzIuZG90KHRoaXMubV9KdkJELCB2RCk7XG4gICAgICAgICAgICBDZG90ICs9ICh0aGlzLm1fSndBICogd0EgLSB0aGlzLm1fSndDICogd0MpICsgKHRoaXMubV9Kd0IgKiB3QiAtIHRoaXMubV9Kd0QgKiB3RCk7XG4gICAgICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbWFzcyAqIENkb3Q7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZSArPSBpbXB1bHNlO1xuICAgICAgICAgICAgdkEuYWRkTXVsKHRoaXMubV9tQSAqIGltcHVsc2UsIHRoaXMubV9KdkFDKTtcbiAgICAgICAgICAgIHdBICs9IHRoaXMubV9pQSAqIGltcHVsc2UgKiB0aGlzLm1fSndBO1xuICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9tQiAqIGltcHVsc2UsIHRoaXMubV9KdkJEKTtcbiAgICAgICAgICAgIHdCICs9IHRoaXMubV9pQiAqIGltcHVsc2UgKiB0aGlzLm1fSndCO1xuICAgICAgICAgICAgdkMuc3ViTXVsKHRoaXMubV9tQyAqIGltcHVsc2UsIHRoaXMubV9KdkFDKTtcbiAgICAgICAgICAgIHdDIC09IHRoaXMubV9pQyAqIGltcHVsc2UgKiB0aGlzLm1fSndDO1xuICAgICAgICAgICAgdkQuc3ViTXVsKHRoaXMubV9tRCAqIGltcHVsc2UsIHRoaXMubV9KdkJEKTtcbiAgICAgICAgICAgIHdEIC09IHRoaXMubV9pRCAqIGltcHVsc2UgKiB0aGlzLm1fSndEO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZBKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2Qik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUMuY192ZWxvY2l0eS52LnNldFZlYzIodkMpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlDLmNfdmVsb2NpdHkudyA9IHdDO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlELmNfdmVsb2NpdHkudi5zZXRWZWMyKHZEKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5RC5jX3ZlbG9jaXR5LncgPSB3RDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBlcnJvcnMgYXJlIHdpdGhpbiB0b2xlcmFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBHZWFySm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIGNDID0gdGhpcy5tX2JvZHlDLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQyA9IHRoaXMubV9ib2R5Qy5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgY0QgPSB0aGlzLm1fYm9keUQuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFEID0gdGhpcy5tX2JvZHlELmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB2YXIgcUMgPSBSb3QubmVvKGFDKTtcbiAgICAgICAgICAgIHZhciBxRCA9IFJvdC5uZW8oYUQpO1xuICAgICAgICAgICAgdmFyIGxpbmVhckVycm9yID0gMC4wO1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVBO1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVCO1xuICAgICAgICAgICAgdmFyIEp2QUM7XG4gICAgICAgICAgICB2YXIgSnZCRDtcbiAgICAgICAgICAgIHZhciBKd0E7XG4gICAgICAgICAgICB2YXIgSndCO1xuICAgICAgICAgICAgdmFyIEp3QztcbiAgICAgICAgICAgIHZhciBKd0Q7XG4gICAgICAgICAgICB2YXIgbWFzcyA9IDAuMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fdHlwZTEgPT0gUmV2b2x1dGVKb2ludC5UWVBFKSB7XG4gICAgICAgICAgICAgICAgSnZBQyA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIEp3QSA9IDEuMDtcbiAgICAgICAgICAgICAgICBKd0MgPSAxLjA7XG4gICAgICAgICAgICAgICAgbWFzcyArPSB0aGlzLm1faUEgKyB0aGlzLm1faUM7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZUEgPSBhQSAtIGFDIC0gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gUm90Lm11bFZlYzIocUMsIHRoaXMubV9sb2NhbEF4aXNDKTtcbiAgICAgICAgICAgICAgICB2YXIgckMgPSBSb3QubXVsU3ViKHFDLCB0aGlzLm1fbG9jYWxBbmNob3JDLCB0aGlzLm1fbGNDKTtcbiAgICAgICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsU3ViKHFBLCB0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbGNBKTtcbiAgICAgICAgICAgICAgICBKdkFDID0gdTtcbiAgICAgICAgICAgICAgICBKd0MgPSBWZWMyLmNyb3NzVmVjMlZlYzIockMsIHUpO1xuICAgICAgICAgICAgICAgIEp3QSA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgdSk7XG4gICAgICAgICAgICAgICAgbWFzcyArPSB0aGlzLm1fbUMgKyB0aGlzLm1fbUEgKyB0aGlzLm1faUMgKiBKd0MgKiBKd0MgKyB0aGlzLm1faUEgKiBKd0EgKiBKd0E7XG4gICAgICAgICAgICAgICAgdmFyIHBDID0gVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQywgdGhpcy5tX2xjQyk7XG4gICAgICAgICAgICAgICAgdmFyIHBBID0gUm90Lm11bFRWZWMyKHFDLCBWZWMyLmFkZChyQSwgVmVjMi5zdWIoY0EsIGNDKSkpO1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVBID0gVmVjMi5kb3QoVmVjMi5zdWIocEEsIHBDKSwgdGhpcy5tX2xvY2FsQXhpc0MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV90eXBlMiA9PSBSZXZvbHV0ZUpvaW50LlRZUEUpIHtcbiAgICAgICAgICAgICAgICBKdkJEID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgSndCID0gdGhpcy5tX3JhdGlvO1xuICAgICAgICAgICAgICAgIEp3RCA9IHRoaXMubV9yYXRpbztcbiAgICAgICAgICAgICAgICBtYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1faUIgKyB0aGlzLm1faUQpO1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVCID0gYUIgLSBhRCAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IFJvdC5tdWxWZWMyKHFELCB0aGlzLm1fbG9jYWxBeGlzRCk7XG4gICAgICAgICAgICAgICAgdmFyIHJEID0gUm90Lm11bFN1YihxRCwgdGhpcy5tX2xvY2FsQW5jaG9yRCwgdGhpcy5tX2xjRCk7XG4gICAgICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFN1YihxQiwgdGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xjQik7XG4gICAgICAgICAgICAgICAgSnZCRCA9IFZlYzIubXVsTnVtVmVjMih0aGlzLm1fcmF0aW8sIHUpO1xuICAgICAgICAgICAgICAgIEp3RCA9IHRoaXMubV9yYXRpbyAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyRCwgdSk7XG4gICAgICAgICAgICAgICAgSndCID0gdGhpcy5tX3JhdGlvICogVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCB1KTtcbiAgICAgICAgICAgICAgICBtYXNzICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqICh0aGlzLm1fbUQgKyB0aGlzLm1fbUIpICsgdGhpcy5tX2lEICogSndEICogSndEICsgdGhpcy5tX2lCICogSndCICogSndCO1xuICAgICAgICAgICAgICAgIHZhciBwRCA9IFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckQsIHRoaXMubV9sY0QpO1xuICAgICAgICAgICAgICAgIHZhciBwQiA9IFJvdC5tdWxUVmVjMihxRCwgVmVjMi5hZGQockIsIFZlYzIuc3ViKGNCLCBjRCkpKTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlQiA9IFZlYzIuZG90KHBCLCB0aGlzLm1fbG9jYWxBeGlzRCkgLSBWZWMyLmRvdChwRCwgdGhpcy5tX2xvY2FsQXhpc0QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEMgPSAoY29vcmRpbmF0ZUEgKyB0aGlzLm1fcmF0aW8gKiBjb29yZGluYXRlQikgLSB0aGlzLm1fY29uc3RhbnQ7XG4gICAgICAgICAgICB2YXIgaW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIGlmIChtYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IC1DIC8gbWFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNBLmFkZE11bCh0aGlzLm1fbUEgKiBpbXB1bHNlLCBKdkFDKTtcbiAgICAgICAgICAgIGFBICs9IHRoaXMubV9pQSAqIGltcHVsc2UgKiBKd0E7XG4gICAgICAgICAgICBjQi5hZGRNdWwodGhpcy5tX21CICogaW1wdWxzZSwgSnZCRCk7XG4gICAgICAgICAgICBhQiArPSB0aGlzLm1faUIgKiBpbXB1bHNlICogSndCO1xuICAgICAgICAgICAgY0Muc3ViTXVsKHRoaXMubV9tQyAqIGltcHVsc2UsIEp2QUMpO1xuICAgICAgICAgICAgYUMgLT0gdGhpcy5tX2lDICogaW1wdWxzZSAqIEp3QztcbiAgICAgICAgICAgIGNELnN1Yk11bCh0aGlzLm1fbUQgKiBpbXB1bHNlLCBKdkJEKTtcbiAgICAgICAgICAgIGFEIC09IHRoaXMubV9pRCAqIGltcHVsc2UgKiBKd0Q7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jLnNldFZlYzIoY0EpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qy5jX3Bvc2l0aW9uLmMuc2V0VmVjMihjQyk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUMuY19wb3NpdGlvbi5hID0gYUM7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUQuY19wb3NpdGlvbi5jLnNldFZlYzIoY0QpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlELmNfcG9zaXRpb24uYSA9IGFEO1xuICAgICAgICAgICAgLy8gVE9ET19FUklOIG5vdCBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgcmV0dXJuIGxpbmVhckVycm9yIDwgU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbG9wO1xuICAgICAgICB9O1xuICAgICAgICBHZWFySm9pbnQuVFlQRSA9ICdnZWFyLWpvaW50JztcbiAgICAgICAgcmV0dXJuIEdlYXJKb2ludDtcbiAgICB9KEpvaW50KSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgREVGQVVMVFMkNSA9IHtcbiAgICAgICAgbWF4Rm9yY2U6IDEuMCxcbiAgICAgICAgbWF4VG9ycXVlOiAxLjAsXG4gICAgICAgIGNvcnJlY3Rpb25GYWN0b3I6IDAuM1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtb3RvciBqb2ludCBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIHJlbGF0aXZlIG1vdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMuIEFcbiAgICAgKiB0eXBpY2FsIHVzYWdlIGlzIHRvIGNvbnRyb2wgdGhlIG1vdmVtZW50IG9mIGEgZHluYW1pYyBib2R5IHdpdGggcmVzcGVjdCB0b1xuICAgICAqIHRoZSBncm91bmQuXG4gICAgICovXG4gICAgdmFyIE1vdG9ySm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhNb3RvckpvaW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBNb3RvckpvaW50KGRlZiwgYm9keUEsIGJvZHlCKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBNb3RvckpvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW90b3JKb2ludChkZWYsIGJvZHlBLCBib2R5Qik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkNSk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gTW90b3JKb2ludC5UWVBFO1xuICAgICAgICAgICAgX3RoaXMubV9saW5lYXJPZmZzZXQgPSBOdW1iZXIuaXNGaW5pdGUoZGVmLmxpbmVhck9mZnNldCkgPyBWZWMyLmNsb25lKGRlZi5saW5lYXJPZmZzZXQpIDogYm9keUEuZ2V0TG9jYWxQb2ludChib2R5Qi5nZXRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIF90aGlzLm1fYW5ndWxhck9mZnNldCA9IE51bWJlci5pc0Zpbml0ZShkZWYuYW5ndWxhck9mZnNldCkgPyBkZWYuYW5ndWxhck9mZnNldCA6IGJvZHlCLmdldEFuZ2xlKCkgLSBib2R5QS5nZXRBbmdsZSgpO1xuICAgICAgICAgICAgX3RoaXMubV9saW5lYXJJbXB1bHNlID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9tYXhGb3JjZSA9IGRlZi5tYXhGb3JjZTtcbiAgICAgICAgICAgIF90aGlzLm1fbWF4VG9ycXVlID0gZGVmLm1heFRvcnF1ZTtcbiAgICAgICAgICAgIF90aGlzLm1fY29ycmVjdGlvbkZhY3RvciA9IGRlZi5jb3JyZWN0aW9uRmFjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gUG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQ2RvdCA9IHYyIC0gdjFcbiAgICAgICAgICAgIC8vID0gdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tldyBdXG4gICAgICAgICAgICAvLyBJZGVudGl0eSB1c2VkOlxuICAgICAgICAgICAgLy8gdyBrICUgKHJ4IGkgKyByeSBqKSA9IHcgKiAoLXJ5IGkgKyByeCBqKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHIxID0gb2Zmc2V0IC0gYzFcbiAgICAgICAgICAgIC8vIHIyID0gLWMyXG4gICAgICAgICAgICAvLyBBbmdsZSBjb25zdHJhaW50XG4gICAgICAgICAgICAvLyBDZG90ID0gdzIgLSB3MVxuICAgICAgICAgICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXG4gICAgICAgICAgICAvLyBLID0gaW52STEgKyBpbnZJMlxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgYm9keUE6IHRoaXMubV9ib2R5QSxcbiAgICAgICAgICAgICAgICBib2R5QjogdGhpcy5tX2JvZHlCLFxuICAgICAgICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkLFxuICAgICAgICAgICAgICAgIG1heEZvcmNlOiB0aGlzLm1fbWF4Rm9yY2UsXG4gICAgICAgICAgICAgICAgbWF4VG9ycXVlOiB0aGlzLm1fbWF4VG9ycXVlLFxuICAgICAgICAgICAgICAgIGNvcnJlY3Rpb25GYWN0b3I6IHRoaXMubV9jb3JyZWN0aW9uRmFjdG9yLFxuICAgICAgICAgICAgICAgIGxpbmVhck9mZnNldDogdGhpcy5tX2xpbmVhck9mZnNldCxcbiAgICAgICAgICAgICAgICBhbmd1bGFyT2Zmc2V0OiB0aGlzLm1fYW5ndWxhck9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTW90b3JKb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgTW90b3JKb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5fc2V0QW5jaG9ycyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWF4aW11bSBmcmljdGlvbiBmb3JjZSBpbiBOLlxuICAgICAgICAgKi9cbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGZvcmNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXhpbXVtIGZyaWN0aW9uIGZvcmNlIGluIE4uXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1heGltdW0gZnJpY3Rpb24gdG9ycXVlIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXhUb3JxdWUgPSB0b3JxdWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG1heGltdW0gZnJpY3Rpb24gdG9ycXVlIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLmdldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4VG9ycXVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBwb3NpdGlvbiBjb3JyZWN0aW9uIGZhY3RvciBpbiB0aGUgcmFuZ2UgWzAsMV0uXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5zZXRDb3JyZWN0aW9uRmFjdG9yID0gZnVuY3Rpb24gKGZhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5tX2NvcnJlY3Rpb25GYWN0b3IgPSBmYWN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIGNvcnJlY3Rpb24gZmFjdG9yIGluIHRoZSByYW5nZSBbMCwxXS5cbiAgICAgICAgICovXG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLmdldENvcnJlY3Rpb25GYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2NvcnJlY3Rpb25GYWN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQvZ2V0IHRoZSB0YXJnZXQgbGluZWFyIG9mZnNldCwgaW4gZnJhbWUgQSwgaW4gbWV0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuc2V0TGluZWFyT2Zmc2V0ID0gZnVuY3Rpb24gKGxpbmVhck9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGxpbmVhck9mZnNldC54ICE9IHRoaXMubV9saW5lYXJPZmZzZXQueCB8fCBsaW5lYXJPZmZzZXQueSAhPSB0aGlzLm1fbGluZWFyT2Zmc2V0LnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW5lYXJPZmZzZXQuc2V0KGxpbmVhck9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLmdldExpbmVhck9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbGluZWFyT2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0L2dldCB0aGUgdGFyZ2V0IGFuZ3VsYXIgb2Zmc2V0LCBpbiByYWRpYW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuc2V0QW5ndWxhck9mZnNldCA9IGZ1bmN0aW9uIChhbmd1bGFyT2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAoYW5ndWxhck9mZnNldCAhPSB0aGlzLm1fYW5ndWxhck9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9ib2R5QS5zZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJPZmZzZXQgPSBhbmd1bGFyT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRBbmd1bGFyT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9hbmd1bGFyT2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRQb3NpdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUIgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRQb3NpdGlvbigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiBmb3JjZSBvbiBib2R5QiBhdCB0aGUgam9pbnQgYW5jaG9yIGluIE5ld3RvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubXVsTnVtVmVjMihpbnZfZHQsIHRoaXMubV9saW5lYXJJbXB1bHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIE1vdG9ySm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9hbmd1bGFySW1wdWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuaW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IHRoaXMubV9ib2R5QS5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NBID0gdGhpcy5tX2JvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQiA9IHRoaXMubV9ib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52SUEgPSB0aGlzLm1fYm9keUEubV9pbnZJO1xuICAgICAgICAgICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzIG1hdHJpeC5cbiAgICAgICAgICAgIHRoaXMubV9yQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbGluZWFyT2Zmc2V0LCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB0aGlzLm1fckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5uZWcodGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXG4gICAgICAgICAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cbiAgICAgICAgICAgIC8vIE1hdGxhYlxuICAgICAgICAgICAgLy8gSyA9IFsgbUErcjF5XjIqaUErbUIrcjJ5XjIqaUIsIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIC1yMXkqaUEtcjJ5KmlCXVxuICAgICAgICAgICAgLy8gWyAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCBtQStyMXheMippQSttQityMnheMippQiwgcjF4KmlBK3IyeCppQl1cbiAgICAgICAgICAgIC8vIFsgLXIxeSppQS1yMnkqaUIsIHIxeCppQStyMngqaUIsIGlBK2lCXVxuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgICAgLy8gVXBwZXIgMiBieSAyIG9mIEsgZm9yIHBvaW50IHRvIHBvaW50XG4gICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgICAgICAgICAgSy5leC54ID0gbUEgKyBtQiArIGlBICogdGhpcy5tX3JBLnkgKiB0aGlzLm1fckEueSArIGlCICogdGhpcy5tX3JCLnkgKiB0aGlzLm1fckIueTtcbiAgICAgICAgICAgIEsuZXgueSA9IC1pQSAqIHRoaXMubV9yQS54ICogdGhpcy5tX3JBLnkgLSBpQiAqIHRoaXMubV9yQi54ICogdGhpcy5tX3JCLnk7XG4gICAgICAgICAgICBLLmV5LnggPSBLLmV4Lnk7XG4gICAgICAgICAgICBLLmV5LnkgPSBtQSArIG1CICsgaUEgKiB0aGlzLm1fckEueCAqIHRoaXMubV9yQS54ICsgaUIgKiB0aGlzLm1fckIueCAqIHRoaXMubV9yQi54O1xuICAgICAgICAgICAgdGhpcy5tX2xpbmVhck1hc3MgPSBLLmdldEludmVyc2UoKTtcbiAgICAgICAgICAgIHRoaXMubV9hbmd1bGFyTWFzcyA9IGlBICsgaUI7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2FuZ3VsYXJNYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJNYXNzID0gMS4wIC8gdGhpcy5tX2FuZ3VsYXJNYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2xpbmVhckVycm9yID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFyRXJyb3IuYWRkQ29tYmluZSgxLCBjQiwgMSwgdGhpcy5tX3JCKTtcbiAgICAgICAgICAgIHRoaXMubV9saW5lYXJFcnJvci5zdWJDb21iaW5lKDEsIGNBLCAxLCB0aGlzLm1fckEpO1xuICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJFcnJvciA9IGFCIC0gYUEgLSB0aGlzLm1fYW5ndWxhck9mZnNldDtcbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UubXVsKHN0ZXAuZHRSYXRpbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVvKHRoaXMubV9saW5lYXJJbXB1bHNlLngsIHRoaXMubV9saW5lYXJJbXB1bHNlLnkpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCkgKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgUCkgKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2Uuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9hbmd1bGFySW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYgPSB2QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgTW90b3JKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICB2YXIgaCA9IHN0ZXAuZHQ7XG4gICAgICAgICAgICB2YXIgaW52X2ggPSBzdGVwLmludl9kdDtcbiAgICAgICAgICAgIC8vIFNvbHZlIGFuZ3VsYXIgZnJpY3Rpb25cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdCA9IHdCIC0gd0EgKyBpbnZfaCAqIHRoaXMubV9jb3JyZWN0aW9uRmFjdG9yICogdGhpcy5tX2FuZ3VsYXJFcnJvcjtcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fYW5ndWxhck1hc3MgKiBDZG90O1xuICAgICAgICAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHZhciBtYXhJbXB1bHNlID0gaCAqIHRoaXMubV9tYXhUb3JxdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gY2xhbXAodGhpcy5tX2FuZ3VsYXJJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fYW5ndWxhckltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogaW1wdWxzZTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgZnJpY3Rpb25cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIENkb3QuYWRkQ29tYmluZSgxLCB2QiwgMSwgVmVjMi5jcm9zc051bVZlYzIod0IsIHRoaXMubV9yQikpO1xuICAgICAgICAgICAgICAgIENkb3Quc3ViQ29tYmluZSgxLCB2QSwgMSwgVmVjMi5jcm9zc051bVZlYzIod0EsIHRoaXMubV9yQSkpO1xuICAgICAgICAgICAgICAgIENkb3QuYWRkTXVsKGludl9oICogdGhpcy5tX2NvcnJlY3Rpb25GYWN0b3IsIHRoaXMubV9saW5lYXJFcnJvcik7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBWZWMyLm5lZyhNYXQyMi5tdWxWZWMyKHRoaXMubV9saW5lYXJNYXNzLCBDZG90KSk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSBWZWMyLmNsb25lKHRoaXMubV9saW5lYXJJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBoICogdGhpcy5tX21heEZvcmNlO1xuICAgICAgICAgICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLmNsYW1wKG1heEltcHVsc2UpO1xuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBWZWMyLnN1Yih0aGlzLm1fbGluZWFySW1wdWxzZSwgb2xkSW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKG1BLCBpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIGltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bChtQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYgPSB2QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBlcnJvcnMgYXJlIHdpdGhpbiB0b2xlcmFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBNb3RvckpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE1vdG9ySm9pbnQuVFlQRSA9ICdtb3Rvci1qb2ludCc7XG4gICAgICAgIHJldHVybiBNb3RvckpvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX1BJJDIgPSBNYXRoLlBJO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIERFRkFVTFRTJDQgPSB7XG4gICAgICAgIG1heEZvcmNlOiAwLjAsXG4gICAgICAgIGZyZXF1ZW5jeUh6OiA1LjAsXG4gICAgICAgIGRhbXBpbmdSYXRpbzogMC43XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1vdXNlIGpvaW50IGlzIHVzZWQgdG8gbWFrZSBhIHBvaW50IG9uIGEgYm9keSB0cmFjayBhIHNwZWNpZmllZCB3b3JsZFxuICAgICAqIHBvaW50LiBUaGlzIGEgc29mdCBjb25zdHJhaW50IHdpdGggYSBtYXhpbXVtIGZvcmNlLiBUaGlzIGFsbG93cyB0aGVcbiAgICAgKiBjb25zdHJhaW50IHRvIHN0cmV0Y2ggYW5kIHdpdGhvdXQgYXBwbHlpbmcgaHVnZSBmb3JjZXMuXG4gICAgICpcbiAgICAgKiBZb3UgbmVlZCB0byBjYWxsIHNldFRhcmdldCh0YXJnZXQpIGV2ZXJ5IHRpbWUgdGhhdCBtb3VzZSBpc1xuICAgICAqIG1vdmVkLCB0byB0cmFjayB0aGUgbmV3IGxvY2F0aW9uIG9mIHRoZSBtb3VzZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IHRoaXMgam9pbnQgaXMgbm90IGRvY3VtZW50ZWQgaW4gdGhlIG1hbnVhbCBiZWNhdXNlIGl0IHdhcyBkZXZlbG9wZWQgdG9cbiAgICAgKiBiZSB1c2VkIGluIHRoZSB0ZXN0YmVkLiBJZiB5b3Ugd2FudCB0byBsZWFybiBob3cgdG8gdXNlIHRoZSBtb3VzZSBqb2ludCwgbG9va1xuICAgICAqIGF0IHRoZSB0ZXN0YmVkLlxuICAgICAqL1xuICAgIHZhciBNb3VzZUpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTW91c2VKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTW91c2VKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBNb3VzZUpvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW91c2VKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyQ0KTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVmLCBib2R5QSwgYm9keUIpIHx8IHRoaXM7XG4gICAgICAgICAgICBib2R5QSA9IF90aGlzLm1fYm9keUE7XG4gICAgICAgICAgICBib2R5QiA9IF90aGlzLm1fYm9keUI7XG4gICAgICAgICAgICBfdGhpcy5tX3R5cGUgPSBNb3VzZUpvaW50LlRZUEU7XG4gICAgICAgICAgICBpZiAoVmVjMi5pc1ZhbGlkKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3RhcmdldEEgPSBWZWMyLmNsb25lKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChWZWMyLmlzVmFsaWQoZGVmLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX3RhcmdldEEgPSBWZWMyLmNsb25lKGRlZi50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubV90YXJnZXRBID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQiA9IFRyYW5zZm9ybS5tdWxUVmVjMihib2R5Qi5nZXRUcmFuc2Zvcm0oKSwgX3RoaXMubV90YXJnZXRBKTtcbiAgICAgICAgICAgIF90aGlzLm1fbWF4Rm9yY2UgPSBkZWYubWF4Rm9yY2U7XG4gICAgICAgICAgICBfdGhpcy5tX2ltcHVsc2UgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIF90aGlzLm1fZnJlcXVlbmN5SHogPSBkZWYuZnJlcXVlbmN5SHo7XG4gICAgICAgICAgICBfdGhpcy5tX2RhbXBpbmdSYXRpbyA9IGRlZi5kYW1waW5nUmF0aW87XG4gICAgICAgICAgICBfdGhpcy5tX2JldGEgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2dhbW1hID0gMC4wO1xuICAgICAgICAgICAgLy8gU29sdmVyIHRlbXBcbiAgICAgICAgICAgIF90aGlzLm1fckIgPSBWZWMyLnplcm8oKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxDZW50ZXJCID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBfdGhpcy5tX2ludk1hc3NCID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9pbnZJQiA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fbWFzcyA9IG5ldyBNYXQyMigpO1xuICAgICAgICAgICAgX3RoaXMubV9DID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAvLyBwID0gYXR0YWNoZWQgcG9pbnQsIG0gPSBtb3VzZSBwb2ludFxuICAgICAgICAgICAgLy8gQyA9IHAgLSBtXG4gICAgICAgICAgICAvLyBDZG90ID0gdlxuICAgICAgICAgICAgLy8gPSB2ICsgY3Jvc3ModywgcilcbiAgICAgICAgICAgIC8vIEogPSBbSSByX3NrZXddXG4gICAgICAgICAgICAvLyBJZGVudGl0eSB1c2VkOlxuICAgICAgICAgICAgLy8gdyBrICUgKHJ4IGkgKyByeSBqKSA9IHcgKiAoLXJ5IGkgKyByeCBqKVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5tX3R5cGUsXG4gICAgICAgICAgICAgICAgYm9keUE6IHRoaXMubV9ib2R5QSxcbiAgICAgICAgICAgICAgICBib2R5QjogdGhpcy5tX2JvZHlCLFxuICAgICAgICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRoaXMubV9jb2xsaWRlQ29ubmVjdGVkLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5tX3RhcmdldEEsXG4gICAgICAgICAgICAgICAgbWF4Rm9yY2U6IHRoaXMubV9tYXhGb3JjZSxcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3lIejogdGhpcy5tX2ZyZXF1ZW5jeUh6LFxuICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbzogdGhpcy5tX2RhbXBpbmdSYXRpbyxcbiAgICAgICAgICAgICAgICBfbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBNb3VzZUpvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEudGFyZ2V0ID0gVmVjMi5jbG9uZShkYXRhLnRhcmdldCk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgTW91c2VKb2ludChkYXRhKTtcbiAgICAgICAgICAgIGlmIChkYXRhLl9sb2NhbEFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICBqb2ludC5tX2xvY2FsQW5jaG9yQiA9IGRhdGEuX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGlzIHRvIHVwZGF0ZSB0aGUgdGFyZ2V0IHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKFZlYzIuYXJlRXF1YWwodGFyZ2V0LCB0aGlzLm1fdGFyZ2V0QSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX3RhcmdldEEuc2V0KHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fdGFyZ2V0QTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWF4aW11bSBmb3JjZSBpbiBOZXd0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGZvcmNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXhpbXVtIGZvcmNlIGluIE5ld3RvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3VzZUpvaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGZyZXF1ZW5jeSBpbiBIZXJ0ei5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLnNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChoeikge1xuICAgICAgICAgICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gaHo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZyZXF1ZW5jeSBpbiBIZXJ0ei5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRhbXBpbmcgcmF0aW8gKGRpbWVuc2lvbmxlc3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuc2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICAgICAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gcmF0aW87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGRhbXBpbmcgcmF0aW8gKGRpbWVuc2lvbmxlc3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuZ2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9kYW1waW5nUmF0aW87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QSBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5jbG9uZSh0aGlzLm1fdGFyZ2V0QSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5tdWxOdW1WZWMyKGludl9kdCwgdGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgb24gYm9keUIgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogMC4wO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hpZnQgdGhlIG9yaWdpbiBmb3IgYW55IHBvaW50cyBzdG9yZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBNb3VzZUpvaW50LnByb3RvdHlwZS5zaGlmdE9yaWdpbiA9IGZ1bmN0aW9uIChuZXdPcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXMubV90YXJnZXRBLnN1YihuZXdPcmlnaW4pO1xuICAgICAgICB9O1xuICAgICAgICBNb3VzZUpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludklCID0gdGhpcy5tX2JvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgY0IgPSBwb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QiA9IHZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB2ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB2YXIgbWFzcyA9IHRoaXMubV9ib2R5Qi5nZXRNYXNzKCk7XG4gICAgICAgICAgICAvLyBGcmVxdWVuY3lcbiAgICAgICAgICAgIHZhciBvbWVnYSA9IDIuMCAqIG1hdGhfUEkkMiAqIHRoaXMubV9mcmVxdWVuY3lIejtcbiAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcbiAgICAgICAgICAgIHZhciBkID0gMi4wICogbWFzcyAqIHRoaXMubV9kYW1waW5nUmF0aW8gKiBvbWVnYTtcbiAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcbiAgICAgICAgICAgIHZhciBrID0gbWFzcyAqIChvbWVnYSAqIG9tZWdhKTtcbiAgICAgICAgICAgIC8vIG1hZ2ljIGZvcm11bGFzXG4gICAgICAgICAgICAvLyBnYW1tYSBoYXMgdW5pdHMgb2YgaW52ZXJzZSBtYXNzLlxuICAgICAgICAgICAgLy8gYmV0YSBoYXMgdW5pdHMgb2YgaW52ZXJzZSB0aW1lLlxuICAgICAgICAgICAgdmFyIGggPSBzdGVwLmR0O1xuICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gaCAqIChkICsgaCAqIGspO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9nYW1tYSAhPSAwLjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSAxLjAgLyB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYmV0YSA9IGggKiBrICogdGhpcy5tX2dhbW1hO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxuICAgICAgICAgICAgdGhpcy5tX3JCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIC8vIEsgPSBbKDEvbTEgKyAxL20yKSAqIGV5ZSgyKSAtIHNrZXcocjEpICogaW52STEgKiBza2V3KHIxKSAtIHNrZXcocjIpICpcbiAgICAgICAgICAgIC8vIGludkkyICogc2tldyhyMildXG4gICAgICAgICAgICAvLyA9IFsxL20xKzEvbTIgMCBdICsgaW52STEgKiBbcjEueSpyMS55IC1yMS54KnIxLnldICsgaW52STIgKiBbcjEueSpyMS55XG4gICAgICAgICAgICAvLyAtcjEueCpyMS55XVxuICAgICAgICAgICAgLy8gWyAwIDEvbTErMS9tMl0gWy1yMS54KnIxLnkgcjEueCpyMS54XSBbLXIxLngqcjEueSByMS54KnIxLnhdXG4gICAgICAgICAgICB2YXIgSyA9IG5ldyBNYXQyMigpO1xuICAgICAgICAgICAgSy5leC54ID0gdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklCICogdGhpcy5tX3JCLnkgKiB0aGlzLm1fckIueVxuICAgICAgICAgICAgICAgICsgdGhpcy5tX2dhbW1hO1xuICAgICAgICAgICAgSy5leC55ID0gLXRoaXMubV9pbnZJQiAqIHRoaXMubV9yQi54ICogdGhpcy5tX3JCLnk7XG4gICAgICAgICAgICBLLmV5LnggPSBLLmV4Lnk7XG4gICAgICAgICAgICBLLmV5LnkgPSB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiB0aGlzLm1fckIueCAqIHRoaXMubV9yQi54XG4gICAgICAgICAgICAgICAgKyB0aGlzLm1fZ2FtbWE7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcyA9IEsuZ2V0SW52ZXJzZSgpO1xuICAgICAgICAgICAgdGhpcy5tX0Muc2V0VmVjMihjQik7XG4gICAgICAgICAgICB0aGlzLm1fQy5hZGRDb21iaW5lKDEsIHRoaXMubV9yQiwgLTEsIHRoaXMubV90YXJnZXRBKTtcbiAgICAgICAgICAgIHRoaXMubV9DLm11bCh0aGlzLm1fYmV0YSk7XG4gICAgICAgICAgICAvLyBDaGVhdCB3aXRoIHNvbWUgZGFtcGluZ1xuICAgICAgICAgICAgd0IgKj0gMC45ODtcbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLm11bChzdGVwLmR0UmF0aW8pO1xuICAgICAgICAgICAgICAgIHZCLmFkZE11bCh0aGlzLm1faW52TWFzc0IsIHRoaXMubV9pbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCB0aGlzLm1faW1wdWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZWxvY2l0eS52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBNb3VzZUpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgdkIgPSBWZWMyLmNsb25lKHZlbG9jaXR5LnYpO1xuICAgICAgICAgICAgdmFyIHdCID0gdmVsb2NpdHkudztcbiAgICAgICAgICAgIC8vIENkb3QgPSB2ICsgY3Jvc3ModywgcilcbiAgICAgICAgICAgIHZhciBDZG90ID0gVmVjMi5jcm9zc051bVZlYzIod0IsIHRoaXMubV9yQik7XG4gICAgICAgICAgICBDZG90LmFkZCh2Qik7XG4gICAgICAgICAgICBDZG90LmFkZENvbWJpbmUoMSwgdGhpcy5tX0MsIHRoaXMubV9nYW1tYSwgdGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICAgICAgQ2RvdC5uZWcoKTtcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gTWF0MjIubXVsVmVjMih0aGlzLm1fbWFzcywgQ2RvdCk7XG4gICAgICAgICAgICB2YXIgb2xkSW1wdWxzZSA9IFZlYzIuY2xvbmUodGhpcy5tX2ltcHVsc2UpO1xuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuYWRkKGltcHVsc2UpO1xuICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBzdGVwLmR0ICogdGhpcy5tX21heEZvcmNlO1xuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuY2xhbXAobWF4SW1wdWxzZSk7XG4gICAgICAgICAgICBpbXB1bHNlID0gVmVjMi5zdWIodGhpcy5tX2ltcHVsc2UsIG9sZEltcHVsc2UpO1xuICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgaW1wdWxzZSk7XG4gICAgICAgICAgICB3QiArPSB0aGlzLm1faW52SUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIHZlbG9jaXR5LnYuc2V0VmVjMih2Qik7XG4gICAgICAgICAgICB2ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VKb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBNb3VzZUpvaW50LlRZUEUgPSAnbW91c2Utam9pbnQnO1xuICAgICAgICByZXR1cm4gTW91c2VKb2ludDtcbiAgICB9KEpvaW50KSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9hYnMkMiA9IE1hdGguYWJzO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIERFRkFVTFRTJDMgPSB7XG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBwdWxsZXkgam9pbnQgaXMgY29ubmVjdGVkIHRvIHR3byBib2RpZXMgYW5kIHR3byBmaXhlZCBncm91bmQgcG9pbnRzLiBUaGVcbiAgICAgKiBwdWxsZXkgc3VwcG9ydHMgYSByYXRpbyBzdWNoIHRoYXQ6IGxlbmd0aDEgKyByYXRpbyAqIGxlbmd0aDIgPD0gY29uc3RhbnRcbiAgICAgKlxuICAgICAqIFllcywgdGhlIGZvcmNlIHRyYW5zbWl0dGVkIGlzIHNjYWxlZCBieSB0aGUgcmF0aW8uXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiB0aGUgcHVsbGV5IGpvaW50IGNhbiBnZXQgYSBiaXQgc3F1aXJyZWxseSBieSBpdHNlbGYuIFRoZXkgb2Z0ZW4gd29ya1xuICAgICAqIGJldHRlciB3aGVuIGNvbWJpbmVkIHdpdGggcHJpc21hdGljIGpvaW50cy4gWW91IHNob3VsZCBhbHNvIGNvdmVyIHRoZSB0aGVcbiAgICAgKiBhbmNob3IgcG9pbnRzIHdpdGggc3RhdGljIHNoYXBlcyB0byBwcmV2ZW50IG9uZSBzaWRlIGZyb20gZ29pbmcgdG8gemVyb1xuICAgICAqIGxlbmd0aC5cbiAgICAgKi9cbiAgICB2YXIgUHVsbGV5Sm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhQdWxsZXlKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUHVsbGV5Sm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGdyb3VuZEEsIGdyb3VuZEIsIGFuY2hvckEsIGFuY2hvckIsIHJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBQdWxsZXlKb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFB1bGxleUpvaW50KGRlZiwgYm9keUEsIGJvZHlCLCBncm91bmRBLCBncm91bmRCLCBhbmNob3JBLCBhbmNob3JCLCByYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkMyk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gUHVsbGV5Sm9pbnQuVFlQRTtcbiAgICAgICAgICAgIF90aGlzLm1fZ3JvdW5kQW5jaG9yQSA9IFZlYzIuY2xvbmUoZ3JvdW5kQSA/IGdyb3VuZEEgOiBkZWYuZ3JvdW5kQW5jaG9yQSB8fCBWZWMyLm5lbygtMS4wLCAxLjApKTtcbiAgICAgICAgICAgIF90aGlzLm1fZ3JvdW5kQW5jaG9yQiA9IFZlYzIuY2xvbmUoZ3JvdW5kQiA/IGdyb3VuZEIgOiBkZWYuZ3JvdW5kQW5jaG9yQiB8fCBWZWMyLm5lbygxLjAsIDEuMCkpO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBWZWMyLmNsb25lKGFuY2hvckEgPyBib2R5QS5nZXRMb2NhbFBvaW50KGFuY2hvckEpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLm5lbygtMS4wLCAwLjApKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JCID0gVmVjMi5jbG9uZShhbmNob3JCID8gYm9keUIuZ2V0TG9jYWxQb2ludChhbmNob3JCKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi5uZW8oMS4wLCAwLjApKTtcbiAgICAgICAgICAgIF90aGlzLm1fbGVuZ3RoQSA9IE51bWJlci5pc0Zpbml0ZShkZWYubGVuZ3RoQSkgPyBkZWYubGVuZ3RoQSA6IFZlYzIuZGlzdGFuY2UoYW5jaG9yQSwgZ3JvdW5kQSk7XG4gICAgICAgICAgICBfdGhpcy5tX2xlbmd0aEIgPSBOdW1iZXIuaXNGaW5pdGUoZGVmLmxlbmd0aEIpID8gZGVmLmxlbmd0aEIgOiBWZWMyLmRpc3RhbmNlKGFuY2hvckIsIGdyb3VuZEIpO1xuICAgICAgICAgICAgX3RoaXMubV9yYXRpbyA9IE51bWJlci5pc0Zpbml0ZShyYXRpbykgPyByYXRpbyA6IGRlZi5yYXRpbztcbiAgICAgICAgICAgIF90aGlzLm1fY29uc3RhbnQgPSBfdGhpcy5tX2xlbmd0aEEgKyBfdGhpcy5tX3JhdGlvICogX3RoaXMubV9sZW5ndGhCO1xuICAgICAgICAgICAgX3RoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gUHVsbGV5OlxuICAgICAgICAgICAgLy8gbGVuZ3RoMSA9IG5vcm0ocDEgLSBzMSlcbiAgICAgICAgICAgIC8vIGxlbmd0aDIgPSBub3JtKHAyIC0gczIpXG4gICAgICAgICAgICAvLyBDMCA9IChsZW5ndGgxICsgcmF0aW8gKiBsZW5ndGgyKV9pbml0aWFsXG4gICAgICAgICAgICAvLyBDID0gQzAgLSAobGVuZ3RoMSArIHJhdGlvICogbGVuZ3RoMilcbiAgICAgICAgICAgIC8vIHUxID0gKHAxIC0gczEpIC8gbm9ybShwMSAtIHMxKVxuICAgICAgICAgICAgLy8gdTIgPSAocDIgLSBzMikgLyBub3JtKHAyIC0gczIpXG4gICAgICAgICAgICAvLyBDZG90ID0gLWRvdCh1MSwgdjEgKyBjcm9zcyh3MSwgcjEpKSAtIHJhdGlvICogZG90KHUyLCB2MiArIGNyb3NzKHcyLCByMikpXG4gICAgICAgICAgICAvLyBKID0gLVt1MSBjcm9zcyhyMSwgdTEpIHJhdGlvICogdTIgcmF0aW8gKiBjcm9zcyhyMiwgdTIpXVxuICAgICAgICAgICAgLy8gSyA9IEogKiBpbnZNICogSlRcbiAgICAgICAgICAgIC8vID0gaW52TWFzczEgKyBpbnZJMSAqIGNyb3NzKHIxLCB1MSleMiArIHJhdGlvXjIgKiAoaW52TWFzczIgKyBpbnZJMiAqXG4gICAgICAgICAgICAvLyBjcm9zcyhyMiwgdTIpXjIpXG4gICAgICAgIH1cbiAgICAgICAgUHVsbGV5Sm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICBncm91bmRBbmNob3JBOiB0aGlzLm1fZ3JvdW5kQW5jaG9yQSxcbiAgICAgICAgICAgICAgICBncm91bmRBbmNob3JCOiB0aGlzLm1fZ3JvdW5kQW5jaG9yQixcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgICAgIGxlbmd0aEE6IHRoaXMubV9sZW5ndGhBLFxuICAgICAgICAgICAgICAgIGxlbmd0aEI6IHRoaXMubV9sZW5ndGhCLFxuICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLm1fcmF0aW8sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFB1bGxleUpvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IG5ldyBQdWxsZXlKb2ludChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZmlyc3QgZ3JvdW5kIGFuY2hvci5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRHcm91bmRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ncm91bmRBbmNob3JBO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzZWNvbmQgZ3JvdW5kIGFuY2hvci5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRHcm91bmRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ncm91bmRBbmNob3JCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5QS5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRMZW5ndGhBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGhBO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5Qi5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRMZW5ndGhCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGhCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBwdWxsZXkgcmF0aW8uXG4gICAgICAgICAqL1xuICAgICAgICBQdWxsZXlKb2ludC5wcm90b3R5cGUuZ2V0UmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX3JhdGlvO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5QS5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRDdXJyZW50TGVuZ3RoQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMubV9ncm91bmRBbmNob3JBO1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIuZGlzdGFuY2UocCwgcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBzZWdtZW50IGF0dGFjaGVkIHRvIGJvZHlCLlxuICAgICAgICAgKi9cbiAgICAgICAgUHVsbGV5Sm9pbnQucHJvdG90eXBlLmdldEN1cnJlbnRMZW5ndGhCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5tX2dyb3VuZEFuY2hvckI7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5kaXN0YW5jZShwLCBzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNoaWZ0IHRoZSBvcmlnaW4gZm9yIGFueSBwb2ludHMgc3RvcmVkIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV3T3JpZ2luXG4gICAgICAgICAqL1xuICAgICAgICBQdWxsZXlKb2ludC5wcm90b3R5cGUuc2hpZnRPcmlnaW4gPSBmdW5jdGlvbiAobmV3T3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yQS5zdWIobmV3T3JpZ2luKTtcbiAgICAgICAgICAgIHRoaXMubV9ncm91bmRBbmNob3JCLnN1YihuZXdPcmlnaW4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBQdWxsZXlKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlCIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgUHVsbGV5Sm9pbnQucHJvdG90eXBlLmdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIGZvcmNlIG9uIGJvZHlCIGF0IHRoZSBqb2ludCBhbmNob3IgaW4gTmV3dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubXVsTnVtVmVjMih0aGlzLm1faW1wdWxzZSwgdGhpcy5tX3VCKS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH07XG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgIHRoaXMubV9yQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHB1bGxleSBheGVzLlxuICAgICAgICAgICAgdGhpcy5tX3VBID0gVmVjMi5zdWIoVmVjMi5hZGQoY0EsIHRoaXMubV9yQSksIHRoaXMubV9ncm91bmRBbmNob3JBKTtcbiAgICAgICAgICAgIHRoaXMubV91QiA9IFZlYzIuc3ViKFZlYzIuYWRkKGNCLCB0aGlzLm1fckIpLCB0aGlzLm1fZ3JvdW5kQW5jaG9yQik7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoQSA9IHRoaXMubV91QS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGhCID0gdGhpcy5tX3VCLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aEEgPiAxMC4wICogU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3VBLm11bCgxLjAgLyBsZW5ndGhBKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubV91QS5zZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoQiA+IDEwLjAgKiBTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdUIubXVsKDEuMCAvIGxlbmd0aEIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3VCLnNldFplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgZWZmZWN0aXZlIG1hc3MuXG4gICAgICAgICAgICB2YXIgcnVBID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgdGhpcy5tX3VBKTtcbiAgICAgICAgICAgIHZhciBydUIgPSBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JCLCB0aGlzLm1fdUIpO1xuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBICsgdGhpcy5tX2ludklBICogcnVBICogcnVBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklCICogcnVCICogcnVCO1xuICAgICAgICAgICAgdGhpcy5tX21hc3MgPSBtQSArIHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqIG1CO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9tYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSAxLjAgLyB0aGlzLm1fbWFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgdmFyaWFibGUgdGltZSBzdGVwcy5cbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICAgICAgICAgLy8gV2FybSBzdGFydGluZy5cbiAgICAgICAgICAgICAgICB2YXIgUEEgPSBWZWMyLm11bE51bVZlYzIoLXRoaXMubV9pbXB1bHNlLCB0aGlzLm1fdUEpO1xuICAgICAgICAgICAgICAgIHZhciBQQiA9IFZlYzIubXVsTnVtVmVjMigtdGhpcy5tX3JhdGlvICogdGhpcy5tX2ltcHVsc2UsIHRoaXMubV91Qik7XG4gICAgICAgICAgICAgICAgdkEuYWRkTXVsKHRoaXMubV9pbnZNYXNzQSwgUEEpO1xuICAgICAgICAgICAgICAgIHdBICs9IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIFBBKTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQQik7XG4gICAgICAgICAgICAgICAgd0IgKz0gdGhpcy5tX2ludklCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgUEIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5zb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2cEEgPSBWZWMyLmFkZCh2QSwgVmVjMi5jcm9zc051bVZlYzIod0EsIHRoaXMubV9yQSkpO1xuICAgICAgICAgICAgdmFyIHZwQiA9IFZlYzIuYWRkKHZCLCBWZWMyLmNyb3NzTnVtVmVjMih3QiwgdGhpcy5tX3JCKSk7XG4gICAgICAgICAgICB2YXIgQ2RvdCA9IC1WZWMyLmRvdCh0aGlzLm1fdUEsIHZwQSkgLSB0aGlzLm1fcmF0aW8gKiBWZWMyLmRvdCh0aGlzLm1fdUIsIHZwQik7XG4gICAgICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbWFzcyAqIENkb3Q7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZSArPSBpbXB1bHNlO1xuICAgICAgICAgICAgdmFyIFBBID0gVmVjMi5tdWxOdW1WZWMyKC1pbXB1bHNlLCB0aGlzLm1fdUEpO1xuICAgICAgICAgICAgdmFyIFBCID0gVmVjMi5tdWxOdW1WZWMyKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlLCB0aGlzLm1fdUIpO1xuICAgICAgICAgICAgdkEuYWRkTXVsKHRoaXMubV9pbnZNYXNzQSwgUEEpO1xuICAgICAgICAgICAgd0EgKz0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUEEpO1xuICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUEIpO1xuICAgICAgICAgICAgd0IgKz0gdGhpcy5tX2ludklCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgUEIpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudiA9IHZCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGVycm9ycyBhcmUgd2l0aGluIHRvbGVyYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIFB1bGxleUpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcHVsbGV5IGF4ZXMuXG4gICAgICAgICAgICB2YXIgdUEgPSBWZWMyLnN1YihWZWMyLmFkZChjQSwgdGhpcy5tX3JBKSwgdGhpcy5tX2dyb3VuZEFuY2hvckEpO1xuICAgICAgICAgICAgdmFyIHVCID0gVmVjMi5zdWIoVmVjMi5hZGQoY0IsIHRoaXMubV9yQiksIHRoaXMubV9ncm91bmRBbmNob3JCKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGhBID0gdUEubGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoQiA9IHVCLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aEEgPiAxMC4wICogU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgdUEubXVsKDEuMCAvIGxlbmd0aEEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdUEuc2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aEIgPiAxMC4wICogU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICAgICAgdUIubXVsKDEuMCAvIGxlbmd0aEIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdUIuc2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cbiAgICAgICAgICAgIHZhciBydUEgPSBWZWMyLmNyb3NzVmVjMlZlYzIockEsIHVBKTtcbiAgICAgICAgICAgIHZhciBydUIgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIHVCKTtcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQSArIHRoaXMubV9pbnZJQSAqIHJ1QSAqIHJ1QTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQiArIHRoaXMubV9pbnZJQiAqIHJ1QiAqIHJ1QjtcbiAgICAgICAgICAgIHZhciBtYXNzID0gbUEgKyB0aGlzLm1fcmF0aW8gKiB0aGlzLm1fcmF0aW8gKiBtQjtcbiAgICAgICAgICAgIGlmIChtYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgbWFzcyA9IDEuMCAvIG1hc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgQyA9IHRoaXMubV9jb25zdGFudCAtIGxlbmd0aEEgLSB0aGlzLm1fcmF0aW8gKiBsZW5ndGhCO1xuICAgICAgICAgICAgdmFyIGxpbmVhckVycm9yID0gbWF0aF9hYnMkMihDKTtcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLW1hc3MgKiBDO1xuICAgICAgICAgICAgdmFyIFBBID0gVmVjMi5tdWxOdW1WZWMyKC1pbXB1bHNlLCB1QSk7XG4gICAgICAgICAgICB2YXIgUEIgPSBWZWMyLm11bE51bVZlYzIoLXRoaXMubV9yYXRpbyAqIGltcHVsc2UsIHVCKTtcbiAgICAgICAgICAgIGNBLmFkZE11bCh0aGlzLm1faW52TWFzc0EsIFBBKTtcbiAgICAgICAgICAgIGFBICs9IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgUEEpO1xuICAgICAgICAgICAgY0IuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUEIpO1xuICAgICAgICAgICAgYUIgKz0gdGhpcy5tX2ludklCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCBQQik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jID0gY0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hID0gYUE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jID0gY0I7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgICAgICAgICByZXR1cm4gbGluZWFyRXJyb3IgPCBTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3A7XG4gICAgICAgIH07XG4gICAgICAgIFB1bGxleUpvaW50LlRZUEUgPSAncHVsbGV5LWpvaW50JztcbiAgICAgICAgcmV0dXJuIFB1bGxleUpvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX21pbiQxID0gTWF0aC5taW47XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgTGltaXRTdGF0ZTtcbiAgICAoZnVuY3Rpb24gKExpbWl0U3RhdGUpIHtcbiAgICAgICAgTGltaXRTdGF0ZVtMaW1pdFN0YXRlW1wiaW5hY3RpdmVMaW1pdFwiXSA9IDBdID0gXCJpbmFjdGl2ZUxpbWl0XCI7XG4gICAgICAgIExpbWl0U3RhdGVbTGltaXRTdGF0ZVtcImF0TG93ZXJMaW1pdFwiXSA9IDFdID0gXCJhdExvd2VyTGltaXRcIjtcbiAgICAgICAgTGltaXRTdGF0ZVtMaW1pdFN0YXRlW1wiYXRVcHBlckxpbWl0XCJdID0gMl0gPSBcImF0VXBwZXJMaW1pdFwiO1xuICAgICAgICBMaW1pdFN0YXRlW0xpbWl0U3RhdGVbXCJlcXVhbExpbWl0c1wiXSA9IDNdID0gXCJlcXVhbExpbWl0c1wiO1xuICAgIH0pKExpbWl0U3RhdGUgfHwgKExpbWl0U3RhdGUgPSB7fSkpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIERFRkFVTFRTJDIgPSB7XG4gICAgICAgIG1heExlbmd0aDogMC4wLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSByb3BlIGpvaW50IGVuZm9yY2VzIGEgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMgb24gdHdvIGJvZGllcy4gSXRcbiAgICAgKiBoYXMgbm8gb3RoZXIgZWZmZWN0LlxuICAgICAqXG4gICAgICogV2FybmluZzogaWYgeW91IGF0dGVtcHQgdG8gY2hhbmdlIHRoZSBtYXhpbXVtIGxlbmd0aCBkdXJpbmcgdGhlIHNpbXVsYXRpb25cbiAgICAgKiB5b3Ugd2lsbCBnZXQgc29tZSBub24tcGh5c2ljYWwgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBBIG1vZGVsIHRoYXQgd291bGQgYWxsb3cgeW91IHRvIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgbGVuZ3RoIHdvdWxkIGhhdmUgc29tZVxuICAgICAqIHNwb25naW5lc3MsIHNvIEkgY2hvc2Ugbm90IHRvIGltcGxlbWVudCBpdCB0aGF0IHdheS4gU2VlIHtAbGluayBEaXN0YW5jZUpvaW50fSBpZiB5b3VcbiAgICAgKiB3YW50IHRvIGR5bmFtaWNhbGx5IGNvbnRyb2wgbGVuZ3RoLlxuICAgICAqL1xuICAgIHZhciBSb3BlSm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSb3BlSm9pbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJvcGVKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBSb3BlSm9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSb3BlSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkMik7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gUm9wZUpvaW50LlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUEuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLm5lbygtMS4wLCAwLjApKTtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxBbmNob3JCID0gVmVjMi5jbG9uZShhbmNob3IgPyBib2R5Qi5nZXRMb2NhbFBvaW50KGFuY2hvcikgOiBkZWYubG9jYWxBbmNob3JCIHx8IFZlYzIubmVvKDEuMCwgMC4wKSk7XG4gICAgICAgICAgICBfdGhpcy5tX21heExlbmd0aCA9IGRlZi5tYXhMZW5ndGg7XG4gICAgICAgICAgICBfdGhpcy5tX21hc3MgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2xlbmd0aCA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fc3RhdGUgPSBMaW1pdFN0YXRlLmluYWN0aXZlTGltaXQ7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAvLyBMaW1pdDpcbiAgICAgICAgICAgIC8vIEMgPSBub3JtKHBCIC0gcEEpIC0gTFxuICAgICAgICAgICAgLy8gdSA9IChwQiAtIHBBKSAvIG5vcm0ocEIgLSBwQSlcbiAgICAgICAgICAgIC8vIENkb3QgPSBkb3QodSwgdkIgKyBjcm9zcyh3QiwgckIpIC0gdkEgLSBjcm9zcyh3QSwgckEpKVxuICAgICAgICAgICAgLy8gSiA9IFstdSAtY3Jvc3MockEsIHUpIHUgY3Jvc3MockIsIHUpXVxuICAgICAgICAgICAgLy8gSyA9IEogKiBpbnZNICogSlRcbiAgICAgICAgICAgIC8vID0gaW52TWFzc0EgKyBpbnZJQSAqIGNyb3NzKHJBLCB1KV4yICsgaW52TWFzc0IgKyBpbnZJQiAqIGNyb3NzKHJCLCB1KV4yXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aDogdGhpcy5tX21heExlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUm9wZUpvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IG5ldyBSb3BlSm9pbnQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcm9wZS5cbiAgICAgICAgICovXG4gICAgICAgIFJvcGVKb2ludC5wcm90b3R5cGUuc2V0TWF4TGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5tX21heExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHJvcGUuXG4gICAgICAgICAqL1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLmdldE1heExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbWF4TGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLmdldExpbWl0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPIExpbWl0U3RhdGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fc3RhdGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QSBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFJvcGVKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHlCIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiBmb3JjZSBvbiBib2R5QiBhdCB0aGUgam9pbnQgYW5jaG9yIGluIE5ld3RvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMi5tdWxOdW1WZWMyKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fdSkubXVsKGludl9kdCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHJlYWN0aW9uIHRvcnF1ZSBvbiBib2R5QiBpbiBOKm0uXG4gICAgICAgICAqL1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfTtcbiAgICAgICAgUm9wZUpvaW50LnByb3RvdHlwZS5pbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBID0gdGhpcy5tX2JvZHlBLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCID0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0EgPSB0aGlzLm1fYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludk1hc3NCID0gdGhpcy5tX2JvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQSA9IHRoaXMubV9ib2R5QS5tX2ludkk7XG4gICAgICAgICAgICB0aGlzLm1faW52SUIgPSB0aGlzLm1fYm9keUIubV9pbnZJO1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdGhpcy5tX3JBID0gUm90Lm11bFN1YihxQSwgdGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSk7XG4gICAgICAgICAgICB0aGlzLm1fckIgPSBSb3QubXVsU3ViKHFCLCB0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKTtcbiAgICAgICAgICAgIHRoaXMubV91ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB0aGlzLm1fdS5hZGRDb21iaW5lKDEsIGNCLCAxLCB0aGlzLm1fckIpO1xuICAgICAgICAgICAgdGhpcy5tX3Uuc3ViQ29tYmluZSgxLCBjQSwgMSwgdGhpcy5tX3JBKTtcbiAgICAgICAgICAgIHRoaXMubV9sZW5ndGggPSB0aGlzLm1fdS5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBDID0gdGhpcy5tX2xlbmd0aCAtIHRoaXMubV9tYXhMZW5ndGg7XG4gICAgICAgICAgICBpZiAoQyA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9zdGF0ZSA9IExpbWl0U3RhdGUuYXRVcHBlckxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3N0YXRlID0gTGltaXRTdGF0ZS5pbmFjdGl2ZUxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV9sZW5ndGggPiBTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdS5tdWwoMS4wIC8gdGhpcy5tX2xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cbiAgICAgICAgICAgIHZhciBjckEgPSBWZWMyLmNyb3NzVmVjMlZlYzIodGhpcy5tX3JBLCB0aGlzLm1fdSk7XG4gICAgICAgICAgICB2YXIgY3JCID0gVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgdGhpcy5tX3UpO1xuICAgICAgICAgICAgdmFyIGludk1hc3MgPSB0aGlzLm1faW52TWFzc0EgKyB0aGlzLm1faW52SUEgKiBjckEgKiBjckEgKyB0aGlzLm1faW52TWFzc0IgKyB0aGlzLm1faW52SUIgKiBjckIgKiBjckI7XG4gICAgICAgICAgICB0aGlzLm1fbWFzcyA9IGludk1hc3MgIT0gMC4wID8gMS4wIC8gaW52TWFzcyA6IDAuMDtcbiAgICAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlIHRoZSBpbXB1bHNlIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKHRoaXMubV9pbXB1bHNlLCB0aGlzLm1fdSk7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKHRoaXMubV9pbnZNYXNzQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCk7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gdGhpcy5tX2ludklCICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQiwgUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2QSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52LnNldFZlYzIodkIpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICBSb3BlSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgLy8gQ2RvdCA9IGRvdCh1LCB2ICsgY3Jvc3ModywgcikpXG4gICAgICAgICAgICB2YXIgdnBBID0gVmVjMi5hZGRDcm9zc051bVZlYzIodkEsIHdBLCB0aGlzLm1fckEpO1xuICAgICAgICAgICAgdmFyIHZwQiA9IFZlYzIuYWRkQ3Jvc3NOdW1WZWMyKHZCLCB3QiwgdGhpcy5tX3JCKTtcbiAgICAgICAgICAgIHZhciBDID0gdGhpcy5tX2xlbmd0aCAtIHRoaXMubV9tYXhMZW5ndGg7XG4gICAgICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuZG90KHRoaXMubV91LCBWZWMyLnN1Yih2cEIsIHZwQSkpO1xuICAgICAgICAgICAgLy8gUHJlZGljdGl2ZSBjb25zdHJhaW50LlxuICAgICAgICAgICAgaWYgKEMgPCAwLjApIHtcbiAgICAgICAgICAgICAgICBDZG90ICs9IHN0ZXAuaW52X2R0ICogQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLXRoaXMubV9tYXNzICogQ2RvdDtcbiAgICAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2ltcHVsc2U7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZSA9IG1hdGhfbWluJDEoMC4wLCB0aGlzLm1faW1wdWxzZSArIGltcHVsc2UpO1xuICAgICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgICAgIHZhciBQID0gVmVjMi5tdWxOdW1WZWMyKGltcHVsc2UsIHRoaXMubV91KTtcbiAgICAgICAgICAgIHZBLnN1Yk11bCh0aGlzLm1faW52TWFzc0EsIFApO1xuICAgICAgICAgICAgd0EgLT0gdGhpcy5tX2ludklBICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCk7XG4gICAgICAgICAgICB2Qi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICAgICAgICAgIHdCICs9IHRoaXMubV9pbnZJQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIFApO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudiA9IHZBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudiA9IHZCO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudyA9IHdCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGVycm9ycyBhcmUgd2l0aGluIHRvbGVyYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIFJvcGVKb2ludC5wcm90b3R5cGUuc29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBjQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFN1YihxQSwgdGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSk7XG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsU3ViKHFCLCB0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKTtcbiAgICAgICAgICAgIHZhciB1ID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICB1LmFkZENvbWJpbmUoMSwgY0IsIDEsIHJCKTtcbiAgICAgICAgICAgIHUuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHUubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB2YXIgQyA9IGxlbmd0aCAtIHRoaXMubV9tYXhMZW5ndGg7XG4gICAgICAgICAgICBDID0gY2xhbXAoQywgMC4wLCBTZXR0aW5nc0ludGVybmFsLm1heExpbmVhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX21hc3MgKiBDO1xuICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm11bE51bVZlYzIoaW1wdWxzZSwgdSk7XG4gICAgICAgICAgICBjQS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgICAgIGFBIC09IHRoaXMubV9pbnZJQSAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgUCk7XG4gICAgICAgICAgICBjQi5hZGRNdWwodGhpcy5tX2ludk1hc3NCLCBQKTtcbiAgICAgICAgICAgIGFCICs9IHRoaXMubV9pbnZJQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgUCk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jLnNldFZlYzIoY0EpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYSA9IGFBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYy5zZXRWZWMyKGNCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmEgPSBhQjtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggLSB0aGlzLm1fbWF4TGVuZ3RoIDwgU2V0dGluZ3NJbnRlcm5hbC5saW5lYXJTbG9wO1xuICAgICAgICB9O1xuICAgICAgICBSb3BlSm9pbnQuVFlQRSA9ICdyb3BlLWpvaW50JztcbiAgICAgICAgcmV0dXJuIFJvcGVKb2ludDtcbiAgICB9KEpvaW50KSk7XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9hYnMkMSA9IE1hdGguYWJzO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfUEkkMSA9IE1hdGguUEk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgREVGQVVMVFMkMSA9IHtcbiAgICAgICAgZnJlcXVlbmN5SHo6IDAuMCxcbiAgICAgICAgZGFtcGluZ1JhdGlvOiAwLjAsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHdlbGQgam9pbnQgZXNzZW50aWFsbHkgZ2x1ZXMgdHdvIGJvZGllcyB0b2dldGhlci4gQSB3ZWxkIGpvaW50IG1heSBkaXN0b3J0XG4gICAgICogc29tZXdoYXQgYmVjYXVzZSB0aGUgaXNsYW5kIGNvbnN0cmFpbnQgc29sdmVyIGlzIGFwcHJveGltYXRlLlxuICAgICAqL1xuICAgIHZhciBXZWxkSm9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhXZWxkSm9pbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFdlbGRKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBXZWxkSm9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWxkSm9pbnQoZGVmLCBib2R5QSwgYm9keUIsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWYgPSBvcHRpb25zKGRlZiwgREVGQVVMVFMkMSk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gV2VsZEpvaW50LlRZUEU7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQSA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUEuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQSB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICBfdGhpcy5tX2xvY2FsQW5jaG9yQiA9IFZlYzIuY2xvbmUoYW5jaG9yID8gYm9keUIuZ2V0TG9jYWxQb2ludChhbmNob3IpIDogZGVmLmxvY2FsQW5jaG9yQiB8fCBWZWMyLnplcm8oKSk7XG4gICAgICAgICAgICBfdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gTnVtYmVyLmlzRmluaXRlKGRlZi5yZWZlcmVuY2VBbmdsZSkgPyBkZWYucmVmZXJlbmNlQW5nbGUgOiBib2R5Qi5nZXRBbmdsZSgpIC0gYm9keUEuZ2V0QW5nbGUoKTtcbiAgICAgICAgICAgIF90aGlzLm1fZnJlcXVlbmN5SHogPSBkZWYuZnJlcXVlbmN5SHo7XG4gICAgICAgICAgICBfdGhpcy5tX2RhbXBpbmdSYXRpbyA9IGRlZi5kYW1waW5nUmF0aW87XG4gICAgICAgICAgICBfdGhpcy5tX2ltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgX3RoaXMubV9iaWFzID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9nYW1tYSA9IDAuMDtcbiAgICAgICAgICAgIC8vIFNvbHZlciB0ZW1wXG4gICAgICAgICAgICBfdGhpcy5tX3JBO1xuICAgICAgICAgICAgX3RoaXMubV9yQjtcbiAgICAgICAgICAgIF90aGlzLm1fbG9jYWxDZW50ZXJBO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbENlbnRlckI7XG4gICAgICAgICAgICBfdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgX3RoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgIF90aGlzLm1faW52SUE7XG4gICAgICAgICAgICBfdGhpcy5tX2ludklCO1xuICAgICAgICAgICAgX3RoaXMubV9tYXNzID0gbmV3IE1hdDMzKCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAvLyBQb2ludC10by1wb2ludCBjb25zdHJhaW50XG4gICAgICAgICAgICAvLyBDID0gcDIgLSBwMVxuICAgICAgICAgICAgLy8gQ2RvdCA9IHYyIC0gdjFcbiAgICAgICAgICAgIC8vIC8gPSB2MiArIGNyb3NzKHcyLCByMikgLSB2MSAtIGNyb3NzKHcxLCByMSlcbiAgICAgICAgICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3IF1cbiAgICAgICAgICAgIC8vIElkZW50aXR5IHVzZWQ6XG4gICAgICAgICAgICAvLyB3IGsgJSAocnggaSArIHJ5IGopID0gdyAqICgtcnkgaSArIHJ4IGopXG4gICAgICAgICAgICAvLyBBbmdsZSBjb25zdHJhaW50XG4gICAgICAgICAgICAvLyBDID0gYW5nbGUyIC0gYW5nbGUxIC0gcmVmZXJlbmNlQW5nbGVcbiAgICAgICAgICAgIC8vIENkb3QgPSB3MiAtIHcxXG4gICAgICAgICAgICAvLyBKID0gWzAgMCAtMSAwIDAgMV1cbiAgICAgICAgICAgIC8vIEsgPSBpbnZJMSArIGludkkyXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLl9zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubV90eXBlLFxuICAgICAgICAgICAgICAgIGJvZHlBOiB0aGlzLm1fYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUI6IHRoaXMubV9ib2R5QixcbiAgICAgICAgICAgICAgICBjb2xsaWRlQ29ubmVjdGVkOiB0aGlzLm1fY29sbGlkZUNvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3lIejogdGhpcy5tX2ZyZXF1ZW5jeUh6LFxuICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbzogdGhpcy5tX2RhbXBpbmdSYXRpbyxcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckE6IHRoaXMubV9sb2NhbEFuY2hvckEsXG4gICAgICAgICAgICAgICAgbG9jYWxBbmNob3JCOiB0aGlzLm1fbG9jYWxBbmNob3JCLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUFuZ2xlOiB0aGlzLm1fcmVmZXJlbmNlQW5nbGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFdlbGRKb2ludC5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgd29ybGQsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmJvZHlBID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlBLCB3b3JsZCk7XG4gICAgICAgICAgICBkYXRhLmJvZHlCID0gcmVzdG9yZShCb2R5LCBkYXRhLmJvZHlCLCB3b3JsZCk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBuZXcgV2VsZEpvaW50KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFdlbGRKb2ludC5wcm90b3R5cGUuX3NldEFuY2hvcnMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmFuY2hvckEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLnNldFZlYzIodGhpcy5tX2JvZHlBLmdldExvY2FsUG9pbnQoZGVmLmFuY2hvckEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5sb2NhbEFuY2hvckEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLnNldFZlYzIoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmLmFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JCLnNldFZlYzIodGhpcy5tX2JvZHlCLmdldExvY2FsUG9pbnQoZGVmLmFuY2hvckIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5sb2NhbEFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3JCLnNldFZlYzIoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLmdldExvY2FsQW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxBbmNob3JCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWZlcmVuY2UgYW5nbGUuXG4gICAgICAgICAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLmdldFJlZmVyZW5jZUFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBmcmVxdWVuY3kgaW4gSHouXG4gICAgICAgICAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLnNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChoeikge1xuICAgICAgICAgICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gaHo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZnJlcXVlbmN5IGluIEh6LlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5nZXRGcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2ZyZXF1ZW5jeUh6O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRhbXBpbmcgcmF0aW8uXG4gICAgICAgICAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLnNldERhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uIChyYXRpbykge1xuICAgICAgICAgICAgdGhpcy5tX2RhbXBpbmdSYXRpbyA9IHJhdGlvO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGRhbXBpbmcgcmF0aW8uXG4gICAgICAgICAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLmdldERhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZGFtcGluZ1JhdGlvO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLmdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5QiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIFdlbGRKb2ludC5wcm90b3R5cGUuZ2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuZ2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gZm9yY2Ugb24gYm9keUIgYXQgdGhlIGpvaW50IGFuY2hvciBpbiBOZXd0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIubmVvKHRoaXMubV9pbXB1bHNlLngsIHRoaXMubV9pbXB1bHNlLnkpLm11bChpbnZfZHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgb24gYm9keUIgaW4gTiptLlxuICAgICAgICAgKi9cbiAgICAgICAgV2VsZEpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS56O1xuICAgICAgICB9O1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludklBID0gdGhpcy5tX2JvZHlBLm1faW52STtcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQiA9IHRoaXMubV9ib2R5Qi5tX2ludkk7XG4gICAgICAgICAgICB2YXIgYUEgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgcUEgPSBSb3QubmVvKGFBKTtcbiAgICAgICAgICAgIHZhciBxQiA9IFJvdC5uZW8oYUIpO1xuICAgICAgICAgICAgdGhpcy5tX3JBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgIHRoaXMubV9yQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tld11cbiAgICAgICAgICAgIC8vIFsgMCAtMSAwIDFdXG4gICAgICAgICAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cbiAgICAgICAgICAgIC8vIE1hdGxhYlxuICAgICAgICAgICAgLy8gSyA9IFsgbUErcjF5XjIqaUErbUIrcjJ5XjIqaUIsIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIC1yMXkqaUEtcjJ5KmlCXVxuICAgICAgICAgICAgLy8gWyAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCBtQStyMXheMippQSttQityMnheMippQiwgcjF4KmlBK3IyeCppQl1cbiAgICAgICAgICAgIC8vIFsgLXIxeSppQS1yMnkqaUIsIHIxeCppQStyMngqaUIsIGlBK2lCXVxuICAgICAgICAgICAgdmFyIG1BID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgICAgdmFyIG1CID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgICAgdmFyIGlBID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgICAgdmFyIGlCID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgICAgdmFyIEsgPSBuZXcgTWF0MzMoKTtcbiAgICAgICAgICAgIEsuZXgueCA9IG1BICsgbUIgKyB0aGlzLm1fckEueSAqIHRoaXMubV9yQS55ICogaUEgKyB0aGlzLm1fckIueSAqIHRoaXMubV9yQi55XG4gICAgICAgICAgICAgICAgKiBpQjtcbiAgICAgICAgICAgIEsuZXkueCA9IC10aGlzLm1fckEueSAqIHRoaXMubV9yQS54ICogaUEgLSB0aGlzLm1fckIueSAqIHRoaXMubV9yQi54ICogaUI7XG4gICAgICAgICAgICBLLmV6LnggPSAtdGhpcy5tX3JBLnkgKiBpQSAtIHRoaXMubV9yQi55ICogaUI7XG4gICAgICAgICAgICBLLmV4LnkgPSBLLmV5Lng7XG4gICAgICAgICAgICBLLmV5LnkgPSBtQSArIG1CICsgdGhpcy5tX3JBLnggKiB0aGlzLm1fckEueCAqIGlBICsgdGhpcy5tX3JCLnggKiB0aGlzLm1fckIueFxuICAgICAgICAgICAgICAgICogaUI7XG4gICAgICAgICAgICBLLmV6LnkgPSB0aGlzLm1fckEueCAqIGlBICsgdGhpcy5tX3JCLnggKiBpQjtcbiAgICAgICAgICAgIEsuZXgueiA9IEsuZXoueDtcbiAgICAgICAgICAgIEsuZXkueiA9IEsuZXoueTtcbiAgICAgICAgICAgIEsuZXoueiA9IGlBICsgaUI7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgSy5nZXRJbnZlcnNlMjIodGhpcy5tX21hc3MpO1xuICAgICAgICAgICAgICAgIHZhciBpbnZNID0gaUEgKyBpQjtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGludk0gPiAwLjAgPyAxLjAgLyBpbnZNIDogMC4wO1xuICAgICAgICAgICAgICAgIHZhciBDID0gYUIgLSBhQSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgICAgICAgICAvLyBGcmVxdWVuY3lcbiAgICAgICAgICAgICAgICB2YXIgb21lZ2EgPSAyLjAgKiBtYXRoX1BJJDEgKiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxuICAgICAgICAgICAgICAgIHZhciBkID0gMi4wICogbSAqIHRoaXMubV9kYW1waW5nUmF0aW8gKiBvbWVnYTtcbiAgICAgICAgICAgICAgICAvLyBTcHJpbmcgc3RpZmZuZXNzXG4gICAgICAgICAgICAgICAgdmFyIGsgPSBtICogb21lZ2EgKiBvbWVnYTtcbiAgICAgICAgICAgICAgICAvLyBtYWdpYyBmb3JtdWxhc1xuICAgICAgICAgICAgICAgIHZhciBoID0gc3RlcC5kdDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSBoICogKGQgKyBoICogayk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gdGhpcy5tX2dhbW1hICE9IDAuMCA/IDEuMCAvIHRoaXMubV9nYW1tYSA6IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fYmlhcyA9IEMgKiBoICogayAqIHRoaXMubV9nYW1tYTtcbiAgICAgICAgICAgICAgICBpbnZNICs9IHRoaXMubV9nYW1tYTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbWFzcy5lei56ID0gaW52TSAhPSAwLjAgPyAxLjAgLyBpbnZNIDogMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoSy5lei56ID09IDAuMCkge1xuICAgICAgICAgICAgICAgIEsuZ2V0SW52ZXJzZTIyKHRoaXMubV9tYXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSAwLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JpYXMgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBLLmdldFN5bUludmVyc2UzMyh0aGlzLm1fbWFzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2dhbW1hID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9iaWFzID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5tdWwoc3RlcC5kdFJhdGlvKTtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVvKHRoaXMubV9pbXB1bHNlLngsIHRoaXMubV9pbXB1bHNlLnkpO1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCkgKyB0aGlzLm1faW1wdWxzZS56KTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogKFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIFApICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52ID0gdkE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53ID0gd0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52ID0gdkI7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIFdlbGRKb2ludC5wcm90b3R5cGUuc29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIHZCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudjtcbiAgICAgICAgICAgIHZhciB3QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5Lnc7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QyID0gd0IgLSB3QTtcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZTIgPSAtdGhpcy5tX21hc3MuZXoueiAqIChDZG90MiArIHRoaXMubV9iaWFzICsgdGhpcy5tX2dhbW1hICogdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiArPSBpbXB1bHNlMjtcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIGltcHVsc2UyO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogaW1wdWxzZTI7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QxID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgQ2RvdDEuYWRkQ29tYmluZSgxLCB2QiwgMSwgVmVjMi5jcm9zc051bVZlYzIod0IsIHRoaXMubV9yQikpO1xuICAgICAgICAgICAgICAgIENkb3QxLnN1YkNvbWJpbmUoMSwgdkEsIDEsIFZlYzIuY3Jvc3NOdW1WZWMyKHdBLCB0aGlzLm1fckEpKTtcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZTEgPSBWZWMyLm5lZyhNYXQzMy5tdWxWZWMyKHRoaXMubV9tYXNzLCBDZG90MSkpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gaW1wdWxzZTEueDtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ICs9IGltcHVsc2UxLnk7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBWZWMyLmNsb25lKGltcHVsc2UxKTtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogVmVjMi5jcm9zc1ZlYzJWZWMyKHRoaXMubV9yQSwgUCk7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QxID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgQ2RvdDEuYWRkQ29tYmluZSgxLCB2QiwgMSwgVmVjMi5jcm9zc051bVZlYzIod0IsIHRoaXMubV9yQikpO1xuICAgICAgICAgICAgICAgIENkb3QxLnN1YkNvbWJpbmUoMSwgdkEsIDEsIFZlYzIuY3Jvc3NOdW1WZWMyKHdBLCB0aGlzLm1fckEpKTtcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdDIgPSB3QiAtIHdBO1xuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gbmV3IFZlYzMoQ2RvdDEueCwgQ2RvdDEueSwgQ2RvdDIpO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gVmVjMy5uZWcoTWF0MzMubXVsVmVjMyh0aGlzLm1fbWFzcywgQ2RvdCkpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVvKGltcHVsc2UueCwgaW1wdWxzZS55KTtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogKFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckEsIFApICsgaW1wdWxzZS56KTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogKFZlYzIuY3Jvc3NWZWMyVmVjMih0aGlzLm1fckIsIFApICsgaW1wdWxzZS56KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnYgPSB2QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYgPSB2QjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBlcnJvcnMgYXJlIHdpdGhpbiB0b2xlcmFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBXZWxkSm9pbnQucHJvdG90eXBlLnNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBjQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmM7XG4gICAgICAgICAgICB2YXIgYUIgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hO1xuICAgICAgICAgICAgdmFyIHFBID0gUm90Lm5lbyhhQSk7XG4gICAgICAgICAgICB2YXIgcUIgPSBSb3QubmVvKGFCKTtcbiAgICAgICAgICAgIHZhciBtQSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgICAgIHZhciBtQiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgICAgIHZhciBpQSA9IHRoaXMubV9pbnZJQTtcbiAgICAgICAgICAgIHZhciBpQiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgICAgIHZhciByQSA9IFJvdC5tdWxWZWMyKHFBLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JBLCB0aGlzLm1fbG9jYWxDZW50ZXJBKSk7XG4gICAgICAgICAgICB2YXIgckIgPSBSb3QubXVsVmVjMihxQiwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQiwgdGhpcy5tX2xvY2FsQ2VudGVyQikpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uRXJyb3I7XG4gICAgICAgICAgICB2YXIgYW5ndWxhckVycm9yO1xuICAgICAgICAgICAgdmFyIEsgPSBuZXcgTWF0MzMoKTtcbiAgICAgICAgICAgIEsuZXgueCA9IG1BICsgbUIgKyByQS55ICogckEueSAqIGlBICsgckIueSAqIHJCLnkgKiBpQjtcbiAgICAgICAgICAgIEsuZXkueCA9IC1yQS55ICogckEueCAqIGlBIC0gckIueSAqIHJCLnggKiBpQjtcbiAgICAgICAgICAgIEsuZXoueCA9IC1yQS55ICogaUEgLSByQi55ICogaUI7XG4gICAgICAgICAgICBLLmV4LnkgPSBLLmV5Lng7XG4gICAgICAgICAgICBLLmV5LnkgPSBtQSArIG1CICsgckEueCAqIHJBLnggKiBpQSArIHJCLnggKiByQi54ICogaUI7XG4gICAgICAgICAgICBLLmV6LnkgPSByQS54ICogaUEgKyByQi54ICogaUI7XG4gICAgICAgICAgICBLLmV4LnogPSBLLmV6Lng7XG4gICAgICAgICAgICBLLmV5LnogPSBLLmV6Lnk7XG4gICAgICAgICAgICBLLmV6LnogPSBpQSArIGlCO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9mcmVxdWVuY3lIeiA+IDAuMCkge1xuICAgICAgICAgICAgICAgIHZhciBDMSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgICAgIEMxLmFkZENvbWJpbmUoMSwgY0IsIDEsIHJCKTtcbiAgICAgICAgICAgICAgICBDMS5zdWJDb21iaW5lKDEsIGNBLCAxLCByQSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25FcnJvciA9IEMxLmxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IDAuMDtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVnKEsuc29sdmUyMihDMSkpO1xuICAgICAgICAgICAgICAgIGNBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgYUEgLT0gaUEgKiBWZWMyLmNyb3NzVmVjMlZlYzIockEsIFApO1xuICAgICAgICAgICAgICAgIGNCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgYUIgKz0gaUIgKiBWZWMyLmNyb3NzVmVjMlZlYzIockIsIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIEMxID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICAgICAgQzEuYWRkQ29tYmluZSgxLCBjQiwgMSwgckIpO1xuICAgICAgICAgICAgICAgIEMxLnN1YkNvbWJpbmUoMSwgY0EsIDEsIHJBKTtcbiAgICAgICAgICAgICAgICB2YXIgQzIgPSBhQiAtIGFBIC0gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXJyb3IgPSBDMS5sZW5ndGgoKTtcbiAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBtYXRoX2FicyQxKEMyKTtcbiAgICAgICAgICAgICAgICB2YXIgQyA9IG5ldyBWZWMzKEMxLngsIEMxLnksIEMyKTtcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgaWYgKEsuZXoueiA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICBpbXB1bHNlID0gVmVjMy5uZWcoSy5zb2x2ZTMzKEMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlMiA9IFZlYzIubmVnKEsuc29sdmUyMihDMSkpO1xuICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLnNldChpbXB1bHNlMi54LCBpbXB1bHNlMi55LCAwLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubmVvKGltcHVsc2UueCwgaW1wdWxzZS55KTtcbiAgICAgICAgICAgICAgICBjQS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIGFBIC09IGlBICogKFZlYzIuY3Jvc3NWZWMyVmVjMihyQSwgUCkgKyBpbXB1bHNlLnopO1xuICAgICAgICAgICAgICAgIGNCLmFkZE11bChtQiwgUCk7XG4gICAgICAgICAgICAgICAgYUIgKz0gaUIgKiAoVmVjMi5jcm9zc1ZlYzJWZWMyKHJCLCBQKSArIGltcHVsc2Uueik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jID0gY0E7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hID0gYUE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jID0gY0I7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5hID0gYUI7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25FcnJvciA8PSBTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IFNldHRpbmdzSW50ZXJuYWwuYW5ndWxhclNsb3A7XG4gICAgICAgIH07XG4gICAgICAgIFdlbGRKb2ludC5UWVBFID0gJ3dlbGQtam9pbnQnO1xuICAgICAgICByZXR1cm4gV2VsZEpvaW50O1xuICAgIH0oSm9pbnQpKTtcblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXRoX2FicyA9IE1hdGguYWJzO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG1hdGhfUEkgPSBNYXRoLlBJO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIERFRkFVTFRTID0ge1xuICAgICAgICBlbmFibGVNb3RvcjogZmFsc2UsXG4gICAgICAgIG1heE1vdG9yVG9ycXVlOiAwLjAsXG4gICAgICAgIG1vdG9yU3BlZWQ6IDAuMCxcbiAgICAgICAgZnJlcXVlbmN5SHo6IDIuMCxcbiAgICAgICAgZGFtcGluZ1JhdGlvOiAwLjcsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHdoZWVsIGpvaW50LiBUaGlzIGpvaW50IHByb3ZpZGVzIHR3byBkZWdyZWVzIG9mIGZyZWVkb206IHRyYW5zbGF0aW9uIGFsb25nXG4gICAgICogYW4gYXhpcyBmaXhlZCBpbiBib2R5QSBhbmQgcm90YXRpb24gaW4gdGhlIHBsYW5lLiBJbiBvdGhlciB3b3JkcywgaXQgaXMgYVxuICAgICAqIHBvaW50IHRvIGxpbmUgY29uc3RyYWludCB3aXRoIGEgcm90YXRpb25hbCBtb3RvciBhbmQgYSBsaW5lYXIgc3ByaW5nL2RhbXBlci5cbiAgICAgKiBUaGlzIGpvaW50IGlzIGRlc2lnbmVkIGZvciB2ZWhpY2xlIHN1c3BlbnNpb25zLlxuICAgICAqL1xuICAgIHZhciBXaGVlbEpvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoV2hlZWxKb2ludCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gV2hlZWxKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yLCBheGlzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKCEoX3RoaXMgaW5zdGFuY2VvZiBXaGVlbEpvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2hlZWxKb2ludChkZWYsIGJvZHlBLCBib2R5QiwgYW5jaG9yLCBheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZiA9IG9wdGlvbnMoZGVmLCBERUZBVUxUUyk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgYm9keUEsIGJvZHlCKSB8fCB0aGlzO1xuICAgICAgICAgICAgYm9keUEgPSBfdGhpcy5tX2JvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBfdGhpcy5tX2JvZHlCO1xuICAgICAgICAgICAgX3RoaXMubV9heCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV9heSA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgX3RoaXMubV90eXBlID0gV2hlZWxKb2ludC5UWVBFO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckEgPSBWZWMyLmNsb25lKGFuY2hvciA/IGJvZHlBLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckEgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgX3RoaXMubV9sb2NhbEFuY2hvckIgPSBWZWMyLmNsb25lKGFuY2hvciA/IGJvZHlCLmdldExvY2FsUG9pbnQoYW5jaG9yKSA6IGRlZi5sb2NhbEFuY2hvckIgfHwgVmVjMi56ZXJvKCkpO1xuICAgICAgICAgICAgaWYgKFZlYzIuaXNWYWxpZChheGlzKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm1fbG9jYWxYQXhpc0EgPSBib2R5QS5nZXRMb2NhbFZlY3RvcihheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFZlYzIuaXNWYWxpZChkZWYubG9jYWxBeGlzQSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsWEF4aXNBID0gVmVjMi5jbG9uZShkZWYubG9jYWxBeGlzQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChWZWMyLmlzVmFsaWQoZGVmLmxvY2FsQXhpcykpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbEF4aXMgaXMgcmVuYW1lZCB0byBsb2NhbEF4aXNBLCB0aGlzIGlzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgX3RoaXMubV9sb2NhbFhBeGlzQSA9IFZlYzIuY2xvbmUoZGVmLmxvY2FsQXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tX2xvY2FsWEF4aXNBID0gVmVjMi5uZW8oMS4wLCAwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMubV9sb2NhbFlBeGlzQSA9IFZlYzIuY3Jvc3NOdW1WZWMyKDEuMCwgX3RoaXMubV9sb2NhbFhBeGlzQSk7XG4gICAgICAgICAgICBfdGhpcy5tX21hc3MgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX21vdG9yTWFzcyA9IDAuMDtcbiAgICAgICAgICAgIF90aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9zcHJpbmdNYXNzID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9zcHJpbmdJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgX3RoaXMubV9tYXhNb3RvclRvcnF1ZSA9IGRlZi5tYXhNb3RvclRvcnF1ZTtcbiAgICAgICAgICAgIF90aGlzLm1fbW90b3JTcGVlZCA9IGRlZi5tb3RvclNwZWVkO1xuICAgICAgICAgICAgX3RoaXMubV9lbmFibGVNb3RvciA9IGRlZi5lbmFibGVNb3RvcjtcbiAgICAgICAgICAgIF90aGlzLm1fZnJlcXVlbmN5SHogPSBkZWYuZnJlcXVlbmN5SHo7XG4gICAgICAgICAgICBfdGhpcy5tX2RhbXBpbmdSYXRpbyA9IGRlZi5kYW1waW5nUmF0aW87XG4gICAgICAgICAgICBfdGhpcy5tX2JpYXMgPSAwLjA7XG4gICAgICAgICAgICBfdGhpcy5tX2dhbW1hID0gMC4wO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgLy8gTGluZWFyIGNvbnN0cmFpbnQgKHBvaW50LXRvLWxpbmUpXG4gICAgICAgICAgICAvLyBkID0gcEIgLSBwQSA9IHhCICsgckIgLSB4QSAtIHJBXG4gICAgICAgICAgICAvLyBDID0gZG90KGF5LCBkKVxuICAgICAgICAgICAgLy8gQ2RvdCA9IGRvdChkLCBjcm9zcyh3QSwgYXkpKSArIGRvdChheSwgdkIgKyBjcm9zcyh3QiwgckIpIC0gdkEgLSBjcm9zcyh3QSxcbiAgICAgICAgICAgIC8vIHJBKSlcbiAgICAgICAgICAgIC8vID0gLWRvdChheSwgdkEpIC0gZG90KGNyb3NzKGQgKyByQSwgYXkpLCB3QSkgKyBkb3QoYXksIHZCKSArIGRvdChjcm9zcyhyQixcbiAgICAgICAgICAgIC8vIGF5KSwgdkIpXG4gICAgICAgICAgICAvLyBKID0gWy1heSwgLWNyb3NzKGQgKyByQSwgYXkpLCBheSwgY3Jvc3MockIsIGF5KV1cbiAgICAgICAgICAgIC8vIFNwcmluZyBsaW5lYXIgY29uc3RyYWludFxuICAgICAgICAgICAgLy8gQyA9IGRvdChheCwgZClcbiAgICAgICAgICAgIC8vIENkb3QgPSA9IC1kb3QoYXgsIHZBKSAtIGRvdChjcm9zcyhkICsgckEsIGF4KSwgd0EpICsgZG90KGF4LCB2QikgK1xuICAgICAgICAgICAgLy8gZG90KGNyb3NzKHJCLCBheCksIHZCKVxuICAgICAgICAgICAgLy8gSiA9IFstYXggLWNyb3NzKGQrckEsIGF4KSBheCBjcm9zcyhyQiwgYXgpXVxuICAgICAgICAgICAgLy8gTW90b3Igcm90YXRpb25hbCBjb25zdHJhaW50XG4gICAgICAgICAgICAvLyBDZG90ID0gd0IgLSB3QVxuICAgICAgICAgICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5fc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm1fdHlwZSxcbiAgICAgICAgICAgICAgICBib2R5QTogdGhpcy5tX2JvZHlBLFxuICAgICAgICAgICAgICAgIGJvZHlCOiB0aGlzLm1fYm9keUIsXG4gICAgICAgICAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgZW5hYmxlTW90b3I6IHRoaXMubV9lbmFibGVNb3RvcixcbiAgICAgICAgICAgICAgICBtYXhNb3RvclRvcnF1ZTogdGhpcy5tX21heE1vdG9yVG9ycXVlLFxuICAgICAgICAgICAgICAgIG1vdG9yU3BlZWQ6IHRoaXMubV9tb3RvclNwZWVkLFxuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeUh6OiB0aGlzLm1fZnJlcXVlbmN5SHosXG4gICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvOiB0aGlzLm1fZGFtcGluZ1JhdGlvLFxuICAgICAgICAgICAgICAgIGxvY2FsQW5jaG9yQTogdGhpcy5tX2xvY2FsQW5jaG9yQSxcbiAgICAgICAgICAgICAgICBsb2NhbEFuY2hvckI6IHRoaXMubV9sb2NhbEFuY2hvckIsXG4gICAgICAgICAgICAgICAgbG9jYWxBeGlzQTogdGhpcy5tX2xvY2FsWEF4aXNBLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXaGVlbEpvaW50Ll9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhLCB3b3JsZCwgcmVzdG9yZSkge1xuICAgICAgICAgICAgZGF0YSA9IF9fYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUEgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUEsIHdvcmxkKTtcbiAgICAgICAgICAgIGRhdGEuYm9keUIgPSByZXN0b3JlKEJvZHksIGRhdGEuYm9keUIsIHdvcmxkKTtcbiAgICAgICAgICAgIHZhciBqb2ludCA9IG5ldyBXaGVlbEpvaW50KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLl9zZXRBbmNob3JzID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKHRoaXMubV9ib2R5QS5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JBKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQS5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5hbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKHRoaXMubV9ib2R5Qi5nZXRMb2NhbFBvaW50KGRlZi5hbmNob3JCKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYubG9jYWxBbmNob3JCKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQi5zZXRWZWMyKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5sb2NhbEF4aXNBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2xvY2FsWEF4aXNBLnNldFZlYzIoZGVmLmxvY2FsQXhpc0EpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9sb2NhbFlBeGlzQS5zZXRWZWMyKFZlYzIuY3Jvc3NOdW1WZWMyKDEuMCwgZGVmLmxvY2FsQXhpc0EpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRMb2NhbEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQW5jaG9yQjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2NhbCBqb2ludCBheGlzIHJlbGF0aXZlIHRvIGJvZHlBLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0TG9jYWxBeGlzQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxYQXhpc0E7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgam9pbnQgdHJhbnNsYXRpb24sIHVzdWFsbHkgaW4gbWV0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0Sm9pbnRUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgICAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgICAgICAgIHZhciBwQSA9IGJBLmdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICAgICAgICAgICB2YXIgcEIgPSBiQi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgdmFyIGQgPSBWZWMyLnN1YihwQiwgcEEpO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBiQS5nZXRXb3JsZFZlY3Rvcih0aGlzLm1fbG9jYWxYQXhpc0EpO1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gVmVjMi5kb3QoZCwgYXhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgam9pbnQgdHJhbnNsYXRpb24gc3BlZWQsIHVzdWFsbHkgaW4gbWV0ZXJzIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRKb2ludFNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgcmV0dXJuIHdCIC0gd0E7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJcyB0aGUgam9pbnQgbW90b3IgZW5hYmxlZD9cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmlzTW90b3JFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVNb3RvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIHRoZSBqb2ludCBtb3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIGlmIChmbGFnID09IHRoaXMubV9lbmFibGVNb3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBmbGFnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtb3RvciBzcGVlZCwgdXN1YWxseSBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XG4gICAgICAgICAgICBpZiAoc3BlZWQgPT0gdGhpcy5tX21vdG9yU3BlZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLnNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBzcGVlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbW90b3Igc3BlZWQsIHVzdWFsbHkgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuZ2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fbW90b3JTcGVlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldC9HZXQgdGhlIG1heGltdW0gbW90b3IgZm9yY2UsIHVzdWFsbHkgaW4gTi1tLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuc2V0TWF4TW90b3JUb3JxdWUgPSBmdW5jdGlvbiAodG9ycXVlKSB7XG4gICAgICAgICAgICBpZiAodG9ycXVlID09IHRoaXMubV9tYXhNb3RvclRvcnF1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuc2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fbWF4TW90b3JUb3JxdWUgPSB0b3JxdWU7XG4gICAgICAgIH07XG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmdldE1heE1vdG9yVG9ycXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCBtb3RvciB0b3JxdWUgZ2l2ZW4gdGhlIGludmVyc2UgdGltZSBzdGVwLCB1c3VhbGx5IGluIE4tbS5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmdldE1vdG9yVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9tb3RvckltcHVsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQvR2V0IHRoZSBzcHJpbmcgZnJlcXVlbmN5IGluIGhlcnR6LiBTZXR0aW5nIHRoZSBmcmVxdWVuY3kgdG8gemVybyBkaXNhYmxlc1xuICAgICAgICAgKiB0aGUgc3ByaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuc2V0U3ByaW5nRnJlcXVlbmN5SHogPSBmdW5jdGlvbiAoaHopIHtcbiAgICAgICAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xuICAgICAgICB9O1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRTcHJpbmdGcmVxdWVuY3lIeiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQvR2V0IHRoZSBzcHJpbmcgZGFtcGluZyByYXRpb1xuICAgICAgICAgKi9cbiAgICAgICAgV2hlZWxKb2ludC5wcm90b3R5cGUuc2V0U3ByaW5nRGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICAgICAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gcmF0aW87XG4gICAgICAgIH07XG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmdldFNwcmluZ0RhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1fZGFtcGluZ1JhdGlvO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keUIgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5nZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSByZWFjdGlvbiBmb3JjZSBvbiBib2R5QiBhdCB0aGUgam9pbnQgYW5jaG9yIGluIE5ld3RvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5nZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYzIuY29tYmluZSh0aGlzLm1faW1wdWxzZSwgdGhpcy5tX2F5LCB0aGlzLm1fc3ByaW5nSW1wdWxzZSwgdGhpcy5tX2F4KS5tdWwoaW52X2R0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHlCIGluIE4qbS5cbiAgICAgICAgICovXG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIHRoaXMubV9tb3RvckltcHVsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLmluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckEgPSB0aGlzLm1fYm9keUEubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSB0aGlzLm1fYm9keUIubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgICAgICAgIHRoaXMubV9pbnZNYXNzQSA9IHRoaXMubV9ib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICAgICB0aGlzLm1faW52TWFzc0IgPSB0aGlzLm1fYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgICAgdGhpcy5tX2ludklBID0gdGhpcy5tX2JvZHlBLm1faW52STtcbiAgICAgICAgICAgIHRoaXMubV9pbnZJQiA9IHRoaXMubV9ib2R5Qi5tX2ludkk7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICB2YXIgY0EgPSB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciB2QSA9IHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0EgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgdmFyIGNCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQiA9IHRoaXMubV9ib2R5Qi5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgdkIgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdCID0gdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzc2VzLlxuICAgICAgICAgICAgdmFyIHJBID0gUm90Lm11bFZlYzIocUEsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckEsIHRoaXMubV9sb2NhbENlbnRlckEpKTtcbiAgICAgICAgICAgIHZhciByQiA9IFJvdC5tdWxWZWMyKHFCLCBWZWMyLnN1Yih0aGlzLm1fbG9jYWxBbmNob3JCLCB0aGlzLm1fbG9jYWxDZW50ZXJCKSk7XG4gICAgICAgICAgICB2YXIgZCA9IFZlYzIuemVybygpO1xuICAgICAgICAgICAgZC5hZGRDb21iaW5lKDEsIGNCLCAxLCByQik7XG4gICAgICAgICAgICBkLnN1YkNvbWJpbmUoMSwgY0EsIDEsIHJBKTtcbiAgICAgICAgICAgIC8vIFBvaW50IHRvIGxpbmUgY29uc3RyYWludFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMubV9heSA9IFJvdC5tdWxWZWMyKHFBLCB0aGlzLm1fbG9jYWxZQXhpc0EpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zQXkgPSBWZWMyLmNyb3NzVmVjMlZlYzIoVmVjMi5hZGQoZCwgckEpLCB0aGlzLm1fYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zQnkgPSBWZWMyLmNyb3NzVmVjMlZlYzIockIsIHRoaXMubV9heSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX21hc3MgPSBtQSArIG1CICsgaUEgKiB0aGlzLm1fc0F5ICogdGhpcy5tX3NBeSArIGlCICogdGhpcy5tX3NCeVxuICAgICAgICAgICAgICAgICAgICAqIHRoaXMubV9zQnk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubV9tYXNzID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9tYXNzID0gMS4wIC8gdGhpcy5tX21hc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3ByaW5nIGNvbnN0cmFpbnRcbiAgICAgICAgICAgIHRoaXMubV9zcHJpbmdNYXNzID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5tX2JpYXMgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSAwLjA7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2F4ID0gUm90Lm11bFZlYzIocUEsIHRoaXMubV9sb2NhbFhBeGlzQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NBeCA9IFZlYzIuY3Jvc3NWZWMyVmVjMihWZWMyLmFkZChkLCByQSksIHRoaXMubV9heCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NCeCA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgdGhpcy5tX2F4KTtcbiAgICAgICAgICAgICAgICB2YXIgaW52TWFzcyA9IG1BICsgbUIgKyBpQSAqIHRoaXMubV9zQXggKiB0aGlzLm1fc0F4ICsgaUIgKiB0aGlzLm1fc0J4XG4gICAgICAgICAgICAgICAgICAgICogdGhpcy5tX3NCeDtcbiAgICAgICAgICAgICAgICBpZiAoaW52TWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fc3ByaW5nTWFzcyA9IDEuMCAvIGludk1hc3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBDID0gVmVjMi5kb3QoZCwgdGhpcy5tX2F4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRnJlcXVlbmN5XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbWVnYSA9IDIuMCAqIG1hdGhfUEkgKiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgICAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhbXAgPSAyLjAgKiB0aGlzLm1fc3ByaW5nTWFzcyAqIHRoaXMubV9kYW1waW5nUmF0aW8gKiBvbWVnYTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3ByaW5nIHN0aWZmbmVzc1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IHRoaXMubV9zcHJpbmdNYXNzICogb21lZ2EgKiBvbWVnYTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBzdGVwLmR0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fZ2FtbWEgPSBoICogKGRhbXAgKyBoICogayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1fZ2FtbWEgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9nYW1tYSA9IDEuMCAvIHRoaXMubV9nYW1tYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fYmlhcyA9IEMgKiBoICogayAqIHRoaXMubV9nYW1tYTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tX3NwcmluZ01hc3MgPSBpbnZNYXNzICsgdGhpcy5tX2dhbW1hO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tX3NwcmluZ01hc3MgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubV9zcHJpbmdNYXNzID0gMS4wIC8gdGhpcy5tX3NwcmluZ01hc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc3ByaW5nSW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJvdGF0aW9uYWwgbW90b3JcbiAgICAgICAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gaUEgKyBpQjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tX21vdG9yTWFzcyA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gMS4wIC8gdGhpcy5tX21vdG9yTWFzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gMC4wO1xuICAgICAgICAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciB2YXJpYWJsZSB0aW1lIHN0ZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zcHJpbmdJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIuY29tYmluZSh0aGlzLm1faW1wdWxzZSwgdGhpcy5tX2F5LCB0aGlzLm1fc3ByaW5nSW1wdWxzZSwgdGhpcy5tX2F4KTtcbiAgICAgICAgICAgICAgICB2YXIgTEEgPSB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9zQXkgKyB0aGlzLm1fc3ByaW5nSW1wdWxzZSAqIHRoaXMubV9zQXggKyB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHZhciBMQiA9IHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3NCeSArIHRoaXMubV9zcHJpbmdJbXB1bHNlICogdGhpcy5tX3NCeCArIHRoaXMubV9tb3RvckltcHVsc2U7XG4gICAgICAgICAgICAgICAgdkEuc3ViTXVsKHRoaXMubV9pbnZNYXNzQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gdGhpcy5tX2ludklBICogTEE7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUCk7XG4gICAgICAgICAgICAgICAgd0IgKz0gdGhpcy5tX2ludklCICogTEI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc3ByaW5nSW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZBKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3ZlbG9jaXR5LncgPSB3QTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnYuc2V0VmVjMih2Qik7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53ID0gd0I7XG4gICAgICAgIH07XG4gICAgICAgIFdoZWVsSm9pbnQucHJvdG90eXBlLnNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgbUEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICAgICB2YXIgbUIgPSB0aGlzLm1faW52TWFzc0I7XG4gICAgICAgICAgICB2YXIgaUEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICAgICB2YXIgaUIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICAgICB2YXIgdkEgPSB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52O1xuICAgICAgICAgICAgdmFyIHdBID0gdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudztcbiAgICAgICAgICAgIHZhciB2QiA9IHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LnY7XG4gICAgICAgICAgICB2YXIgd0IgPSB0aGlzLm1fYm9keUIuY192ZWxvY2l0eS53O1xuICAgICAgICAgICAgLy8gU29sdmUgc3ByaW5nIGNvbnN0cmFpbnRcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgQ2RvdCA9IFZlYzIuZG90KHRoaXMubV9heCwgdkIpIC0gVmVjMi5kb3QodGhpcy5tX2F4LCB2QSkgKyB0aGlzLm1fc0J4ICogd0IgLSB0aGlzLm1fc0F4ICogd0E7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX3NwcmluZ01hc3MgKiAoQ2RvdCArIHRoaXMubV9iaWFzICsgdGhpcy5tX2dhbW1hICogdGhpcy5tX3NwcmluZ0ltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zcHJpbmdJbXB1bHNlICs9IGltcHVsc2U7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm11bE51bVZlYzIoaW1wdWxzZSwgdGhpcy5tX2F4KTtcbiAgICAgICAgICAgICAgICB2YXIgTEEgPSBpbXB1bHNlICogdGhpcy5tX3NBeDtcbiAgICAgICAgICAgICAgICB2YXIgTEIgPSBpbXB1bHNlICogdGhpcy5tX3NCeDtcbiAgICAgICAgICAgICAgICB2QS5zdWJNdWwobUEsIFApO1xuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTEE7XG4gICAgICAgICAgICAgICAgdkIuYWRkTXVsKG1CLCBQKTtcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIExCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29sdmUgcm90YXRpb25hbCBtb3RvciBjb25zdHJhaW50XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIENkb3QgPSB3QiAtIHdBIC0gdGhpcy5tX21vdG9yU3BlZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtdGhpcy5tX21vdG9yTWFzcyAqIENkb3Q7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gY2xhbXAodGhpcy5tX21vdG9ySW1wdWxzZSArIGltcHVsc2UsIC1tYXhJbXB1bHNlLCBtYXhJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZSAtIG9sZEltcHVsc2U7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogaW1wdWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50IHRvIGxpbmUgY29uc3RyYWludFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBDZG90ID0gVmVjMi5kb3QodGhpcy5tX2F5LCB2QikgLSBWZWMyLmRvdCh0aGlzLm1fYXksIHZBKSArIHRoaXMubV9zQnkgKiB3QiAtIHRoaXMubV9zQXkgKiB3QTtcbiAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZSA9IC10aGlzLm1fbWFzcyAqIENkb3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UgKz0gaW1wdWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgUCA9IFZlYzIubXVsTnVtVmVjMihpbXB1bHNlLCB0aGlzLm1fYXkpO1xuICAgICAgICAgICAgICAgIHZhciBMQSA9IGltcHVsc2UgKiB0aGlzLm1fc0F5O1xuICAgICAgICAgICAgICAgIHZhciBMQiA9IGltcHVsc2UgKiB0aGlzLm1fc0J5O1xuICAgICAgICAgICAgICAgIHZBLnN1Yk11bChtQSwgUCk7XG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBMQTtcbiAgICAgICAgICAgICAgICB2Qi5hZGRNdWwobUIsIFApO1xuICAgICAgICAgICAgICAgIHdCICs9IGlCICogTEI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY192ZWxvY2l0eS52LnNldFZlYzIodkEpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlBLmNfdmVsb2NpdHkudyA9IHdBO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfdmVsb2NpdHkudi5zZXRWZWMyKHZCKTtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5Qi5jX3ZlbG9jaXR5LncgPSB3QjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBlcnJvcnMgYXJlIHdpdGhpbiB0b2xlcmFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBXaGVlbEpvaW50LnByb3RvdHlwZS5zb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgdmFyIGNBID0gdGhpcy5tX2JvZHlBLmNfcG9zaXRpb24uYztcbiAgICAgICAgICAgIHZhciBhQSA9IHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmE7XG4gICAgICAgICAgICB2YXIgY0IgPSB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jO1xuICAgICAgICAgICAgdmFyIGFCID0gdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYTtcbiAgICAgICAgICAgIHZhciBxQSA9IFJvdC5uZW8oYUEpO1xuICAgICAgICAgICAgdmFyIHFCID0gUm90Lm5lbyhhQik7XG4gICAgICAgICAgICB2YXIgckEgPSBSb3QubXVsVmVjMihxQSwgVmVjMi5zdWIodGhpcy5tX2xvY2FsQW5jaG9yQSwgdGhpcy5tX2xvY2FsQ2VudGVyQSkpO1xuICAgICAgICAgICAgdmFyIHJCID0gUm90Lm11bFZlYzIocUIsIFZlYzIuc3ViKHRoaXMubV9sb2NhbEFuY2hvckIsIHRoaXMubV9sb2NhbENlbnRlckIpKTtcbiAgICAgICAgICAgIHZhciBkID0gVmVjMi56ZXJvKCk7XG4gICAgICAgICAgICBkLmFkZENvbWJpbmUoMSwgY0IsIDEsIHJCKTtcbiAgICAgICAgICAgIGQuc3ViQ29tYmluZSgxLCBjQSwgMSwgckEpO1xuICAgICAgICAgICAgdmFyIGF5ID0gUm90Lm11bFZlYzIocUEsIHRoaXMubV9sb2NhbFlBeGlzQSk7XG4gICAgICAgICAgICB2YXIgc0F5ID0gVmVjMi5jcm9zc1ZlYzJWZWMyKFZlYzIuYWRkKGQsIHJBKSwgYXkpO1xuICAgICAgICAgICAgdmFyIHNCeSA9IFZlYzIuY3Jvc3NWZWMyVmVjMihyQiwgYXkpO1xuICAgICAgICAgICAgdmFyIEMgPSBWZWMyLmRvdChkLCBheSk7XG4gICAgICAgICAgICB2YXIgayA9IHRoaXMubV9pbnZNYXNzQSArIHRoaXMubV9pbnZNYXNzQiArIHRoaXMubV9pbnZJQSAqIHRoaXMubV9zQXkgKiB0aGlzLm1fc0F5ICsgdGhpcy5tX2ludklCICogdGhpcy5tX3NCeSAqIHRoaXMubV9zQnk7XG4gICAgICAgICAgICB2YXIgaW1wdWxzZSA9IGsgIT0gMC4wID8gLUMgLyBrIDogMC4wO1xuICAgICAgICAgICAgdmFyIFAgPSBWZWMyLm11bE51bVZlYzIoaW1wdWxzZSwgYXkpO1xuICAgICAgICAgICAgdmFyIExBID0gaW1wdWxzZSAqIHNBeTtcbiAgICAgICAgICAgIHZhciBMQiA9IGltcHVsc2UgKiBzQnk7XG4gICAgICAgICAgICBjQS5zdWJNdWwodGhpcy5tX2ludk1hc3NBLCBQKTtcbiAgICAgICAgICAgIGFBIC09IHRoaXMubV9pbnZJQSAqIExBO1xuICAgICAgICAgICAgY0IuYWRkTXVsKHRoaXMubV9pbnZNYXNzQiwgUCk7XG4gICAgICAgICAgICBhQiArPSB0aGlzLm1faW52SUIgKiBMQjtcbiAgICAgICAgICAgIHRoaXMubV9ib2R5QS5jX3Bvc2l0aW9uLmMuc2V0VmVjMihjQSk7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUEuY19wb3NpdGlvbi5hID0gYUE7XG4gICAgICAgICAgICB0aGlzLm1fYm9keUIuY19wb3NpdGlvbi5jLnNldFZlYzIoY0IpO1xuICAgICAgICAgICAgdGhpcy5tX2JvZHlCLmNfcG9zaXRpb24uYSA9IGFCO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhfYWJzKEMpIDw9IFNldHRpbmdzSW50ZXJuYWwubGluZWFyU2xvcDtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlZWxKb2ludC5UWVBFID0gJ3doZWVsLWpvaW50JztcbiAgICAgICAgcmV0dXJuIFdoZWVsSm9pbnQ7XG4gICAgfShKb2ludCkpO1xuXG4gICAgdmFyIFNJRCA9IDA7XG4gICAgZnVuY3Rpb24gU2VyaWFsaXplcihvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHZhciByb290Q2xhc3MgPSBvcHRzLnJvb3RDbGFzcyB8fCBXb3JsZDtcbiAgICAgICAgdmFyIHByZVNlcmlhbGl6ZSA9IG9wdHMucHJlU2VyaWFsaXplIHx8IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iajsgfTtcbiAgICAgICAgdmFyIHBvc3RTZXJpYWxpemUgPSBvcHRzLnBvc3RTZXJpYWxpemUgfHwgZnVuY3Rpb24gKGRhdGEsIG9iaikgeyByZXR1cm4gZGF0YTsgfTtcbiAgICAgICAgdmFyIHByZURlc2VyaWFsaXplID0gb3B0cy5wcmVEZXNlcmlhbGl6ZSB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgICAgICAgdmFyIHBvc3REZXNlcmlhbGl6ZSA9IG9wdHMucG9zdERlc2VyaWFsaXplIHx8IGZ1bmN0aW9uIChvYmosIGRhdGEpIHsgcmV0dXJuIG9iajsgfTtcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSByZWYgb2JqZWN0cyBkdXJpbmcgc2VyaWFsaXplXG4gICAgICAgIHZhciByZWZUeXBlcyA9IHtcbiAgICAgICAgICAgIFdvcmxkOiBXb3JsZCxcbiAgICAgICAgICAgIEJvZHk6IEJvZHksXG4gICAgICAgICAgICBKb2ludDogSm9pbnQsXG4gICAgICAgICAgICBGaXh0dXJlOiBGaXh0dXJlLFxuICAgICAgICAgICAgU2hhcGU6IFNoYXBlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgcmVzdG9yZSB0byBkZXNlcmlhbGl6ZSBvYmplY3RzIGFuZCByZWZzXG4gICAgICAgIHZhciByZXN0b3JlVHlwZXMgPSBfX2Fzc2lnbih7IFZlYzI6IFZlYzIsXG4gICAgICAgICAgICBWZWMzOiBWZWMzIH0sIHJlZlR5cGVzKTtcbiAgICAgICAgdmFyIENMQVNTX0JZX1RZUEVfUFJPUCA9IChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbQm9keS5TVEFUSUNdID0gQm9keSxcbiAgICAgICAgICAgIF9hW0JvZHkuRFlOQU1JQ10gPSBCb2R5LFxuICAgICAgICAgICAgX2FbQm9keS5LSU5FTUFUSUNdID0gQm9keSxcbiAgICAgICAgICAgIF9hW0NoYWluU2hhcGUuVFlQRV0gPSBDaGFpblNoYXBlLFxuICAgICAgICAgICAgX2FbQm94U2hhcGUuVFlQRV0gPSBCb3hTaGFwZSxcbiAgICAgICAgICAgIF9hW0VkZ2VTaGFwZS5UWVBFXSA9IEVkZ2VTaGFwZSxcbiAgICAgICAgICAgIF9hW1BvbHlnb25TaGFwZS5UWVBFXSA9IFBvbHlnb25TaGFwZSxcbiAgICAgICAgICAgIF9hW0NpcmNsZVNoYXBlLlRZUEVdID0gQ2lyY2xlU2hhcGUsXG4gICAgICAgICAgICBfYVtEaXN0YW5jZUpvaW50LlRZUEVdID0gRGlzdGFuY2VKb2ludCxcbiAgICAgICAgICAgIF9hW0ZyaWN0aW9uSm9pbnQuVFlQRV0gPSBGcmljdGlvbkpvaW50LFxuICAgICAgICAgICAgX2FbR2VhckpvaW50LlRZUEVdID0gR2VhckpvaW50LFxuICAgICAgICAgICAgX2FbTW90b3JKb2ludC5UWVBFXSA9IE1vdG9ySm9pbnQsXG4gICAgICAgICAgICBfYVtNb3VzZUpvaW50LlRZUEVdID0gTW91c2VKb2ludCxcbiAgICAgICAgICAgIF9hW1ByaXNtYXRpY0pvaW50LlRZUEVdID0gUHJpc21hdGljSm9pbnQsXG4gICAgICAgICAgICBfYVtQdWxsZXlKb2ludC5UWVBFXSA9IFB1bGxleUpvaW50LFxuICAgICAgICAgICAgX2FbUmV2b2x1dGVKb2ludC5UWVBFXSA9IFJldm9sdXRlSm9pbnQsXG4gICAgICAgICAgICBfYVtSb3BlSm9pbnQuVFlQRV0gPSBSb3BlSm9pbnQsXG4gICAgICAgICAgICBfYVtXZWxkSm9pbnQuVFlQRV0gPSBXZWxkSm9pbnQsXG4gICAgICAgICAgICBfYVtXaGVlbEpvaW50LlRZUEVdID0gV2hlZWxKb2ludCxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgdGhpcy50b0pzb24gPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBbXTtcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IFtyb290XTtcbiAgICAgICAgICAgIHZhciByZWZNYXAgPSB7fTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0b3JlUmVmKHZhbHVlLCB0eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLl9fc2lkID0gdmFsdWUuX19zaWQgfHwgKytTSUQ7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZNYXBbdmFsdWUuX19zaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBqc29uLmxlbmd0aCArIHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlR5cGU6IHR5cGVOYW1lXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlZk1hcFt2YWx1ZS5fX3NpZF0gPSByZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWZNYXBbdmFsdWUuX19zaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICAgICAgICAgICAgICAgIG9iaiA9IHByZVNlcmlhbGl6ZShvYmopO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gb2JqLl9zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcG9zdFNlcmlhbGl6ZShkYXRhLCBvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdG9Kc29uKHZhbHVlLCB0b3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUuX3NlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvci1pblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZU5hbWUgaW4gcmVmVHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiByZWZUeXBlc1t0eXBlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlUmVmKHZhbHVlLCB0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgPSAwOyBrZXkgPCB2YWx1ZS5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtrZXldID0gdG9Kc29uKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvci1pblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVba2V5XSA9IHRvSnNvbih2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IHRvSnNvbihvYmosIG9iaik7XG4gICAgICAgICAgICAgICAganNvbi5wdXNoKHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mcm9tSnNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICB2YXIgcmVmTWFwID0ge307XG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kRGVzZXJpbGl6ZXIoZGF0YSwgY2xzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjbHMgfHwgIWNscy5fZGVzZXJpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzID0gQ0xBU1NfQllfVFlQRV9QUk9QW2RhdGEudHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbHMgJiYgY2xzLl9kZXNlcmlhbGl6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVzZXJpYWxpemUgYSBkYXRhIG9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemUoY2xzLCBkYXRhLCBjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzZXJpYWxpemVyID0gZmluZERlc2VyaWxpemVyKGRhdGEsIGNscyk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXNlcmlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhID0gcHJlRGVzZXJpYWxpemUoZGF0YSk7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IGRlc2VyaWFsaXplcihkYXRhLCBjdHgsIHJlc3RvcmVSZWYpO1xuICAgICAgICAgICAgICAgIG9iaiA9IHBvc3REZXNlcmlhbGl6ZShvYmosIGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc3RvcmUgYSByZWYgb2JqZWN0IG9yIGRlc2VyaWFsaXplIGEgZGF0YSBvYmplY3QuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhpcyBpcyBwYXNzZWQgYXMgY2FsbGJhY2sgdG8gY2xhc3MgZGVzZXJpYWxpemVycy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVzdG9yZVJlZihjbHMsIHJlZiwgY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWYucmVmSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNscyAmJiBjbHMuX2Rlc2VyaWFsaXplICYmIGRlc2VyaWFsaXplKGNscywgcmVmLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbHMgPSByZXN0b3JlVHlwZXNbcmVmLnJlZlR5cGVdIHx8IGNscztcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSByZWYucmVmSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZNYXBbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ganNvbltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBkZXNlcmlhbGl6ZShjbHMsIGRhdGEsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZk1hcFtpbmRleF0gPSBvYmo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWZNYXBbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvb3QgPSByb290Q2xhc3MuX2Rlc2VyaWFsaXplKGpzb25bMF0sIG51bGwsIHJlc3RvcmVSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIoKTtcbiAgICBTZXJpYWxpemVyLnRvSnNvbiA9IHNlcmlhbGl6ZXIudG9Kc29uO1xuICAgIFNlcmlhbGl6ZXIuZnJvbUpzb24gPSBzZXJpYWxpemVyLmZyb21Kc29uO1xuXG4gICAgdmFyIFRlc3RiZWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlc3RiZWQoKSB7XG4gICAgICAgICAgICAvKiogV29ybGQgdmlld2JveCB3aWR0aC4gKi9cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSA4MDtcbiAgICAgICAgICAgIC8qKiBXb3JsZCB2aWV3Ym94IGhlaWdodC4gKi9cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gNjA7XG4gICAgICAgICAgICAvKiogV29ybGQgdmlld2JveCBjZW50ZXIgdmVydGljYWwgb2Zmc2V0LiAqL1xuICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgIC8qKiBXb3JsZCB2aWV3Ym94IGNlbnRlciBob3Jpem9udGFsIG9mZnNldC4gKi9cbiAgICAgICAgICAgIHRoaXMueSA9IC0xMDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gLTE7XG4gICAgICAgICAgICAvKiogV29ybGQgc2ltdWxhdGlvbiBzdGVwIGZyZXF1ZW5jeSAqL1xuICAgICAgICAgICAgdGhpcy5oeiA9IDYwO1xuICAgICAgICAgICAgLyoqIFdvcmxkIHNpbXVsYXRpb24gc3BlZWQsIGRlZmF1bHQgaXMgMSAqL1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IDE7XG4gICAgICAgICAgICB0aGlzLnJhdGlvID0gMTY7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPSAnIzIyMjIyMic7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUtleXMgPSB7fTtcbiAgICAgICAgICAgIC8qKiBjYWxsYmFjaywgdG8gYmUgaW1wbGVtZW50ZWQgYnkgdXNlciAqL1xuICAgICAgICAgICAgdGhpcy5zdGVwID0gZnVuY3Rpb24gKGR0LCB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKiBjYWxsYmFjaywgdG8gYmUgaW1wbGVtZW50ZWQgYnkgdXNlciAqL1xuICAgICAgICAgICAgdGhpcy5rZXlkb3duID0gZnVuY3Rpb24gKGtleUNvZGUsIGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKiBjYWxsYmFjaywgdG8gYmUgaW1wbGVtZW50ZWQgYnkgdXNlciAqL1xuICAgICAgICAgICAgdGhpcy5rZXl1cCA9IGZ1bmN0aW9uIChrZXlDb2RlLCBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzTWFwID0ge307XG4gICAgICAgIH1cbiAgICAgICAgVGVzdGJlZC5tb3VudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YmVkLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciBrZXlfMSA9IGE7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSBiO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVfMSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWVfMSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNNYXBba2V5XzFdID0gdmFsdWVfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3ItaW5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlfMiBpbiBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8yID0gYVtrZXlfMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVfMiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWVfMiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzTWFwW2tleV8yXSA9IHZhbHVlXzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld2xpbmUgPSAnXFxuJztcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5zdGF0dXNUZXh0IHx8ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuc3RhdHVzTWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0dXNNYXBba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9ICh0ZXh0ICYmIG5ld2xpbmUpICsga2V5ICsgJzogJyArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzKHRleHQpO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YmVkLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZm8odGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIFRlc3RiZWQucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgICAgIHIgPSByICogMjU2IHwgMDtcbiAgICAgICAgICAgIGcgPSBnICogMjU2IHwgMDtcbiAgICAgICAgICAgIGIgPSBiICogMjU2IHwgMDtcbiAgICAgICAgICAgIHJldHVybiAncmdiKCcgKyByICsgJywgJyArIGcgKyAnLCAnICsgYiArICcpJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRlc3RiZWQ7XG4gICAgfSgpKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gdGVzdGJlZChhLCBiKSB7XG4gICAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYjtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGEgIT09IG51bGwgJiYgYSAhPT0gdm9pZCAwID8gYSA6IGI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlc3RiZWQgPSBUZXN0YmVkLm1vdW50KG9wdGlvbnMpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICB2YXIgd29ybGQgPSBjYWxsYmFjayh0ZXN0YmVkKSB8fCB0ZXN0YmVkLndvcmxkO1xuICAgICAgICAgICAgdGVzdGJlZC5zdGFydCh3b3JsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdGJlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogUGxhbmNrLmpzXG4gICAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDIxIEVyaW4gQ2F0dG8sIEFsaSBTaGFraWJhXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICBDb250YWN0LmFkZFR5cGUoQ2lyY2xlU2hhcGUuVFlQRSwgQ2lyY2xlU2hhcGUuVFlQRSwgQ2lyY2xlQ2lyY2xlQ29udGFjdCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBDaXJjbGVDaXJjbGVDb250YWN0KG1hbmlmb2xkLCB4ZkEsIGZpeHR1cmVBLCBpbmRleEEsIHhmQiwgZml4dHVyZUIsIGluZGV4Qikge1xuICAgICAgICBDb2xsaWRlQ2lyY2xlcyhtYW5pZm9sZCwgZml4dHVyZUEuZ2V0U2hhcGUoKSwgeGZBLCBmaXh0dXJlQi5nZXRTaGFwZSgpLCB4ZkIpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovIHZhciBwQSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcEIgPSB2ZWMyKDAsIDApO1xuICAgIHZhciBDb2xsaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgY2lyY2xlQSwgeGZBLCBjaXJjbGVCLCB4ZkIpIHtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDA7XG4gICAgICAgIHRyYW5zZm9ybVZlYzIocEEsIHhmQSwgY2lyY2xlQS5tX3ApO1xuICAgICAgICB0cmFuc2Zvcm1WZWMyKHBCLCB4ZkIsIGNpcmNsZUIubV9wKTtcbiAgICAgICAgdmFyIGRpc3RTcXIgPSBkaXN0U3FyVmVjMihwQiwgcEEpO1xuICAgICAgICB2YXIgckEgPSBjaXJjbGVBLm1fcmFkaXVzO1xuICAgICAgICB2YXIgckIgPSBjaXJjbGVCLm1fcmFkaXVzO1xuICAgICAgICB2YXIgcmFkaXVzID0gckEgKyByQjtcbiAgICAgICAgaWYgKGRpc3RTcXIgPiByYWRpdXMgKiByYWRpdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYW5pZm9sZC50eXBlID0gZXhwb3J0cy5NYW5pZm9sZFR5cGUuZV9jaXJjbGVzO1xuICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5sb2NhbFBvaW50LCBjaXJjbGVBLm1fcCk7XG4gICAgICAgIHplcm9WZWMyKG1hbmlmb2xkLmxvY2FsTm9ybWFsKTtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgIGNvcHlWZWMyKG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50LCBjaXJjbGVCLm1fcCk7XG4gICAgICAgIC8vIG1hbmlmb2xkLnBvaW50c1swXS5pZC5rZXkgPSAwO1xuICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuc2V0RmVhdHVyZXMoMCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgsIDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBQbGFuY2suanNcbiAgICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXJpbiBDYXR0bywgQWxpIFNoYWtpYmFcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgICAqIFNPRlRXQVJFLlxuICAgICAqL1xuICAgIENvbnRhY3QuYWRkVHlwZShFZGdlU2hhcGUuVFlQRSwgQ2lyY2xlU2hhcGUuVFlQRSwgRWRnZUNpcmNsZUNvbnRhY3QpO1xuICAgIENvbnRhY3QuYWRkVHlwZShDaGFpblNoYXBlLlRZUEUsIENpcmNsZVNoYXBlLlRZUEUsIENoYWluQ2lyY2xlQ29udGFjdCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBFZGdlQ2lyY2xlQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmaXh0dXJlQSwgaW5kZXhBLCB4ZkIsIGZpeHR1cmVCLCBpbmRleEIpIHtcbiAgICAgICAgdmFyIHNoYXBlQSA9IGZpeHR1cmVBLmdldFNoYXBlKCk7XG4gICAgICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5nZXRTaGFwZSgpO1xuICAgICAgICBDb2xsaWRlRWRnZUNpcmNsZShtYW5pZm9sZCwgc2hhcGVBLCB4ZkEsIHNoYXBlQiwgeGZCKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ2hhaW5DaXJjbGVDb250YWN0KG1hbmlmb2xkLCB4ZkEsIGZpeHR1cmVBLCBpbmRleEEsIHhmQiwgZml4dHVyZUIsIGluZGV4Qikge1xuICAgICAgICB2YXIgY2hhaW4gPSBmaXh0dXJlQS5nZXRTaGFwZSgpO1xuICAgICAgICB2YXIgZWRnZSA9IG5ldyBFZGdlU2hhcGUoKTtcbiAgICAgICAgY2hhaW4uZ2V0Q2hpbGRFZGdlKGVkZ2UsIGluZGV4QSk7XG4gICAgICAgIHZhciBzaGFwZUEgPSBlZGdlO1xuICAgICAgICB2YXIgc2hhcGVCID0gZml4dHVyZUIuZ2V0U2hhcGUoKTtcbiAgICAgICAgQ29sbGlkZUVkZ2VDaXJjbGUobWFuaWZvbGQsIHNoYXBlQSwgeGZBLCBzaGFwZUIsIHhmQik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGUgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGUxID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBlMiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgUSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgUCA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbiQyID0gdmVjMigwLCAwKTtcbiAgICAvLyBDb21wdXRlIGNvbnRhY3QgcG9pbnRzIGZvciBlZGdlIHZlcnN1cyBjaXJjbGUuXG4gICAgLy8gVGhpcyBhY2NvdW50cyBmb3IgZWRnZSBjb25uZWN0aXZpdHkuXG4gICAgdmFyIENvbGxpZGVFZGdlQ2lyY2xlID0gZnVuY3Rpb24gKG1hbmlmb2xkLCBlZGdlQSwgeGZBLCBjaXJjbGVCLCB4ZkIpIHtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDA7XG4gICAgICAgIC8vIENvbXB1dGUgY2lyY2xlIGluIGZyYW1lIG9mIGVkZ2VcbiAgICAgICAgcmV0cmFuc2Zvcm1WZWMyKFEsIHhmQiwgeGZBLCBjaXJjbGVCLm1fcCk7XG4gICAgICAgIHZhciBBID0gZWRnZUEubV92ZXJ0ZXgxO1xuICAgICAgICB2YXIgQiA9IGVkZ2VBLm1fdmVydGV4MjtcbiAgICAgICAgZGlmZlZlYzIoZSwgQiwgQSk7XG4gICAgICAgIC8vIEJhcnljZW50cmljIGNvb3JkaW5hdGVzXG4gICAgICAgIHZhciB1ID0gZG90VmVjMihlLCBCKSAtIGRvdFZlYzIoZSwgUSk7XG4gICAgICAgIHZhciB2ID0gZG90VmVjMihlLCBRKSAtIGRvdFZlYzIoZSwgQSk7XG4gICAgICAgIHZhciByYWRpdXMgPSBlZGdlQS5tX3JhZGl1cyArIGNpcmNsZUIubV9yYWRpdXM7XG4gICAgICAgIC8vIFJlZ2lvbiBBXG4gICAgICAgIGlmICh2IDw9IDAuMCkge1xuICAgICAgICAgICAgY29weVZlYzIoUCwgQSk7XG4gICAgICAgICAgICB2YXIgZGRfMSA9IGRpc3RTcXJWZWMyKFEsIEEpO1xuICAgICAgICAgICAgaWYgKGRkXzEgPiByYWRpdXMgKiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJcyB0aGVyZSBhbiBlZGdlIGNvbm5lY3RlZCB0byBBP1xuICAgICAgICAgICAgaWYgKGVkZ2VBLm1faGFzVmVydGV4MCkge1xuICAgICAgICAgICAgICAgIHZhciBBMSA9IGVkZ2VBLm1fdmVydGV4MDtcbiAgICAgICAgICAgICAgICB2YXIgQjEgPSBBO1xuICAgICAgICAgICAgICAgIGRpZmZWZWMyKGUxLCBCMSwgQTEpO1xuICAgICAgICAgICAgICAgIHZhciB1MSA9IGRvdFZlYzIoZTEsIEIxKSAtIGRvdFZlYzIoZTEsIFEpO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBjaXJjbGUgaW4gUmVnaW9uIEFCIG9mIHRoZSBwcmV2aW91cyBlZGdlP1xuICAgICAgICAgICAgICAgIGlmICh1MSA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuaWZvbGQudHlwZSA9IGV4cG9ydHMuTWFuaWZvbGRUeXBlLmVfY2lyY2xlcztcbiAgICAgICAgICAgIHplcm9WZWMyKG1hbmlmb2xkLmxvY2FsTm9ybWFsKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKG1hbmlmb2xkLmxvY2FsUG9pbnQsIFApO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludCwgY2lyY2xlQi5tX3ApO1xuICAgICAgICAgICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuc2V0RmVhdHVyZXMoMCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgsIDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpb24gQlxuICAgICAgICBpZiAodSA8PSAwLjApIHtcbiAgICAgICAgICAgIGNvcHlWZWMyKFAsIEIpO1xuICAgICAgICAgICAgdmFyIGRkXzIgPSBkaXN0U3FyVmVjMihRLCBQKTtcbiAgICAgICAgICAgIGlmIChkZF8yID4gcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSXMgdGhlcmUgYW4gZWRnZSBjb25uZWN0ZWQgdG8gQj9cbiAgICAgICAgICAgIGlmIChlZGdlQS5tX2hhc1ZlcnRleDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgQjIgPSBlZGdlQS5tX3ZlcnRleDM7XG4gICAgICAgICAgICAgICAgdmFyIEEyID0gQjtcbiAgICAgICAgICAgICAgICBkaWZmVmVjMihlMiwgQjIsIEEyKTtcbiAgICAgICAgICAgICAgICB2YXIgdjIgPSBkb3RWZWMyKGUyLCBRKSAtIGRvdFZlYzIoZTIsIEEyKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGUgY2lyY2xlIGluIFJlZ2lvbiBBQiBvZiB0aGUgbmV4dCBlZGdlP1xuICAgICAgICAgICAgICAgIGlmICh2MiA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuaWZvbGQudHlwZSA9IGV4cG9ydHMuTWFuaWZvbGRUeXBlLmVfY2lyY2xlcztcbiAgICAgICAgICAgIHplcm9WZWMyKG1hbmlmb2xkLmxvY2FsTm9ybWFsKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKG1hbmlmb2xkLmxvY2FsUG9pbnQsIFApO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDE7XG4gICAgICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludCwgY2lyY2xlQi5tX3ApO1xuICAgICAgICAgICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuc2V0RmVhdHVyZXMoMSwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgsIDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpb24gQUJcbiAgICAgICAgdmFyIGRlbiA9IGxlbmd0aFNxclZlYzIoZSk7XG4gICAgICAgIGNvbWJpbmVWZWMyKFAsIHUgLyBkZW4sIEEsIHYgLyBkZW4sIEIpO1xuICAgICAgICB2YXIgZGQgPSBkaXN0U3FyVmVjMihRLCBQKTtcbiAgICAgICAgaWYgKGRkID4gcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3Jvc3NOdW1WZWMyKG4kMiwgMSwgZSk7XG4gICAgICAgIGlmIChkb3RWZWMyKG4kMiwgUSkgLSBkb3RWZWMyKG4kMiwgQSkgPCAwLjApIHtcbiAgICAgICAgICAgIG5lZ1ZlYzIobiQyKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVWZWMyKG4kMik7XG4gICAgICAgIG1hbmlmb2xkLnR5cGUgPSBleHBvcnRzLk1hbmlmb2xkVHlwZS5lX2ZhY2VBO1xuICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5sb2NhbE5vcm1hbCwgbiQyKTtcbiAgICAgICAgY29weVZlYzIobWFuaWZvbGQubG9jYWxQb2ludCwgQSk7XG4gICAgICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAxO1xuICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludCwgY2lyY2xlQi5tX3ApO1xuICAgICAgICAvLyBtYW5pZm9sZC5wb2ludHNbMF0uaWQua2V5ID0gMDtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLnNldEZlYXR1cmVzKDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfZmFjZSwgMCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgaW5jaWRlbnRFZGdlID0gW25ldyBDbGlwVmVydGV4KCksIG5ldyBDbGlwVmVydGV4KCldO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGNsaXBQb2ludHMxJDEgPSBbbmV3IENsaXBWZXJ0ZXgoKSwgbmV3IENsaXBWZXJ0ZXgoKV07XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY2xpcFBvaW50czIkMSA9IFtuZXcgQ2xpcFZlcnRleCgpLCBuZXcgQ2xpcFZlcnRleCgpXTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBjbGlwU2VnbWVudFRvTGluZU5vcm1hbCA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdjEgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG4kMSA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgeGYkMSA9IHRyYW5zZm9ybSgwLCAwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciB2MTEgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIHYxMiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbG9jYWxUYW5nZW50ID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBsb2NhbE5vcm1hbCA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcGxhbmVQb2ludCA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgdGFuZ2VudCA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbm9ybWFsJDEgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIG5vcm1hbDEkMSA9IHZlYzIoMCwgMCk7XG4gICAgQ29udGFjdC5hZGRUeXBlKFBvbHlnb25TaGFwZS5UWVBFLCBQb2x5Z29uU2hhcGUuVFlQRSwgUG9seWdvbkNvbnRhY3QpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gZnVuY3Rpb24gUG9seWdvbkNvbnRhY3QobWFuaWZvbGQsIHhmQSwgZml4dHVyZUEsIGluZGV4QSwgeGZCLCBmaXh0dXJlQiwgaW5kZXhCKSB7XG4gICAgICAgIENvbGxpZGVQb2x5Z29ucyhtYW5pZm9sZCwgZml4dHVyZUEuZ2V0U2hhcGUoKSwgeGZBLCBmaXh0dXJlQi5nZXRTaGFwZSgpLCB4ZkIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBtYXggc2VwYXJhdGlvbiBiZXR3ZWVuIHBvbHkxIGFuZCBwb2x5MiB1c2luZyBlZGdlIG5vcm1hbHMgZnJvbVxuICAgICAqIHBvbHkxLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gZnVuY3Rpb24gZmluZE1heFNlcGFyYXRpb24ocG9seTEsIHhmMSwgcG9seTIsIHhmMiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBjb3VudDEgPSBwb2x5MS5tX2NvdW50O1xuICAgICAgICB2YXIgY291bnQyID0gcG9seTIubV9jb3VudDtcbiAgICAgICAgdmFyIG4xcyA9IHBvbHkxLm1fbm9ybWFscztcbiAgICAgICAgdmFyIHYxcyA9IHBvbHkxLm1fdmVydGljZXM7XG4gICAgICAgIHZhciB2MnMgPSBwb2x5Mi5tX3ZlcnRpY2VzO1xuICAgICAgICBpbnZUcmFuc2Zvcm1UcmFuc2Zvcm0oeGYkMSwgeGYyLCB4ZjEpO1xuICAgICAgICB2YXIgYmVzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1heFNlcGFyYXRpb24gPSAtSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQxOyArK2kpIHtcbiAgICAgICAgICAgIC8vIEdldCBwb2x5MSBub3JtYWwgaW4gZnJhbWUyLlxuICAgICAgICAgICAgcm90VmVjMihuJDEsIHhmJDEucSwgbjFzW2ldKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybVZlYzIodjEsIHhmJDEsIHYxc1tpXSk7XG4gICAgICAgICAgICAvLyBGaW5kIGRlZXBlc3QgcG9pbnQgZm9yIG5vcm1hbCBpLlxuICAgICAgICAgICAgdmFyIHNpID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50MjsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpaiA9IGRvdFZlYzIobiQxLCB2MnNbal0pIC0gZG90VmVjMihuJDEsIHYxKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lqIDwgc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgc2kgPSBzaWo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpID4gbWF4U2VwYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIG1heFNlcGFyYXRpb24gPSBzaTtcbiAgICAgICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVzZWQgdG8ga2VlcCBsYXN0IEZpbmRNYXhTZXBhcmF0aW9uIGNhbGwgdmFsdWVzXG4gICAgICAgIG91dHB1dC5tYXhTZXBhcmF0aW9uID0gbWF4U2VwYXJhdGlvbjtcbiAgICAgICAgb3V0cHV0LmJlc3RJbmRleCA9IGJlc3RJbmRleDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBmaW5kSW5jaWRlbnRFZGdlKGNsaXBWZXJ0ZXgsIHBvbHkxLCB4ZjEsIGVkZ2UxLCBwb2x5MiwgeGYyKSB7XG4gICAgICAgIHZhciBub3JtYWxzMSA9IHBvbHkxLm1fbm9ybWFscztcbiAgICAgICAgdmFyIGNvdW50MiA9IHBvbHkyLm1fY291bnQ7XG4gICAgICAgIHZhciB2ZXJ0aWNlczIgPSBwb2x5Mi5tX3ZlcnRpY2VzO1xuICAgICAgICB2YXIgbm9ybWFsczIgPSBwb2x5Mi5tX25vcm1hbHM7XG4gICAgICAgIC8vIEdldCB0aGUgbm9ybWFsIG9mIHRoZSByZWZlcmVuY2UgZWRnZSBpbiBwb2x5MidzIGZyYW1lLlxuICAgICAgICByZXJvdFZlYzIobm9ybWFsMSQxLCB4ZjIucSwgeGYxLnEsIG5vcm1hbHMxW2VkZ2UxXSk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGluY2lkZW50IGVkZ2Ugb24gcG9seTIuXG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBtaW5Eb3QgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDI7ICsraSkge1xuICAgICAgICAgICAgdmFyIGRvdCA9IGRvdFZlYzIobm9ybWFsMSQxLCBub3JtYWxzMltpXSk7XG4gICAgICAgICAgICBpZiAoZG90IDwgbWluRG90KSB7XG4gICAgICAgICAgICAgICAgbWluRG90ID0gZG90O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgY2xpcCB2ZXJ0aWNlcyBmb3IgdGhlIGluY2lkZW50IGVkZ2UuXG4gICAgICAgIHZhciBpMSA9IGluZGV4O1xuICAgICAgICB2YXIgaTIgPSBpMSArIDEgPCBjb3VudDIgPyBpMSArIDEgOiAwO1xuICAgICAgICB0cmFuc2Zvcm1WZWMyKGNsaXBWZXJ0ZXhbMF0udiwgeGYyLCB2ZXJ0aWNlczJbaTFdKTtcbiAgICAgICAgY2xpcFZlcnRleFswXS5pZC5zZXRGZWF0dXJlcyhlZGdlMSwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV9mYWNlLCBpMSwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgpO1xuICAgICAgICB0cmFuc2Zvcm1WZWMyKGNsaXBWZXJ0ZXhbMV0udiwgeGYyLCB2ZXJ0aWNlczJbaTJdKTtcbiAgICAgICAgY2xpcFZlcnRleFsxXS5pZC5zZXRGZWF0dXJlcyhlZGdlMSwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV9mYWNlLCBpMiwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovIHZhciBtYXhTZXBhcmF0aW9uID0ge1xuICAgICAgICBtYXhTZXBhcmF0aW9uOiAwLFxuICAgICAgICBiZXN0SW5kZXg6IDAsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpbmQgZWRnZSBub3JtYWwgb2YgbWF4IHNlcGFyYXRpb24gb24gQSAtIHJldHVybiBpZiBzZXBhcmF0aW5nIGF4aXMgaXMgZm91bmQ8YnI+XG4gICAgICogRmluZCBlZGdlIG5vcm1hbCBvZiBtYXggc2VwYXJhdGlvbiBvbiBCIC0gcmV0dXJuIGlmIHNlcGFyYXRpb24gYXhpcyBpcyBmb3VuZDxicj5cbiAgICAgKiBDaG9vc2UgcmVmZXJlbmNlIGVkZ2UgYXMgbWluKG1pbkEsIG1pbkIpPGJyPlxuICAgICAqIEZpbmQgaW5jaWRlbnQgZWRnZTxicj5cbiAgICAgKiBDbGlwXG4gICAgICpcbiAgICAgKiBUaGUgbm9ybWFsIHBvaW50cyBmcm9tIDEgdG8gMlxuICAgICAqL1xuICAgIHZhciBDb2xsaWRlUG9seWdvbnMgPSBmdW5jdGlvbiAobWFuaWZvbGQsIHBvbHlBLCB4ZkEsIHBvbHlCLCB4ZkIpIHtcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDA7XG4gICAgICAgIHZhciB0b3RhbFJhZGl1cyA9IHBvbHlBLm1fcmFkaXVzICsgcG9seUIubV9yYWRpdXM7XG4gICAgICAgIGZpbmRNYXhTZXBhcmF0aW9uKHBvbHlBLCB4ZkEsIHBvbHlCLCB4ZkIsIG1heFNlcGFyYXRpb24pO1xuICAgICAgICB2YXIgZWRnZUEgPSBtYXhTZXBhcmF0aW9uLmJlc3RJbmRleDtcbiAgICAgICAgdmFyIHNlcGFyYXRpb25BID0gbWF4U2VwYXJhdGlvbi5tYXhTZXBhcmF0aW9uO1xuICAgICAgICBpZiAoc2VwYXJhdGlvbkEgPiB0b3RhbFJhZGl1cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZmluZE1heFNlcGFyYXRpb24ocG9seUIsIHhmQiwgcG9seUEsIHhmQSwgbWF4U2VwYXJhdGlvbik7XG4gICAgICAgIHZhciBlZGdlQiA9IG1heFNlcGFyYXRpb24uYmVzdEluZGV4O1xuICAgICAgICB2YXIgc2VwYXJhdGlvbkIgPSBtYXhTZXBhcmF0aW9uLm1heFNlcGFyYXRpb247XG4gICAgICAgIGlmIChzZXBhcmF0aW9uQiA+IHRvdGFsUmFkaXVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcG9seTE7IC8vIHJlZmVyZW5jZSBwb2x5Z29uXG4gICAgICAgIHZhciBwb2x5MjsgLy8gaW5jaWRlbnQgcG9seWdvblxuICAgICAgICB2YXIgeGYxO1xuICAgICAgICB2YXIgeGYyO1xuICAgICAgICB2YXIgZWRnZTE7IC8vIHJlZmVyZW5jZSBlZGdlXG4gICAgICAgIHZhciBmbGlwO1xuICAgICAgICB2YXIga190b2wgPSAwLjEgKiBTZXR0aW5nc0ludGVybmFsLmxpbmVhclNsb3A7XG4gICAgICAgIGlmIChzZXBhcmF0aW9uQiA+IHNlcGFyYXRpb25BICsga190b2wpIHtcbiAgICAgICAgICAgIHBvbHkxID0gcG9seUI7XG4gICAgICAgICAgICBwb2x5MiA9IHBvbHlBO1xuICAgICAgICAgICAgeGYxID0geGZCO1xuICAgICAgICAgICAgeGYyID0geGZBO1xuICAgICAgICAgICAgZWRnZTEgPSBlZGdlQjtcbiAgICAgICAgICAgIG1hbmlmb2xkLnR5cGUgPSBleHBvcnRzLk1hbmlmb2xkVHlwZS5lX2ZhY2VCO1xuICAgICAgICAgICAgZmxpcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2x5MSA9IHBvbHlBO1xuICAgICAgICAgICAgcG9seTIgPSBwb2x5QjtcbiAgICAgICAgICAgIHhmMSA9IHhmQTtcbiAgICAgICAgICAgIHhmMiA9IHhmQjtcbiAgICAgICAgICAgIGVkZ2UxID0gZWRnZUE7XG4gICAgICAgICAgICBtYW5pZm9sZC50eXBlID0gZXhwb3J0cy5NYW5pZm9sZFR5cGUuZV9mYWNlQTtcbiAgICAgICAgICAgIGZsaXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNpZGVudEVkZ2VbMF0ucmVjeWNsZSgpLCBpbmNpZGVudEVkZ2VbMV0ucmVjeWNsZSgpO1xuICAgICAgICBmaW5kSW5jaWRlbnRFZGdlKGluY2lkZW50RWRnZSwgcG9seTEsIHhmMSwgZWRnZTEsIHBvbHkyLCB4ZjIpO1xuICAgICAgICB2YXIgY291bnQxID0gcG9seTEubV9jb3VudDtcbiAgICAgICAgdmFyIHZlcnRpY2VzMSA9IHBvbHkxLm1fdmVydGljZXM7XG4gICAgICAgIHZhciBpdjEgPSBlZGdlMTtcbiAgICAgICAgdmFyIGl2MiA9IGVkZ2UxICsgMSA8IGNvdW50MSA/IGVkZ2UxICsgMSA6IDA7XG4gICAgICAgIGNvcHlWZWMyKHYxMSwgdmVydGljZXMxW2l2MV0pO1xuICAgICAgICBjb3B5VmVjMih2MTIsIHZlcnRpY2VzMVtpdjJdKTtcbiAgICAgICAgZGlmZlZlYzIobG9jYWxUYW5nZW50LCB2MTIsIHYxMSk7XG4gICAgICAgIG5vcm1hbGl6ZVZlYzIobG9jYWxUYW5nZW50KTtcbiAgICAgICAgY3Jvc3NWZWMyTnVtKGxvY2FsTm9ybWFsLCBsb2NhbFRhbmdlbnQsIDEuMCk7XG4gICAgICAgIGNvbWJpbmVWZWMyKHBsYW5lUG9pbnQsIDAuNSwgdjExLCAwLjUsIHYxMik7XG4gICAgICAgIHJvdFZlYzIodGFuZ2VudCwgeGYxLnEsIGxvY2FsVGFuZ2VudCk7XG4gICAgICAgIGNyb3NzVmVjMk51bShub3JtYWwkMSwgdGFuZ2VudCwgMS4wKTtcbiAgICAgICAgdHJhbnNmb3JtVmVjMih2MTEsIHhmMSwgdjExKTtcbiAgICAgICAgdHJhbnNmb3JtVmVjMih2MTIsIHhmMSwgdjEyKTtcbiAgICAgICAgLy8gRmFjZSBvZmZzZXQuXG4gICAgICAgIHZhciBmcm9udE9mZnNldCA9IGRvdFZlYzIobm9ybWFsJDEsIHYxMSk7XG4gICAgICAgIC8vIFNpZGUgb2Zmc2V0cywgZXh0ZW5kZWQgYnkgcG9seXRvcGUgc2tpbiB0aGlja25lc3MuXG4gICAgICAgIHZhciBzaWRlT2Zmc2V0MSA9IC1kb3RWZWMyKHRhbmdlbnQsIHYxMSkgKyB0b3RhbFJhZGl1cztcbiAgICAgICAgdmFyIHNpZGVPZmZzZXQyID0gZG90VmVjMih0YW5nZW50LCB2MTIpICsgdG90YWxSYWRpdXM7XG4gICAgICAgIC8vIENsaXAgaW5jaWRlbnQgZWRnZSBhZ2FpbnN0IGV4dHJ1ZGVkIGVkZ2UxIHNpZGUgZWRnZXMuXG4gICAgICAgIGNsaXBQb2ludHMxJDFbMF0ucmVjeWNsZSgpLCBjbGlwUG9pbnRzMSQxWzFdLnJlY3ljbGUoKTtcbiAgICAgICAgY2xpcFBvaW50czIkMVswXS5yZWN5Y2xlKCksIGNsaXBQb2ludHMyJDFbMV0ucmVjeWNsZSgpO1xuICAgICAgICAvLyBDbGlwIHRvIGJveCBzaWRlIDFcbiAgICAgICAgc2V0VmVjMihjbGlwU2VnbWVudFRvTGluZU5vcm1hbCwgLXRhbmdlbnQueCwgLXRhbmdlbnQueSk7XG4gICAgICAgIHZhciBucDEgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMSQxLCBpbmNpZGVudEVkZ2UsIGNsaXBTZWdtZW50VG9MaW5lTm9ybWFsLCBzaWRlT2Zmc2V0MSwgaXYxKTtcbiAgICAgICAgaWYgKG5wMSA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGlwIHRvIG5lZ2F0aXZlIGJveCBzaWRlIDFcbiAgICAgICAgc2V0VmVjMihjbGlwU2VnbWVudFRvTGluZU5vcm1hbCwgdGFuZ2VudC54LCB0YW5nZW50LnkpO1xuICAgICAgICB2YXIgbnAyID0gY2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czIkMSwgY2xpcFBvaW50czEkMSwgY2xpcFNlZ21lbnRUb0xpbmVOb3JtYWwsIHNpZGVPZmZzZXQyLCBpdjIpO1xuICAgICAgICBpZiAobnAyIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBjbGlwUG9pbnRzMiBjb250YWlucyB0aGUgY2xpcHBlZCBwb2ludHMuXG4gICAgICAgIGNvcHlWZWMyKG1hbmlmb2xkLmxvY2FsTm9ybWFsLCBsb2NhbE5vcm1hbCk7XG4gICAgICAgIGNvcHlWZWMyKG1hbmlmb2xkLmxvY2FsUG9pbnQsIHBsYW5lUG9pbnQpO1xuICAgICAgICB2YXIgcG9pbnRDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBvaW50czIkMS5sZW5ndGggLyogbWF4TWFuaWZvbGRQb2ludHMgKi87ICsraSkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBkb3RWZWMyKG5vcm1hbCQxLCBjbGlwUG9pbnRzMiQxW2ldLnYpIC0gZnJvbnRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSB0b3RhbFJhZGl1cykge1xuICAgICAgICAgICAgICAgIHZhciBjcCA9IG1hbmlmb2xkLnBvaW50c1twb2ludENvdW50XTtcbiAgICAgICAgICAgICAgICBpbnZUcmFuc2Zvcm1WZWMyKGNwLmxvY2FsUG9pbnQsIHhmMiwgY2xpcFBvaW50czIkMVtpXS52KTtcbiAgICAgICAgICAgICAgICBjcC5pZC5zZXQoY2xpcFBvaW50czIkMVtpXS5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dhcCBmZWF0dXJlc1xuICAgICAgICAgICAgICAgICAgICBjcC5pZC5zd2FwRmVhdHVyZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytwb2ludENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSBwb2ludENvdW50O1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgQ29udGFjdC5hZGRUeXBlKFBvbHlnb25TaGFwZS5UWVBFLCBDaXJjbGVTaGFwZS5UWVBFLCBQb2x5Z29uQ2lyY2xlQ29udGFjdCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBQb2x5Z29uQ2lyY2xlQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmaXh0dXJlQSwgaW5kZXhBLCB4ZkIsIGZpeHR1cmVCLCBpbmRleEIpIHtcbiAgICAgICAgQ29sbGlkZVBvbHlnb25DaXJjbGUobWFuaWZvbGQsIGZpeHR1cmVBLmdldFNoYXBlKCksIHhmQSwgZml4dHVyZUIuZ2V0U2hhcGUoKSwgeGZCKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY0xvY2FsID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBmYWNlQ2VudGVyID0gdmVjMigwLCAwKTtcbiAgICB2YXIgQ29sbGlkZVBvbHlnb25DaXJjbGUgPSBmdW5jdGlvbiAobWFuaWZvbGQsIHBvbHlnb25BLCB4ZkEsIGNpcmNsZUIsIHhmQikge1xuICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMDtcbiAgICAgICAgLy8gQ29tcHV0ZSBjaXJjbGUgcG9zaXRpb24gaW4gdGhlIGZyYW1lIG9mIHRoZSBwb2x5Z29uLlxuICAgICAgICByZXRyYW5zZm9ybVZlYzIoY0xvY2FsLCB4ZkIsIHhmQSwgY2lyY2xlQi5tX3ApO1xuICAgICAgICAvLyBGaW5kIHRoZSBtaW4gc2VwYXJhdGluZyBlZGdlLlxuICAgICAgICB2YXIgbm9ybWFsSW5kZXggPSAwO1xuICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHBvbHlnb25BLm1fcmFkaXVzICsgY2lyY2xlQi5tX3JhZGl1cztcbiAgICAgICAgdmFyIHZlcnRleENvdW50ID0gcG9seWdvbkEubV9jb3VudDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gcG9seWdvbkEubV92ZXJ0aWNlcztcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBwb2x5Z29uQS5tX25vcm1hbHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIHMgPSBkb3RWZWMyKG5vcm1hbHNbaV0sIGNMb2NhbCkgLSBkb3RWZWMyKG5vcm1hbHNbaV0sIHZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIGlmIChzID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgLy8gRWFybHkgb3V0LlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzID4gc2VwYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSBzO1xuICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJ0aWNlcyB0aGF0IHN1YnRlbmQgdGhlIGluY2lkZW50IGZhY2UuXG4gICAgICAgIHZhciB2ZXJ0SW5kZXgxID0gbm9ybWFsSW5kZXg7XG4gICAgICAgIHZhciB2ZXJ0SW5kZXgyID0gdmVydEluZGV4MSArIDEgPCB2ZXJ0ZXhDb3VudCA/IHZlcnRJbmRleDEgKyAxIDogMDtcbiAgICAgICAgdmFyIHYxID0gdmVydGljZXNbdmVydEluZGV4MV07XG4gICAgICAgIHZhciB2MiA9IHZlcnRpY2VzW3ZlcnRJbmRleDJdO1xuICAgICAgICAvLyBJZiB0aGUgY2VudGVyIGlzIGluc2lkZSB0aGUgcG9seWdvbiAuLi5cbiAgICAgICAgaWYgKHNlcGFyYXRpb24gPCBFUFNJTE9OKSB7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMTtcbiAgICAgICAgICAgIG1hbmlmb2xkLnR5cGUgPSBleHBvcnRzLk1hbmlmb2xkVHlwZS5lX2ZhY2VBO1xuICAgICAgICAgICAgY29weVZlYzIobWFuaWZvbGQubG9jYWxOb3JtYWwsIG5vcm1hbHNbbm9ybWFsSW5kZXhdKTtcbiAgICAgICAgICAgIGNvbWJpbmVWZWMyKG1hbmlmb2xkLmxvY2FsUG9pbnQsIDAuNSwgdjEsIDAuNSwgdjIpO1xuICAgICAgICAgICAgY29weVZlYzIobWFuaWZvbGQucG9pbnRzWzBdLmxvY2FsUG9pbnQsIGNpcmNsZUIubV9wKTtcbiAgICAgICAgICAgIC8vIG1hbmlmb2xkLnBvaW50c1swXS5pZC5rZXkgPSAwO1xuICAgICAgICAgICAgbWFuaWZvbGQucG9pbnRzWzBdLmlkLnNldEZlYXR1cmVzKDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4LCAwLCBleHBvcnRzLkNvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuICAgICAgICAvLyB1MSA9IChjTG9jYWwgLSB2MSkgZG90ICh2MiAtIHYxKSlcbiAgICAgICAgdmFyIHUxID0gZG90VmVjMihjTG9jYWwsIHYyKSAtIGRvdFZlYzIoY0xvY2FsLCB2MSkgLSBkb3RWZWMyKHYxLCB2MikgKyBkb3RWZWMyKHYxLCB2MSk7XG4gICAgICAgIC8vIHUyID0gKGNMb2NhbCAtIHYyKSBkb3QgKHYxIC0gdjIpXG4gICAgICAgIHZhciB1MiA9IGRvdFZlYzIoY0xvY2FsLCB2MSkgLSBkb3RWZWMyKGNMb2NhbCwgdjIpIC0gZG90VmVjMih2MiwgdjEpICsgZG90VmVjMih2MiwgdjIpO1xuICAgICAgICBpZiAodTEgPD0gMC4wKSB7XG4gICAgICAgICAgICBpZiAoZGlzdFNxclZlYzIoY0xvY2FsLCB2MSkgPiByYWRpdXMgKiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMTtcbiAgICAgICAgICAgIG1hbmlmb2xkLnR5cGUgPSBleHBvcnRzLk1hbmlmb2xkVHlwZS5lX2ZhY2VBO1xuICAgICAgICAgICAgZGlmZlZlYzIobWFuaWZvbGQubG9jYWxOb3JtYWwsIGNMb2NhbCwgdjEpO1xuICAgICAgICAgICAgbm9ybWFsaXplVmVjMihtYW5pZm9sZC5sb2NhbE5vcm1hbCk7XG4gICAgICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5sb2NhbFBvaW50LCB2MSk7XG4gICAgICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludCwgY2lyY2xlQi5tX3ApO1xuICAgICAgICAgICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuc2V0RmVhdHVyZXMoMCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgsIDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1MiA8PSAwLjApIHtcbiAgICAgICAgICAgIGlmIChkaXN0U3FyVmVjMihjTG9jYWwsIHYyKSA+IHJhZGl1cyAqIHJhZGl1cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50Q291bnQgPSAxO1xuICAgICAgICAgICAgbWFuaWZvbGQudHlwZSA9IGV4cG9ydHMuTWFuaWZvbGRUeXBlLmVfZmFjZUE7XG4gICAgICAgICAgICBkaWZmVmVjMihtYW5pZm9sZC5sb2NhbE5vcm1hbCwgY0xvY2FsLCB2Mik7XG4gICAgICAgICAgICBub3JtYWxpemVWZWMyKG1hbmlmb2xkLmxvY2FsTm9ybWFsKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKG1hbmlmb2xkLmxvY2FsUG9pbnQsIHYyKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKG1hbmlmb2xkLnBvaW50c1swXS5sb2NhbFBvaW50LCBjaXJjbGVCLm1fcCk7XG4gICAgICAgICAgICAvLyBtYW5pZm9sZC5wb2ludHNbMF0uaWQua2V5ID0gMDtcbiAgICAgICAgICAgIG1hbmlmb2xkLnBvaW50c1swXS5pZC5zZXRGZWF0dXJlcygwLCBleHBvcnRzLkNvbnRhY3RGZWF0dXJlVHlwZS5lX3ZlcnRleCwgMCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tYmluZVZlYzIoZmFjZUNlbnRlciwgMC41LCB2MSwgMC41LCB2Mik7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvbl8xID0gZG90VmVjMihjTG9jYWwsIG5vcm1hbHNbdmVydEluZGV4MV0pIC0gZG90VmVjMihmYWNlQ2VudGVyLCBub3JtYWxzW3ZlcnRJbmRleDFdKTtcbiAgICAgICAgICAgIGlmIChzZXBhcmF0aW9uXzEgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludENvdW50ID0gMTtcbiAgICAgICAgICAgIG1hbmlmb2xkLnR5cGUgPSBleHBvcnRzLk1hbmlmb2xkVHlwZS5lX2ZhY2VBO1xuICAgICAgICAgICAgY29weVZlYzIobWFuaWZvbGQubG9jYWxOb3JtYWwsIG5vcm1hbHNbdmVydEluZGV4MV0pO1xuICAgICAgICAgICAgY29weVZlYzIobWFuaWZvbGQubG9jYWxQb2ludCwgZmFjZUNlbnRlcik7XG4gICAgICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5wb2ludHNbMF0ubG9jYWxQb2ludCwgY2lyY2xlQi5tX3ApO1xuICAgICAgICAgICAgLy8gbWFuaWZvbGQucG9pbnRzWzBdLmlkLmtleSA9IDA7XG4gICAgICAgICAgICBtYW5pZm9sZC5wb2ludHNbMF0uaWQuc2V0RmVhdHVyZXMoMCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgsIDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFBsYW5jay5qc1xuICAgICAqIFRoZSBNSVQgTGljZW5zZVxuICAgICAqIENvcHlyaWdodCAoYykgMjAyMSBFcmluIENhdHRvLCBBbGkgU2hha2liYVxuICAgICAqXG4gICAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAqXG4gICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAgICogU09GVFdBUkUuXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbWF0aF9taW4gPSBNYXRoLm1pbjtcbiAgICBDb250YWN0LmFkZFR5cGUoRWRnZVNoYXBlLlRZUEUsIFBvbHlnb25TaGFwZS5UWVBFLCBFZGdlUG9seWdvbkNvbnRhY3QpO1xuICAgIENvbnRhY3QuYWRkVHlwZShDaGFpblNoYXBlLlRZUEUsIFBvbHlnb25TaGFwZS5UWVBFLCBDaGFpblBvbHlnb25Db250YWN0KTtcbiAgICAvKiogQGludGVybmFsICovIGZ1bmN0aW9uIEVkZ2VQb2x5Z29uQ29udGFjdChtYW5pZm9sZCwgeGZBLCBmQSwgaW5kZXhBLCB4ZkIsIGZCLCBpbmRleEIpIHtcbiAgICAgICAgQ29sbGlkZUVkZ2VQb2x5Z29uKG1hbmlmb2xkLCBmQS5nZXRTaGFwZSgpLCB4ZkEsIGZCLmdldFNoYXBlKCksIHhmQik7XG4gICAgfVxuICAgIC8vIHJldXNlZFxuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGVkZ2VfcmV1c2UgPSBuZXcgRWRnZVNoYXBlKCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBDaGFpblBvbHlnb25Db250YWN0KG1hbmlmb2xkLCB4ZkEsIGZBLCBpbmRleEEsIHhmQiwgZkIsIGluZGV4Qikge1xuICAgICAgICB2YXIgY2hhaW4gPSBmQS5nZXRTaGFwZSgpO1xuICAgICAgICBjaGFpbi5nZXRDaGlsZEVkZ2UoZWRnZV9yZXVzZSwgaW5kZXhBKTtcbiAgICAgICAgQ29sbGlkZUVkZ2VQb2x5Z29uKG1hbmlmb2xkLCBlZGdlX3JldXNlLCB4ZkEsIGZCLmdldFNoYXBlKCksIHhmQik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIEVQQXhpc1R5cGU7XG4gICAgKGZ1bmN0aW9uIChFUEF4aXNUeXBlKSB7XG4gICAgICAgIEVQQXhpc1R5cGVbRVBBeGlzVHlwZVtcImVfdW5rbm93blwiXSA9IC0xXSA9IFwiZV91bmtub3duXCI7XG4gICAgICAgIEVQQXhpc1R5cGVbRVBBeGlzVHlwZVtcImVfZWRnZUFcIl0gPSAxXSA9IFwiZV9lZGdlQVwiO1xuICAgICAgICBFUEF4aXNUeXBlW0VQQXhpc1R5cGVbXCJlX2VkZ2VCXCJdID0gMl0gPSBcImVfZWRnZUJcIjtcbiAgICB9KShFUEF4aXNUeXBlIHx8IChFUEF4aXNUeXBlID0ge30pKTtcbiAgICAvLyB1bnVzZWQ/XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgVmVydGV4VHlwZTtcbiAgICAoZnVuY3Rpb24gKFZlcnRleFR5cGUpIHtcbiAgICAgICAgVmVydGV4VHlwZVtWZXJ0ZXhUeXBlW1wiZV9pc29sYXRlZFwiXSA9IDBdID0gXCJlX2lzb2xhdGVkXCI7XG4gICAgICAgIFZlcnRleFR5cGVbVmVydGV4VHlwZVtcImVfY29uY2F2ZVwiXSA9IDFdID0gXCJlX2NvbmNhdmVcIjtcbiAgICAgICAgVmVydGV4VHlwZVtWZXJ0ZXhUeXBlW1wiZV9jb252ZXhcIl0gPSAyXSA9IFwiZV9jb252ZXhcIjtcbiAgICB9KShWZXJ0ZXhUeXBlIHx8IChWZXJ0ZXhUeXBlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHN0cnVjdHVyZSBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGJlc3Qgc2VwYXJhdGluZyBheGlzLlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIEVQQXhpcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRVBBeGlzKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFUEF4aXM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGhvbGRzIHBvbHlnb24gQiBleHByZXNzZWQgaW4gZnJhbWUgQS5cbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovIHZhciBUZW1wUG9seWdvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVtcFBvbHlnb24oKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gW107IC8vIFtTZXR0aW5ncy5tYXhQb2x5Z29uVmVydGljZXNdXG4gICAgICAgICAgICB0aGlzLm5vcm1hbHMgPSBbXTsgLy8gW1NldHRpbmdzLm1heFBvbHlnb25WZXJ0aWNlc107XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU2V0dGluZ3NJbnRlcm5hbC5tYXhQb2x5Z29uVmVydGljZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaCh2ZWMyKDAsIDApKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHMucHVzaCh2ZWMyKDAsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGVtcFBvbHlnb247XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgZmFjZSB1c2VkIGZvciBjbGlwcGluZ1xuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIFJlZmVyZW5jZUZhY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUZhY2UoKSB7XG4gICAgICAgICAgICB0aGlzLnYxID0gdmVjMigwLCAwKTtcbiAgICAgICAgICAgIHRoaXMudjIgPSB2ZWMyKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwgPSB2ZWMyKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5zaWRlTm9ybWFsMSA9IHZlYzIoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLnNpZGVOb3JtYWwyID0gdmVjMigwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBSZWZlcmVuY2VGYWNlLnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy52MSk7XG4gICAgICAgICAgICB6ZXJvVmVjMih0aGlzLnYyKTtcbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMubm9ybWFsKTtcbiAgICAgICAgICAgIHplcm9WZWMyKHRoaXMuc2lkZU5vcm1hbDEpO1xuICAgICAgICAgICAgemVyb1ZlYzIodGhpcy5zaWRlTm9ybWFsMik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZlcmVuY2VGYWNlO1xuICAgIH0oKSk7XG4gICAgLy8gcmV1c2VkXG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY2xpcFBvaW50czEgPSBbbmV3IENsaXBWZXJ0ZXgoKSwgbmV3IENsaXBWZXJ0ZXgoKV07XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgY2xpcFBvaW50czIgPSBbbmV3IENsaXBWZXJ0ZXgoKSwgbmV3IENsaXBWZXJ0ZXgoKV07XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgaWUgPSBbbmV3IENsaXBWZXJ0ZXgoKSwgbmV3IENsaXBWZXJ0ZXgoKV07XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZWRnZUF4aXMgPSBuZXcgRVBBeGlzKCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcG9seWdvbkF4aXMgPSBuZXcgRVBBeGlzKCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcG9seWdvbkJBID0gbmV3IFRlbXBQb2x5Z29uKCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgcmYgPSBuZXcgUmVmZXJlbmNlRmFjZSgpO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGNlbnRyb2lkQiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgZWRnZTAgPSB2ZWMyKDAsIDApO1xuICAgIC8qKiBAaW50ZXJuYWwgKi8gdmFyIGVkZ2UxID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBlZGdlMiA9IHZlYzIoMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgeGYgPSB0cmFuc2Zvcm0oMCwgMCwgMCk7XG4gICAgLyoqIEBpbnRlcm5hbCAqLyB2YXIgbm9ybWFsID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBub3JtYWwwID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBub3JtYWwxID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBub3JtYWwyID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBsb3dlckxpbWl0ID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciB1cHBlckxpbWl0ID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBwZXJwID0gdmVjMigwLCAwKTtcbiAgICAvKiogQGludGVybmFsICovIHZhciBuID0gdmVjMigwLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNvbGxpZGVzIGFuZCBlZGdlIGFuZCBhIHBvbHlnb24sIHRha2luZyBpbnRvIGFjY291bnQgZWRnZVxuICAgICAqIGFkamFjZW5jeS5cbiAgICAgKi9cbiAgICB2YXIgQ29sbGlkZUVkZ2VQb2x5Z29uID0gZnVuY3Rpb24gKG1hbmlmb2xkLCBlZGdlQSwgeGZBLCBwb2x5Z29uQiwgeGZCKSB7XG4gICAgICAgIC8vIEFsZ29yaXRobTpcbiAgICAgICAgLy8gMS4gQ2xhc3NpZnkgdjEgYW5kIHYyXG4gICAgICAgIC8vIDIuIENsYXNzaWZ5IHBvbHlnb24gY2VudHJvaWQgYXMgZnJvbnQgb3IgYmFja1xuICAgICAgICAvLyAzLiBGbGlwIG5vcm1hbCBpZiBuZWNlc3NhcnlcbiAgICAgICAgLy8gNC4gSW5pdGlhbGl6ZSBub3JtYWwgcmFuZ2UgdG8gWy1waSwgcGldIGFib3V0IGZhY2Ugbm9ybWFsXG4gICAgICAgIC8vIDUuIEFkanVzdCBub3JtYWwgcmFuZ2UgYWNjb3JkaW5nIHRvIGFkamFjZW50IGVkZ2VzXG4gICAgICAgIC8vIDYuIFZpc2l0IGVhY2ggc2VwYXJhdGluZyBheGVzLCBvbmx5IGFjY2VwdCBheGVzIHdpdGhpbiB0aGUgcmFuZ2VcbiAgICAgICAgLy8gNy4gUmV0dXJuIGlmIF9hbnlfIGF4aXMgaW5kaWNhdGVzIHNlcGFyYXRpb25cbiAgICAgICAgLy8gOC4gQ2xpcFxuICAgICAgICAvLyBsZXQgbV90eXBlMTogVmVydGV4VHlwZTtcbiAgICAgICAgLy8gbGV0IG1fdHlwZTI6IFZlcnRleFR5cGU7XG4gICAgICAgIGludlRyYW5zZm9ybVRyYW5zZm9ybSh4ZiwgeGZBLCB4ZkIpO1xuICAgICAgICB0cmFuc2Zvcm1WZWMyKGNlbnRyb2lkQiwgeGYsIHBvbHlnb25CLm1fY2VudHJvaWQpO1xuICAgICAgICB2YXIgdjAgPSBlZGdlQS5tX3ZlcnRleDA7XG4gICAgICAgIHZhciB2MSA9IGVkZ2VBLm1fdmVydGV4MTtcbiAgICAgICAgdmFyIHYyID0gZWRnZUEubV92ZXJ0ZXgyO1xuICAgICAgICB2YXIgdjMgPSBlZGdlQS5tX3ZlcnRleDM7XG4gICAgICAgIHZhciBoYXNWZXJ0ZXgwID0gZWRnZUEubV9oYXNWZXJ0ZXgwO1xuICAgICAgICB2YXIgaGFzVmVydGV4MyA9IGVkZ2VBLm1faGFzVmVydGV4MztcbiAgICAgICAgZGlmZlZlYzIoZWRnZTEsIHYyLCB2MSk7XG4gICAgICAgIG5vcm1hbGl6ZVZlYzIoZWRnZTEpO1xuICAgICAgICBzZXRWZWMyKG5vcm1hbDEsIGVkZ2UxLnksIC1lZGdlMS54KTtcbiAgICAgICAgdmFyIG9mZnNldDEgPSBkb3RWZWMyKG5vcm1hbDEsIGNlbnRyb2lkQikgLSBkb3RWZWMyKG5vcm1hbDEsIHYxKTtcbiAgICAgICAgdmFyIG9mZnNldDAgPSAwLjA7XG4gICAgICAgIHZhciBvZmZzZXQyID0gMC4wO1xuICAgICAgICB2YXIgY29udmV4MSA9IGZhbHNlO1xuICAgICAgICB2YXIgY29udmV4MiA9IGZhbHNlO1xuICAgICAgICB6ZXJvVmVjMihub3JtYWwwKTtcbiAgICAgICAgemVyb1ZlYzIobm9ybWFsMik7XG4gICAgICAgIC8vIElzIHRoZXJlIGEgcHJlY2VkaW5nIGVkZ2U/XG4gICAgICAgIGlmIChoYXNWZXJ0ZXgwKSB7XG4gICAgICAgICAgICBkaWZmVmVjMihlZGdlMCwgdjEsIHYwKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVZlYzIoZWRnZTApO1xuICAgICAgICAgICAgc2V0VmVjMihub3JtYWwwLCBlZGdlMC55LCAtZWRnZTAueCk7XG4gICAgICAgICAgICBjb252ZXgxID0gY3Jvc3NWZWMyVmVjMihlZGdlMCwgZWRnZTEpID49IDAuMDtcbiAgICAgICAgICAgIG9mZnNldDAgPSBWZWMyLmRvdChub3JtYWwwLCBjZW50cm9pZEIpIC0gVmVjMi5kb3Qobm9ybWFsMCwgdjApO1xuICAgICAgICB9XG4gICAgICAgIC8vIElzIHRoZXJlIGEgZm9sbG93aW5nIGVkZ2U/XG4gICAgICAgIGlmIChoYXNWZXJ0ZXgzKSB7XG4gICAgICAgICAgICBkaWZmVmVjMihlZGdlMiwgdjMsIHYyKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVZlYzIoZWRnZTIpO1xuICAgICAgICAgICAgc2V0VmVjMihub3JtYWwyLCBlZGdlMi55LCAtZWRnZTIueCk7XG4gICAgICAgICAgICBjb252ZXgyID0gVmVjMi5jcm9zc1ZlYzJWZWMyKGVkZ2UxLCBlZGdlMikgPiAwLjA7XG4gICAgICAgICAgICBvZmZzZXQyID0gVmVjMi5kb3Qobm9ybWFsMiwgY2VudHJvaWRCKSAtIFZlYzIuZG90KG5vcm1hbDIsIHYyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbnQ7XG4gICAgICAgIHplcm9WZWMyKG5vcm1hbCk7XG4gICAgICAgIHplcm9WZWMyKGxvd2VyTGltaXQpO1xuICAgICAgICB6ZXJvVmVjMih1cHBlckxpbWl0KTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGZyb250IG9yIGJhY2sgY29sbGlzaW9uLiBEZXRlcm1pbmUgY29sbGlzaW9uIG5vcm1hbCBsaW1pdHMuXG4gICAgICAgIGlmIChoYXNWZXJ0ZXgwICYmIGhhc1ZlcnRleDMpIHtcbiAgICAgICAgICAgIGlmIChjb252ZXgxICYmIGNvbnZleDIpIHtcbiAgICAgICAgICAgICAgICBmcm9udCA9IG9mZnNldDAgPj0gMC4wIHx8IG9mZnNldDEgPj0gMC4wIHx8IG9mZnNldDIgPj0gMC4wO1xuICAgICAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihub3JtYWwsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihsb3dlckxpbWl0LCBub3JtYWwwKTtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIodXBwZXJMaW1pdCwgbm9ybWFsMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKG5vcm1hbCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKGxvd2VyTGltaXQsIC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMih1cHBlckxpbWl0LCAtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29udmV4MSkge1xuICAgICAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MCA+PSAwLjAgfHwgKG9mZnNldDEgPj0gMC4wICYmIG9mZnNldDIgPj0gMC4wKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIobm9ybWFsLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIobG93ZXJMaW1pdCwgbm9ybWFsMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKHVwcGVyTGltaXQsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihub3JtYWwsIC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihsb3dlckxpbWl0LCAtMSwgbm9ybWFsMik7XG4gICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIodXBwZXJMaW1pdCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnZleDIpIHtcbiAgICAgICAgICAgICAgICBmcm9udCA9IG9mZnNldDIgPj0gMC4wIHx8IChvZmZzZXQwID49IDAuMCAmJiBvZmZzZXQxID49IDAuMCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKG5vcm1hbCwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKGxvd2VyTGltaXQsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMih1cHBlckxpbWl0LCBub3JtYWwyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIobm9ybWFsLCAtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIobG93ZXJMaW1pdCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKHVwcGVyTGltaXQsIC0xLCBub3JtYWwwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9udCA9IG9mZnNldDAgPj0gMC4wICYmIG9mZnNldDEgPj0gMC4wICYmIG9mZnNldDIgPj0gMC4wO1xuICAgICAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihub3JtYWwsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihsb3dlckxpbWl0LCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIodXBwZXJMaW1pdCwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKG5vcm1hbCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKGxvd2VyTGltaXQsIC0xLCBub3JtYWwyKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMih1cHBlckxpbWl0LCAtMSwgbm9ybWFsMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1ZlcnRleDApIHtcbiAgICAgICAgICAgIGlmIChjb252ZXgxKSB7XG4gICAgICAgICAgICAgICAgZnJvbnQgPSBvZmZzZXQwID49IDAuMCB8fCBvZmZzZXQxID49IDAuMDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIobm9ybWFsLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIobG93ZXJMaW1pdCwgbm9ybWFsMCk7XG4gICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIodXBwZXJMaW1pdCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihub3JtYWwsIC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIobG93ZXJMaW1pdCwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIodXBwZXJMaW1pdCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MCA+PSAwLjAgJiYgb2Zmc2V0MSA+PSAwLjA7XG4gICAgICAgICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKG5vcm1hbCwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKGxvd2VyTGltaXQsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKHVwcGVyTGltaXQsIC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE11bFZlYzIobm9ybWFsLCAtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKGxvd2VyTGltaXQsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKHVwcGVyTGltaXQsIC0xLCBub3JtYWwwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzVmVydGV4Mykge1xuICAgICAgICAgICAgaWYgKGNvbnZleDIpIHtcbiAgICAgICAgICAgICAgICBmcm9udCA9IG9mZnNldDEgPj0gMC4wIHx8IG9mZnNldDIgPj0gMC4wO1xuICAgICAgICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5VmVjMihub3JtYWwsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKGxvd2VyTGltaXQsIC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIodXBwZXJMaW1pdCwgbm9ybWFsMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKG5vcm1hbCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNdWxWZWMyKGxvd2VyTGltaXQsIC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIodXBwZXJMaW1pdCwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbnQgPSBvZmZzZXQxID49IDAuMCAmJiBvZmZzZXQyID49IDAuMDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIobm9ybWFsLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihsb3dlckxpbWl0LCAtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKHVwcGVyTGltaXQsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihub3JtYWwsIC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TXVsVmVjMihsb3dlckxpbWl0LCAtMSwgbm9ybWFsMik7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlWZWMyKHVwcGVyTGltaXQsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb250ID0gb2Zmc2V0MSA+PSAwLjA7XG4gICAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihub3JtYWwsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIHNldE11bFZlYzIobG93ZXJMaW1pdCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgIHNldE11bFZlYzIodXBwZXJMaW1pdCwgLTEsIG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0TXVsVmVjMihub3JtYWwsIC0xLCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihsb3dlckxpbWl0LCBub3JtYWwxKTtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMih1cHBlckxpbWl0LCBub3JtYWwxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgcG9seWdvbkIgaW4gZnJhbWVBXG4gICAgICAgIHBvbHlnb25CQS5jb3VudCA9IHBvbHlnb25CLm1fY291bnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbkIubV9jb3VudDsgKytpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1WZWMyKHBvbHlnb25CQS52ZXJ0aWNlc1tpXSwgeGYsIHBvbHlnb25CLm1fdmVydGljZXNbaV0pO1xuICAgICAgICAgICAgcm90VmVjMihwb2x5Z29uQkEubm9ybWFsc1tpXSwgeGYucSwgcG9seWdvbkIubV9ub3JtYWxzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFkaXVzID0gcG9seWdvbkIubV9yYWRpdXMgKyBlZGdlQS5tX3JhZGl1cztcbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IDA7XG4gICAgICAgIHsgLy8gQ29tcHV0ZUVkZ2VTZXBhcmF0aW9uXG4gICAgICAgICAgICBlZGdlQXhpcy50eXBlID0gRVBBeGlzVHlwZS5lX2VkZ2VBO1xuICAgICAgICAgICAgZWRnZUF4aXMuaW5kZXggPSBmcm9udCA/IDAgOiAxO1xuICAgICAgICAgICAgZWRnZUF4aXMuc2VwYXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uQkEuY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gcG9seWdvbkJBLnZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzID0gZG90VmVjMihub3JtYWwsIHYpIC0gZG90VmVjMihub3JtYWwsIHYxKTtcbiAgICAgICAgICAgICAgICBpZiAocyA8IGVkZ2VBeGlzLnNlcGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZUF4aXMuc2VwYXJhdGlvbiA9IHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHZhbGlkIG5vcm1hbCBjYW4gYmUgZm91bmQgdGhhbiB0aGlzIGVkZ2Ugc2hvdWxkIG5vdCBjb2xsaWRlLlxuICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IHdoeSB3ZSBuZWVkIHRoaXMgaWYgaGVyZT9cbiAgICAgICAgaWYgKGVkZ2VBeGlzLnR5cGUgPT0gRVBBeGlzVHlwZS5lX3Vua25vd24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRnZUF4aXMuc2VwYXJhdGlvbiA+IHJhZGl1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHsgLy8gQ29tcHV0ZVBvbHlnb25TZXBhcmF0aW9uXG4gICAgICAgICAgICBwb2x5Z29uQXhpcy50eXBlID0gRVBBeGlzVHlwZS5lX3Vua25vd247XG4gICAgICAgICAgICBwb2x5Z29uQXhpcy5pbmRleCA9IC0xO1xuICAgICAgICAgICAgcG9seWdvbkF4aXMuc2VwYXJhdGlvbiA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIHNldFZlYzIocGVycCwgLW5vcm1hbC55LCBub3JtYWwueCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25CQS5jb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2V0TXVsVmVjMihuLCAtMSwgcG9seWdvbkJBLm5vcm1hbHNbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBzMSA9IGRvdFZlYzIobiwgcG9seWdvbkJBLnZlcnRpY2VzW2ldKSAtIGRvdFZlYzIobiwgdjEpO1xuICAgICAgICAgICAgICAgIHZhciBzMiA9IGRvdFZlYzIobiwgcG9seWdvbkJBLnZlcnRpY2VzW2ldKSAtIGRvdFZlYzIobiwgdjIpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gbWF0aF9taW4oczEsIHMyKTtcbiAgICAgICAgICAgICAgICBpZiAocyA+IHJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkF4aXMudHlwZSA9IEVQQXhpc1R5cGUuZV9lZGdlQjtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkF4aXMuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy5zZXBhcmF0aW9uID0gcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkamFjZW5jeVxuICAgICAgICAgICAgICAgIGlmIChkb3RWZWMyKG4sIHBlcnApID49IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG90VmVjMihuLCBub3JtYWwpIC0gZG90VmVjMih1cHBlckxpbWl0LCBub3JtYWwpIDwgLVNldHRpbmdzSW50ZXJuYWwuYW5ndWxhclNsb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG90VmVjMihuLCBub3JtYWwpIC0gZG90VmVjMihsb3dlckxpbWl0LCBub3JtYWwpIDwgLVNldHRpbmdzSW50ZXJuYWwuYW5ndWxhclNsb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzID4gcG9seWdvbkF4aXMuc2VwYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy50eXBlID0gRVBBeGlzVHlwZS5lX2VkZ2VCO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BeGlzLnNlcGFyYXRpb24gPSBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seWdvbkF4aXMudHlwZSAhPSBFUEF4aXNUeXBlLmVfdW5rbm93biAmJiBwb2x5Z29uQXhpcy5zZXBhcmF0aW9uID4gcmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGh5c3RlcmVzaXMgZm9yIGppdHRlciByZWR1Y3Rpb24uXG4gICAgICAgIHZhciBrX3JlbGF0aXZlVG9sID0gMC45ODtcbiAgICAgICAgdmFyIGtfYWJzb2x1dGVUb2wgPSAwLjAwMTtcbiAgICAgICAgdmFyIHByaW1hcnlBeGlzO1xuICAgICAgICBpZiAocG9seWdvbkF4aXMudHlwZSA9PSBFUEF4aXNUeXBlLmVfdW5rbm93bikge1xuICAgICAgICAgICAgcHJpbWFyeUF4aXMgPSBlZGdlQXhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb2x5Z29uQXhpcy5zZXBhcmF0aW9uID4ga19yZWxhdGl2ZVRvbCAqIGVkZ2VBeGlzLnNlcGFyYXRpb24gKyBrX2Fic29sdXRlVG9sKSB7XG4gICAgICAgICAgICBwcmltYXJ5QXhpcyA9IHBvbHlnb25BeGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJpbWFyeUF4aXMgPSBlZGdlQXhpcztcbiAgICAgICAgfVxuICAgICAgICBpZVswXS5yZWN5Y2xlKCksIGllWzFdLnJlY3ljbGUoKTtcbiAgICAgICAgaWYgKHByaW1hcnlBeGlzLnR5cGUgPT0gRVBBeGlzVHlwZS5lX2VkZ2VBKSB7XG4gICAgICAgICAgICBtYW5pZm9sZC50eXBlID0gZXhwb3J0cy5NYW5pZm9sZFR5cGUuZV9mYWNlQTtcbiAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHBvbHlnb24gbm9ybWFsIHRoYXQgaXMgbW9zdCBhbnRpLXBhcmFsbGVsIHRvIHRoZSBlZGdlXG4gICAgICAgICAgICAvLyBub3JtYWwuXG4gICAgICAgICAgICB2YXIgYmVzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSBkb3RWZWMyKG5vcm1hbCwgcG9seWdvbkJBLm5vcm1hbHNbMF0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2x5Z29uQkEuY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRvdFZlYzIobm9ybWFsLCBwb2x5Z29uQkEubm9ybWFsc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpMSA9IGJlc3RJbmRleDtcbiAgICAgICAgICAgIHZhciBpMiA9IGkxICsgMSA8IHBvbHlnb25CQS5jb3VudCA/IGkxICsgMSA6IDA7XG4gICAgICAgICAgICBjb3B5VmVjMihpZVswXS52LCBwb2x5Z29uQkEudmVydGljZXNbaTFdKTtcbiAgICAgICAgICAgIGllWzBdLmlkLnNldEZlYXR1cmVzKDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfZmFjZSwgaTEsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4KTtcbiAgICAgICAgICAgIGNvcHlWZWMyKGllWzFdLnYsIHBvbHlnb25CQS52ZXJ0aWNlc1tpMl0pO1xuICAgICAgICAgICAgaWVbMV0uaWQuc2V0RmVhdHVyZXMoMCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV9mYWNlLCBpMiwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV92ZXJ0ZXgpO1xuICAgICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgcmYuaTEgPSAwO1xuICAgICAgICAgICAgICAgIHJmLmkyID0gMTtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihyZi52MSwgdjEpO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMyKHJmLnYyLCB2Mik7XG4gICAgICAgICAgICAgICAgY29weVZlYzIocmYubm9ybWFsLCBub3JtYWwxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJmLmkxID0gMTtcbiAgICAgICAgICAgICAgICByZi5pMiA9IDA7XG4gICAgICAgICAgICAgICAgY29weVZlYzIocmYudjEsIHYyKTtcbiAgICAgICAgICAgICAgICBjb3B5VmVjMihyZi52MiwgdjEpO1xuICAgICAgICAgICAgICAgIHNldE11bFZlYzIocmYubm9ybWFsLCAtMSwgbm9ybWFsMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYW5pZm9sZC50eXBlID0gZXhwb3J0cy5NYW5pZm9sZFR5cGUuZV9mYWNlQjtcbiAgICAgICAgICAgIGNvcHlWZWMyKGllWzBdLnYsIHYxKTtcbiAgICAgICAgICAgIGllWzBdLmlkLnNldEZlYXR1cmVzKDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4LCBwcmltYXJ5QXhpcy5pbmRleCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV9mYWNlKTtcbiAgICAgICAgICAgIGNvcHlWZWMyKGllWzFdLnYsIHYyKTtcbiAgICAgICAgICAgIGllWzFdLmlkLnNldEZlYXR1cmVzKDAsIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlLmVfdmVydGV4LCBwcmltYXJ5QXhpcy5pbmRleCwgZXhwb3J0cy5Db250YWN0RmVhdHVyZVR5cGUuZV9mYWNlKTtcbiAgICAgICAgICAgIHJmLmkxID0gcHJpbWFyeUF4aXMuaW5kZXg7XG4gICAgICAgICAgICByZi5pMiA9IHJmLmkxICsgMSA8IHBvbHlnb25CQS5jb3VudCA/IHJmLmkxICsgMSA6IDA7XG4gICAgICAgICAgICBjb3B5VmVjMihyZi52MSwgcG9seWdvbkJBLnZlcnRpY2VzW3JmLmkxXSk7XG4gICAgICAgICAgICBjb3B5VmVjMihyZi52MiwgcG9seWdvbkJBLnZlcnRpY2VzW3JmLmkyXSk7XG4gICAgICAgICAgICBjb3B5VmVjMihyZi5ub3JtYWwsIHBvbHlnb25CQS5ub3JtYWxzW3JmLmkxXSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmVjMihyZi5zaWRlTm9ybWFsMSwgcmYubm9ybWFsLnksIC1yZi5ub3JtYWwueCk7XG4gICAgICAgIHNldFZlYzIocmYuc2lkZU5vcm1hbDIsIC1yZi5zaWRlTm9ybWFsMS54LCAtcmYuc2lkZU5vcm1hbDEueSk7XG4gICAgICAgIHJmLnNpZGVPZmZzZXQxID0gZG90VmVjMihyZi5zaWRlTm9ybWFsMSwgcmYudjEpO1xuICAgICAgICByZi5zaWRlT2Zmc2V0MiA9IGRvdFZlYzIocmYuc2lkZU5vcm1hbDIsIHJmLnYyKTtcbiAgICAgICAgLy8gQ2xpcCBpbmNpZGVudCBlZGdlIGFnYWluc3QgZXh0cnVkZWQgZWRnZTEgc2lkZSBlZGdlcy5cbiAgICAgICAgY2xpcFBvaW50czFbMF0ucmVjeWNsZSgpLCBjbGlwUG9pbnRzMVsxXS5yZWN5Y2xlKCk7XG4gICAgICAgIGNsaXBQb2ludHMyWzBdLnJlY3ljbGUoKSwgY2xpcFBvaW50czJbMV0ucmVjeWNsZSgpO1xuICAgICAgICAvLyBDbGlwIHRvIGJveCBzaWRlIDFcbiAgICAgICAgdmFyIG5wMSA9IGNsaXBTZWdtZW50VG9MaW5lKGNsaXBQb2ludHMxLCBpZSwgcmYuc2lkZU5vcm1hbDEsIHJmLnNpZGVPZmZzZXQxLCByZi5pMSk7XG4gICAgICAgIGlmIChucDEgPCBTZXR0aW5nc0ludGVybmFsLm1heE1hbmlmb2xkUG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xpcCB0byBuZWdhdGl2ZSBib3ggc2lkZSAxXG4gICAgICAgIHZhciBucDIgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMiwgY2xpcFBvaW50czEsIHJmLnNpZGVOb3JtYWwyLCByZi5zaWRlT2Zmc2V0MiwgcmYuaTIpO1xuICAgICAgICBpZiAobnAyIDwgU2V0dGluZ3NJbnRlcm5hbC5tYXhNYW5pZm9sZFBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBjbGlwUG9pbnRzMiBjb250YWlucyB0aGUgY2xpcHBlZCBwb2ludHMuXG4gICAgICAgIGlmIChwcmltYXJ5QXhpcy50eXBlID09IEVQQXhpc1R5cGUuZV9lZGdlQSkge1xuICAgICAgICAgICAgY29weVZlYzIobWFuaWZvbGQubG9jYWxOb3JtYWwsIHJmLm5vcm1hbCk7XG4gICAgICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5sb2NhbFBvaW50LCByZi52MSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5sb2NhbE5vcm1hbCwgcG9seWdvbkIubV9ub3JtYWxzW3JmLmkxXSk7XG4gICAgICAgICAgICBjb3B5VmVjMihtYW5pZm9sZC5sb2NhbFBvaW50LCBwb2x5Z29uQi5tX3ZlcnRpY2VzW3JmLmkxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvaW50Q291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNldHRpbmdzSW50ZXJuYWwubWF4TWFuaWZvbGRQb2ludHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBkb3RWZWMyKHJmLm5vcm1hbCwgY2xpcFBvaW50czJbaV0udikgLSBkb3RWZWMyKHJmLm5vcm1hbCwgcmYudjEpO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPD0gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNwID0gbWFuaWZvbGQucG9pbnRzW3BvaW50Q291bnRdOyAvLyBNYW5pZm9sZFBvaW50XG4gICAgICAgICAgICAgICAgaWYgKHByaW1hcnlBeGlzLnR5cGUgPT0gRVBBeGlzVHlwZS5lX2VkZ2VBKSB7XG4gICAgICAgICAgICAgICAgICAgIGludlRyYW5zZm9ybVZlYzIoY3AubG9jYWxQb2ludCwgeGYsIGNsaXBQb2ludHMyW2ldLnYpO1xuICAgICAgICAgICAgICAgICAgICBjcC5pZC5zZXQoY2xpcFBvaW50czJbaV0uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVZlYzIoY3AubG9jYWxQb2ludCwgY2xpcFBvaW50czJbaV0udik7XG4gICAgICAgICAgICAgICAgICAgIGNwLmlkLnNldChjbGlwUG9pbnRzMltpXS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGNwLmlkLnN3YXBGZWF0dXJlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK3BvaW50Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFuaWZvbGQucG9pbnRDb3VudCA9IHBvaW50Q291bnQ7XG4gICAgfTtcblxuICAgIC8qKiBAZGVwcmVjYXRlZCBNZXJnZWQgd2l0aCBtYWluIG5hbWVzcGFjZSAqL1xuICAgIHZhciBpbnRlcm5hbCA9IHtcbiAgICAgICAgQ29sbGlkZVBvbHlnb25zOiBDb2xsaWRlUG9seWdvbnMsXG4gICAgICAgIFNldHRpbmdzOiBTZXR0aW5nc0ludGVybmFsLFxuICAgICAgICBTd2VlcDogU3dlZXAsXG4gICAgICAgIE1hbmlmb2xkOiBNYW5pZm9sZCxcbiAgICAgICAgRGlzdGFuY2U6IERpc3RhbmNlLFxuICAgICAgICBUaW1lT2ZJbXBhY3Q6IFRpbWVPZkltcGFjdCxcbiAgICAgICAgRHluYW1pY1RyZWU6IER5bmFtaWNUcmVlLFxuICAgICAgICBzdGF0czogc3RhdHNcbiAgICB9O1xuXG4gICAgdmFyIHBsYW5jayA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBNYXRoOiBtYXRoLFxuICAgICAgICBTZXJpYWxpemVyOiBTZXJpYWxpemVyLFxuICAgICAgICBUZXN0YmVkOiBUZXN0YmVkLFxuICAgICAgICB0ZXN0YmVkOiB0ZXN0YmVkLFxuICAgICAgICBWZWMyOiBWZWMyLFxuICAgICAgICBWZWMzOiBWZWMzLFxuICAgICAgICBNYXQyMjogTWF0MjIsXG4gICAgICAgIE1hdDMzOiBNYXQzMyxcbiAgICAgICAgVHJhbnNmb3JtOiBUcmFuc2Zvcm0sXG4gICAgICAgIFJvdDogUm90LFxuICAgICAgICBBQUJCOiBBQUJCLFxuICAgICAgICBTaGFwZTogU2hhcGUsXG4gICAgICAgIEZpeHR1cmVQcm94eTogRml4dHVyZVByb3h5LFxuICAgICAgICBGaXh0dXJlOiBGaXh0dXJlLFxuICAgICAgICBCb2R5OiBCb2R5LFxuICAgICAgICBDb250YWN0RWRnZTogQ29udGFjdEVkZ2UsXG4gICAgICAgIG1peEZyaWN0aW9uOiBtaXhGcmljdGlvbixcbiAgICAgICAgbWl4UmVzdGl0dXRpb246IG1peFJlc3RpdHV0aW9uLFxuICAgICAgICBWZWxvY2l0eUNvbnN0cmFpbnRQb2ludDogVmVsb2NpdHlDb25zdHJhaW50UG9pbnQsXG4gICAgICAgIENvbnRhY3Q6IENvbnRhY3QsXG4gICAgICAgIEpvaW50RWRnZTogSm9pbnRFZGdlLFxuICAgICAgICBKb2ludDogSm9pbnQsXG4gICAgICAgIFdvcmxkOiBXb3JsZCxcbiAgICAgICAgQ2lyY2xlU2hhcGU6IENpcmNsZVNoYXBlLFxuICAgICAgICBDaXJjbGU6IENpcmNsZSxcbiAgICAgICAgRWRnZVNoYXBlOiBFZGdlU2hhcGUsXG4gICAgICAgIEVkZ2U6IEVkZ2UsXG4gICAgICAgIFBvbHlnb25TaGFwZTogUG9seWdvblNoYXBlLFxuICAgICAgICBQb2x5Z29uOiBQb2x5Z29uLFxuICAgICAgICBDaGFpblNoYXBlOiBDaGFpblNoYXBlLFxuICAgICAgICBDaGFpbjogQ2hhaW4sXG4gICAgICAgIEJveFNoYXBlOiBCb3hTaGFwZSxcbiAgICAgICAgQm94OiBCb3gsXG4gICAgICAgIENvbGxpZGVDaXJjbGVzOiBDb2xsaWRlQ2lyY2xlcyxcbiAgICAgICAgQ29sbGlkZUVkZ2VDaXJjbGU6IENvbGxpZGVFZGdlQ2lyY2xlLFxuICAgICAgICBDb2xsaWRlUG9seWdvbnM6IENvbGxpZGVQb2x5Z29ucyxcbiAgICAgICAgQ29sbGlkZVBvbHlnb25DaXJjbGU6IENvbGxpZGVQb2x5Z29uQ2lyY2xlLFxuICAgICAgICBDb2xsaWRlRWRnZVBvbHlnb246IENvbGxpZGVFZGdlUG9seWdvbixcbiAgICAgICAgRGlzdGFuY2VKb2ludDogRGlzdGFuY2VKb2ludCxcbiAgICAgICAgRnJpY3Rpb25Kb2ludDogRnJpY3Rpb25Kb2ludCxcbiAgICAgICAgR2VhckpvaW50OiBHZWFySm9pbnQsXG4gICAgICAgIE1vdG9ySm9pbnQ6IE1vdG9ySm9pbnQsXG4gICAgICAgIE1vdXNlSm9pbnQ6IE1vdXNlSm9pbnQsXG4gICAgICAgIFByaXNtYXRpY0pvaW50OiBQcmlzbWF0aWNKb2ludCxcbiAgICAgICAgUHVsbGV5Sm9pbnQ6IFB1bGxleUpvaW50LFxuICAgICAgICBSZXZvbHV0ZUpvaW50OiBSZXZvbHV0ZUpvaW50LFxuICAgICAgICBSb3BlSm9pbnQ6IFJvcGVKb2ludCxcbiAgICAgICAgV2VsZEpvaW50OiBXZWxkSm9pbnQsXG4gICAgICAgIFdoZWVsSm9pbnQ6IFdoZWVsSm9pbnQsXG4gICAgICAgIFNldHRpbmdzOiBTZXR0aW5ncyxcbiAgICAgICAgU2V0dGluZ3NJbnRlcm5hbDogU2V0dGluZ3NJbnRlcm5hbCxcbiAgICAgICAgU3dlZXA6IFN3ZWVwLFxuICAgICAgICBnZXQgTWFuaWZvbGRUeXBlICgpIHsgcmV0dXJuIGV4cG9ydHMuTWFuaWZvbGRUeXBlOyB9LFxuICAgICAgICBnZXQgQ29udGFjdEZlYXR1cmVUeXBlICgpIHsgcmV0dXJuIGV4cG9ydHMuQ29udGFjdEZlYXR1cmVUeXBlOyB9LFxuICAgICAgICBnZXQgUG9pbnRTdGF0ZSAoKSB7IHJldHVybiBleHBvcnRzLlBvaW50U3RhdGU7IH0sXG4gICAgICAgIENsaXBWZXJ0ZXg6IENsaXBWZXJ0ZXgsXG4gICAgICAgIE1hbmlmb2xkOiBNYW5pZm9sZCxcbiAgICAgICAgTWFuaWZvbGRQb2ludDogTWFuaWZvbGRQb2ludCxcbiAgICAgICAgQ29udGFjdElEOiBDb250YWN0SUQsXG4gICAgICAgIFdvcmxkTWFuaWZvbGQ6IFdvcmxkTWFuaWZvbGQsXG4gICAgICAgIGdldFBvaW50U3RhdGVzOiBnZXRQb2ludFN0YXRlcyxcbiAgICAgICAgY2xpcFNlZ21lbnRUb0xpbmU6IGNsaXBTZWdtZW50VG9MaW5lLFxuICAgICAgICBEaXN0YW5jZUlucHV0OiBEaXN0YW5jZUlucHV0LFxuICAgICAgICBEaXN0YW5jZU91dHB1dDogRGlzdGFuY2VPdXRwdXQsXG4gICAgICAgIFNpbXBsZXhDYWNoZTogU2ltcGxleENhY2hlLFxuICAgICAgICBEaXN0YW5jZTogRGlzdGFuY2UsXG4gICAgICAgIERpc3RhbmNlUHJveHk6IERpc3RhbmNlUHJveHksXG4gICAgICAgIHRlc3RPdmVybGFwOiB0ZXN0T3ZlcmxhcCxcbiAgICAgICAgU2hhcGVDYXN0SW5wdXQ6IFNoYXBlQ2FzdElucHV0LFxuICAgICAgICBTaGFwZUNhc3RPdXRwdXQ6IFNoYXBlQ2FzdE91dHB1dCxcbiAgICAgICAgU2hhcGVDYXN0OiBTaGFwZUNhc3QsXG4gICAgICAgIFRPSUlucHV0OiBUT0lJbnB1dCxcbiAgICAgICAgZ2V0IFRPSU91dHB1dFN0YXRlICgpIHsgcmV0dXJuIGV4cG9ydHMuVE9JT3V0cHV0U3RhdGU7IH0sXG4gICAgICAgIFRPSU91dHB1dDogVE9JT3V0cHV0LFxuICAgICAgICBUaW1lT2ZJbXBhY3Q6IFRpbWVPZkltcGFjdCxcbiAgICAgICAgVHJlZU5vZGU6IFRyZWVOb2RlLFxuICAgICAgICBEeW5hbWljVHJlZTogRHluYW1pY1RyZWUsXG4gICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgaW50ZXJuYWw6IGludGVybmFsXG4gICAgfSk7XG5cbiAgICBleHBvcnRzLkFBQkIgPSBBQUJCO1xuICAgIGV4cG9ydHMuQm9keSA9IEJvZHk7XG4gICAgZXhwb3J0cy5Cb3ggPSBCb3g7XG4gICAgZXhwb3J0cy5Cb3hTaGFwZSA9IEJveFNoYXBlO1xuICAgIGV4cG9ydHMuQ2hhaW4gPSBDaGFpbjtcbiAgICBleHBvcnRzLkNoYWluU2hhcGUgPSBDaGFpblNoYXBlO1xuICAgIGV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuICAgIGV4cG9ydHMuQ2lyY2xlU2hhcGUgPSBDaXJjbGVTaGFwZTtcbiAgICBleHBvcnRzLkNsaXBWZXJ0ZXggPSBDbGlwVmVydGV4O1xuICAgIGV4cG9ydHMuQ29sbGlkZUNpcmNsZXMgPSBDb2xsaWRlQ2lyY2xlcztcbiAgICBleHBvcnRzLkNvbGxpZGVFZGdlQ2lyY2xlID0gQ29sbGlkZUVkZ2VDaXJjbGU7XG4gICAgZXhwb3J0cy5Db2xsaWRlRWRnZVBvbHlnb24gPSBDb2xsaWRlRWRnZVBvbHlnb247XG4gICAgZXhwb3J0cy5Db2xsaWRlUG9seWdvbkNpcmNsZSA9IENvbGxpZGVQb2x5Z29uQ2lyY2xlO1xuICAgIGV4cG9ydHMuQ29sbGlkZVBvbHlnb25zID0gQ29sbGlkZVBvbHlnb25zO1xuICAgIGV4cG9ydHMuQ29udGFjdCA9IENvbnRhY3Q7XG4gICAgZXhwb3J0cy5Db250YWN0RWRnZSA9IENvbnRhY3RFZGdlO1xuICAgIGV4cG9ydHMuQ29udGFjdElEID0gQ29udGFjdElEO1xuICAgIGV4cG9ydHMuRGlzdGFuY2UgPSBEaXN0YW5jZTtcbiAgICBleHBvcnRzLkRpc3RhbmNlSW5wdXQgPSBEaXN0YW5jZUlucHV0O1xuICAgIGV4cG9ydHMuRGlzdGFuY2VKb2ludCA9IERpc3RhbmNlSm9pbnQ7XG4gICAgZXhwb3J0cy5EaXN0YW5jZU91dHB1dCA9IERpc3RhbmNlT3V0cHV0O1xuICAgIGV4cG9ydHMuRGlzdGFuY2VQcm94eSA9IERpc3RhbmNlUHJveHk7XG4gICAgZXhwb3J0cy5EeW5hbWljVHJlZSA9IER5bmFtaWNUcmVlO1xuICAgIGV4cG9ydHMuRWRnZSA9IEVkZ2U7XG4gICAgZXhwb3J0cy5FZGdlU2hhcGUgPSBFZGdlU2hhcGU7XG4gICAgZXhwb3J0cy5GaXh0dXJlID0gRml4dHVyZTtcbiAgICBleHBvcnRzLkZpeHR1cmVQcm94eSA9IEZpeHR1cmVQcm94eTtcbiAgICBleHBvcnRzLkZyaWN0aW9uSm9pbnQgPSBGcmljdGlvbkpvaW50O1xuICAgIGV4cG9ydHMuR2VhckpvaW50ID0gR2VhckpvaW50O1xuICAgIGV4cG9ydHMuSm9pbnQgPSBKb2ludDtcbiAgICBleHBvcnRzLkpvaW50RWRnZSA9IEpvaW50RWRnZTtcbiAgICBleHBvcnRzLk1hbmlmb2xkID0gTWFuaWZvbGQ7XG4gICAgZXhwb3J0cy5NYW5pZm9sZFBvaW50ID0gTWFuaWZvbGRQb2ludDtcbiAgICBleHBvcnRzLk1hdDIyID0gTWF0MjI7XG4gICAgZXhwb3J0cy5NYXQzMyA9IE1hdDMzO1xuICAgIGV4cG9ydHMuTWF0aCA9IG1hdGg7XG4gICAgZXhwb3J0cy5Nb3RvckpvaW50ID0gTW90b3JKb2ludDtcbiAgICBleHBvcnRzLk1vdXNlSm9pbnQgPSBNb3VzZUpvaW50O1xuICAgIGV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XG4gICAgZXhwb3J0cy5Qb2x5Z29uU2hhcGUgPSBQb2x5Z29uU2hhcGU7XG4gICAgZXhwb3J0cy5QcmlzbWF0aWNKb2ludCA9IFByaXNtYXRpY0pvaW50O1xuICAgIGV4cG9ydHMuUHVsbGV5Sm9pbnQgPSBQdWxsZXlKb2ludDtcbiAgICBleHBvcnRzLlJldm9sdXRlSm9pbnQgPSBSZXZvbHV0ZUpvaW50O1xuICAgIGV4cG9ydHMuUm9wZUpvaW50ID0gUm9wZUpvaW50O1xuICAgIGV4cG9ydHMuUm90ID0gUm90O1xuICAgIGV4cG9ydHMuU2VyaWFsaXplciA9IFNlcmlhbGl6ZXI7XG4gICAgZXhwb3J0cy5TZXR0aW5ncyA9IFNldHRpbmdzO1xuICAgIGV4cG9ydHMuU2V0dGluZ3NJbnRlcm5hbCA9IFNldHRpbmdzSW50ZXJuYWw7XG4gICAgZXhwb3J0cy5TaGFwZSA9IFNoYXBlO1xuICAgIGV4cG9ydHMuU2hhcGVDYXN0ID0gU2hhcGVDYXN0O1xuICAgIGV4cG9ydHMuU2hhcGVDYXN0SW5wdXQgPSBTaGFwZUNhc3RJbnB1dDtcbiAgICBleHBvcnRzLlNoYXBlQ2FzdE91dHB1dCA9IFNoYXBlQ2FzdE91dHB1dDtcbiAgICBleHBvcnRzLlNpbXBsZXhDYWNoZSA9IFNpbXBsZXhDYWNoZTtcbiAgICBleHBvcnRzLlN3ZWVwID0gU3dlZXA7XG4gICAgZXhwb3J0cy5UT0lJbnB1dCA9IFRPSUlucHV0O1xuICAgIGV4cG9ydHMuVE9JT3V0cHV0ID0gVE9JT3V0cHV0O1xuICAgIGV4cG9ydHMuVGVzdGJlZCA9IFRlc3RiZWQ7XG4gICAgZXhwb3J0cy5UaW1lT2ZJbXBhY3QgPSBUaW1lT2ZJbXBhY3Q7XG4gICAgZXhwb3J0cy5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm07XG4gICAgZXhwb3J0cy5UcmVlTm9kZSA9IFRyZWVOb2RlO1xuICAgIGV4cG9ydHMuVmVjMiA9IFZlYzI7XG4gICAgZXhwb3J0cy5WZWMzID0gVmVjMztcbiAgICBleHBvcnRzLlZlbG9jaXR5Q29uc3RyYWludFBvaW50ID0gVmVsb2NpdHlDb25zdHJhaW50UG9pbnQ7XG4gICAgZXhwb3J0cy5XZWxkSm9pbnQgPSBXZWxkSm9pbnQ7XG4gICAgZXhwb3J0cy5XaGVlbEpvaW50ID0gV2hlZWxKb2ludDtcbiAgICBleHBvcnRzLldvcmxkID0gV29ybGQ7XG4gICAgZXhwb3J0cy5Xb3JsZE1hbmlmb2xkID0gV29ybGRNYW5pZm9sZDtcbiAgICBleHBvcnRzLmNsaXBTZWdtZW50VG9MaW5lID0gY2xpcFNlZ21lbnRUb0xpbmU7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwbGFuY2s7XG4gICAgZXhwb3J0cy5nZXRQb2ludFN0YXRlcyA9IGdldFBvaW50U3RhdGVzO1xuICAgIGV4cG9ydHMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBleHBvcnRzLm1peEZyaWN0aW9uID0gbWl4RnJpY3Rpb247XG4gICAgZXhwb3J0cy5taXhSZXN0aXR1dGlvbiA9IG1peFJlc3RpdHV0aW9uO1xuICAgIGV4cG9ydHMuc3RhdHMgPSBzdGF0cztcbiAgICBleHBvcnRzLnRlc3RPdmVybGFwID0gdGVzdE92ZXJsYXA7XG4gICAgZXhwb3J0cy50ZXN0YmVkID0gdGVzdGJlZDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYW5jay5qcy5tYXBcbiJdfQ==
